import type {
  ComptimeExpression
  ComptimeStatement
  StatementTuple
} from ./types.civet

import {
  gatherRecursive
} from "./traversal.civet"

generate, { prune, type Options } from "../generate.civet"

function processComptime(statements: StatementTuple[]): void
  gatherRecursive statements,
    (node): node is (ComptimeStatement | ComptimeExpression) =>
      node.type is "ComptimeStatement" or node.type is "ComptimeExpression"
  .forEach (exp) =>
    content := exp.type is "ComptimeStatement" ? exp.block : exp.expression
    // Convert the comptime block into JS code
    options: Options := js: true
    js := generate prune(content), options
    // If there are any errors, leave the comptime subtree alone
    // (so there's still an error).
    return if options.errors?
    output := eval?.(`"use strict";${js}`)
    if exp.type is "ComptimeExpression"
      let string
      try
        string = JSON.stringify output
      catch e
        exp.children = [
          type: "Error"
          message: `comptime result ${output} not JSON serializable: ${e}`
        ]
        return
      exp.children = [string]
    else
      exp.children = []

export {
  processComptime
}
