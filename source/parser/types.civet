type ASTNode = ASTNodeBase | ASTError | ASTRef | ASTLeaf | ASTNode[] | ASTString | undefined
type ASTString = string & type?: never
type ASTNodeBase =
  type: string
  children: ASTNode[]
  blockPrefix?: unknown
  names?: string[]
  parent?: ASTNodeBase | undefined

type ASTError =
  type: "Error"
  message: string

type Loc =
  pos: number
  length: number

type ASTLeaf = ASTNodeBase &
  $loc: Loc
  token: string

type CommentNode = ASTLeaf & type: "Comment"

type WSNode = "" | (ASTLeaf | CommentNode)[]

type Children = ASTNode[]

type StatementDelimiter = ASTNode
type IndentNode = ASTNode

type StatementTuple = [IndentNode, ASTNode, StatementDelimiter?]

type Condition = ParenthesizedExpression

type ParenthesizedExpression
  type: "ParenthesizedExpression"
  children: Children
  parent: ASTNodeBase
  expression: ASTNode
  implicit?: boolean

type IfStatement
  type: "IfStatement"
  children: Children
  condition: Condition
  then: BlockStatement
  else: [ ASTNode, ElseToken, BlockStatement ] | undefined

type IterationStatement
  type: "IterationStatement"
  children: Children
  parent: ASTNodeBase | undefined
  block: BlockStatement

type SwitchStatement
  type: "SwitchStatement"
  children: Children
  parent: ASTNodeBase | undefined
  condition: Condition
  caseBlock: CaseBlock

type CaseBlock
  type: "CaseBlock"
  clauses: CaseClause[]
  children: Children

type CaseClause
  type: unknown
  children: Children
  break?: ASTNode
  block: BlockStatement

type LabeledStatement
  type: "LabeledStatement"
  label: ASTNode
  statement: ASTNodeBase
  children: Children

type ElseToken = { $loc: Loc, token: "else" }

type ASTRef =
  type: "Ref"
  base: string
  id: string

type AtBinding =
  type: "AtBinding"
  ref: ASTRef

type BlockStatement =
  type: "BlockStatement"
  children: ASTNode[]
  expressions: StatementTuple[]
  bare: boolean
  root: boolean
  parent: ASTNodeBase | undefined

type DeclarationStatement =
  type: "Declaration"
  children: Children
  names: string[]
  bindings: Binding[]
  parent: ASTNodeBase | undefined

type Binding =
  type: "Binding"
  children: Children
  names: string[]
  pattern: BindingIdentifier | BindingPattern
  suffix: TypeSuffix | undefined
  initializer: [unknown, unknown, ASTNodeBase] | undefined
  splices: unknown[]
  thisAssignments: unknown[]

type Identifier =
  type: "Identifier"
  name: string
  names: string[]
  children: [ ASTLeaf ]
  parent: ASTNodeBase | undefined

type ReturnValue =
  type: "ReturnValue"
  children: Children

type BindingIdentifier = AtBinding | Identifier | ReturnValue

type BindingPattern = ObjectBindingPattern | ArrayBindingPattern | PinPattern | Literal | RegularExpressionLiteral

type RegularExpressionLiteral = ASTLeaf & type: "RegularExpressionLiteral"

type ArrayBindingPattern = ASTNodeBase

type PinPattern = ASTNodeBase

type NonNewlineWhitespace = (ASTLeaf | " ")[]

type BindingPatternContent = unknown[]

type ObjectBindingPattern =
  type: "ObjectBindingPattern",
  children: [NonNewlineWhitespace, ASTLeaf, BindingPatternContent, WSNode, ASTLeaf],
  names: string[],
  properties: BindingPatternContent,

type MethodDefinition =
  type: "MethodDefinition"
  children: ASTNode[]
  name: string
  signature: FunctionSignature
  block: BlockStatement
  parameters: ParametersNode
  parent: ASTNodeBase | undefined

type FunctionSignature =
  type: "MethodSignature" | "FunctionSignature"
  children: ASTNode[]
  name: string
  optional: unknown
  modifier: MethodModifier
  returnType: ReturnTypeAnnotation | undefined
  parameters: ParametersNode
  parent: ASTNodeBase | undefined

type TypeSuffix =
  type: "TypeSuffix"
  ts: true
  optional?: ASTNode
  t?: ASTNode
  children: Children

type ReturnTypeAnnotation =
  type: "ReturnTypeAnnotation"
  ts: true
  optional?: ASTNode
  t: ASTNodeBase &
    type: string
    t: ASTNodeBase
  children: Children

type MethodModifier =
  get?: boolean
  set?: boolean
  async?: boolean

type ParametersNode =
  type: "Parameters"
  children: ASTNode[]
  names: string[]
  parent: ASTNode | undefined
  tp: TypeParameters | undefined

type TypeParameters = unknown

type FunctionNode = FunctionExpression | ArrowFunction | MethodDefinition

type Literal =
  type: "Literal",
  subtype: LiteralContentNode["type"],
  children: [ LiteralContentNode ],
  raw: string,

type LiteralContentNode = ASTLeaf & {
  type?: "NumericLiteral" | "StringLiteral"
}

type Predicate = (node: Exclude<ASTNode, undefined>) => boolean

type TabConfig = number | undefined

type ParseRule = (context: {fail: () => void}, state: {pos: number, input: string}) => ???

type TypeNode = TypeIdentifierNode | LiteralTypeNode

type TypeIdentifierNode =
  type: "IdentifierType"
  children: ASTNode[]
  raw: string
  args: TypeArgumentsNode

type TypeArgumentsNode =
  type: "TypeArguments"
  ts: true
  types: TypeNode[]
  children: ASTNode[]

type LiteralTypeNode =
  type: "LiteralType"
  t: TypeLiteralNode
  children: ASTNode[]

type VoidType = ASTLeaf & type: "VoidType"

type TypeLiteralNode = ASTLeaf | VoidType

type ThisAssignments = [string, ASTRef][]

export type {
  ASTError,
  ASTLeaf,
  ASTNode,
  ASTNodeBase,
  ASTRef,
  ASTString,
  ArrayBindingPattern,
  AtBinding,
  Binding,
  BindingIdentifier,
  BindingPattern,
  BindingPatternContent,
  BlockStatement,
  CaseBlock,
  CaseClause,
  Children,
  CommentNode,
  Condition,
  DeclarationStatement,
  ElseToken,
  FunctionNode,
  FunctionSignature,
  Identifier,
  IfStatement,
  IndentNode,
  IterationStatement,
  LabeledStatement,
  Literal,
  LiteralContentNode,
  LiteralTypeNode,
  MethodDefinition,
  MethodModifier,
  NonNewlineWhitespace,
  ObjectBindingPattern,
  ParametersNode,
  ParenthesizedExpression,
  ParseRule,
  PinPattern,
  Predicate,
  RegularExpressionLiteral,
  ReturnTypeAnnotation,
  ReturnValue,
  StatementDelimiter,
  StatementTuple,
  SwitchStatement,
  TabConfig,
  ThisAssignments,
  TypeArgumentsNode,
  TypeIdentifierNode,
  TypeLiteralNode,
  TypeNode,
  TypeParameters,
  TypeSuffix,
  VoidType,
  WSNode,
}
