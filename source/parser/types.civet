export typeASTNode = ASTNodeBase | ASTError | ASTRef | ASTLeaf | ASTNode[] | ASTString | undefined
export typeASTString = string & type?: never
export typeASTNodeBase =
  type: string
  children: ASTNode[]
  blockPrefix?: unknown
  names?: string[]
  parent?: ASTNodeBase | undefined

export typeASTError =
  type: "Error"
  message: string

export typeLoc =
  pos: number
  length: number

export typeASTLeaf = ASTNodeBase &
  $loc: Loc
  token: string

export typeCommentNode = ASTLeaf & type: "Comment"

export typeWSNode = "" | (ASTLeaf | CommentNode)[]

export typeChildren = ASTNode[]

export typeStatementDelimiter = ASTNode
export typeIndentNode = ASTNode

export typeStatementTuple = [IndentNode, ASTNode, StatementDelimiter?]

export typeCondition = ParenthesizedExpression

export typeParenthesizedExpression
  type: "ParenthesizedExpression"
  children: Children
  parent: ASTNodeBase
  expression: ASTNode
  implicit?: boolean

export typeIfStatement
  type: "IfStatement"
  children: Children
  condition: Condition
  then: BlockStatement
  else: [ ASTNode, ElseToken, BlockStatement ] | undefined

export typeIterationStatement
  type: "IterationStatement"
  children: Children
  parent: ASTNodeBase | undefined
  block: BlockStatement

export typeSwitchStatement
  type: "SwitchStatement"
  children: Children
  parent: ASTNodeBase | undefined
  condition: Condition
  caseBlock: CaseBlock

export typeCaseBlock
  type: "CaseBlock"
  clauses: CaseClause[]
  children: Children

export typeCaseClause
  type: unknown
  children: Children
  break?: ASTNode
  block: BlockStatement

export typeLabeledStatement
  type: "LabeledStatement"
  label: ASTNode
  statement: ASTNodeBase
  children: Children

export typeElseToken = { $loc: Loc, token: "else" }

export typeASTRef =
  type: "Ref"
  base: string
  id: string

export typeAtBinding =
  type: "AtBinding"
  ref: ASTRef

export typeBlockStatement =
  type: "BlockStatement"
  children: ASTNode[]
  expressions: StatementTuple[]
  bare: boolean
  root: boolean
  parent: ASTNodeBase | undefined

export typeDeclarationStatement =
  type: "Declaration"
  children: Children
  names: string[]
  bindings: Binding[]
  parent: ASTNodeBase | undefined

export typeBinding =
  type: "Binding"
  children: Children
  names: string[]
  pattern: BindingIdentifier | BindingPattern
  suffix: TypeSuffix | undefined
  initializer: [unknown, unknown, ASTNodeBase] | undefined
  splices: unknown[]
  thisAssignments: unknown[]

export typeIdentifier =
  type: "Identifier"
  name: string
  names: string[]
  children: [ ASTLeaf ]
  parent: ASTNodeBase | undefined

export typeReturnValue =
  type: "ReturnValue"
  children: Children

export typeBindingIdentifier = AtBinding | Identifier | ReturnValue

export typeBindingPattern = ObjectBindingPattern | ArrayBindingPattern | PinPattern | Literal | RegularExpressionLiteral

export typeRegularExpressionLiteral = ASTLeaf & type: "RegularExpressionLiteral"

export typeArrayBindingPattern = ASTNodeBase

export typePinPattern = ASTNodeBase

export typeNonNewlineWhitespace = (ASTLeaf | " ")[]

export typeBindingPatternContent = unknown[]

export typeObjectBindingPattern =
  type: "ObjectBindingPattern",
  children: [NonNewlineWhitespace, ASTLeaf, BindingPatternContent, WSNode, ASTLeaf],
  names: string[],
  properties: BindingPatternContent,

export typeMethodDefinition =
  type: "MethodDefinition"
  children: ASTNode[]
  name: string
  signature: FunctionSignature
  block: BlockStatement
  parameters: ParametersNode
  parent: ASTNodeBase | undefined

export typeFunctionSignature =
  type: "MethodSignature" | "FunctionSignature"
  children: ASTNode[]
  name: string
  optional: unknown
  modifier: MethodModifier
  returnType: ReturnTypeAnnotation | undefined
  parameters: ParametersNode
  parent: ASTNodeBase | undefined

export typeTypeSuffix =
  type: "TypeSuffix"
  ts: true
  optional?: ASTNode
  t?: ASTNode
  children: Children

export typeReturnTypeAnnotation =
  type: "ReturnTypeAnnotation"
  ts: true
  optional?: ASTNode
  t: ASTNodeBase &
    type: string
    t: ASTNodeBase
  children: Children

export typeMethodModifier =
  get?: boolean
  set?: boolean
  async?: boolean

export typeParametersNode =
  type: "Parameters"
  children: ASTNode[]
  names: string[]
  parent: ASTNode | undefined
  tp: TypeParameters | undefined

export typeTypeParameters = unknown

export typeFunctionNode = FunctionExpression | ArrowFunction | MethodDefinition

export typeLiteral =
  type: "Literal",
  subtype: LiteralContentNode["type"],
  children: [ LiteralContentNode ],
  raw: string,

export typeLiteralContentNode = ASTLeaf & {
  type?: "NumericLiteral" | "StringLiteral"
}

export typePredicate = (node: Exclude<ASTNode, undefined>) => boolean

export typeTabConfig = number | undefined

export typeParseRule = (context: {fail: () => void}, state: {pos: number, input: string}) => ???

export typeTypeNode = TypeIdentifierNode | LiteralTypeNode

export typeTypeIdentifierNode =
  type: "IdentifierType"
  children: ASTNode[]
  raw: string
  args: TypeArgumentsNode

export typeTypeArgumentsNode =
  type: "TypeArguments"
  ts: true
  types: TypeNode[]
  children: ASTNode[]

export typeLiteralTypeNode =
  type: "LiteralType"
  t: TypeLiteralNode
  children: ASTNode[]

export typeVoidexport type= ASTLeaf & type: "VoidType"

export typeTypeLiteralNode = ASTLeaf | VoidType

export typeThisAssignments = [string, ASTRef][]
