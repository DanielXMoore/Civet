import type {
  ASTNode
  ASTNodeBase
  ASTLeaf
  ASTError
  Children
  RangeDots
  RangeExpression
} from ./types.civet

import {
  insertTrimmingSpace
  literalValue
  makeLeftHandSideExpression
} from ./util.civet

import {
  makeRef
  maybeRef
} from ./ref.civet

function processRangeExpression(start: ASTNode, ws1: ASTNode, range: RangeDots, end: ASTNode)
  ws1 = [ws1, range.children[0]] // whitespace before ..
  ws2 := range.children[1]       // whitespace after ..
  comma := { $loc: range.$loc, token: "," }
  // Length of range is abs(start - end) + lengthAdjust
  abs :=
    switch range.increasing
      when true
        &: number
      when false
        -&: number
      else
        Math.abs
  lengthAdjust :=
    1 - Number(not range.left.inclusive) - Number(not range.right.inclusive)
  lengthAdjustExpression :=
    if lengthAdjust > 0 then ` + ${lengthAdjust}`
    else if lengthAdjust < 0 then ` - ${-lengthAdjust}`

  let children: Children?
  if start is like {type: "Literal"} and end is like {type: "Literal"}
    startValue .= literalValue start
    endValue .= literalValue end

    if startValue <? "string" and endValue <? "string"
      unless startValue# is 1 is endValue#
        throw new Error "String range start and end must be a single character"

      startCode .= startValue.charCodeAt(0)
      endCode .= endValue.charCodeAt(0)
      step := startCode <= endCode ? 1 : -1

      length := abs(endCode - startCode) + lengthAdjust
      startCode += step unless range.left.inclusive

      if length <= 26
        children =
          . "["
          . Array.from { length }, (_, i) =>
              JSON.stringify String.fromCharCode startCode + i * step
            .join ", "
          . "]"
      else
        children =
          . `Array.from({length: ${length.toString()}}, `
          . "(_, i) => String.fromCharCode(", startCode.toString()
          . step > 0 ? " + " : " - ", "i))"
      children.unshift range.error if range.error?
    else if startValue <? "number" and endValue <? "number"
      step := startValue <= endValue ? 1 : -1
      length := abs(endValue - startValue) + lengthAdjust
      startValue += step unless range.left.inclusive
      if length <= 20
        // Use array of literal values
        children =
          . "["
          . Array.from({ length }, (_, i) => startValue as number + i * step)
            .join ", "
          . "]"
        children.unshift range.error if range.error?

  unless children?
    if range.increasing?
      sign := range.increasing ? "+" : "-"
      end = makeLeftHandSideExpression end
      children =
        . "((s) => Array.from({length: "
        . range.increasing ? [ws2, end, " - s"] : ["s - ", ws2, end]
        . lengthAdjustExpression
        . "}, (_, i) => s ", sign, " i))"
        . "("
        . if range.left.inclusive
            start
          else
            [makeLeftHandSideExpression(start), ` ${sign} 1`]
        . ...ws1, ")"
    else
      children =
        . "((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)"
        . lengthAdjustExpression
        . "}, (_, i) => s + i * step)})"
        . "(", start, ...ws1, comma, ws2, end, ")"

  {
    type: "RangeExpression"
    children, start, end
    error: range.error
    left: range.left
    right: range.right
    increasing: range.increasing
  }

// Construct for loop from RangeLiteral
function forRange(
  open: ASTLeaf
  forDeclaration: ASTNode
  range: RangeExpression
  stepExp: ASTNode
  close: ASTLeaf
)
  { start, end, left, right, increasing } := range

  counterRef := makeRef("i")

  infinite := end is like {type: "Identifier", name: "Infinity"}

  let stepRef, asc: boolean?
  if stepExp
    stepExp = insertTrimmingSpace(stepExp, "")
    stepRef = maybeRef(stepExp, "step")
  else if infinite
    stepExp = stepRef = "1"
  else if increasing?
    if increasing
      stepExp = stepRef = "1"
      asc = true
    else
      stepExp = stepRef = "-1"
      asc = false

  // start needs to be ref'd to compute start <= end, unless we know direction
  startRef .= if stepRef then start else maybeRef(start, "start")
  endRef .= maybeRef(end, "end")

  startRefDec := (startRef !== start) ? [startRef, " = ", start, ", "] : []
  endRefDec := (endRef !== end) ? [endRef, " = ", end, ", "] : []

  unless left.inclusive
    startRef =
      . makeLeftHandSideExpression(start)
      . " + "
      . stepRef

  let ascDec: ASTNode[] = [], ascRef
  if stepRef
    unless stepRef is stepExp
      ascDec = [", ", stepRef, " = ", stepExp]

  else if "Literal" is start.type is end.type
    asc = literalValue(start) <= literalValue(end)
    if "StringLiteral" is start.subtype is end.subtype
      startRef = literalValue(start).charCodeAt(0).toString()
      endRef = literalValue(end).charCodeAt(0).toString()

  else
    ascRef = makeRef("asc")
    ascDec = [", ", ascRef, " = ", startRef, " <= ", endRef]

  let varAssign: ASTNode[] = [], varLetAssign = varAssign, varLet = varAssign, blockPrefix
  if forDeclaration?.declare // var/let/const declaration of variable
    if forDeclaration.declare.token is "let"
      varName := forDeclaration.children.splice(1)  // strip let
      varAssign = [...insertTrimmingSpace(varName, ""), " = "]
      varLet = [",", ...varName, " = ", counterRef]
    else // const or var: put inside loop
      // TODO: missing indentation
      value := "StringLiteral" is start.subtype ? ["String.fromCharCode(", counterRef, ")"] : counterRef
      blockPrefix = [
        ["", [forDeclaration, " = ", value], ";"]
      ]
  else if forDeclaration // Coffee-style for loop
    varAssign = varLetAssign = [forDeclaration, " = "]

  declaration :=
    type: "Declaration"
    children: ["let ", ...startRefDec, ...endRefDec, counterRef, " = ", ...varLetAssign, startRef, ...varLet, ...ascDec]
    names: forDeclaration?.names

  counterPart := right.inclusive
    ? [counterRef, " <= ", endRef, " : ", counterRef, " >= ", endRef]
    : [counterRef, " < ", endRef, " : ", counterRef, " > ", endRef]

  condition :=
    infinite ? [] :
    asc? ? (asc ? counterPart[0...3] : counterPart[4..]) :
    stepRef ? [stepRef, " !== 0 && (", stepRef, " > 0 ? ", ...counterPart, ")"] :
    [ascRef, " ? ", ...counterPart]

  increment :=
    stepRef === "1" ? [...varAssign, "++", counterRef] :
    stepRef === "-1" ? [...varAssign, "--", counterRef] :
    stepRef
      ? [...varAssign, counterRef, " += ", stepRef]
      : ascRef
        ? [...varAssign, ascRef, " ? ++", counterRef, " : --", counterRef]
        : [...varAssign, asc ? "++" : "--", counterRef]

  return {
    declaration
    children: [range.error, open, declaration, "; ", ...condition, "; ", ...increment, close]
    blockPrefix
  }

function processForInOf($0: [
  awaits: ASTNode,
  eachOwn: undefined | [ASTLeaf, ASTNode],
  open: ASTNode,
  declaration: ASTNode,
  declaration2: [ws1: ASTNode, comma: ASTLeaf, ws2: ASTNode, decl2: ASTNode],
  ws: ASTNode,
  inOf: ASTLeaf,
  exp: ASTNodeBase,
  step: ASTNode,
  close: ASTNode
], getRef)
  [awaits, eachOwn, open, declaration, declaration2, ws, inOf, exp, step, close] .= $0

  if exp.type is "RangeExpression" and inOf.token is "of" and !declaration2
    // TODO: add support for `declaration2` to efficient `forRange`
    return forRange(open, declaration, exp, step, close)
  else if step
    throw new Error("for..of/in cannot use 'by' except with range literals")

  let eachOwnError: ASTError?
  let hoistDec, blockPrefix: ASTNode[] = []

  // for each item[, index] of array
  if eachOwn and eachOwn[0].token is "each"
    if inOf.token is "of"
      counterRef := makeRef("i")
      lenRef := makeRef("len")
      expRef := maybeRef(exp)

      const increment = "++"
      let assignmentNames = [...declaration.names]

      if declaration2
        const [, , ws2, decl2] = declaration2  // strip __ Comma __
        blockPrefix.push(["", [
          insertTrimmingSpace(ws2, ""), decl2, " = ", counterRef
        ], ";"])
        assignmentNames.push(...decl2.names)

      expRefDec := (expRef !== exp)
        // Trim a single leading space if present
        ? [insertTrimmingSpace(expRef, " "), " = ", insertTrimmingSpace(exp, ""), ", "]
        : []

      blockPrefix.push ["", {
        type: "Declaration"
        children: [declaration, " = ", insertTrimmingSpace(expRef, ""), "[", counterRef, "]"]
        names: assignmentNames
      }, ";"]

      declaration =
        type: "Declaration"
        children: ["let ", ...expRefDec, counterRef, " = 0, ", lenRef, " = ", insertTrimmingSpace(expRef, ""), ".length"]
        names: []

      condition := [counterRef, " < ", lenRef, "; "]
      children := [open, declaration, "; ", condition, counterRef, increment, close]
      return { declaration, children, blockPrefix }
    else
      eachOwnError =
        type: "Error",
        message: "'each' is only meaningful in for..of loops",

  // for own..in
  own .= eachOwn and eachOwn[0].token is "own"
  let expRef: ASTNode?
  if own and inOf.token is not "in"
    own = false
    eachOwnError =
      type: "Error"
      message: "'own' is only meaningful in for..in loops"

  // TypeScript doesn't support typed declarations in for loops,
  // so pull such declarations inside the loop:
  //   for var x: T of y -> for (const x1 of y) {var x: T = x1;
  // for..in loops need a similar ref-based declaration
  // for dereferencing to get the associated value.
  { binding } := declaration
  pattern .= binding?.pattern
  if binding?.typeSuffix or (
    inOf.token is "in" and declaration2 and pattern.type is not "Identifier"
  )
    itemRef := makeRef if inOf.token is "in" then "key" else "item"
    blockPrefix.push ["", {
      type: "Declaration"
      children: [declaration, " = ", itemRef]
      names: declaration.names
    }, ";"]
    pattern = itemRef
    declaration =
      type: "ForDeclaration"
      binding: {
        type: "Binding"
        pattern
        children: [ pattern ]
        names: []
      }
      children: ["const ", itemRef]
      names: []

  unless declaration2 or own
    return {
      declaration
      blockPrefix
      children: [awaits, eachOwnError, open, declaration, ws, inOf, expRef ?? exp, step, close] // omit declaration2, replace eachOwn with eachOwnError, replace exp with expRef
    }

  let ws2: ASTNode?, decl2: ASTNode?
  if (declaration2) [, , ws2, decl2] = declaration2  // strip __ Comma __

  switch inOf.token
    when "of" // for item, index of iter
      counterRef := makeRef "i"
      hoistDec = {
        type: "Declaration"
        children: ["let ", counterRef, " = 0"]
        names: []
      }
      blockPrefix.push ["", {
        type: "Declaration"
        children: [insertTrimmingSpace(ws2, ""), decl2, " = ", counterRef, "++"]
        names: decl2.names
      }, ";"]

    when "in" // for key, value in object
      // First, wrap object in ref if complex expression
      expRef := maybeRef(exp)
      unless expRef is exp
        hoistDec =
          type: "Declaration"
          children: ["let ", expRef]
          names: []
        exp =
          type: "AssignmentExpression"
          children: [" ", expRef, " =", exp]
      // for own..in
      if own
        const hasPropRef = getRef("hasProp")
        blockPrefix.push ["", ["if (!", hasPropRef, "(", insertTrimmingSpace(expRef, ""), ", ", insertTrimmingSpace(pattern, ""), ")) continue"], ";"]
      if decl2
        blockPrefix.push ["", {
          type: "Declaration"
          children: [insertTrimmingSpace(ws2, ""), decl2, " = ", insertTrimmingSpace(expRef, ""), "[", insertTrimmingSpace(pattern, ""), "]"]
          names: decl2.names
        }, ";"]

    else
      throw new Error `for item, index must use 'of' or 'in' instead of '${inOf.token}'`

  return {
    declaration,
    children: [awaits, eachOwnError, open, declaration, ws, inOf, exp, step, close], // omit declaration2, replace each with eachOwnError
    blockPrefix,
    hoistDec,
  }

export {
  forRange
  processForInOf
  processRangeExpression
}
