import type {
  ASTNode
  BlockStatement
} from ./types.civet

import {
  gatherNodes
  gatherRecursive
} from ./traversal.civet

import {
  isFunction
} from ./util.civet

import {
  braceBlock
  getIndent
} from ./block.civet

{ getConfig } from "../parser.hera"

function findDecs(statements: ASTNode)
  declarations := gatherNodes statements, .type is "Declaration"
  declarationNames := declarations.flatMap .names
  globals := getConfig().globals or []

  return new Set globals ++ declarationNames

function createConstLetDecs(statements, scopes, letOrConst: "let" | "const"): void
  function findVarDecs(statements, decs): Set<string>
    declarationNames := gatherRecursive statements, (node) =>
      node.type is "Declaration" and
      node.children and
      node.children# > 0 and
      node.children[0].token and
      node.children[0].token.startsWith("var") or
      node.type is "FunctionExpression"
    .filter .type is "Declaration"
    .flatMap .names
    new Set declarationNames

  declaredIdentifiers .= findVarDecs statements

  function hasDec(name)
    declaredIdentifiers.has(name) or scopes.some .has name

  function gatherBlockOrOther(statement)
    gatherNodes statement,
      .type is "BlockStatement" or
      .type is "AssignmentExpression" or
      .type is "Declaration"
    .flatMap (node) =>
      if node.type is "BlockStatement"
        // bare blocks is not a safe position to insert let declaration
        node.bare ? gatherBlockOrOther(node.expressions) : node
      else if node.children and node.children#
        [...gatherBlockOrOther(node.children), node]
      else
        []

  currentScope .= new Set
  scopes.push currentScope

  fnNodes := gatherNodes statements, isFunction
  forNodes := gatherNodes statements, .type is "ForStatement"

  targetStatements: StatementTuple[] .= []
  for each statement of statements
    nodes := gatherBlockOrOther statement
    undeclaredIdentifiers .= []
    for each node of nodes
      if node.type is "BlockStatement"
        block .= node
        fnNode .= fnNodes.find .block is block
        forNode .= forNodes.find .block is block
        if fnNode?
          scopes.push new Set fnNode.parameters.names
          createConstLetDecs(block.expressions, scopes, letOrConst)
          scopes.pop()
        else if forNode?
          scopes.push new Set forNode.declaration.names
          createConstLetDecs(block.expressions, scopes, letOrConst)
          scopes.pop()
        else
          createConstLetDecs(block.expressions, scopes, letOrConst)
        continue
      // Assignment and Declaration all use 'names'.
      continue unless node.names?
      names := node.names.filter (name) => not hasDec name
      if node.type is "AssignmentExpression"
        undeclaredIdentifiers.push ...names
      for each name of names
        currentScope.add name

    if undeclaredIdentifiers#
      indent .= statement[0]
      // Is this statement a simple assignment like 'a = 1'?
      firstIdentifier .= gatherNodes(statement[1], .type is "Identifier")[0]
      if (undeclaredIdentifiers# is 1
        and statement[1].type is "AssignmentExpression"
        and statement[1].names# is 1
        and statement[1].names[0] is undeclaredIdentifiers[0]
        and firstIdentifier and firstIdentifier.names == undeclaredIdentifiers[0]
        and gatherNodes(statement[1], .type is "ObjectBindingPattern")# is 0)
        statement[1].children.unshift [`${letOrConst} `]
      else
        tail .= "\n"
        // Does this statement start with a newline?
        if gatherNodes(indent, .token and .token.endsWith("\n"))#
          tail = undefined
        // Have to use 'let' instead of 'const' if the assignment is inside an expression
        targetStatements.push [indent, {
          type: "Declaration"
          children: ["let ", ...undeclaredIdentifiers.join(", ")]
          names: undeclaredIdentifiers
        }, tail]
    targetStatements.push(statement)

  scopes.pop()
  statements.splice(0, statements#, ...targetStatements)

// CoffeeScript compatible automatic var insertion
function createVarDecs(block: BlockStatement, scopes, pushVar?): void
  // NOTE: var and let/const have different scoping rules
  // need to keep var scopes when entering functions and within a var scope keep
  // track of lexical scopes within blocks
  function hasDec(name)
    return scopes.some .has name

  function findAssignments(statements, decs)
    assignmentStatements .= gatherNodes statements, .type is "AssignmentExpression"

    if assignmentStatements#
      // Get nested assignments that could be in expressions
      assignmentStatements ++=
        findAssignments assignmentStatements.map((s) => s.children), decs

    // Ignore assignment statements for public static class assignments, which don't need declaration
    assignmentStatements.filter !(&.parent?.type is "CoffeeClassPublic")

  // Let descendent blocks add the var at the outer enclosing function scope
  pushVar ?= (name: string) =>
    varIds.push(name)
    decs.add(name)

  { expressions: statements } := block
  decs := findDecs statements
  scopes.push decs
  varIds := []
  assignmentStatements := findAssignments statements, scopes
  undeclaredIdentifiers := assignmentStatements.flatMap ?.names or []

  // Unique, undeclared identifiers in this scope
  undeclaredIdentifiers.filter((x, i, a) => {
    if (!hasDec(x)) return a.indexOf(x) is i
  }).forEach(pushVar)

  const fnNodes = gatherNodes(statements, isFunction)
  const forNodes = gatherNodes(statements, (s) => s.type is "ForStatement")

  const blockNodes = new Set(gatherNodes(statements, (s) => s.type is "BlockStatement"))
  // Remove function blocks and for statements, they get handled separately because they have additional parameter scopes and lexical scopes to add
  fnNodes.forEach(({ block }) => blockNodes.delete(block))
  forNodes.forEach(({ block }) => blockNodes.delete(block))

  // recurse into nested blocks
  blockNodes.forEach (block) =>
    createVarDecs(block, scopes, pushVar)

  // recurse into for loops
  forNodes.forEach ({ block, declaration }) =>
    scopes.push(new Set(declaration?.names))
    createVarDecs(block, scopes, pushVar)
    scopes.pop()

  // recurse into nested functions
  fnNodes.forEach ({ block, parameters }) =>
    scopes.push(new Set(parameters.names))
    createVarDecs(block, scopes)
    scopes.pop()

  if varIds.length
    // get indent from first statement
    const indent = getIndent(statements[0])
    let delimiter = ";"
    if statements[0][1]?.parent?.root
      delimiter = ";\n"
    // TODO: Declaration ast node
    braceBlock block
    statements.unshift([indent, {
      type: "Declaration"
      children: ["var ", varIds.join(", ")]
    }, delimiter])

  scopes.pop()

export {
  createConstLetDecs
  createVarDecs
}
