import type {
  ASTNode
  ASTNodeObject
  DeclarationStatement
} from "./types.civet"

function makeRef(base = "ref", id = base): ASTRef
  return {
    type: "Ref"
    base
    id
  }

/**
 * Returns a new ref if the expression needs a ref (not a simple value).
 * Otherwise returns undefined.
 */
function needsRef(expression: ASTNodeObject, base = "ref")
  switch (expression.type) {
    case "Ref":
    case "Identifier":
    case "Literal":
      return
  }
  return makeRef(base)

// Transform into a ref if needed
function maybeRef(exp: ASTNode, base: string = "ref"): ASTNode
  if (!needsRef(exp)) return exp
  return makeRef(base)

function makeRefAssignment(ref: ASTNode, exp: ASTNode): {
  hoistDec: DeclarationStatement
  refAssignment: ASTNode
  refAssignmentComma: ASTNode[]
}
  refAssignment :=
    type: "AssignmentExpression"
    children: [ref, " = ", exp]
  {
    hoistDec:
      type: "Declaration"
      children: ["let ", ref]
      names: []
    refAssignment
    refAssignmentComma:
      if refAssignment
        [refAssignment, ","]
      else
        []
  }

function maybeRefAssignment(exp: ASTNode, base: string = "ref"): {
  ref: ASTNode
  hoistDec?: DeclarationStatement?
  refAssignment?: ASTNode
  refAssignmentComma: ASTNode[]
}
  let hoistDec, refAssignment
  ref := maybeRef exp, base
  if ref is exp
    { ref, refAssignmentComma: [] }
  else
    { ref, ...makeRefAssignment ref, exp }

export {
  makeRef
  makeRefAssignment
  maybeRef
  maybeRefAssignment
  needsRef
}
