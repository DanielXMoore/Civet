import type {
  ASTNode
  ASTNodeObject
  DeclarationStatement
} from "./types.civet"

function makeRef(base = "ref", id = base): ASTRef
  return {
    type: "Ref"
    base
    id
  }

/**
 * Returns a new ref if the expression needs a ref (not a simple value).
 * Otherwise returns undefined.
 */
function needsRef(expression: ASTNodeObject, base = "ref")
  switch (expression.type) {
    case "Ref":
    case "Identifier":
    case "Literal":
      return
  }
  return makeRef(base)

// Transform into a ref if needed
function maybeRef(exp: ASTNode, base: string = "ref"): ASTNode
  if (!needsRef(exp)) return exp
  return makeRef(base)

function makeRefAssignment(ref: ASTNode, exp: ASTNode): {
  hoistDec: DeclarationStatement
  refAssignment: ASTNode
}
  hoistDec:
    type: "Declaration"
    children: ["let ", ref]
    names: []
  refAssignment:
    type: "AssignmentExpression"
    children: [ref, " = ", exp]

function maybeRefAssignment(exp: ASTNode, base: string = "ref"): {
  ref: ASTNode
  hoistDec: DeclarationStatement?
  refAssignment: ASTNode
}
  let hoistDec, refAssignment
  ref := maybeRef exp, base
  unless ref is exp
    { hoistDec, refAssignment } = makeRefAssignment ref, exp

  return { ref, hoistDec, refAssignment }

export {
  makeRef
  makeRefAssignment
  maybeRef
  maybeRefAssignment
  needsRef
}
