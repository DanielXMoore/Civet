/**
 * lib.civet holds functions that are used inside parser.hera
 *
 * The rules inside parser.hera should be simple and short.
 * Most of the helpers/transforms should make their way into
 * here eventually.
 */

import type {
  ASTLeaf
  ASTNode
  ASTNodeBase
  Binding
  BlockStatement
  DeclarationStatement
  FunctionNode
  LabeledStatement
  MethodDefinition
  ParseRule
  ReturnTypeAnnotation
  StatementTuple
  TypeSuffix
  WSNode
} from types.civet

import {
  gatherRecursiveWithinFunction
  findAncestor
  gatherNodes
  gatherRecursive
  gatherRecursiveAll
} from traversal.civet

import {
  addParentPointers
  deepCopy
  getTrimmingSpace
  hasAwait
  hasYield
  insertTrimmingSpace
  isAsyncGeneratorVoidType
  isComma
  isEmptyBareBlock
  isFunction
  isGeneratorVoidType
  isPromiseVoidType
  isVoidType
  isWhitespaceOrEmpty
  literalValue
  makeAmpersandFunction
  makeLeftHandSideExpression
  makeNode
  makeRef
  maybeRef
  updateParentPointers
  wrapIIFE
  wrapWithReturn
} from util.civet

import {
  blockWithPrefix
  braceBlock
  duplicateBlock
  getIndent
  hoistRefDecs
  makeEmptyBlock
  processBlocks
} from block.civet

import { processPipelineExpressions } from pipe.civet
import { forRange, processForInOf } from for.civet
import { processDeclarationConditions, processPatternMatching } from pattern-matching.civet
import {
  adjustAtBindings
  adjustBindingElements
  gatherBindingCode
} from binding.civet
import { processBinaryOpExpression } from op.civet
import { processUnaryExpression } from unary.civet
import { createConstLetDecs, createVarDecs } from auto-dec.civet

import {
  dedentBlockString
  dedentBlockSubstitutions
  getIndentLevel
  modifyString
  processCoffeeInterpolation
  quoteString
} from string.civet

function addPostfixStatement(statement: StatementTuple, ws: ASTNode, post)
  expressions := [
    ...post.blockPrefix or []
    ["", statement]
  ]

  block := makeNode {
    type: "BlockStatement"
    children: [" { ", expressions, " }"]
    expressions
  }

  children := [...post.children, block]

  // This removes trailing whitespace for easier testing
  if (!isWhitespaceOrEmpty(ws)) children.push(ws)

  post = makeNode { ...post, children, block }
  if post.type is "IfStatement"
    post.then = block
  return post

assert := {
  equal(a, b, msg): void
    /* c8 ignore next */
    throw new Error(`Assertion failed [${msg}]: ${a} !== ${b}`) if a !== b
}

// Negate expression inside condition
function negateCondition(condition)
  { expression } .= condition
  children := condition.children.slice()
  i := children.indexOf(expression)
  if i < 0
    throw new Error `Could not find expression in condition`
  children[i] = expression =
    type: "UnaryExpression"
    children: [
      "!"
      makeLeftHandSideExpression expression
    ]
  { ...condition, expression, children }

function expressionizeIfClause(clause, b, e)
  { condition } := clause  // remove 'if'
  [ ...condRest, closeParen ] := condition.children  // separate ')'
  children := [
    ...condRest
    "?"
    b
  ]
  if e
    // Replace 'else' in e[1] with ':'. (e[0] is space before 'else')
    children.push e[0], ":", ...e[2..]
  else
    children.push ":void 0"
  children.push closeParen

  {
    type: "IfExpression",
    children,
  }

function expressionizeTypeIf([ws, ifOp, condition, t, e])
  children := [
    ws
    "("
    insertTrimmingSpace condition, ""
    "?"
  ]
  unless ifOp.negated xor condition.negated // if
    children.push t
    if e
      // Replace 'else' in e[1] with ':'. (e[0] is space before 'else')
      children.push e[0], ":", ...e[2..]
    else
      children.push ":never"
  else // unless
    if e
      children.push ...e[2..], e[0], ":"
    else
      children.push "never:"
    children.push t
  children.push ")"
  children

function expressionizeIteration(exp): void
  const { async, subtype, block, children, statement } = exp
  const i = children.indexOf(statement)
  if i < 0
    throw new Error("Could not find iteration statement in iteration expression")

  if subtype is "DoStatement"
    // Just wrap with IIFE
    insertReturn(block)
    children.splice(i, 1, ...wrapIIFE(["", statement, undefined], async))
    updateParentPointers exp
    return

  const resultsRef = makeRef("results")

  // insert `results.push` to gather results array
  insertPush(block, resultsRef)
  braceBlock(block)

  // Wrap with IIFE
  children.splice(i,
    1,
    ...wrapIIFE([
      ["", ["const ", resultsRef, "=[]"], ";"],
      ...children.map((c) => ["", c, undefined]),
      ["", wrapWithReturn(resultsRef)],
    ], async)
  )
  updateParentPointers exp

/**
 * This adjusts #x.y().z and @x.y().z when used inside Object glob expressions
 * to remove `this.` where necessary.
 *
 * [See More](../test/object.civet)
 */
function handleThisPrivateShorthands(value)
  if value.privateShorthand
    value = value.children[1].children[1]

    return [value, false]

  if value.type is "MemberExpression" or value.type is "CallExpression"
    suppressPrefix .= value.thisShorthand
    value = {
      ...value,
      children: value.children.map (c, i) =>
        if i is 0
          let s
          [c, s] = handleThisPrivateShorthands c
          suppressPrefix ||= s

        c
    }

    return [value, suppressPrefix]

  return [value, value.thisShorthand]

/**
 * Process globs, bind shorthand, and call shortcuts, in Call/MemberExpression
 */
function processCallMemberExpression(node)
  { children } := node

  // Parenthesized operator like (+), immediately called, expands to
  // use of the operator. This is useful for e.g. shortcutting (&&).
  if children[0]?.parenthesizedOp?.token and children[1]?.type is "Call"
    op := children[0].parenthesizedOp
    call .= children[1]
    args := [...call.args] // shallow copy
    call = { ...call, args }
    // Remove trailing comma
    if comma := isComma args.-1
      comma.token = ''
    // Arguments already start and end with open and close parentheses.
    // Replace each comma with an instance of the operator and matching parens.
    commaCount .= 0
    for each arg of args
      if comma := isComma arg
        comma.token = `)${op.token}(`
        commaCount++
    // Don't mess with (+)()
    if args.length
      children.splice 0, 2,
        commaCount ?
          type: "ParenthesizedExpression",
          children: ["(", call, ")"]
        : { ...call, type: "ParenthesizedExpression" }

  // Process globs and bind shorthand
  for (let i = 0; i < children.length; i++) {
    const glob = children[i]
    if (glob?.type is "PropertyGlob") {
      let prefix = children.slice(0, i)
      const parts = []
      let hoistDec, refAssignment
      // add ref to ensure object base evaluated only once
      if (prefix.length > 1) {
        const ref = makeRef()
        hoistDec = {
          type: "Declaration",
          children: ["let ", ref],
          names: [],
        }
        refAssignment = [{
          type: "AssignmentExpression",
          children: [ref, " = ", prefix],
        }, ","]
        prefix = [ref]
      }
      prefix = prefix.concat(glob.dot)

      for (const part of glob.object.properties) {
        if part.type is "MethodDefinition"
          throw new Error("Glob pattern cannot have method definition")
        if part.value and !["CallExpression", "MemberExpression", "Identifier"].includes(part.value.type)
          throw new Error(`Glob pattern must have call or member expression value, found ${JSON.stringify(part.value)}`)

        suppressPrefix .= false
        value .= part.value ?? part.name
        wValue := getTrimmingSpace part.value

        [value, suppressPrefix] = handleThisPrivateShorthands value

        if !suppressPrefix // Don't prefix @ shorthand
          value = prefix.concat(insertTrimmingSpace(value, ""))
        if (wValue) value.unshift(wValue)
        if (part.type is "SpreadProperty") {
          parts.push({
            type: part.type,
            value,
            dots: part.dots,
            delim: part.delim,
            names: part.names,
            children: part.children.slice(0, 2) // whitespace, ...
              .concat(value, part.delim)
          })
        } else {
          parts.push({
            type: part.type is "Identifier" ? "Property" : part.type,
            name: part.name,
            value,
            delim: part.delim,
            names: part.names,
            children: [
              isWhitespaceOrEmpty(part.children[0]) and part.children[0],
              part.name,
              isWhitespaceOrEmpty(part.children[2]) and part.children[2],
              part.children[3]?.token is ":" ? part.children[3] : ":",
              value,
              part.delim, // comma delimiter
            ]
          })
        }
      }
      let object = {
        type: "ObjectExpression",
        children: [
          glob.object.children.0, // {
          ...parts,
          glob.object.children.-1, // whitespace and }
        ],
        properties: parts,
        hoistDec,
      }
      if (refAssignment) {
        object = {
          type: "ParenthesizedExpression",
          children: ["(", ...refAssignment, object, ")"],
          expression: object,
        }
      }
      if (i is children.length - 1) return object
      return processCallMemberExpression({  // in case there are more
        ...node,
        children: [object, ...children.slice(i + 1)]
      })
    } else if (glob?.type is "PropertyBind") {
      // TODO: add ref to ensure object base evaluated only once
      const prefix = children.slice(0, i)
      return processCallMemberExpression({  // in case there are more
        ...node,
        children: [
          prefix,
          {
            ...glob,
            type: "PropertyAccess",
            children: [...glob.children, ".bind(", prefix, ")"]
          },
          ...children.slice(i + 1)
        ]
      })
    }
  }
  return node

function wrapIterationReturningResults(statement, outer, outerRef?): void {
  if (statement.type is "DoStatement") {
    if (outerRef) {
      insertPush(statement.block, outerRef)
    } else {
      insertReturn(statement.block, outer)
    }
    return
  }

  const resultsRef = makeRef("results")

  const declaration = {
    type: "Declaration",
    children: ["const ", resultsRef, "=[];"],
  }

  insertPush(statement.block, resultsRef)

  outer.children.unshift(declaration)
  if (outerRef) {
    statement.children.push(";", outerRef, ".push(", resultsRef, ");")
  } else {
    statement.children.push(";return ", resultsRef, ";")
  }
}

// NOTE: this is almost the same as insertReturn but doesn't remove `breaks` in `when` and
// does construct an else clause pushing undefined in if statements that lack them
// and adds to the beginning and the end of the expression's children.
// Maybe these insertion modifications can be refactored to be more DRY eventually.
function insertPush(node, ref): void {
  if (!node) return
  // TODO: unify this with the `exp` switch
  switch (node.type) {
    case "BlockStatement":
      if (node.expressions.length) {
        const last = node.expressions[node.expressions.length - 1]
        insertPush(last, ref)
      } else {
        node.expressions.push([ref, ".push(void 0);"])
      }
      return
    case "CaseBlock":
      node.clauses.forEach((clause) => {
        insertPush(clause, ref)
      })
      return
    // NOTE: "CaseClause"s don't push
    case "WhenClause":
      insertPush(node.block, ref)
      return
    case "DefaultClause":
      insertPush(node.block, ref)
      return
  }
  if (!Array.isArray(node)) return

  [, exp] .= node
  return unless exp
  indent := getIndent(node)

  outer := exp
  {type} .= exp
  if type is "LabelledStatement"
    exp = (exp as LabeledStatement).statement
    {type} = exp

  switch (exp.type) {
    case "BreakStatement":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "EmptyStatement":
    case "ReturnStatement":
    case "ThrowStatement":
      return
    case "Declaration":
      exp.children.push(["", [";", ref, ".push(",
        patternAsValue(exp.bindings.-1.pattern), ")"]])
      return
    case "ForStatement":
    case "IterationStatement":
    case "DoStatement":
      wrapIterationReturningResults(exp, outer, ref)
      return
    case "BlockStatement":
      insertPush(exp.expressions[exp.expressions.length - 1], ref)
      return
    case "IfStatement":
      // if block
      insertPush(exp.then, ref)
      if (exp.then.bare)
        exp.then.children.push(";")
      // else block
      if (exp.else) insertPush(exp.else[2], ref)
      // Add else block pushing undefined if no else block
      else exp.children.push([" else {\n", indent, ref, ".push(undefined)\n", indent, "}"])
      return
    case "PatternMatchingStatement":
      insertPush(exp.children[0][0], ref)
      return
    case "SwitchStatement":
      // insert a results.push in each case block
      insertPush(exp.children[2], ref)
      return
    case "TryStatement":
      // NOTE: CoffeeScript doesn't add a push to an empty catch block but does add if there is any statement in the catch block
      // we always add a push to the catch block
      // NOTE: does not insert a push in the finally block
      exp.blocks.forEach((block) => insertPush(block, ref))
      return
  }

  // Don't push if there's a trailing semicolon
  if (node[node.length - 1]?.type is "SemicolonDelimiter") return

  // Insert push wrapping expression
  node.splice(1, 0, ref, ".push(")
  node.push(")")
}

function processParams(f): void {
  const { type, parameters, block } = f
  const isConstructor = f.name is 'constructor'

  // Check for singleton TypeParameters <Foo> before arrow function,
  // which TypeScript (in tsx mode) treats like JSX; replace with <Foo,>
  if (type is "ArrowFunction" and parameters and parameters.tp and parameters.tp.parameters.length is 1) {
    parameters.tp.parameters.push(",")
  }

  if (!block) return
  const { expressions } = block
  if (!expressions) return
  const { blockPrefix } = parameters

  let indent: string
  if (!expressions.length) {
    indent = ""
  } else {
    indent = expressions[0][0]
  }

  const [splices, thisAssignments] = gatherBindingCode(parameters, {
    injectParamProps: isConstructor
  })

  const delimiter = {
    type: "SemicolonDelimiter",
    children: [";"],
  }

  const prefix = splices
    .map (s) => ["let ", s]
    .concat(thisAssignments)
    .map((s) => s.type
      ? {
        // TODO: figure out how to get JS only statement tuples
        ...s,
        children: [indent, ...s.children, delimiter]
      }
      : [indent, s, delimiter]
    )

  if (!prefix.length) return
  // In constructor definition, insert prefix after first super() call
  if (isConstructor) {
    const superCalls = gatherNodes expressions, (exp) =>
      exp.type is "CallExpression" and exp.children[0]?.token is "super"
    if (superCalls.length) {
      const {child} = findAncestor(superCalls[0],
        (ancestor) => ancestor is block)
      const index = findChildIndex(expressions, child)
      if (index < 0) {
        throw new Error("Could not find super call within top-level expressions")
      }
      expressions.splice(index + 1, 0, ...prefix)
      return
    }
  }
  expressions.unshift(...prefix)
}

/**
 * If `child.parent is parent`, then this should find the index `i` such that
 * `parent.children[i]` contains `child`.  This requires looking in
 * `parent.children` while descending into any arrays.
 * Also works if you pass an array (such as `parent.children`) as the `parent`,
 * which is useful for working with e.g. the `expressions` property.
 * Returns -1 if `child` cannot be found.
 */
function findChildIndex(parent, child)
  children := Array.isArray(parent) ? parent : parent.children
  for each c, i of children
    if c is child or (Array.isArray(c) and arrayRecurse(c))
      return i
  function arrayRecurse(array)
    for each c, i of array
      if c is child or (Array.isArray(c) and arrayRecurse(c))
        return true
  return -1

/**
 * Replace this node with another, by modifying its parent's children.
 */
function replaceNode(node: ASTNodeBase, newNode: ASTNode): void
  unless node.parent?
    throw new Error "replaceNode failed: node has no parent"
  function recurse(children: ASTNode[]): boolean
    for each child, i of children
      if child is node
        children[i] = newNode
        return true
      else if Array.isArray child
        return true if recurse child
    return false
  unless recurse node.parent.children
    throw new Error "replaceNode failed: didn't find child node in parent"
  if newNode <? "object" and not Array.isArray newNode
    newNode.parent = node.parent

function patternAsValue(pattern) {
  switch (pattern.type) {
    case "ArrayBindingPattern": {
      const children = [...pattern.children]
      const index = children.indexOf(pattern.elements)
      if (index < 0) throw new Error("failed to find elements in ArrayBindingPattern")
      children[index] = pattern.elements.map((el) => {
        const [ws, e, delim] = el.children
        return { ...el, children: [ws, patternAsValue(e), delim] }
      })
      return { ...pattern, children }
    }
    case "ObjectBindingPattern": {
      const children = [...pattern.children]
      const index = children.indexOf(pattern.properties)
      if (index < 0) throw new Error("failed to find properties in ArrayBindingPattern")
      children[index] = pattern.properties.map(patternAsValue)
      return { ...pattern, children }
    }
    case "Identifier":
    case "BindingProperty": {
      const children = [pattern.name, pattern.delim]
      // Check for leading whitespace
      if (isWhitespaceOrEmpty(pattern.children[0])) {
        children.unshift(pattern.children[0])
      }
      return { ...pattern, children }
    }
    default:
      return pattern
  }
}

// [indent, statement, semicolon]
function insertReturn(node: ASTNode, outerNode: ASTNode = node): void
  if (!node) return
  // TODO: unify this with the `exp` switch
  switch node.type
    case "BlockStatement":
      if node.expressions.length
        const last = node.expressions[node.expressions.length - 1]
        insertReturn(last)
      else
        // NOTE: Kind of hacky but I'm too much of a coward to make `->` add an implicit return
        if node.parent.type is "CatchClause"
          node.expressions.push(["return"])
      return
    // NOTE: "CaseClause"s don't get a return statements inserted
    case "WhenClause":
      // Remove inserted `break;` if it hasn't already been removed
      node.children.splice node.children.indexOf(node.break), 1 if node.break
      if node.block.expressions.length
        insertReturn(node.block)
      else
        node.block.expressions.push(wrapWithReturn())
      return
    case "DefaultClause":
      insertReturn(node.block)
      return
  if (!Array.isArray(node)) return

  [, exp, semi] .= node
  return if semi?.type is "SemicolonDelimiter"
  return unless exp

  outer := exp
  {type} .= exp
  if type is "LabelledStatement"
    exp = (exp as LabeledStatement).statement
    {type} = exp

  switch type
    case "BreakStatement":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "EmptyStatement":
    case "ReturnStatement":
    case "ThrowStatement":
      return
    case "Declaration":
      exp.children.push ["", {
        type: "ReturnStatement",
        children: [";return ", patternAsValue(exp.bindings.-1.pattern)],
        parent: exp
      }]
      return
    case "FunctionExpression":
      // Add return after function declaration if it has an id to not interfere with hoisting
      if (exp.id)
        exp.children.push ["",
          type: "ReturnStatement"
          children: [";return ", exp.id]
          parent: exp
        ]
        return
      /* c8 ignore next 3 */
      // This is currently never hit because anonymous FunctionExpressions are already wrapped in parens by this point
      // Add return in normal way for functions without ids
      break
    case "ForStatement":
    case "IterationStatement":
    case "DoStatement":
      wrapIterationReturningResults(exp, outer)
      return
    case "BlockStatement":
      insertReturn(exp.expressions[exp.expressions.length - 1])
      return
    case "IfStatement":
      // if block
      insertReturn(exp.then)
      // else block
      if (exp.else) insertReturn(exp.else[2])
      // Add explicit return after if block if no else block
      else exp.children.push ["", {
        type: "ReturnStatement"
        // NOTE: add a prefixed semi-colon because the if block may not be braced
        children: [";return"]
        parent: exp
      }]
      return
    case "PatternMatchingStatement":
      insertReturn(exp.children[0][0])
      return
    case "SwitchStatement":
      insertSwitchReturns(exp)
      return
    case "TryStatement":
      exp.blocks.forEach((block) => insertReturn(block))
      // NOTE: do not insert a return in the finally block
      return

  // Don't add return if there's a trailing semicolon
  if (node[node.length - 1]?.type is "SemicolonDelimiter") return

  // Insert return after indentation and before expression
  const returnStatement = wrapWithReturn(node[1])
  node.splice(1, 1, returnStatement)

// insert a return in each when/else/default block
// case blocks don't get implicit returns
// maybe default blocks shouldn't either?
function insertSwitchReturns(exp): void
  exp.caseBlock.clauses.forEach (clause) =>
    insertReturn clause


// Wrap expression in parentheses to make into a statement when:
// * object literal expression
// * anonymous function expression
// * comma operators applied to above
function makeExpressionStatement(expression: ASTNode): ASTNode
  if Array.isArray(expression) and expression[1]?[0]?[0]?[1]?.token is "," // CommaExpression
    [
      makeExpressionStatement expression[0]
      expression[1].map ([comma, exp]) => // CommaDelimiter AssignmentExpression
        [comma, makeExpressionStatement exp]
    ]
  else if expression?.type is "ObjectExpression" or
          (expression?.type is "FunctionExpression" and not expression.id)
    makeLeftHandSideExpression expression
  else
    expression

const typeNeedsNoParens = new Set [
  "IdentifierType"
  "ImportType"
  "LiteralType"
  "TupleType"
  "ParenthesizedType"
  "UnaryType"
]

/**
 * Parenthesize type if it might need it in some contexts.
 */
function parenthesizeType(type: ASTNodeBase)
  return type if typeNeedsNoParens.has type.type
  ["(", type, ")"]

// Look for last property access like `.foo` or `[computed]` or root Identifier,
// before any calls like `(args)`, non-null assertions `!`, and optionals `?`.
// The return value should have a `name` property (for "Identifier" and
// "Index"), or have `type` of "Index" (for `[computed]`), or be undefined.
function lastAccessInCallExpression(exp) {
  return exp if exp.type is "Identifier"
  let children, i
  do {
    ({ children } = exp)
    i = children.length - 1
    while (i >= 0 and (
      children[i].type is "Call" ||
      children[i].type is "NonNullAssertion" ||
      children[i].type is "Optional"
    )) i--
    if (i < 0) return
    // Recurse into nested MemberExpression, e.g. from `x.y()`
  } while (children[i].type is "MemberExpression" and (exp = children[i]))
  return children[i]
}

// Given a MethodDefinition, convert into a FunctionExpression.
// Returns undefined if the method is a getter or setter.
function convertMethodToFunction(method) {
  const { signature, block } = method
  let { modifier, optional } = signature
  if (optional) return
  if (modifier) {
    if (modifier.get or modifier.set) {
      return
    } else if (modifier.async) {
      // put function after async
      modifier = [modifier.children[0][0], " function ", ...modifier.children.slice(1)]
    } else {
      modifier = ["function ", ...(modifier.children or [])]
    }
  } else {
    modifier = "function ";
  }
  return {
    ...signature,
    id: signature.name,
    signature,
    type: "FunctionExpression",
    children: [
      [modifier, ...signature.children.slice(1)],
      block,
    ],
    block,
  }
}

/**
 * Convert type suffix of `?: T` to `: undefined | T`
 */
function convertOptionalType(suffix: TypeSuffix | ReturnTypeAnnotation): void
  if (suffix.t as ASTNodeBase).type is "AssertsType"
    spliceChild suffix, suffix.optional, 1, suffix.optional =
      type: "Error"
      message: "Can't use optional ?: syntax with asserts type"
    return
  spliceChild suffix, suffix.optional, 1, suffix.optional = undefined
  // Return types with | need to be wrapped in parentheses
  wrap := suffix.type is "ReturnTypeAnnotation"
  spliceChild suffix, suffix.t, 1, suffix.t = [
    getTrimmingSpace suffix.t
    wrap and "("
    // TODO: avoid parens if unnecessary
    "undefined | "
    parenthesizeType insertTrimmingSpace suffix.t, ""
    wrap and ")"
  ]

// Convert an ObjectExpression (with `properties`)
// into a set of JSX attributes.
// {foo} is equivalent to foo={foo}, and
// {foo, bar: baz} is equivalent to foo={foo} and bar={baz}.
// {...foo} is a special case.
function convertObjectToJSXAttributes(obj) {
  const { properties } = obj
  const parts = [] // JSX attributes
  const rest = []  // parts that need to be in {...rest} form
  for (let i = 0; i < properties.length; i++) {
    if (i > 0) parts.push(' ')
    const part = properties[i]
    switch (part.type) {
      case 'Identifier':
        parts.push([part.name, '={', part.name, '}'])
        break
      case 'Property':
        if (part.name.type is 'ComputedPropertyName') {
          rest.push(part)
        } else {
          parts.push([part.name, '={', insertTrimmingSpace(part.value, ''), '}'])
        }
        break
      case 'SpreadProperty':
        parts.push(['{', part.dots, part.value, '}'])
        break
      case 'MethodDefinition':
        const func = convertMethodToFunction(part)
        if (func) {
          parts.push([part.name, '={', convertMethodToFunction(part), '}'])
        } else {
          rest.push(part)
        }
        break
      default:
        throw new Error(`invalid object literal type in JSX attribute: ${part.type}`)
    }
  }
  if (rest.length) {
    parts.push(['{...{', ...rest, '}}'])
  }
  return parts
}

/**
 * Returns a new MethodDefinition node.
 */
function makeGetterMethod(name, ws, value, returnType, block?: BlockStatement, kind: { token: "get" | "set" } = { token: "get" }, autoReturn: boolean = true): MethodDefinition
  { token } := kind
  ws = insertTrimmingSpace(ws, "")
  let setVal
  parameters := token is "get" ?
    type: "Parameters"
    children: ["()"]
    names: []
    implicit: true
  :
    type: "Parameters"
    children: ["(", setVal = makeRef("value"), ")"]
    names: []
    implicit: false

  let expressions: StatementTuple[]
  if block
    // Duplicate block to avoid mutating original
    block = duplicateBlock(block)
    expressions = block.expressions
  else
    expressions = []
    block = {
      type: "BlockStatement"
      expressions
      children: ["{ ", expressions, " }"]
    }

  if autoReturn
    finalStatement: StatementTuple := token is "get" ?
      [ [expressions[0]?.[0] or "", ws], wrapWithReturn(value) ]
    :
      [ [expressions[0]?.[0] or "", ws], [ value, " = ", setVal ] ]

    expressions.push finalStatement

  children := [kind, " ", name, parameters, returnType, block]

  return {
    type: "MethodDefinition",
    children,
    name,
    signature: {
      type: "MethodSignature"
      modifier: {
        get: token is "get"
        set: token is "set"
        async: false
      },
      name,
      returnType,
    },
    block,
    parameters,
  }

function processAssignmentDeclaration(decl: ASTLeaf, pattern: Binding["pattern"], suffix: TypeSuffix, ws: WSNode, assign: ASTLeaf, e: ASTNode)
  // Adjust position to space before assignment to make TypeScript remapping happier
  decl = {
    ...decl,
    $loc:
      pos: assign.$loc.pos - 1
      length: assign.$loc.length + 1
  }

  [splices, assignments] .= gatherBindingCode pattern

  splices = splices.map (s) => [", ", s]
  thisAssignments := assignments.map (a) => ["", a, ";"] as const

  initializer := [ws, assign, e]
  binding := makeNode {
    type: "Binding",
    pattern,
    initializer,
    splices,
    suffix,
    thisAssignments,
    children: [pattern, suffix, initializer]
  }

  children := [decl, binding]

  makeNode {
    type: "Declaration",
    pattern.names,
    decl,
    bindings: [binding],
    splices,
    thisAssignments,
    children,
  }

function processDeclarations(statements: StatementTuple[]): void
  // @ts-ignore
  gatherRecursiveAll statements, .type is "Declaration"
  // @ts-ignore
  .forEach ({ bindings }: DeclarationStatement) =>
    bindings?.forEach (binding) =>
      suffix := binding.suffix
      if suffix and suffix.optional and suffix.t
        // Convert `let x?: T` to `let x: undefined | T`
        convertOptionalType suffix

      { initializer } := binding
      if initializer
        exp := initializer[2]

// Add implicit block unless followed by a method/function of the same name,
// or block is within an ExportDeclaration.
function implicitFunctionBlock(f): void {
  if (f.abstract or f.block or f.signature?.optional) return

  const { name, parent } = f
  if (parent?.type is "ExportDeclaration") return
  const expressions = parent?.expressions ?? parent?.elements
  const currentIndex = expressions?.findIndex(([, def]) => def is f)
  const following = currentIndex >= 0 and expressions[currentIndex + 1]?.[1]

  if (f.type is following?.type and name and name is following.name) {
    f.ts = true
  } else {
    const block = makeEmptyBlock()
    block.parent = f
    f.block = block
    f.children.push(block)
    f.ts = false
  }
}

function processReturn(f: FunctionNode, implicitReturns: boolean): void
  { returnType } .= f.signature
  if returnType and returnType.optional
    convertOptionalType returnType

  if (!processReturnValue(f) and implicitReturns)
    { signature, block } := f
    { modifier, name, returnType } := signature
    { async, generator, set } := modifier
    isMethod := f.type is "MethodDefinition"
    isConstructor := isMethod and name is "constructor"
    isVoid := (or)
      isVoidType(returnType?.t)
      (and)
        async
        (or)
          isPromiseVoidType(returnType?.t)
          generator and isAsyncGeneratorVoidType(returnType?.t)
      (and)
        not async
        generator
        isGeneratorVoidType(returnType?.t)

    if block?.type is "BlockStatement"
      if isVoid or set or isConstructor
        if block.bare and block.implicitlyReturned
          block.children = [ " {", ...block.children, " }" ]
          block.bare = block.implicitlyReturned = false
      else
        unless block.implicitlyReturned
          insertReturn(block)

function processFunctions(statements, config): void
  gatherRecursiveAll(statements, ({ type }) => type is "FunctionExpression" or type is "ArrowFunction")
  .forEach (f) =>
    if (f.type is "FunctionExpression") implicitFunctionBlock(f)
    processParams(f)
    processReturn(f, config.implicitReturns)

  gatherRecursiveAll(statements, ({ type }) => type is "MethodDefinition")
  .forEach (f) =>
    implicitFunctionBlock(f)
    processParams(f)
    processReturn(f, config.implicitReturns)


function processBindingPatternLHS(lhs, tail): void {
  // Expand AtBindings first before gathering splices
  adjustAtBindings(lhs, true)
  const [splices, thisAssignments] = gatherBindingCode(lhs)
  // TODO: This isn't quite right for compound assignments, may need to wrap with parens and use comma to return the complete value
  tail.push(...splices.map((s) => [", ", s]), ...thisAssignments.map((a) => [", ", a]))
}

function processAssignments(statements): void {
  // Move assignments/updates within LHS of assignments/updates
  // to run earlier via comma operator
  gatherRecursiveAll(statements, (n) => n.type is "AssignmentExpression" or n.type is "UpdateExpression")
    .forEach((exp) => {
      function extractAssignment(lhs) {
        let expr = lhs
        while expr.type is "ParenthesizedExpression"
          expr = expr.expression
        if (expr.type is "AssignmentExpression" ||
          expr.type is "UpdateExpression") {
          if (expr.type is "UpdateExpression" &&
            expr.children[0] is expr.assigned) {  // postfix update
            pre.push("(")
            post.push([", ", lhs, ")"])
          } else {
            pre.push(["(", lhs, ", "])
            post.push(")")
          }
          // TODO: use ref to avoid duplicating function calls
          return expr.assigned
        }
      }
      const pre = [], post = []
      switch (exp.type) {
        case "AssignmentExpression":
          if (!exp.lhs) return
          exp.lhs.forEach((lhsPart, i) => {
            let newLhs = extractAssignment(lhsPart[1])
            if (newLhs) {
              lhsPart[1] = newLhs
            }
          })
          break
        case "UpdateExpression":
          let newLhs = extractAssignment(exp.assigned)
          if (newLhs) {
            const i = exp.children.indexOf(exp.assigned)
            exp.assigned = exp.children[i] = newLhs
          }
          break
      }
      if (pre.length) exp.children.unshift(...pre)
      if (post.length) exp.children.push(...post)
      // TODO: need to make this a parenthesized expression when when we add parens
    })

  gatherRecursiveAll(statements, (n) => n.type is "AssignmentExpression" and n.names is null)
    .forEach((exp) => {
      let { lhs: $1, exp: $2 } = exp, tail = [], i = 0, len = $1.length

      // identifier=, xor=, ++=
      if $1.some((left) => left[left.length - 1].special)
        if ($1.length !== 1) throw new Error("Only one assignment with id= is allowed")
        [, lhs, , op] := $1[0]
        { call, omitLhs } := op
        // Wrap right-hand side with call
        index := exp.children.indexOf($2)
        if (index < 0) throw new Error("Assertion error: exp not in AssignmentExpression")
        exp.children.splice index, 1,
          exp.exp = $2 = [call, "(", lhs, ", ", $2, ")"]
        if omitLhs
          replaceNode exp, $2

      // Force parens around destructuring object assignments
      // Walk from left to right the minimal number of parens are added and enclose all destructured assignments
      // TODO: Could validate some lhs ecmascript rules here if we wanted to
      let wrapped = false
      while (i < len) {
        const lastAssignment = $1[i++]
        const [, lhs, , op] = lastAssignment
        if (op.token !== "=") continue

        if (lhs.type is "ObjectExpression" or lhs.type is "ObjectBindingPattern") {
          // Wrap with parens to distinguish from braced blocks
          if (!wrapped) {
            wrapped = true
            lhs.children.splice(0, 0, "(")
            tail.push(")")
          }
        }
      }

      // TODO: Handle optional assignment refs

      // Walk from right to left to handle splices
      i = len - 1
      while (i >= 0) {
        const lastAssignment = $1[i]

        if (lastAssignment[3].token is "=") {
          const lhs = lastAssignment[1]

          // Splice assignment
          if (lhs.type is "MemberExpression") {
            const members = lhs.children
            const lastMember = members[members.length - 1]

            // TODO: this is kind of bonkers
            if (lastMember.type is "SliceExpression") {
              const { start, end, children: c } = lastMember
              // TODO: don't lose as many source mappings
              c[0].token = ".splice("
              c[1] = start
              c[2] = ", "
              if (end)
                c[3] = [end, " - ", start]
              else
                c[3] = ["1/0"]
              c[4] = [", ...", $2]
              c[5] = ")"

              // Remove assignment token
              lastAssignment.pop()
              if (isWhitespaceOrEmpty(lastAssignment[2])) lastAssignment.pop()
              // TODO: this only works for the last assignment, not multiple splice assignments, or splice assignments earlier in the chain
              if ($1.length > 1) {
                throw new Error("Not implemented yet! TODO: Handle multiple splice assignments")
              }

              exp.children = [$1]
              exp.names = []
              return
            }
          } else if (lhs.type is "ObjectBindingPattern" or lhs.type is "ArrayBindingPattern") {
            processBindingPatternLHS(lhs, tail)
          }
          // NOTE: currently not processing any non-binding pattern ObjectExpression or ArrayExpressions
          // This might not be correct in all situations, esp BindingPatterns nested inside ObjectExpressions
        }
        i--
      }

      // Gather all identifier names from the lhs array
      exp.names = $1.flatMap(([, l]) => l.names or [])
      const index = exp.children.indexOf($2)
      if (index < 0) throw new Error("Assertion error: exp not in AssignmentExpression")
      exp.children.splice(index + 1, 0, ...tail)
    })
}

function attachPostfixStatementAsExpression(exp, post): void {
  switch (post[1].type) {
    case "ForStatement":
    case "IterationStatement":
    case "DoStatement": {
      const statement = addPostfixStatement(exp, ...post)
      return {
        type: "IterationExpression",
        children: [statement],
        block: statement.block,
        statement,
      }
    }
    case "IfStatement":
      return expressionizeIfClause(post[1], exp)
    default:
      throw new Error("Unknown postfix statement")
  }
}

function processTypes(node: ASTNode)
  // T? -> T | undefined; T?? -> T | undefined | null
  gatherRecursiveAll node, (n) => n.type is "UnaryType"
  // @ts-ignore
  .forEach (unary: ASTNodeBase): void =>
    let last: ASTNode
    count .= 0
    while unary.suffix.length and unary.suffix.-1?.token is "?"
      last = unary.suffix.pop()
      count++
    return unless count
    if unary.parent?.type is "TypeTuple"
      // Leave one ? inside a type tuple
      if count is 1
        unary.suffix.push last
        return
      replaceNode unary, [
        getTrimmingSpace unary
        "("
        parenthesizeType insertTrimmingSpace unary, ""
        " | null)"
        last
      ]
    else
      replaceNode unary, [
        getTrimmingSpace unary
        "("
        parenthesizeType insertTrimmingSpace unary, ""
        count is 1 ? " | undefined" : " | undefined | null"
        ")"
      ]

function processProgram(root: BlockStatement, config, m, ReservedWord: ParseRule): void {
  // invariants
  assert.equal(m.forbidBracedApplication.length, 1, "forbidBracedApplication")
  assert.equal(m.forbidClassImplicitCall.length, 1, "forbidClassImplicitCall")
  assert.equal(m.forbidIndentedApplication.length, 1, "forbidIndentedApplication")
  assert.equal(m.forbidNewlineBinaryOp.length, 1, "forbidNewlineBinaryOp")
  assert.equal(m.forbidTrailingMemberProperty.length, 1, "forbidTrailingMemberProperty")
  assert.equal(m.JSXTagStack.length, 1, "JSXTagStack")

  addParentPointers(root)

  const { expressions: statements } = root

  processTypes(statements)
  processDeclarationConditions(statements)
  processPipelineExpressions(statements)
  processDeclarations(statements)
  processAssignments(statements)
  processPatternMatching(statements, ReservedWord)

  // Modify iteration expressions
  gatherRecursiveAll(statements, (n) => n.type is "IterationExpression")
    .forEach((e) => expressionizeIteration(e))

  // Hoist hoistDec attributes to actual declarations.
  // NOTE: This should come after iteration expressions get processed
  // into IIFEs.
  hoistRefDecs(statements)

  // Adding implicit returns should happen after hoisting any ref declarations
  // so their target node can be found in the block without being inside a return
  processFunctions(statements, config)

  // Insert prelude
  statements.unshift(...m.prelude)

  if (config.autoLet) {
    createConstLetDecs(statements, [], "let")
  } else if(config.autoConst) {
    createConstLetDecs(statements, [], "const")
  } else if (config.autoVar) {
    createVarDecs(statements, [])
  }

  processBlocks(statements)

  populateRefs(statements)
  adjustAtBindings(statements)
}

function populateRefs(statements: ASTNode): void {
  const refNodes = gatherRecursive(statements, ({ type }) => type is "Ref")

  if (refNodes.length) {
    // Find all ids within nested scopes
    const ids = gatherRecursive(statements, (s) => s.type is "Identifier")
    const names = new Set(ids.flatMap(({ names }) => names or []))

    // Populate each ref
    refNodes.forEach((ref) => {
      const { type, base } = ref
      if (type !== "Ref") return

      ref.type = "Identifier"

      let n = 0
      let name = base

      // check for name collisions and increment name suffix
      while (names.has(name)) {
        n++
        name = `${base}${n}`
      }

      names.add(name)
      ref.children = ref.names = [name]
    })
  }
}

/**
 * Support for `return.value` and `return =`
 * for changing automatic return value of function.
 * Returns whether any present (so shouldn't do implicit return).
 */
function processReturnValue(func: FunctionNode)
  { block } := func
  values: ASTNodeBase[] := (gatherRecursiveWithinFunction block,
    ({ type }) => type is "ReturnValue") as ASTNodeBase[]
  return false unless values.length

  ref := makeRef "ret"

  let declaration
  values.forEach (value) =>
    value.children = [ref]

    // Check whether return.value already declared within this function
    { ancestor, child } := findAncestor(value,
      ({ type }) => type is "Declaration",
      isFunction)
    declaration ??= child if ancestor  // remember binding

  // Compute default return type
  returnType .= func.returnType ?? func.signature?.returnType
  if returnType
    { t } := returnType
    switch t.type
      "TypePredicate"
        returnType = ": boolean"
      "AssertsType"
        returnType = undefined

  // Modify existing declaration, or add declaration of return.value after {
  if declaration
    unless declaration.suffix?
      declaration.children[1] = declaration.suffix = returnType
  else
    block.expressions.unshift [
      getIndent block.expressions[0]
    ,
      type: "Declaration"
      children: ["let ", ref, returnType]
      names: []
    ,
      ";"
    ]

  // Transform existing `return` -> `return ret`
  gatherRecursiveWithinFunction block,
    (r) => r.type is "ReturnStatement" and not r.expression
  .forEach (r) =>
    r.expression = ref
    r.children.splice -1, 1, " ", ref

  // Implicit return before }
  unless block.children.-2?.type is "ReturnStatement"
    block.expressions.push [
      [getIndent(block.expressions.-1)]
    ,
      type: "ReturnStatement",
      expression: ref,
      children: ["return ", ref]
    ]

  return true

function prune(node: ASTNode): ASTNode {
  if (node is null or node is undefined) return
  if (node.length is 0) return

  if (Array.isArray(node)) {
    const a = node
      .map((n) => prune(n))
      .filter((n) => !!n)

    if (a.length > 1) return a
    if (a.length is 1) return a[0]
    return
  }

  if (node.children != null) {
    node.children = prune(node.children)
    return node
  }

  return node
}

function reorderBindingRestProperty(props) {
  const names = props.flatMap((p) => p.names)

  let restIndex = -1
  let restCount = 0
  props.forEach(({ type }, i) => {
    if (type is "BindingRestProperty") {
      if (restIndex < 0) restIndex = i
      restCount++
    }
  })

  if (restCount is 0) {
    return {
      children: props,
      names,
    }
  } else if (restCount is 1) {
    let after = props.slice(restIndex + 1)
    let rest = props[restIndex]

    props = props.slice(0, restIndex);

    // Swap delimiters of last property and rest so that an omitted trailing comma doesn't end up in the middle
    if (after.length) {
      const {delim: restDelim} = rest,
        lastAfterProp = after[after.length - 1],
        {delim: lastDelim, children: lastAfterChildren} = lastAfterProp

      rest = {
        ...rest,
        delim: lastDelim,
        children: [...rest.children.slice(0, -1), lastDelim],
      }
      after = [
        ...after.slice(0, -1),
        {
          ...lastAfterProp,
          delim: restDelim,
          children: [...lastAfterChildren.slice(0, -1), restDelim]
        }
      ]
    }

    // JS forbids trailing comma after rest property
    if Array.isArray(rest.delim) and rest.delim.-1?.token is ","
      // Can't mutate delim in case of cached nodes
      rest.delim = rest.delim.slice(0, -1)
      rest.children = [ ...rest.children.slice(0, -1), rest.delim ]

    const children = [...props, ...after, rest]

    return {
      children,
      names,
    }
  }

  return {
    children: [{
      type: "Error",
      message: "Multiple rest properties in object pattern",
    }, props]
  }
}

/**
 * Replace all nodes that match predicate with replacer(node)
 */
function replaceNodes(root, predicate, replacer)
  return root unless root?
  array := Array.isArray(root) ? root : root.children
  unless array
    if predicate root
      return replacer root, root
    else
      return root
  for each node, i of array
    return unless node?
    if predicate node
      array[i] = replacer node, root
    else
      replaceNodes node, predicate, replacer
  return root

/**
 * Splice child from children/array, similar to Array.prototype.splice,
 * but specifying a child instead of an index.  Throw if child not found.
 */
function spliceChild(node: ASTNode, child: ASTNode, del, ...replacements)
  children := node?.children ?? node
  unless Array.isArray children
    throw new Error "spliceChild: non-array node has no children field"
  index := children.indexOf child
  if index < 0
    throw new Error "spliceChild: child not found"
  children.splice index, del, ...replacements

function typeOfJSX(node, config, getRef) {
  switch (node.type) {
    case "JSXElement":
      return typeOfJSXElement(node, config, getRef)
    case "JSXFragment":
      return typeOfJSXFragment(node, config, getRef)
  }
}

function typeOfJSXElement(node, config, getRef) {
  if (config.solid) {
    if (config.server and !config.client) {  // server only
      return ["string"]
    }
    let { tag } = node
    // "An intrinsic element always begins with a lowercase letter,
    // and a value-based element always begins with an uppercase letter."
    // [https://www.typescriptlang.org/docs/handbook/jsx.html]
    const clientType =
      tag[0] is tag[0].toLowerCase() ?
        [getRef("IntrinsicElements"), '<"', tag, '">'] :
        ['ReturnType<typeof ', tag, '>']
    if (config.server) {  // isomorphic code for client + server
      return ["string", " | ", clientType]
    } else {  // client only (default)
      return clientType
    }
  }
}

function typeOfJSXFragment(node, config, getRef) {
  if (config.solid) {
    let type = []
    let lastType
    for (let child of node.jsxChildren) {
      switch (child.type) {
        case "JSXText":
          // Solid combines multiple consecutive texts into one string
          if (lastType !== "JSXText") {
            type.push("string")
          }
          break
        case "JSXElement":
          type.push(typeOfJSXElement(child, config, getRef))
          break
        case "JSXFragment":
          // Solid flattens fragments of fragments into one array.
          type.push(...typeOfJSXFragment(child, config, getRef))
          break
        case "JSXChildExpression":
          // Solid discards empty expressions
          if (child.expression) {
            type.push(["typeof ", child.expression])
          }
          break
        default:
          throw new Error(`unknown child in JSXFragment: ${JSON.stringify(child)}`)
      }
      lastType = child.type
    }
    // Solid doesn't wrap single fragment child in an array
    if (type.length is 1) {
      return type[0]
    } else {
      type = type.flatMap((t) => [t, ", "])
      type.pop() // remove trailing comma
      return ["[", type, "]"]
    }
  }
}

export {
  addPostfixStatement,
  adjustBindingElements,
  attachPostfixStatementAsExpression,
  blockWithPrefix,
  convertObjectToJSXAttributes,
  dedentBlockString,
  dedentBlockSubstitutions,
  deepCopy,
  expressionizeIfClause,
  expressionizeTypeIf,
  forRange,
  gatherBindingCode,
  gatherRecursive,
  getIndentLevel,
  getTrimmingSpace,
  hasAwait,
  hasYield,
  insertTrimmingSpace,
  isEmptyBareBlock,
  isWhitespaceOrEmpty,
  lastAccessInCallExpression,
  literalValue,
  makeAmpersandFunction,
  makeEmptyBlock,
  makeExpressionStatement,
  makeGetterMethod,
  makeLeftHandSideExpression,
  makeRef,
  maybeRef,
  modifyString,
  negateCondition,
  processAssignmentDeclaration,
  processBinaryOpExpression,
  processCallMemberExpression,
  processCoffeeInterpolation,
  processForInOf,
  processProgram,
  processUnaryExpression,
  quoteString,
  reorderBindingRestProperty,
  replaceNodes,
  typeOfJSX,
  wrapIIFE,
}
