/**
 * lib.civet holds functions that are used inside parser.hera
 *
 * The rules inside parser.hera should be simple and short.
 * Most of the helpers/transforms should make their way into
 * here eventually.
 */

import type {
  AccessStart
  ASTLeaf
  ASTNode
  ASTNodeBase
  ASTNodeObject
  ASTNodeParent
  ASTRef
  AssignmentExpression
  BlockStatement
  CallExpression
  CatchClause
  Condition
  DeclarationStatement
  DoStatement
  ElseClause
  ExpressionNode
  FinallyClause
  ForStatement
  IfStatement
  IterationStatement
  MemberExpression
  MethodDefinition
  Placeholder
  StatementExpression
  StatementTuple
  TypeSuffix
  WSNode
} from ./types.civet

import {
  findAncestor
  findChildIndex
  gatherRecursive
  gatherRecursiveAll
  gatherRecursiveWithinFunction
} from ./traversal.civet

import {
  addParentPointers
  assert
  deepCopy
  flatJoin
  getTrimmingSpace
  hasAwait
  hasImportDeclaration
  hasYield
  inplaceInsertTrimmingSpace
  inplacePrepend
  insertTrimmingSpace
  isASTNodeObject
  isComma
  isEmptyBareBlock
  isFunction
  isWhitespaceOrEmpty
  literalValue
  makeLeftHandSideExpression
  makeNode
  maybeWrap
  maybeUnwrap
  parenthesizeType
  prepend
  trimFirstSpace
  wrapIIFE
  wrapWithReturn
} from ./util.civet

import {
  makeRef
  makeRefAssignment
  maybeRef
  maybeRefAssignment
  needsRef
} from ./ref.civet

import {
  blockWithPrefix
  duplicateBlock
  hoistRefDecs
  makeBlockFragment
  makeEmptyBlock
  processBlocks
} from ./block.civet

import {
  convertWithClause
  dynamizeImportDeclaration
  dynamizeImportDeclarationExpression
  prependStatementExpressionBlock
  processAssignmentDeclaration
  processDeclarationConditions
  processDeclarations
} from ./declaration.civet

import { processPipelineExpressions } from ./pipe.civet
import { forRange, processForInOf } from ./for.civet
import {
  expressionizeIteration
  makeAmpersandFunction
  processCoffeeDo
  processFunctions
  skipImplicitArguments
} from ./function.civet
import { processPatternMatching } from ./pattern-matching.civet
import {
  adjustAtBindings
  adjustBindingElements
  gatherBindingCode
  gatherBindingPatternTypeSuffix
} from ./binding.civet
import {
  getPrecedence
  precedenceStep
  processBinaryOpExpression
} from ./op.civet
import { processUnaryExpression } from ./unary.civet
import { createConstLetDecs, createVarDecs } from ./auto-dec.civet
import { processComptime } from ./comptime.civet
import { getHelperRef } from ./helper.civet

import {
  dedentBlockString
  dedentBlockSubstitutions
  getIndentLevel
  modifyString
  processCoffeeInterpolation
  quoteString
} from ./string.civet

import {
  getConfig
  getState
  getSync
} from ../parser.hera

function addPostfixStatement(statement: StatementTuple, ws: ASTNode, post)
  expressions := [
    ...post.blockPrefix or []
    ["", statement]
  ]

  block := makeNode {
    type: "BlockStatement"
    children: [" { ", expressions, " }"]
    expressions
  }

  children := [...post.children, block]

  // This removes trailing whitespace for easier testing
  if (!isWhitespaceOrEmpty(ws)) children.push(ws)

  post = makeNode { ...post, children, block }
  if post.type is "IfStatement"
    post.then = block
  return post

/**
 * Adjusts the index access to use brackets instead of dot
 * while accounting for optional chaining.
 */
function adjustIndexAccess(dot: AccessStart): AccessStart
  if dot.optional
    // ?. turns into ?.[
    return {
      ...dot,
      children: [...dot.children, "["]
    }
  else
    dot = replaceNodes deepCopy(dot),
      (node) => node.token is ".",
      (node) => ({ ...node, token: "[" })

  return dot

// Negate expression inside condition
function negateCondition(condition)
  { expression } .= condition
  children := condition.children.slice()
  i := children.indexOf(expression)
  if i < 0
    throw new Error `Could not find expression in condition`
  children[i] = expression =
    type: "UnaryExpression"
    children: [
      "!"
      makeLeftHandSideExpression expression
    ]
  { ...condition, expression, children }

/**
Somewhat incomplete detection of expressions used to
determine when we have to wrap if blocks in IIFE instead of
converting to ternary expressions.
*/
function isExpression(node: ASTNode): boolean
  if Array.isArray(node)
    return node.every(isExpression)

  if typeof node is "string"
    // TODO: may not quite be correct
    return true

  switch node?.type
    case "BlockStatement"
    case "DebuggerStatement"
    case "Declaration"
    case "ForStatement"
    case "IfStatement"
    case "IterationStatement"
    case "ReturnStatement"
    case "SwitchStatement"
    case "ThrowStatement"
    case "TryStatement"
      return false

  return true

function expressionizeBlock(blockOrExpression: ASTNode)
  if { expressions } := blockOrExpression
    l := expressions.length
    results := []

    for [ws, s, _delim], i of expressions
      if (!isExpression(s)) return
      wrapped := makeLeftHandSideExpression s
      if i is l - 1
        results.push [ws, wrapped]
      else
        results.push [ws, wrapped, ","]

    if results# > 1
      makeLeftHandSideExpression results
    else if results#
      results
    else
      ["void 0"]
  else
    blockOrExpression

function expressionizeIfStatement(statement: IfStatement): ASTNode
  { condition, then: b, else: e } := statement
  [ ...condRest, closeParen ] := condition.children  // separate ')'

  expressionizedBlock := expressionizeBlock b

  unless expressionizedBlock
    return wrapIIFE([["", statement]])

  children := [
    ...condRest
    "?"
    expressionizedBlock
  ]
  if e
    e2 := expressionizeBlock(e.block)
    unless e2
      return wrapIIFE([["", statement]])

    // Replace 'else' in e.children[1] with ':'. (e.children[0] is space before 'else')
    children.push e.children[0], ":", e2, ...e.children[3..]
  else
    children.push ":void 0"
  children.push closeParen

  makeNode {
    type: "IfExpression"
    children
  }

function expressionizeTypeIf([ws, ifOp, condition, t, e])
  children := [
    ws
    "("
    insertTrimmingSpace condition, ""
    "?"
  ]
  unless ifOp.negated xor condition.negated // if
    children.push t
    if e
      // Replace 'else' in e[1] with ':'. (e[0] is space before 'else')
      children.push e[0], ":", ...e[2..]
    else
      children.push ":never"
  else // unless
    if e
      children.push ...e[2..], e[0], ":"
    else
      children.push "never:"
    children.push t
  children.push ")"
  children

/**
 * This adjusts #x.y().z and @x.y().z when used inside Object glob expressions
 * to remove `this.` where necessary.
 *
 * [See More](../test/object.civet)
 */
function handleThisPrivateShorthands(value)
  if value.privateShorthand
    value = value.children[1].children[1]

    return [value, false]

  if value.type is "MemberExpression" or value.type is "CallExpression"
    suppressPrefix .= value.thisShorthand
    value = {
      ...value,
      children: value.children.map (c, i) =>
        if i is 0
          let s
          [c, s] = handleThisPrivateShorthands c
          suppressPrefix ||= s

        c
    }

    return [value, suppressPrefix]

  return [value, value.thisShorthand]

function processTryBlock($0: [ASTLeaf, undefined, BlockStatement, CatchClause?, ElseClause?, FinallyClause?])
  [t, , b, c, e, f] .= $0

  // Default behavior catches all exceptions
  if !c and (e or !f)
    emptyCatchBlock := makeEmptyBlock()

    c =
      type: "CatchClause"
      children: [" ", "catch(e) ", emptyCatchBlock]
      block: emptyCatchBlock

  // else clause support
  let hoistDec: DeclarationStatement?
  if e
    c = c!  // absent catch clause would have been created above
    // `let ok = true` before try
    ok := makeRef 'ok'
    hoistDec =
      type: "Declaration"
      children: [ "let ", ok, " = true" ]
      names: []
    // `ok = false` inside catch block
    replaceNode
      c.block
      blockWithPrefix [["", "ok = false"]], c.block
      c
    // Prepend else block to finally block with `if (ok)` prefix
    condition: Condition :=
      type: "ParenthesizedExpression"
      children: ["(", ok, ")"]
      expression: ok
    i := makeNode {
      type: "IfStatement"
      children: ["if", condition, e.block]
      condition
      then: e.block
      else: undefined
    }
    unless f
      emptyFinallyBlock := makeEmptyBlock()
      f =
        type: "FinallyClause"
        children: [" ", "finally ", emptyFinallyBlock]
        block: emptyFinallyBlock
    replaceNode
      f.block
      blockWithPrefix [["", i]], f.block
      f

  blocks := [b]
  blocks.push c.block if c

  return {
    type: "TryStatement"
    blocks
    children: [t, b, c, f]
    hoistDec
  }

/**
 * Process globs, bind shorthand, and call shortcuts, in Call/MemberExpression
 */
function processCallMemberExpression(node: ASTNodeParent): ASTNode
  { children } := node

  // Parenthesized operator like (+), immediately called, expands to
  // use of the operator. This is useful for e.g. shortcutting (&&).
  if children is like [ {parenthesizedOp: {token}}, {type: "Call"}, ... ]
    op := children[0].parenthesizedOp
    call .= children[1]
    args := [...call.args] // shallow copy
    call = {
      ...call
      args
      children: call.children.map (x) => x is call.args ? args : x
    }
    // Remove trailing comma
    if isComma args.-1
      args.-1 = deepCopy args.-1
      (isComma(args.-1) as ASTLeaf).token = ''
    // Arguments already start and end with open and close parentheses.
    // Replace each comma with an instance of the operator and matching parens.
    commaCount .= 0
    for each let arg, i of args
      if isComma arg
        arg = args[i] = deepCopy arg
        (isComma(arg) as ASTLeaf).token = `)${op.token}(`
        commaCount++
    // Don't mess with (+)()
    if args.length
      children.splice 0, 2,
        commaCount ?
          type: "ParenthesizedExpression",
          children: ["(", ...call.children, ")"]
        : { ...call, type: "ParenthesizedExpression" }
      // If nothing left to this CallExpression, remove the wrapper
      if children# is 1
        return children[0]

  // Process globs and bind shorthand
  for (let i = 0; i < children.length; i++) {
    const glob = children[i]
    if (glob?.type is "PropertyGlob") {
      let prefix = children.slice(0, i)
      const parts = []
      let hoistDec, refAssignmentComma
      // add ref to ensure object base evaluated only once
      if prefix.length > 1
        ref := makeRef()
        { hoistDec, refAssignmentComma } = makeRefAssignment ref, prefix
        prefix = [ref]
      prefix = prefix.concat(glob.dot)

      for part of glob.object.properties
        if part.type is "Error"
          parts.push part
          continue
        if part.type is "MethodDefinition"
          parts.push
            type: "Error"
            message: "Glob pattern cannot have method definition"
          continue
        if part.value and !["CallExpression", "MemberExpression", "Identifier"].includes(part.value.type)
          parts.push
            type: "Error"
            message: `Glob pattern must have call or member expression value, found ${JSON.stringify(part.value)}`
          continue

        suppressPrefix .= false
        name .= part.name
        value .= part.value ?? name
        wValue := getTrimmingSpace part.value

        [value, suppressPrefix] = handleThisPrivateShorthands value

        // Not yet needed:
        [name, value] = [value, name] if glob.reversed

        if !suppressPrefix // Don't prefix @ shorthand
          value = prefix.concat(insertTrimmingSpace(value, ""))
        if (wValue) value.unshift(wValue)
        if part.type is "SpreadProperty"
          parts.push {
            type: part.type
            value
            dots: part.dots
            delim: part.delim
            names: part.names
            children: part.children.slice(0, 2) // whitespace, ...
              .concat(value, part.delim)
          }
        else
          parts.push {
            type: part.type is "Identifier" ? "Property" : part.type
            name
            value
            delim: part.delim
            names: part.names
            children: [
              isWhitespaceOrEmpty(part.children[0]) and part.children[0]
              name
              isWhitespaceOrEmpty(part.children[2]) and part.children[2]
              part.children[3]?.token is ":" ? part.children[3] : ":"
              value
              part.delim // comma delimiter
            ]
          }
      object .= {
        type: "ObjectExpression"
        children: [
          glob.object.children.0 // {
          ...parts
          glob.object.children.-1 // whitespace and }
        ],
        properties: parts
        hoistDec
      }
      if refAssignmentComma
        object = {
          type: "ParenthesizedExpression"
          children: ["(", ...refAssignmentComma, object, ")"]
          expression: object
        }
      if (i is children.length - 1) return object
      return processCallMemberExpression({  // in case there are more
        ...node,
        children: [object, ...children.slice(i + 1)]
      })
    } else if (glob?.type is "PropertyBind") {
      // TODO: add ref to ensure object base evaluated only once
      const prefix = children.slice(0, i)
      return processCallMemberExpression({  // in case there are more
        ...node,
        children: [
          prefix,
          {
            ...glob,
            type: "PropertyAccess",
            children: [
              ...glob.children,
              ".bind(",
              prefix,
              ...glob.args.length > 0 ? [", "] : [],
              ...glob.args,
              ")",
            ]
          },
          ...children.slice(i + 1)
        ]
      })
    }
  }
  return node

/**
 * Replace this node with another, by modifying its parent's children.
 */
function replaceNode(node: ASTNodeObject, newNode: ASTNode, parent?: ASTNodeParent): void
  parent ??= node.parent
  unless parent?
    throw new Error "replaceNode failed: node has no parent"

  function recurse(children: ASTNode[]): boolean
    for each child, i of children
      if child is node
        children[i] = newNode
        return true
      else if Array.isArray child
        return true if recurse child
    return false

  unless recurse parent.children
    throw new Error "replaceNode failed: didn't find child node in parent"

  // Adjust 'expression' etc. alias pointers
  for key, value in parent
    if value is node
      parent[key] = newNode

  if isASTNodeObject newNode
    newNode.parent = parent
  // Don't destroy node's parent, as we often include it within newNode
  //node.parent = undefined

// Wrap expression in parentheses to make into a statement when:
// * object literal expression
// * anonymous function expression
// * comma operators applied to above
function makeExpressionStatement(expression: ASTNode): ASTNode
  if Array.isArray(expression) and expression[1]?[0]?[0]?[1]?.token is "," // CommaExpression
    [
      makeExpressionStatement expression[0]
      expression[1].map ([comma, exp]) => // CommaDelimiter AssignmentExpression
        [comma, makeExpressionStatement exp]
    ]
  else if expression?.type is "ObjectExpression" or
          (expression?.type is "FunctionExpression" and not expression.id)
    makeLeftHandSideExpression expression
  else
    expression

// Look for last property access like `.foo` or `[computed]` or root Identifier,
// before any calls like `(args)`, non-null assertions `!`, and optionals `?`.
// The return value should have a `name` property (for "Identifier" and
// "Index"), or have `type` of "Index" (for `[computed]`), or be undefined.
function lastAccessInCallExpression(exp)
  return exp if exp.type is "Identifier"
  let children, i
  do
    // Leaf node occurs e.g. for import.meta
    return unless exp.children?
    { children } = exp
    i = children.length - 1
    while (i >= 0 and (
      children[i].type is "Call" ||
      children[i].type is "NonNullAssertion" ||
      children[i].type is "Optional"
    )) i--
    if (i < 0) return
    // Recurse into nested MemberExpression, e.g. from `x.y()`
  while children[i].type is "MemberExpression" and (exp = children[i])
  return children[i]

// Given a MethodDefinition, convert into a FunctionExpression.
// Returns undefined if the method is a getter or setter.
function convertMethodToFunction(method) {
  const { signature, block } = method
  let { modifier, optional } = signature
  if (optional) return
  if (modifier) {
    if (modifier.get or modifier.set) {
      return
    } else if (modifier.async) {
      // put function after async
      modifier = [modifier.children[0][0], " function ", ...modifier.children.slice(1)]
    } else {
      modifier = ["function ", ...(modifier.children or [])]
    }
  } else {
    modifier = "function ";
  }
  return {
    ...signature,
    id: signature.name,
    signature,
    type: "FunctionExpression",
    children: [
      [modifier, ...signature.children.slice(1)],
      block,
    ],
    block,
  }
}

// Convert NamedImports into equivalent ObjectExpression or ObjectBindingPattern
function convertNamedImportsToObject(node, pattern?: boolean)
  properties := node.specifiers.map (specifier) =>
    if specifier.ts
      { type: "Error", message: "cannot use `type` in dynamic import" }
    else
      { source, binding } := specifier
      delim := specifier.children.-1
      {
        type: pattern ? "BindingProperty" : "Property"
        name: source
        value: binding unless source is binding
        delim
        children: source is binding
          ? [ source, delim ]
          : [ source, ":", binding, delim ]
      }

  {
    type: pattern ? "ObjectBindingPattern" : "ObjectExpression"
    names: node.names
    properties
    children: [
      node.children.0 // {
      properties
      node.children.-1 // }
    ]
  }

// Convert an ObjectExpression (with `properties`)
// into a set of JSX attributes.
// {foo} is equivalent to foo={foo}, and
// {foo, bar: baz} is equivalent to foo={foo} and bar={baz}.
// {...foo} is a special case.
function convertObjectToJSXAttributes(obj) {
  const { properties } = obj
  const parts = [] // JSX attributes
  const rest = []  // parts that need to be in {...rest} form
  for (let i = 0; i < properties.length; i++) {
    if (i > 0) parts.push(' ')
    const part = properties[i]
    switch (part.type) {
      case 'Identifier':
        parts.push([part.name, '={', part.name, '}'])
        break
      case 'Property':
        if (part.name.type is 'ComputedPropertyName') {
          rest.push(part)
        } else {
          parts.push([part.name, '={', insertTrimmingSpace(part.value, ''), '}'])
        }
        break
      case 'SpreadProperty':
        parts.push(['{', part.dots, part.value, '}'])
        break
      case 'MethodDefinition':
        const func = convertMethodToFunction(part)
        if (func) {
          parts.push([part.name, '={', convertMethodToFunction(part), '}'])
        } else {
          rest.push(part)
        }
        break
      default:
        throw new Error(`invalid object literal type in JSX attribute: ${part.type}`)
    }
  }
  if (rest.length) {
    parts.push(['{...{', ...rest, '}}'])
  }
  return parts
}

/**
 * Returns a new MethodDefinition node.
 */
function makeGetterMethod(name, ws, value, returnType, block?: BlockStatement, kind: { token: "get" | "set" } = { token: "get" }, autoReturn: boolean = true): MethodDefinition
  { token } := kind
  ws = insertTrimmingSpace(ws, "")
  let setVal
  parameters := token is "get" ?
    type: "Parameters"
    children: ["()"]
    names: []
    implicit: true
  :
    type: "Parameters"
    children: ["(", setVal = makeRef("value"), ")"]
    names: []
    implicit: false

  let expressions: StatementTuple[]
  if block
    // Duplicate block to avoid mutating original
    block = duplicateBlock(block)
    expressions = block.expressions
  else
    expressions = []
    block = {
      type: "BlockStatement"
      expressions
      children: ["{ ", expressions, " }"]
    }

  if autoReturn
    finalStatement: StatementTuple := token is "get" ?
      [ [expressions[0]?.[0] or "", ws], wrapWithReturn(value) ]
    :
      [ [expressions[0]?.[0] or "", ws], [ value, " = ", setVal ] ]

    expressions.push finalStatement

  children := [kind, " ", name, parameters, returnType, block]

  return {
    type: "MethodDefinition",
    children,
    name,
    signature: {
      type: "MethodSignature"
      modifier: {
        get: token is "get"
        set: token is "set"
        async: false
      },
      name,
      returnType,
    },
    block,
    parameters,
  }

function processBindingPatternLHS(lhs, tail): void
  // Expand AtBindings first before gathering splices
  adjustAtBindings(lhs, true)
  const [splices, thisAssignments] = gatherBindingCode(lhs)
  // TODO: This isn't quite right for compound assignments, may need to wrap with parens and use comma to return the complete value
  tail.push(...splices.map((s) => [", ", s]), ...thisAssignments.map((a) => [", ", a]))

function processAssignments(statements): void {
  // Move assignments/updates within LHS of assignments/updates
  // to run earlier via comma operator
  gatherRecursiveAll(statements, (n) => n.type is "AssignmentExpression" or n.type is "UpdateExpression")
    .forEach (exp) =>
      function extractAssignment(lhs)
        expr .= lhs
        while expr.type is "ParenthesizedExpression"
          expr = expr.expression
        if expr.type is like "AssignmentExpression", "UpdateExpression"
          if expr.type is "UpdateExpression" and
             expr.children[0] is expr.assigned  // postfix update
            pre.push("(")
            post.push([", ", lhs, ")"])
          else
            pre.push(["(", lhs, ", "])
            post.push(")")
          // TODO: use ref to avoid duplicating function calls
          return expr.assigned

      const pre = [], post = []
      switch exp.type
        when "AssignmentExpression"
          if (!exp.lhs) return
          exp.lhs.forEach (lhsPart, i) =>
            if newLhs := extractAssignment(lhsPart[1])
              lhsPart[1] = newLhs
        when "UpdateExpression"
          if newLhs := extractAssignment(exp.assigned)
            i := exp.children.indexOf(exp.assigned)
            exp.assigned = exp.children[i] = newLhs
      if (pre.length) exp.children.unshift(...pre)
      if (post.length) exp.children.push(...post)
      // TODO: need to make this a parenthesized expression when when we add parens

      if exp.type is "UpdateExpression"
        { assigned } := exp
        ref := makeRef()
        newMemberExp := unchainOptionalMemberExpression assigned, ref, (children) =>
          exp.children.map & is assigned ? children : &

        if newMemberExp !== assigned
          if newMemberExp.usesRef
            newMemberExp.hoistDec = {
              type: "Declaration"
              children: ["let ", ref]
              names: []
            }
          replaceNode exp, newMemberExp

  replaceNodesRecursive statements,
    (n) => n.type is "AssignmentExpression" and n.names is null,
    (exp: AssignmentExpression): AssignmentExpression | BlockStatement | ExpressionNode => {
      let { lhs: $1, expression: $2 } = exp, tail = [], len = $1.length

      let block?: BlockStatement
      // Extract StatementExpression as block
      if exp.parent?.type is "BlockStatement" and !$1.-1?.-1?.special// can only prepend to assignments that are children of blocks
        block = makeBlockFragment()
        if ref := prependStatementExpressionBlock(
          {type: "Initializer", expression: $2, children: [undefined, undefined, $2]}
          block
        )
          exp.children = exp.children.map & is $2 ? ref : &
          // @ts-ignore
          $2 = ref
        else
          block = undefined

      // identifier=, xor=, ++=
      if $1.some &.-1.special
        if ($1.length !== 1) throw new Error("Only one assignment with id= is allowed")
        [, lhs, , op] := $1[0]
        { call, omitLhs } := op
        // Wrap right-hand side with call
        index := exp.children.indexOf($2)
        if (index < 0) throw new Error("Assertion error: exp not in AssignmentExpression")
        exp.children.splice index, 1,
          exp.expression = $2 = [call, "(", lhs, ", ", $2, ")"]
        if omitLhs
          return $2

      // Force parens around destructuring object assignments
      // Walk from left to right the minimal number of parens are added and enclose all destructured assignments
      // TODO: Could validate some lhs ecmascript rules here if we wanted to
      wrapped .= false
      i .= 0
      while i < len
        lastAssignment := $1[i++]
        [, lhs, , op] := lastAssignment
        continue unless op.token is "="

        if lhs.type is like "ObjectExpression", "ObjectBindingPattern"
          // Wrap with parens to distinguish from braced blocks
          unless wrapped
            wrapped = true
            lhs.children.splice(0, 0, "(")
            tail.push(")")

      refsToDeclare := new Set<ASTRef>

      // Walk from right to left to handle splices
      i = len - 1
      while i >= 0
        lastAssignment := $1[i]

        if lastAssignment[3].token is "="
          lhs := lastAssignment[1]

          // Splice assignment
          if lhs.type is "MemberExpression"
            members := lhs.children
            lastMember := members[members.length - 1]

            // TODO: this is kind of bonkers
            if lastMember.type is "SliceExpression"
              const { start, end, children: c } = lastMember
              // TODO: don't lose as many source mappings
              c[0].token = ".splice("
              c[1] = start
              c[2] = ", "
              if (end)
                c[3] = [end, " - ", start]
              else
                c[3] = ["1/0"]
              c[4] = [", ...", $2]
              c[5] = ")"

              // Remove assignment token
              lastAssignment.pop()
              if (isWhitespaceOrEmpty(lastAssignment[2])) lastAssignment.pop()
              // TODO: this only works for the last assignment, not multiple splice assignments, or splice assignments earlier in the chain
              if $1.length > 1
                throw new Error("Not implemented yet! TODO: Handle multiple splice assignments")

              exp.children = [$1]
              exp.names = []
              break
          else if lhs.type is like "ObjectBindingPattern", "ArrayBindingPattern"
            processBindingPatternLHS(lhs, tail)
            // Extract temp refs that need to be declared from lhs
            gatherRecursiveAll(lhs, .type is "Ref").forEach refsToDeclare@add

          // NOTE: currently not processing any non-binding pattern ObjectExpression or ArrayExpressions
          // This might not be correct in all situations, esp BindingPatterns nested inside ObjectExpressions
        i--

      // Handle optional chain ?. in lhs of assignments
      i = len - 1
      optionalChainRef := makeRef()
      while i >= 0
        assignment := $1[i]
        [ws1, lhs, ws2, op] := assignment

        if lhs.type is "MemberExpression" or lhs.type is "CallExpression"
          newMemberExp := unchainOptionalMemberExpression lhs, optionalChainRef, (children) =>
            // NOTE: This only executes when lhs contains chains
            // this mutates the assignments array to account for the parts moved into the conditionals
            assigns := $1.splice(i + 1, len - 1 - i)
            $1.pop()
            [ws1, ...children, ws2, op, ...assigns, $2]

          if newMemberExp !== lhs
            if newMemberExp.usesRef
              exp.hoistDec =
                type: "Declaration"
                children: ["let ", optionalChainRef]
                names: []

            replaceNode $2, newMemberExp
            newMemberExp.parent = exp
            $2 = newMemberExp

        i--

      // Add any additional binding refs that need to be declared to our hoisted declarations
      if refsToDeclare.size
        if exp.hoistDec
          exp.hoistDec.children.push [...refsToDeclare].map [",", &]
        else
          exp.hoistDec =
            type: "Declaration"
            children: ["let ", [...refsToDeclare].map (r, i) => i ? [",", r] : r]
            names: []

      // Gather all identifier names from the lhs array
      exp.names = $1.flatMap(([, l]) => l.names or [])

      if tail#
        index := exp.children.indexOf($2)
        if (index < 0) throw new Error("Assertion error: exp not in AssignmentExpression")
        exp.children.splice(index + 1, 0, ...tail)

      if block
        block.parent = exp.parent
        block.expressions.push(["", exp])
        exp.parent = block
        return block

      return exp
    }
}

function unchainOptionalMemberExpression(exp: MemberExpression | CallExpression, ref: ASTRef, innerExp: (exp) => ASTNode)
  j .= 0
  { children } := exp
  usesRef .= false
  conditions := []

  // NOTE: not caching length because the array mutates inside
  while j < children.length
    child := children[j]
    type := child?.type
    hasOptional .= false

    switch type
      when "PropertyAccess"
        if child.dot?.optional
          hasOptional = true
          child.dot.children.shift()
          child.dot.optional = false
      when "Call", "Index"
        if child.optional
          hasOptional = true
          child.children.shift()
          child.optional = undefined

    if hasOptional
      let base

      if j > 1 or needsRef children[0]
        usesRef = true
        base = makeLeftHandSideExpression
          type: "AssignmentExpression"
          children: [ref, " = ", children.splice(0, j)]

        base.parent = child
        children.unshift ref

        j = 0
      else
        base = children[0]

      conditions.push [ base, " != null" ]

    j++

  if l := conditions.length
    cs := flatJoin conditions, " && "

    {
      ...exp
      children: [...cs, " ? ", innerExp(children), " : void 0"]
      usesRef
    }
  else // Unchanged
    exp

function attachPostfixStatementAsExpression(exp, post: [WSNode, IfStatement | IterationStatement | DoStatement | ForStatement])
  postfixStatement := post[1]

  switch postfixStatement.type
    when "ForStatement", "IterationStatement", "DoStatement"
      statement := addPostfixStatement(exp, ...post)
      return {
        type: "IterationExpression",
        children: [statement],
        block: statement.block,
        statement,
      }
    when "IfStatement"
      return expressionizeIfStatement { ...postfixStatement, then: exp }
    else
      throw new Error("Unknown postfix statement")

function processTypes(node: ASTNode)
  // T? -> T | undefined; T?? -> T | undefined | null
  gatherRecursiveAll node, (n) => n.type is "UnaryType"
  // @ts-ignore
  .forEach (unary: ASTNodeBase): void =>
    let last: ASTNode
    count .= 0
    while unary.suffix.length and unary.suffix.-1?.token is "?"
      last = unary.suffix.pop()
      count++
    return unless count
    if unary.parent?.type is "TypeTuple"
      // Leave one ? inside a type tuple
      if count is 1
        unary.suffix.push last
        return
      replaceNode unary, [
        getTrimmingSpace unary
        "("
        parenthesizeType insertTrimmingSpace unary, ""
        " | null)"
        last
      ]
    else
      replaceNode unary, [
        getTrimmingSpace unary
        "("
        parenthesizeType insertTrimmingSpace unary, ""
        count is 1 ? " | undefined" : " | undefined | null"
        ")"
      ]

/**
Wrap any remaining statement expressions in IIFE.
*/
function processStatementExpressions(statements: StatementTuple[]): void
  gatherRecursiveAll(statements, .type is "StatementExpression")
    .forEach (_exp) =>
      exp := _exp as! StatementExpression
      { statement } := exp

      switch statement.type
        when "IfStatement"
          if expression := expressionizeIfStatement(statement)
            replaceNode statement, expression, exp
          else
            replaceNode statement, wrapIIFE([["", statement]]), exp
        when "IterationExpression"
          if statement.subtype is "ComptimeStatement"
            // Transform ComptimeStatement into ComptimeExpression,
            // with IIFE wrapper inside the ComptimeExpression, and no await
            { expressions } := statement.statement.block
            expression := wrapIIFE expressions, hasAwait expressions
            replaceNode statement, makeNode({
              type: "ComptimeExpression"
              expression
              children: [expression]
            }), exp
          // else do nothing, handled separately currently
        else
          replaceNode statement, wrapIIFE([["", statement]]), exp

function processNegativeIndexAccess(statements: StatementTuple[]): void
  gatherRecursiveAll(statements, (n) => n.type is "NegativeIndex")
    .forEach (exp): void =>
      { children } := exp.parent!

      let start = 0
      start++ while start < children# and isWhitespaceOrEmpty children[start]
      index := children.indexOf(exp)

      let ref, subexp
      if index is start+1  // first access
        child := children[start]
        ref = maybeRef(child)
        if ref !== child
          subexp = children.splice start, 1
      else if index > start+1
        ref = makeRef()
        subexp = children.splice start, index - start
      else
        throw new Error("Invalid parse tree for negative index access")

      if subexp
        { hoistDec, refAssignment } := makeRefAssignment ref, subexp
        exp.hoistDec = hoistDec
        children.splice start, 0, makeLeftHandSideExpression refAssignment

      exp.len.children = [
        ref,
        ".length"
      ]

function processProgram(root: BlockStatement): void
  state := getState()
  config := getConfig()

  // invariants
  assert.equal(state.forbidBracedApplication.length, 1, "forbidBracedApplication")
  assert.equal(state.forbidClassImplicitCall.length, 1, "forbidClassImplicitCall")
  assert.equal(state.forbidIndentedApplication.length, 1, "forbidIndentedApplication")
  assert.equal(state.forbidNewlineBinaryOp.length, 1, "forbidNewlineBinaryOp")
  assert.equal(state.forbidTrailingMemberProperty.length, 1, "forbidTrailingMemberProperty")
  assert.equal(state.JSXTagStack.length, 1, "JSXTagStack")

  addParentPointers(root)

  { expressions: statements } := root

  processPlaceholders(statements)
  processNegativeIndexAccess(statements)
  processTypes(statements)
  processDeclarationConditions(statements)
  processPipelineExpressions(statements)
  processDeclarations(statements)
  processAssignments(statements)
  processStatementExpressions(statements)
  processPatternMatching(statements)

  // Modify iteration expressions
  gatherRecursiveAll(statements, (n) => n.type is "IterationExpression")
    .forEach((e) => expressionizeIteration(e))

  // Hoist hoistDec attributes to actual declarations.
  // NOTE: This should come after iteration expressions get processed
  // into IIFEs.
  hoistRefDecs(statements)

  // Adding implicit returns should happen after hoisting any ref declarations
  // so their target node can be found in the block without being inside a return
  processFunctions(statements, config)

  // Insert prelude
  statements.unshift(...state.prelude)

  if (config.autoLet) {
    createConstLetDecs(statements, [], "let")
  } else if(config.autoConst) {
    createConstLetDecs(statements, [], "const")
  } else if (config.autoVar) {
    createVarDecs(root, [])
  }

  processBlocks(statements)

  populateRefs(statements)
  adjustAtBindings(statements)

  // Run synchronous versions of async steps in case we're in sync mode
  if getSync()
    processComptime(statements)

async function processProgramAsync(root: BlockStatement): Promise<void>
  // Called only if we're in async mode
  { expressions: statements } := root
  await processComptime(statements)

function populateRefs(statements: ASTNode): void {
  const refNodes = gatherRecursive(statements, ({ type }) => type is "Ref")

  if (refNodes.length) {
    // Find all ids within nested scopes
    const ids = gatherRecursive(statements, (s) => s.type is "Identifier")
    const names = new Set(ids.flatMap(({ names }) => names or []))

    // Populate each ref
    refNodes.forEach((ref) => {
      const { type, base } = ref
      if (type !== "Ref") return

      ref.type = "Identifier"

      let n = 0
      let name = base

      // check for name collisions and increment name suffix
      while (names.has(name)) {
        n++
        name = `${base}${n}`
      }

      names.add(name)
      ref.children = ref.names = [name]
    })
  }
}

function processPlaceholders(statements: StatementTuple[]): void
  placeholderMap := new Map<ASTNodeObject, (Placeholder)[]>()
  liftedIfs := new Set<IfStatement>()

  gatherRecursiveAll statements, .type is "Placeholder"
  .forEach (_exp) =>
    exp := _exp as! Placeholder
    let ancestor: ASTNodeObject?
    if exp.subtype is "."
      // Partial placeholder . lifts to the nearest call expression,
      // including the call itself and any surrounding unary operations.
      { ancestor } = findAncestor exp, .type is "Call"
      ancestor = ancestor?.parent
      while ancestor?.parent?.type is "UnaryExpression" or ancestor?.parent?.type is "NewExpression"
        ancestor = ancestor.parent
      unless ancestor
        replaceNode exp,
          type: "Error"
          message: 'Partial placeholder . outside of call expression'
        return
    else // "&"
      // Ampersand placeholder & lifts to nearest call expression,
      // excluding the call itself, or else to the nearest block statement.
      let child
      { ancestor, child } = findAncestor exp, (ancestor, child) =>
        {type} := ancestor
        if type is "IfStatement"
          liftedIfs.add ancestor
        (or)
          type is "Call"
          // Block, except for if/else blocks when condition already lifted
          type is "BlockStatement" and
            not (ancestor.parent is like {type: "IfStatement"} and liftedIfs.has ancestor.parent as IfStatement) and
            not (ancestor.parent is like {type: "ElseClause", parent: {type: "IfStatement"}} and liftedIfs.has ancestor.parent!.parent as IfStatement)
          type is "PipelineExpression"
          // Declaration
          type is "Initializer"
          // Right-hand side of assignment
          type is "AssignmentExpression" and
            findChildIndex(ancestor, child) is
            ancestor.children.indexOf ancestor.expression
          type is "ReturnStatement"
          type is "YieldExpression"
      switch ancestor?.type
        when "Call"
          i := findChildIndex ancestor.args, child
          if i >= 0
            ancestor.args[i] = maybeWrap ancestor.args[i], ancestor
            ancestor = ancestor.args[i] as ASTNodeObject
          else
            ancestor = undefined
        when "BlockStatement"
          i := findChildIndex ancestor.expressions, child
          if i >= 0
            ancestor.expressions[i][1] = maybeWrap ancestor.expressions[i][1], ancestor
            ancestor = ancestor.expressions[i][1] as ASTNodeObject
          else
            ancestor = undefined
        when "PipelineExpression"
          i := findChildIndex ancestor, child
          if i is 1  // head
            // & in pipeline head (& |> ...) wraps function around entire pipeline
            ancestor = ancestor
          else if i is 2  // tail item
            j := findChildIndex ancestor.children[i], child
            ancestor.children[i][j][3] = maybeWrap ancestor.children[i][j][3], ancestor
            ancestor = ancestor.children[i][j][3] as ASTNodeObject
          else
            ancestor = undefined
        when "AssignmentExpression", "Initializer", "ReturnStatement", "YieldExpression"
          i := findChildIndex ancestor, child
          if i >= 0 and ancestor.expression is ancestor.children[i]
            ancestor.expression = ancestor.children[i] = maybeWrap ancestor.expression, ancestor
            ancestor = ancestor.expression as ASTNodeObject
          else
            ancestor = undefined
      unless ancestor
        replaceNode exp,
          type: "Error"
          message: 'Ampersand placeholder & outside of block'

    if ancestor?
      if placeholderMap.has ancestor
        placeholderMap.get(ancestor)!.push exp
      else
        placeholderMap.set ancestor, [exp]

  for [ancestor, placeholders] of placeholderMap
    ref .= makeRef "$"

    let typeSuffix: TypeSuffix?
    for each placeholder of placeholders
      // Take first typeSuffix (hope any additional type suffixes are identical)
      typeSuffix ??= placeholder.typeSuffix
      // NOTE: Replace last child instead of placeholder itself
      // so that we preserve any whitespace that's been glommed as a prefix
      replaceNode placeholder.children.-1, ref

    // Function wrapping can change parent; use original for replaceNode
    {parent} := ancestor
    body := maybeUnwrap ancestor
    fnExp .= makeAmpersandFunction { ref, typeSuffix, body }

    // Arrow function needs to be wrapped in parens in many contexts.
    // This doesn't happen with "&", but can with ".".
    let outer: boolean?
    switch parent?.type
      when "Call"
        outer = ancestor is
          parent.args[findChildIndex parent.args, ancestor]
      when "BlockStatement"
        outer = ancestor is
          parent.expressions[findChildIndex parent.expressions, ancestor][1]
      when "PipelineExpression"
        i := findChildIndex parent, ancestor
        outer =
          if i is 1  // head
            ancestor is parent.children[i]
          else if i is 2  // tail item
            ancestor is
            parent.children[i][findChildIndex parent.children[i], ancestor][3]
      when "AssignmentExpression", "Initializer", "ReturnStatement", "YieldExpression"
        outer = ancestor is parent.expression
    unless outer
      fnExp = makeLeftHandSideExpression fnExp

    replaceNode ancestor, fnExp, parent

    // Move a leading space outside the function wrapper
    if ws := getTrimmingSpace body
      inplaceInsertTrimmingSpace body, ""
      inplacePrepend ws, fnExp

  return

function reorderBindingRestProperty(props)
  const names = props.flatMap((p) => p.names)

  let restIndex = -1
  let restCount = 0
  props.forEach(({ type }, i) => {
    if (type is "BindingRestProperty") {
      if (restIndex < 0) restIndex = i
      restCount++
    }
  })

  if restCount is 0
    return {
      children: props
      names
    }

  let after = props.slice(restIndex + 1)
  let rest = props[restIndex]

  props = props.slice(0, restIndex)

  // Swap delimiters of last property and rest so that an omitted trailing comma doesn't end up in the middle
  if after.length
    const {delim: restDelim} = rest,
      lastAfterProp = after[after.length - 1],
      {delim: lastDelim, children: lastAfterChildren} = lastAfterProp

    rest = {
      ...rest,
      delim: lastDelim,
      children: [...rest.children.slice(0, -1), lastDelim],
    }
    after = [
      ...after.slice(0, -1),
      {
        ...lastAfterProp,
        delim: restDelim,
        children: [...lastAfterChildren.slice(0, -1), restDelim]
      }
    ]

  // JS forbids trailing comma after rest property
  if Array.isArray(rest.delim) and rest.delim.-1?.token is ","
    // Can't mutate delim in case of cached nodes
    rest.delim = rest.delim.slice(0, -1)
    rest.children = [ ...rest.children.slice(0, -1), rest.delim ]

  children := [...props, ...after, rest]

  if restCount > 1
    children.push
      type: "Error",
      message: "Multiple rest properties in object pattern",

  return { children, names }

/**
 * Replace all nodes that match predicate with replacer(node)
 */
function replaceNodes(root, predicate, replacer)
  return root unless root?

  array := Array.isArray(root) ? root : root.children

  unless array
    if predicate root
      return replacer root, root
    else
      return root

  for each node, i of array
    return unless node?
    if predicate node
      array[i] = replacer node, root
    else
      replaceNodes node, predicate, replacer

  return root

function replaceNodesRecursive(root, predicate, replacer)
  return root unless root?

  array := Array.isArray(root) ? root : root.children

  unless array
    if predicate root
      return replacer root, root
    else
      return root

  for each node, i of array
    continue unless node?
    if predicate node
      ret := replacer node, root
      replaceNodesRecursive ret, predicate, replacer
      array[i] = ret
    else
      replaceNodesRecursive node, predicate, replacer

  return root

function typeOfJSX(node, config) {
  switch (node.type) {
    case "JSXElement":
      return typeOfJSXElement(node, config)
    case "JSXFragment":
      return typeOfJSXFragment(node, config)
  }
}

function typeOfJSXElement(node, config) {
  if (config.solid) {
    if (config.server and !config.client) {  // server only
      return ["string"]
    }
    let { tag } = node
    // "An intrinsic element always begins with a lowercase letter,
    // and a value-based element always begins with an uppercase letter."
    // [https://www.typescriptlang.org/docs/handbook/jsx.html]
    const clientType =
      tag[0] is tag[0].toLowerCase() ?
        [getHelperRef("IntrinsicElements"), '<"', tag, '">'] :
        ['ReturnType<typeof ', tag, '>']
    if (config.server) {  // isomorphic code for client + server
      return ["string", " | ", clientType]
    } else {  // client only (default)
      return clientType
    }
  }
}

function typeOfJSXFragment(node, config) {
  if (config.solid) {
    let type = []
    let lastType
    for (let child of node.jsxChildren) {
      switch (child.type) {
        case "JSXText":
          // Solid combines multiple consecutive texts into one string
          if (lastType !== "JSXText") {
            type.push("string")
          }
          break
        case "JSXElement":
          type.push(typeOfJSXElement(child, config))
          break
        case "JSXFragment":
          // Solid flattens fragments of fragments into one array.
          type.push(...typeOfJSXFragment(child, config))
          break
        case "JSXChildExpression":
          // Solid discards empty expressions
          if (child.expression) {
            type.push(["typeof ", child.expression])
          }
          break
        default:
          throw new Error(`unknown child in JSXFragment: ${JSON.stringify(child)}`)
      }
      lastType = child.type
    }
    // Solid doesn't wrap single fragment child in an array
    if (type.length is 1) {
      return type[0]
    } else {
      type = type.flatMap((t) => [t, ", "])
      type.pop() // remove trailing comma
      return ["[", type, "]"]
    }
  }
}

export {
  addPostfixStatement
  adjustBindingElements
  adjustIndexAccess
  attachPostfixStatementAsExpression
  blockWithPrefix
  convertNamedImportsToObject
  convertObjectToJSXAttributes
  convertWithClause
  dedentBlockString
  dedentBlockSubstitutions
  deepCopy
  dynamizeImportDeclaration
  dynamizeImportDeclarationExpression
  expressionizeTypeIf
  forRange
  gatherBindingCode
  gatherBindingPatternTypeSuffix
  gatherRecursive
  gatherRecursiveAll
  gatherRecursiveWithinFunction
  getHelperRef
  getIndentLevel
  getPrecedence
  getTrimmingSpace
  hasAwait
  hasImportDeclaration
  hasYield
  insertTrimmingSpace
  isEmptyBareBlock
  isFunction
  isWhitespaceOrEmpty
  lastAccessInCallExpression
  literalValue
  makeAmpersandFunction
  makeEmptyBlock
  makeExpressionStatement
  makeGetterMethod
  makeLeftHandSideExpression
  makeRef
  maybeRef
  maybeRefAssignment
  modifyString
  negateCondition
  precedenceStep
  prepend
  processAssignmentDeclaration
  processBinaryOpExpression
  processCallMemberExpression
  processCoffeeDo
  processCoffeeInterpolation
  processForInOf
  processProgram
  processProgramAsync
  processTryBlock
  processUnaryExpression
  quoteString
  replaceNode
  reorderBindingRestProperty
  replaceNodes
  skipImplicitArguments
  trimFirstSpace
  typeOfJSX
  wrapIIFE
}
