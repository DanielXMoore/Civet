/**
 * lib.civet holds functions that are used inside parser.hera
 *
 * The rules inside parser.hera should be simple and short.
 * Most of the helpers/transforms should make their way into
 * here eventually.
 */

import type {
  AccessStart
  ASTNode
  ASTNodeBase
  ASTRef
  AssignmentExpression
  BlockStatement
  CallExpression
  DoStatement
  ExpressionNode
  ForStatement
  IfStatement
  IterationStatement
  MemberExpression
  MethodDefinition
  ParseRule
  StatementExpression
  StatementTuple
  WSNode
} from ./types.civet

import {
  gatherRecursive
  gatherRecursiveAll
} from ./traversal.civet

import {
  addParentPointers
  assert
  deepCopy
  getTrimmingSpace
  hasAwait
  hasYield
  insertTrimmingSpace
  isComma
  isEmptyBareBlock
  isWhitespaceOrEmpty
  literalValue
  makeAmpersandFunction
  makeLeftHandSideExpression
  makeNode
  makeRef
  maybeRef
  needsRef
  parenthesizeType
  wrapIIFE
  wrapWithReturn
} from ./util.civet

import {
  blockWithPrefix
  duplicateBlock
  hoistRefDecs
  makeBlockFragment
  makeEmptyBlock
  processBlocks
} from ./block.civet

import {
  dynamizeImportDeclaration
  dynamizeImportDeclarationExpression
  prependStatementExpressionBlock
  processAssignmentDeclaration
  processDeclarationConditions
  processDeclarations
} from ./declaration.civet

import { processPipelineExpressions } from ./pipe.civet
import { forRange, processForInOf } from ./for.civet
import {
  processFunctions
  expressionizeIteration
  skipImplicitArguments
} from ./function.civet
import { processPatternMatching } from ./pattern-matching.civet
import {
  adjustAtBindings
  adjustBindingElements
  gatherBindingCode
} from ./binding.civet
import {
  getPrecedence
  precedenceStep
  processBinaryOpExpression
} from ./op.civet
import { processUnaryExpression } from ./unary.civet
import { createConstLetDecs, createVarDecs } from ./auto-dec.civet

import {
  dedentBlockString
  dedentBlockSubstitutions
  getIndentLevel
  modifyString
  processCoffeeInterpolation
  quoteString
} from ./string.civet

function addPostfixStatement(statement: StatementTuple, ws: ASTNode, post)
  expressions := [
    ...post.blockPrefix or []
    ["", statement]
  ]

  block := makeNode {
    type: "BlockStatement"
    children: [" { ", expressions, " }"]
    expressions
  }

  children := [...post.children, block]

  // This removes trailing whitespace for easier testing
  if (!isWhitespaceOrEmpty(ws)) children.push(ws)

  post = makeNode { ...post, children, block }
  if post.type is "IfStatement"
    post.then = block
  return post

/**
 * Adjusts the index access to use brackets instead of dot
 * while accounting for optional chaining.
 */
function adjustIndexAccess(dot: AccessStart): AccessStart
  if dot.optional
    // ?. turns into ?.[
    return {
      ...dot,
      children: [...dot.children, "["]
    }
  else
    dot = replaceNodes deepCopy(dot),
      (node) => node.token is ".",
      (node) => ({ ...node, token: "[" })

  return dot

// Negate expression inside condition
function negateCondition(condition)
  { expression } .= condition
  children := condition.children.slice()
  i := children.indexOf(expression)
  if i < 0
    throw new Error `Could not find expression in condition`
  children[i] = expression =
    type: "UnaryExpression"
    children: [
      "!"
      makeLeftHandSideExpression expression
    ]
  { ...condition, expression, children }

/**
Somewhat incomplete detection of expressions used to
determine when we have to wrap if blocks in IIFE instead of
converting to ternary expressions.
*/
function isExpression(node: ASTNode): boolean
  if Array.isArray(node)
    return node.every(isExpression)

  if typeof node is "string"
    // TODO: may not quite be correct
    return true

  switch node?.type
    case "BlockStatement"
    case "DebuggerStatement"
    case "Declaration"
    case "ForStatement"
    case "IfStatement"
    case "IterationStatement"
    case "ReturnStatement"
    case "SwitchStatement"
    case "ThrowStatement"
    case "TryStatement"
      return false

  return true

function expressionizeBlock(blockOrExpression: ASTNode)
  if { expressions } := blockOrExpression
    l := expressions.length
    results := []

    for [ws, s, _delim], i of expressions
      if (!isExpression(s)) return
      wrapped := makeLeftHandSideExpression s
      if i is l - 1
        results.push [ws, wrapped]
      else
        results.push [ws, wrapped, ","]

    if results.length > 1
      return makeLeftHandSideExpression results

    return results
  else
    blockOrExpression

function expressionizeIfStatement(statement: IfStatement)
  { condition, then: b, else: e } := statement
  [ ...condRest, closeParen ] := condition.children  // separate ')'

  expressionizedBlock := expressionizeBlock b

  unless expressionizedBlock
    return wrapIIFE([["", statement]])

  children := [
    ...condRest
    "?"
    expressionizedBlock
  ]
  if e
    e2 := expressionizeBlock(e[2])
    unless e2
      return wrapIIFE([["", statement]])

    // Replace 'else' in e[1] with ':'. (e[0] is space before 'else')
    children.push e[0], ":", e2, ...e[3..]
  else
    children.push ":void 0"
  children.push closeParen

  {
    type: "IfExpression",
    children,
  }

function expressionizeTypeIf([ws, ifOp, condition, t, e])
  children := [
    ws
    "("
    insertTrimmingSpace condition, ""
    "?"
  ]
  unless ifOp.negated xor condition.negated // if
    children.push t
    if e
      // Replace 'else' in e[1] with ':'. (e[0] is space before 'else')
      children.push e[0], ":", ...e[2..]
    else
      children.push ":never"
  else // unless
    if e
      children.push ...e[2..], e[0], ":"
    else
      children.push "never:"
    children.push t
  children.push ")"
  children

/**
 * This adjusts #x.y().z and @x.y().z when used inside Object glob expressions
 * to remove `this.` where necessary.
 *
 * [See More](../test/object.civet)
 */
function handleThisPrivateShorthands(value)
  if value.privateShorthand
    value = value.children[1].children[1]

    return [value, false]

  if value.type is "MemberExpression" or value.type is "CallExpression"
    suppressPrefix .= value.thisShorthand
    value = {
      ...value,
      children: value.children.map (c, i) =>
        if i is 0
          let s
          [c, s] = handleThisPrivateShorthands c
          suppressPrefix ||= s

        c
    }

    return [value, suppressPrefix]

  return [value, value.thisShorthand]

/**
 * Process globs, bind shorthand, and call shortcuts, in Call/MemberExpression
 */
function processCallMemberExpression(node)
  { children } := node

  // Parenthesized operator like (+), immediately called, expands to
  // use of the operator. This is useful for e.g. shortcutting (&&).
  if children[0]?.parenthesizedOp?.token and children[1]?.type is "Call"
    op := children[0].parenthesizedOp
    call .= children[1]
    args := [...call.args] // shallow copy
    call = { ...call, args }
    // Remove trailing comma
    if comma := isComma args.-1
      comma.token = ''
    // Arguments already start and end with open and close parentheses.
    // Replace each comma with an instance of the operator and matching parens.
    commaCount .= 0
    for each arg of args
      if comma := isComma arg
        comma.token = `)${op.token}(`
        commaCount++
    // Don't mess with (+)()
    if args.length
      children.splice 0, 2,
        commaCount ?
          type: "ParenthesizedExpression",
          children: ["(", call, ")"]
        : { ...call, type: "ParenthesizedExpression" }

  // Process globs and bind shorthand
  for (let i = 0; i < children.length; i++) {
    const glob = children[i]
    if (glob?.type is "PropertyGlob") {
      let prefix = children.slice(0, i)
      const parts = []
      let hoistDec, refAssignment
      // add ref to ensure object base evaluated only once
      if (prefix.length > 1) {
        const ref = makeRef()
        hoistDec = {
          type: "Declaration",
          children: ["let ", ref],
          names: [],
        }
        refAssignment = [{
          type: "AssignmentExpression",
          children: [ref, " = ", prefix],
        }, ","]
        prefix = [ref]
      }
      prefix = prefix.concat(glob.dot)

      for part of glob.object.properties
        if part.type is "MethodDefinition"
          throw new Error("Glob pattern cannot have method definition")
        if part.value and !["CallExpression", "MemberExpression", "Identifier"].includes(part.value.type)
          throw new Error(`Glob pattern must have call or member expression value, found ${JSON.stringify(part.value)}`)

        suppressPrefix .= false
        name .= part.name
        value .= part.value ?? name
        wValue := getTrimmingSpace part.value

        [value, suppressPrefix] = handleThisPrivateShorthands value

        // Not yet needed:
        [name, value] = [value, name] if glob.reversed

        if !suppressPrefix // Don't prefix @ shorthand
          value = prefix.concat(insertTrimmingSpace(value, ""))
        if (wValue) value.unshift(wValue)
        if part.type is "SpreadProperty"
          parts.push {
            type: part.type
            value
            dots: part.dots
            delim: part.delim
            names: part.names
            children: part.children.slice(0, 2) // whitespace, ...
              .concat(value, part.delim)
          }
        else
          parts.push {
            type: part.type is "Identifier" ? "Property" : part.type
            name
            value
            delim: part.delim
            names: part.names
            children: [
              isWhitespaceOrEmpty(part.children[0]) and part.children[0]
              name
              isWhitespaceOrEmpty(part.children[2]) and part.children[2]
              part.children[3]?.token is ":" ? part.children[3] : ":"
              value
              part.delim // comma delimiter
            ]
          }
      object .= {
        type: "ObjectExpression"
        children: [
          glob.object.children.0 // {
          ...parts
          glob.object.children.-1 // whitespace and }
        ],
        properties: parts
        hoistDec
      }
      if refAssignment
        object = {
          type: "ParenthesizedExpression"
          children: ["(", ...refAssignment, object, ")"]
          expression: object
        }
      if (i is children.length - 1) return object
      return processCallMemberExpression({  // in case there are more
        ...node,
        children: [object, ...children.slice(i + 1)]
      })
    } else if (glob?.type is "PropertyBind") {
      // TODO: add ref to ensure object base evaluated only once
      const prefix = children.slice(0, i)
      return processCallMemberExpression({  // in case there are more
        ...node,
        children: [
          prefix,
          {
            ...glob,
            type: "PropertyAccess",
            children: [
              ...glob.children,
              ".bind(",
              prefix,
              ...glob.args.length > 0 ? [", "] : [],
              ...glob.args,
              ")",
            ]
          },
          ...children.slice(i + 1)
        ]
      })
    }
  }
  return node

/**
 * Replace this node with another, by modifying its parent's children.
 */
function replaceNode(node: ASTNodeBase, newNode: ASTNode): void
  unless node.parent?
    throw new Error "replaceNode failed: node has no parent"

  function recurse(children: ASTNode[]): boolean
    for each child, i of children
      if child is node
        children[i] = newNode
        return true
      else if Array.isArray child
        return true if recurse child
    return false

  unless recurse node.parent.children
    throw new Error "replaceNode failed: didn't find child node in parent"

  if newNode <? "object" and not Array.isArray newNode
    newNode.parent = node.parent

// Wrap expression in parentheses to make into a statement when:
// * object literal expression
// * anonymous function expression
// * comma operators applied to above
function makeExpressionStatement(expression: ASTNode): ASTNode
  if Array.isArray(expression) and expression[1]?[0]?[0]?[1]?.token is "," // CommaExpression
    [
      makeExpressionStatement expression[0]
      expression[1].map ([comma, exp]) => // CommaDelimiter AssignmentExpression
        [comma, makeExpressionStatement exp]
    ]
  else if expression?.type is "ObjectExpression" or
          (expression?.type is "FunctionExpression" and not expression.id)
    makeLeftHandSideExpression expression
  else
    expression

// Look for last property access like `.foo` or `[computed]` or root Identifier,
// before any calls like `(args)`, non-null assertions `!`, and optionals `?`.
// The return value should have a `name` property (for "Identifier" and
// "Index"), or have `type` of "Index" (for `[computed]`), or be undefined.
function lastAccessInCallExpression(exp) {
  return exp if exp.type is "Identifier"
  let children, i
  do {
    ({ children } = exp)
    i = children.length - 1
    while (i >= 0 and (
      children[i].type is "Call" ||
      children[i].type is "NonNullAssertion" ||
      children[i].type is "Optional"
    )) i--
    if (i < 0) return
    // Recurse into nested MemberExpression, e.g. from `x.y()`
  } while (children[i].type is "MemberExpression" and (exp = children[i]))
  return children[i]
}

// Given a MethodDefinition, convert into a FunctionExpression.
// Returns undefined if the method is a getter or setter.
function convertMethodToFunction(method) {
  const { signature, block } = method
  let { modifier, optional } = signature
  if (optional) return
  if (modifier) {
    if (modifier.get or modifier.set) {
      return
    } else if (modifier.async) {
      // put function after async
      modifier = [modifier.children[0][0], " function ", ...modifier.children.slice(1)]
    } else {
      modifier = ["function ", ...(modifier.children or [])]
    }
  } else {
    modifier = "function ";
  }
  return {
    ...signature,
    id: signature.name,
    signature,
    type: "FunctionExpression",
    children: [
      [modifier, ...signature.children.slice(1)],
      block,
    ],
    block,
  }
}

// Convert NamedImports into equivalent ObjectExpression or ObjectBindingPattern
function convertNamedImportsToObject(node, pattern?: boolean)
  properties := node.specifiers.map (specifier) =>
    if specifier.ts
      { type: "Error", message: "cannot use `type` in dynamic import" }
    else
      { source, binding } := specifier
      delim := specifier.children.-1
      {
        type: pattern ? "BindingProperty" : "Property"
        name: source
        value: binding unless source is binding
        delim
        children: source is binding
          ? [ source, delim ]
          : [ source, ":", binding, delim ]
      }

  {
    type: pattern ? "ObjectBindingPattern" : "ObjectExpression"
    names: node.names
    properties
    children: [
      node.children.0 // {
      properties
      node.children.-1 // }
    ]
  }

// Convert an ObjectExpression (with `properties`)
// into a set of JSX attributes.
// {foo} is equivalent to foo={foo}, and
// {foo, bar: baz} is equivalent to foo={foo} and bar={baz}.
// {...foo} is a special case.
function convertObjectToJSXAttributes(obj) {
  const { properties } = obj
  const parts = [] // JSX attributes
  const rest = []  // parts that need to be in {...rest} form
  for (let i = 0; i < properties.length; i++) {
    if (i > 0) parts.push(' ')
    const part = properties[i]
    switch (part.type) {
      case 'Identifier':
        parts.push([part.name, '={', part.name, '}'])
        break
      case 'Property':
        if (part.name.type is 'ComputedPropertyName') {
          rest.push(part)
        } else {
          parts.push([part.name, '={', insertTrimmingSpace(part.value, ''), '}'])
        }
        break
      case 'SpreadProperty':
        parts.push(['{', part.dots, part.value, '}'])
        break
      case 'MethodDefinition':
        const func = convertMethodToFunction(part)
        if (func) {
          parts.push([part.name, '={', convertMethodToFunction(part), '}'])
        } else {
          rest.push(part)
        }
        break
      default:
        throw new Error(`invalid object literal type in JSX attribute: ${part.type}`)
    }
  }
  if (rest.length) {
    parts.push(['{...{', ...rest, '}}'])
  }
  return parts
}

/**
 * Returns a new MethodDefinition node.
 */
function makeGetterMethod(name, ws, value, returnType, block?: BlockStatement, kind: { token: "get" | "set" } = { token: "get" }, autoReturn: boolean = true): MethodDefinition
  { token } := kind
  ws = insertTrimmingSpace(ws, "")
  let setVal
  parameters := token is "get" ?
    type: "Parameters"
    children: ["()"]
    names: []
    implicit: true
  :
    type: "Parameters"
    children: ["(", setVal = makeRef("value"), ")"]
    names: []
    implicit: false

  let expressions: StatementTuple[]
  if block
    // Duplicate block to avoid mutating original
    block = duplicateBlock(block)
    expressions = block.expressions
  else
    expressions = []
    block = {
      type: "BlockStatement"
      expressions
      children: ["{ ", expressions, " }"]
    }

  if autoReturn
    finalStatement: StatementTuple := token is "get" ?
      [ [expressions[0]?.[0] or "", ws], wrapWithReturn(value) ]
    :
      [ [expressions[0]?.[0] or "", ws], [ value, " = ", setVal ] ]

    expressions.push finalStatement

  children := [kind, " ", name, parameters, returnType, block]

  return {
    type: "MethodDefinition",
    children,
    name,
    signature: {
      type: "MethodSignature"
      modifier: {
        get: token is "get"
        set: token is "set"
        async: false
      },
      name,
      returnType,
    },
    block,
    parameters,
  }

function processBindingPatternLHS(lhs, tail): void
  // Expand AtBindings first before gathering splices
  adjustAtBindings(lhs, true)
  const [splices, thisAssignments] = gatherBindingCode(lhs)
  // TODO: This isn't quite right for compound assignments, may need to wrap with parens and use comma to return the complete value
  tail.push(...splices.map((s) => [", ", s]), ...thisAssignments.map((a) => [", ", a]))

function processAssignments(statements): void {
  // Move assignments/updates within LHS of assignments/updates
  // to run earlier via comma operator
  gatherRecursiveAll(statements, (n) => n.type is "AssignmentExpression" or n.type is "UpdateExpression")
    .forEach (exp) =>
      function extractAssignment(lhs) {
        let expr = lhs
        while expr.type is "ParenthesizedExpression"
          expr = expr.expression
        if (expr.type is "AssignmentExpression" ||
          expr.type is "UpdateExpression") {
          if (expr.type is "UpdateExpression" &&
            expr.children[0] is expr.assigned) {  // postfix update
            pre.push("(")
            post.push([", ", lhs, ")"])
          } else {
            pre.push(["(", lhs, ", "])
            post.push(")")
          }
          // TODO: use ref to avoid duplicating function calls
          return expr.assigned
        }
      }

      const pre = [], post = []
      switch (exp.type) {
        case "AssignmentExpression":
          if (!exp.lhs) return
          exp.lhs.forEach((lhsPart, i) => {
            let newLhs = extractAssignment(lhsPart[1])
            if (newLhs) {
              lhsPart[1] = newLhs
            }
          })
          break
        case "UpdateExpression":
          let newLhs = extractAssignment(exp.assigned)
          if (newLhs) {
            const i = exp.children.indexOf(exp.assigned)
            exp.assigned = exp.children[i] = newLhs
          }
          break
      }
      if (pre.length) exp.children.unshift(...pre)
      if (post.length) exp.children.push(...post)
      // TODO: need to make this a parenthesized expression when when we add parens

      if exp.type is "UpdateExpression"
        { assigned } := exp
        ref := makeRef()
        newMemberExp := unchainOptionalMemberExpression assigned, ref, (children) =>
          exp.children.map (c) =>
            if c is assigned
              children
            else
              c

        if newMemberExp !== assigned
          if newMemberExp.usesRef
            newMemberExp.hoistDec = {
              type: "Declaration"
              children: ["let ", ref]
              names: []
            }
          replaceNode exp, newMemberExp

  replaceNodesRecursive statements,
    (n) => n.type is "AssignmentExpression" and n.names is null,
    (exp: AssignmentExpression): AssignmentExpression | BlockStatement | ExpressionNode => {
      let { lhs: $1, exp: $2 } = exp, tail = [], i = 0, len = $1.length

      let block?: BlockStatement
      // Extract StatementExpression as block
      if exp.parent.type is "BlockStatement" and !$1.-1?.-1?.special// can only prepend to assignments that are children of blocks
        block = makeBlockFragment()
        if ref := prependStatementExpressionBlock([null,null,$2], block)
          exp.children = exp.children.map (c: ASTNode) -> if c is $2 then ref else c
          // @ts-ignore
          $2 = ref
        else
          block = undefined

      // identifier=, xor=, ++=
      if $1.some((left) => left[left.length - 1].special)
        if ($1.length !== 1) throw new Error("Only one assignment with id= is allowed")
        [, lhs, , op] := $1[0]
        { call, omitLhs } := op
        // Wrap right-hand side with call
        index := exp.children.indexOf($2)
        if (index < 0) throw new Error("Assertion error: exp not in AssignmentExpression")
        exp.children.splice index, 1,
          exp.exp = $2 = [call, "(", lhs, ", ", $2, ")"]
        if omitLhs
          return $2

      // Force parens around destructuring object assignments
      // Walk from left to right the minimal number of parens are added and enclose all destructured assignments
      // TODO: Could validate some lhs ecmascript rules here if we wanted to
      let wrapped = false
      while (i < len) {
        const lastAssignment = $1[i++]
        const [, lhs, , op] = lastAssignment
        if (op.token !== "=") continue

        if (lhs.type is "ObjectExpression" or lhs.type is "ObjectBindingPattern") {
          // Wrap with parens to distinguish from braced blocks
          if (!wrapped) {
            wrapped = true
            lhs.children.splice(0, 0, "(")
            tail.push(")")
          }
        }
      }

      // Walk from right to left to handle splices
      i = len - 1
      while i >= 0
        const lastAssignment = $1[i]

        if (lastAssignment[3].token is "=") {
          const lhs = lastAssignment[1]

          // Splice assignment
          if (lhs.type is "MemberExpression") {
            const members = lhs.children
            const lastMember = members[members.length - 1]

            // TODO: this is kind of bonkers
            if (lastMember.type is "SliceExpression") {
              const { start, end, children: c } = lastMember
              // TODO: don't lose as many source mappings
              c[0].token = ".splice("
              c[1] = start
              c[2] = ", "
              if (end)
                c[3] = [end, " - ", start]
              else
                c[3] = ["1/0"]
              c[4] = [", ...", $2]
              c[5] = ")"

              // Remove assignment token
              lastAssignment.pop()
              if (isWhitespaceOrEmpty(lastAssignment[2])) lastAssignment.pop()
              // TODO: this only works for the last assignment, not multiple splice assignments, or splice assignments earlier in the chain
              if ($1.length > 1) {
                throw new Error("Not implemented yet! TODO: Handle multiple splice assignments")
              }

              exp.children = [$1]
              exp.names = []
              return exp
            }
          } else if (lhs.type is "ObjectBindingPattern" or lhs.type is "ArrayBindingPattern") {
            processBindingPatternLHS(lhs, tail)
          }
          // NOTE: currently not processing any non-binding pattern ObjectExpression or ArrayExpressions
          // This might not be correct in all situations, esp BindingPatterns nested inside ObjectExpressions
        }
        i--

      // Handle optional chain ?. in lhs of assignments
      i = len - 1
      optionalChainRef := makeRef()
      while i >= 0
        assignment := $1[i]
        [ws1, lhs, ws2, op] := assignment

        if lhs.type is "MemberExpression" or lhs.type is "CallExpression"
          newMemberExp := unchainOptionalMemberExpression lhs, optionalChainRef, (children) =>
            // NOTE: This only executes when lhs contains chains
            // this mutates the assignments array to account for the parts moved into the conditionals
            assigns := $1.splice(i + 1, len - 1 - i)
            $1.pop()
            [ws1, ...children, ws2, op, ...assigns, $2]

          if newMemberExp !== lhs
            if newMemberExp.usesRef
              exp.hoistDec = {
                type: "Declaration"
                children: ["let ", optionalChainRef]
                names: []
              }

            replaceNode $2, newMemberExp
            newMemberExp.parent = exp
            $2 = newMemberExp

        i--

      // Gather all identifier names from the lhs array
      exp.names = $1.flatMap(([, l]) => l.names or [])
      const index = exp.children.indexOf($2)
      if (index < 0) throw new Error("Assertion error: exp not in AssignmentExpression")
      exp.children.splice(index + 1, 0, ...tail)

      if block
        block.parent = exp.parent
        block.expressions.push(["", exp])
        exp.parent = block
        return block

      return exp
    }
}

function unchainOptionalMemberExpression(exp: MemberExpression | CallExpression, ref: ASTRef, innerExp: (exp) => ASTNode)
  j .= 0
  { children } := exp
  usesRef .= false
  conditions := []

  // NOTE: not caching length because the array mutates inside
  while j < children.length
    child := children[j]
    type := child?.type
    hasOptional .= false

    switch type
      when "PropertyAccess"
        if child.dot?.optional
          hasOptional = true
          child.dot.children.shift()
          child.dot.optional = false
      when "Call", "Index"
        if child.optional
          hasOptional = true
          child.children.shift()
          child.optional = undefined

    if hasOptional
      let base

      if j > 1 or needsRef children[0]
        usesRef = true
        base = makeLeftHandSideExpression
          type: "AssignmentExpression"
          children: [ref, " = ", children.splice(0, j)]

        base.parent = child
        children.unshift ref

        j = 0
      else
        base = children[0]

      conditions.push [ base, " != null" ]

    j++

  if l := conditions.length
    cs := conditions.map (c, i) =>
      if i is l - 1
        c
      else
        [c, " && "]

    {
      ...exp
      children: [...cs, " ? ", innerExp(children), " : void 0"]
      usesRef
    }
  else // Unchanged
    exp

function attachPostfixStatementAsExpression(exp, post: [WSNode, IfStatement | IterationStatement | DoStatement | ForStatement])
  postfixStatement := post[1]

  switch postfixStatement.type
    case "ForStatement":
    case "IterationStatement":
    case "DoStatement": {
      statement := addPostfixStatement(exp, ...post)
      return {
        type: "IterationExpression",
        children: [statement],
        block: statement.block,
        statement,
      }
    }
    case "IfStatement":
      return expressionizeIfStatement { ...postfixStatement, then: exp }
    default:
      throw new Error("Unknown postfix statement")

function processTypes(node: ASTNode)
  // T? -> T | undefined; T?? -> T | undefined | null
  gatherRecursiveAll node, (n) => n.type is "UnaryType"
  // @ts-ignore
  .forEach (unary: ASTNodeBase): void =>
    let last: ASTNode
    count .= 0
    while unary.suffix.length and unary.suffix.-1?.token is "?"
      last = unary.suffix.pop()
      count++
    return unless count
    if unary.parent?.type is "TypeTuple"
      // Leave one ? inside a type tuple
      if count is 1
        unary.suffix.push last
        return
      replaceNode unary, [
        getTrimmingSpace unary
        "("
        parenthesizeType insertTrimmingSpace unary, ""
        " | null)"
        last
      ]
    else
      replaceNode unary, [
        getTrimmingSpace unary
        "("
        parenthesizeType insertTrimmingSpace unary, ""
        count is 1 ? " | undefined" : " | undefined | null"
        ")"
      ]

/**
Wrap any remaining statement expressions in IIFE.
*/
function processStatementExpressions(statements: StatementTuple[]): void
  gatherRecursiveAll(statements, .type is "StatementExpression")
    .forEach (_exp) =>
      exp := _exp as! StatementExpression
      { statement } := exp
      let ws
      unless exp.children[0] is exp.statement
        ws = exp.children[0]

      switch statement.type
        when "IfStatement"
          if expression := expressionizeIfStatement(statement)
            exp.statement = expression
            exp.children = [exp.statement]
          else
            exp.children = wrapIIFE([["", statement]])
        when "IterationExpression"
          // Do nothing, handled separately currently
        else
          exp.children = wrapIIFE([["", statement]])

      exp.children.unshift(ws) if ws

function processNegativeIndexAccess(statements: StatementTuple[]): void
  gatherRecursiveAll(statements, (n) => n.type is "NegativeIndex")
    .forEach (exp) =>
      { parent } := exp
      index := parent.children.indexOf(exp)
      let ref, subexp
      if index is 1
        child := parent.children[0]
        ref = maybeRef(child)
        if ref !== child
          subexp = parent.children.splice 0, 1
      else if index > 1
        ref = makeRef()
        subexp = parent.children.splice 0, index
      else
        throw new Error("Invalid parse tree for negative index access")

      if subexp
        exp.hoistDec = {
          type: "Declaration",
          children: ["let ", ref],
          names: [],
        }
        parent.children.unshift makeLeftHandSideExpression
          type: "AssignmentExpression"
          children: [ref, " = ", subexp]

      exp.len.children = [
        ref,
        ".length"
      ]

function processProgram(root: BlockStatement, config, m, ReservedWord: ParseRule): void
  // invariants
  assert.equal(m.forbidBracedApplication.length, 1, "forbidBracedApplication")
  assert.equal(m.forbidClassImplicitCall.length, 1, "forbidClassImplicitCall")
  assert.equal(m.forbidIndentedApplication.length, 1, "forbidIndentedApplication")
  assert.equal(m.forbidNewlineBinaryOp.length, 1, "forbidNewlineBinaryOp")
  assert.equal(m.forbidTrailingMemberProperty.length, 1, "forbidTrailingMemberProperty")
  assert.equal(m.JSXTagStack.length, 1, "JSXTagStack")

  addParentPointers(root)

  const { expressions: statements } = root

  processNegativeIndexAccess(statements)
  processTypes(statements)
  processDeclarationConditions(statements, m.getRef)
  processPipelineExpressions(statements)
  processDeclarations(statements)
  processAssignments(statements)
  processStatementExpressions(statements)
  processPatternMatching(statements, ReservedWord, m.getRef)

  // Modify iteration expressions
  gatherRecursiveAll(statements, (n) => n.type is "IterationExpression")
    .forEach((e) => expressionizeIteration(e))

  // Hoist hoistDec attributes to actual declarations.
  // NOTE: This should come after iteration expressions get processed
  // into IIFEs.
  hoistRefDecs(statements)

  // Adding implicit returns should happen after hoisting any ref declarations
  // so their target node can be found in the block without being inside a return
  processFunctions(statements, config)

  // Insert prelude
  statements.unshift(...m.prelude)

  if (config.autoLet) {
    createConstLetDecs(statements, [], "let")
  } else if(config.autoConst) {
    createConstLetDecs(statements, [], "const")
  } else if (config.autoVar) {
    createVarDecs(statements, [])
  }

  processBlocks(statements)

  populateRefs(statements)
  adjustAtBindings(statements)

function populateRefs(statements: ASTNode): void {
  const refNodes = gatherRecursive(statements, ({ type }) => type is "Ref")

  if (refNodes.length) {
    // Find all ids within nested scopes
    const ids = gatherRecursive(statements, (s) => s.type is "Identifier")
    const names = new Set(ids.flatMap(({ names }) => names or []))

    // Populate each ref
    refNodes.forEach((ref) => {
      const { type, base } = ref
      if (type !== "Ref") return

      ref.type = "Identifier"

      let n = 0
      let name = base

      // check for name collisions and increment name suffix
      while (names.has(name)) {
        n++
        name = `${base}${n}`
      }

      names.add(name)
      ref.children = ref.names = [name]
    })
  }
}

function reorderBindingRestProperty(props) {
  const names = props.flatMap((p) => p.names)

  let restIndex = -1
  let restCount = 0
  props.forEach(({ type }, i) => {
    if (type is "BindingRestProperty") {
      if (restIndex < 0) restIndex = i
      restCount++
    }
  })

  if (restCount is 0) {
    return {
      children: props,
      names,
    }
  } else if (restCount is 1) {
    let after = props.slice(restIndex + 1)
    let rest = props[restIndex]

    props = props.slice(0, restIndex);

    // Swap delimiters of last property and rest so that an omitted trailing comma doesn't end up in the middle
    if (after.length) {
      const {delim: restDelim} = rest,
        lastAfterProp = after[after.length - 1],
        {delim: lastDelim, children: lastAfterChildren} = lastAfterProp

      rest = {
        ...rest,
        delim: lastDelim,
        children: [...rest.children.slice(0, -1), lastDelim],
      }
      after = [
        ...after.slice(0, -1),
        {
          ...lastAfterProp,
          delim: restDelim,
          children: [...lastAfterChildren.slice(0, -1), restDelim]
        }
      ]
    }

    // JS forbids trailing comma after rest property
    if Array.isArray(rest.delim) and rest.delim.-1?.token is ","
      // Can't mutate delim in case of cached nodes
      rest.delim = rest.delim.slice(0, -1)
      rest.children = [ ...rest.children.slice(0, -1), rest.delim ]

    const children = [...props, ...after, rest]

    return {
      children,
      names,
    }
  }

  return {
    children: [{
      type: "Error",
      message: "Multiple rest properties in object pattern",
    }, props]
  }
}

/**
 * Replace all nodes that match predicate with replacer(node)
 */
function replaceNodes(root, predicate, replacer)
  return root unless root?

  array := Array.isArray(root) ? root : root.children

  unless array
    if predicate root
      return replacer root, root
    else
      return root

  for each node, i of array
    return unless node?
    if predicate node
      array[i] = replacer node, root
    else
      replaceNodes node, predicate, replacer

  return root

function replaceNodesRecursive(root, predicate, replacer)
  return root unless root?

  array := Array.isArray(root) ? root : root.children

  unless array
    if predicate root
      return replacer root, root
    else
      return root

  for each node, i of array
    continue unless node?
    if predicate node
      ret := replacer node, root
      replaceNodesRecursive ret, predicate, replacer
      array[i] = ret
    else
      replaceNodesRecursive node, predicate, replacer

  return root

function typeOfJSX(node, config, getRef) {
  switch (node.type) {
    case "JSXElement":
      return typeOfJSXElement(node, config, getRef)
    case "JSXFragment":
      return typeOfJSXFragment(node, config, getRef)
  }
}

function typeOfJSXElement(node, config, getRef) {
  if (config.solid) {
    if (config.server and !config.client) {  // server only
      return ["string"]
    }
    let { tag } = node
    // "An intrinsic element always begins with a lowercase letter,
    // and a value-based element always begins with an uppercase letter."
    // [https://www.typescriptlang.org/docs/handbook/jsx.html]
    const clientType =
      tag[0] is tag[0].toLowerCase() ?
        [getRef("IntrinsicElements"), '<"', tag, '">'] :
        ['ReturnType<typeof ', tag, '>']
    if (config.server) {  // isomorphic code for client + server
      return ["string", " | ", clientType]
    } else {  // client only (default)
      return clientType
    }
  }
}

function typeOfJSXFragment(node, config, getRef) {
  if (config.solid) {
    let type = []
    let lastType
    for (let child of node.jsxChildren) {
      switch (child.type) {
        case "JSXText":
          // Solid combines multiple consecutive texts into one string
          if (lastType !== "JSXText") {
            type.push("string")
          }
          break
        case "JSXElement":
          type.push(typeOfJSXElement(child, config, getRef))
          break
        case "JSXFragment":
          // Solid flattens fragments of fragments into one array.
          type.push(...typeOfJSXFragment(child, config, getRef))
          break
        case "JSXChildExpression":
          // Solid discards empty expressions
          if (child.expression) {
            type.push(["typeof ", child.expression])
          }
          break
        default:
          throw new Error(`unknown child in JSXFragment: ${JSON.stringify(child)}`)
      }
      lastType = child.type
    }
    // Solid doesn't wrap single fragment child in an array
    if (type.length is 1) {
      return type[0]
    } else {
      type = type.flatMap((t) => [t, ", "])
      type.pop() // remove trailing comma
      return ["[", type, "]"]
    }
  }
}

export {
  addPostfixStatement
  adjustBindingElements
  adjustIndexAccess
  attachPostfixStatementAsExpression
  blockWithPrefix
  convertNamedImportsToObject
  convertObjectToJSXAttributes
  dedentBlockString
  dedentBlockSubstitutions
  deepCopy
  dynamizeImportDeclaration
  dynamizeImportDeclarationExpression
  expressionizeTypeIf
  forRange
  gatherBindingCode
  gatherRecursive
  getIndentLevel
  getPrecedence
  getTrimmingSpace
  hasAwait
  hasYield
  insertTrimmingSpace
  isEmptyBareBlock
  isWhitespaceOrEmpty
  lastAccessInCallExpression
  literalValue
  makeAmpersandFunction
  makeEmptyBlock
  makeExpressionStatement
  makeGetterMethod
  makeLeftHandSideExpression
  makeRef
  maybeRef
  modifyString
  negateCondition
  precedenceStep
  processAssignmentDeclaration
  processBinaryOpExpression
  processCallMemberExpression
  processCoffeeInterpolation
  processForInOf
  processProgram
  processUnaryExpression
  quoteString
  reorderBindingRestProperty
  replaceNodes
  skipImplicitArguments
  typeOfJSX
  wrapIIFE
}
