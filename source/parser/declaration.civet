import {
  ASTLeaf
  ASTNode
  Binding
  Children
  Initializer
  StatementTuple
  TypeSuffix
  WSNode
} from ./types.civet

import {
  gatherRecursiveAll
} from ./traversal.civet

import {
  convertOptionalType
  makeNode
  makeRef
  updateParentPointers
} from ./util.civet

import {
  assignResults
  wrapIterationReturningResults
} from ./function.civet

import {
  gatherBindingCode
} from ./binding.civet

function processAssignmentDeclaration(decl: ASTLeaf, pattern: Binding["pattern"], suffix: TypeSuffix, ws: WSNode, assign: ASTLeaf, e: ASTNode)
  // Adjust position to space before assignment to make TypeScript remapping happier
  decl = {
    ...decl,
    $loc:
      pos: assign.$loc.pos - 1
      length: assign.$loc.length + 1
  }

  [splices, assignments] .= gatherBindingCode pattern

  splices = splices.map (s) => [", ", s]
  thisAssignments := assignments.map (a) => ["", a, ";"] as const

  initializer := [ws, assign, e]
  binding := makeNode {
    type: "Binding",
    pattern,
    initializer,
    splices,
    suffix,
    thisAssignments,
    children: [pattern, suffix, initializer]
  }

  children := [decl, binding]

  makeNode {
    type: "Declaration",
    pattern.names,
    decl,
    bindings: [binding],
    splices,
    thisAssignments,
    children,
  }

function processDeclarations(statements: StatementTuple[]): void
  // @ts-ignore
  gatherRecursiveAll statements, .type is "Declaration"
  // @ts-ignore
  .forEach (statement: DeclarationStatement) =>
    { bindings } := statement as DeclarationStatement
    bindings?.forEach (binding) =>
      suffix := binding.suffix
      if suffix and suffix.optional and suffix.t
        // Convert `let x?: T` to `let x: undefined | T`
        convertOptionalType suffix

      { initializer } := binding
      if initializer
        prependBlockStatement initializer, statement

function prependBlockStatement(initializer: Initializer, statement: {children: Children}): void
  exp .= initializer[2]

  // Handle nested statement expression
  let ws
  if Array.isArray(exp)
    ws = exp[0]
    exp = exp[1]!

  if exp.type is "StatementExpression"
    pre: ASTNode[] := []
    statementExp := exp.statement
    blockStatement: StatementTuple := ["", statementExp]

    if statementExp.type is "IterationExpression"
      // Async iterations remain inline wrapped with IIFE
      return if statementExp.async

      statement := statementExp.statement
      blockStatement[1] = statement

      wrapIterationReturningResults statement, children: blockStatement, ->
      initializer[2] = statement.resultsRef
    else
      ref := initializer[2] = makeRef()

      assignResults blockStatement, (resultNode) =>
        //@ts-ignore
        makeNode
          type: "AssignmentExpression",
          children: [ref, " = ", resultNode]

      refDec :=
        type: "Declaration",
        children: ["let ", ref, ";"],

      pre.unshift refDec
      //@ts-ignore
      pre.push ws if ws

    // insert statement before the declaration
    //@ts-ignore
    statement.children.unshift(pre, blockStatement, ";")

    updateParentPointers blockStatement, statement

export {
  processAssignmentDeclaration
  processDeclarations
}
