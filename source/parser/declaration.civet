import type {
  ASTLeaf
  ASTNode
  ASTNodeParent
  ASTRef
  Binding
  Children
  DeclarationStatement
  IfStatement
  Initializer
  IterationStatement
  StatementTuple
  SwitchStatement
  TypeSuffix
  WSNode
} from ./types.civet

import {
  blockWithPrefix
  makeEmptyBlock
  replaceBlockExpression
} from ./block.civet

import {
  gatherRecursiveAll
} from ./traversal.civet

import {
  getPatternBlockPrefix
  getPatternConditions
  nonMatcherBindings
} from ./pattern-matching.civet

import {
  convertOptionalType
  makeNode
  updateParentPointers
} from ./util.civet

import {
  makeRef
  maybeRef
} from ./ref.civet

import {
  assignResults
  wrapIterationReturningResults
} from ./function.civet

import {
  gatherBindingCode
} from ./binding.civet

import {
  convertNamedImportsToObject
  insertTrimmingSpace
  processCallMemberExpression
} from ./lib.civet

function processAssignmentDeclaration(decl: ASTLeaf, pattern: Binding["pattern"], suffix: TypeSuffix, ws: WSNode, assign: ASTLeaf, e: ASTNode)
  // Adjust position to space before assignment to make TypeScript remapping happier
  decl = {
    ...decl,
    $loc:
      pos: assign.$loc.pos - 1
      length: assign.$loc.length + 1
  }

  [splices, assignments] .= gatherBindingCode pattern

  splices = splices.map (s) => [", ", s]
  thisAssignments := assignments.map (a) => ["", a, ";"] as const

  initializer := makeNode
    type: "Initializer"
    expression: e
    children: [ws, assign, e]
  binding := makeNode {
    type: "Binding"
    pattern
    initializer
    splices
    suffix
    thisAssignments
    children: [pattern, suffix, initializer]
  }

  children := [decl, binding]

  makeNode {
    type: "Declaration",
    pattern.names,
    decl,
    bindings: [binding],
    splices,
    thisAssignments,
    children,
  }

function processDeclarations(statements: StatementTuple[]): void
  // @ts-ignore
  gatherRecursiveAll statements, .type is "Declaration"
  // @ts-ignore
  .forEach (statement: DeclarationStatement) =>
    { bindings } := statement as DeclarationStatement
    bindings?.forEach (binding) =>
      suffix := binding.suffix
      if suffix and suffix.optional and suffix.t
        // Convert `let x?: T` to `let x: undefined | T`
        convertOptionalType suffix

      { initializer } := binding
      if initializer
        prependStatementExpressionBlock initializer, statement

function prependStatementExpressionBlock(initializer: Initializer, statement: {children: Children}): ASTRef?
  {expression: exp} .= initializer

  // Handle nested statement expression
  let ws
  if Array.isArray(exp)
    ws = exp[0]
    exp = exp[1]!

  return unless exp?.type is "StatementExpression"

  pre: ASTNode[] := []
  statementExp := exp.statement
  blockStatement: StatementTuple := ["", statementExp]
  let ref: ASTRef

  if statementExp.type is "IterationExpression"
    // Async iterations remain inline wrapped with IIFE
    return if statementExp.async

    statement := statementExp.statement
    blockStatement[1] = statement

    // Leave comptime statements wrapped in IIFE
    return if statement.type is "ComptimeStatement"

    if statement.type is "DoStatement"
      ref = initializer.expression = initializer.children[2] = makeRef()
      assignResults blockStatement, (resultNode) =>
        //@ts-ignore
        makeNode
          type: "AssignmentExpression",
          children: [ref, " = ", resultNode]
          parent: statement

      refDec :=
        type: "Declaration",
        children: ["let ", ref, ";"],

      // @ts-ignore
      pre.unshift refDec
    else
      wrapIterationReturningResults statement, children: blockStatement, ->
      ref = initializer.expression = initializer.children[2] = statement.resultsRef
  else
    ref = initializer.expression = initializer.children[2] = makeRef()

    assignResults blockStatement, (resultNode) =>
      //@ts-ignore
      makeNode
        type: "AssignmentExpression",
        children: [ref, " = ", resultNode]
        parent: statement

    refDec :=
      type: "Declaration",
      children: ["let ", ref, ";"],

    pre.unshift refDec
    //@ts-ignore
    pre.push ws if ws

  // insert statement before the declaration
  //@ts-ignore
  statement.children.unshift(pre, blockStatement, ";")
  updateParentPointers blockStatement, statement

  return ref

function processDeclarationCondition(condition, rootCondition, parent: ASTNodeParent): void
  return unless condition.type is "DeclarationCondition"

  { decl, bindings } := condition.declaration as DeclarationStatement
  // TODO: Add support for `let` and `const` declarations with multiple bindings in conditions
  binding := bindings[0]
  { pattern, suffix, initializer } .= binding
  nullCheck := suffix?.optional and not suffix.t and not suffix.nonnull

  unless initializer?
    condition.children = [
      type: "Error"
      message: "Missing initializer in declaration condition"
    ]
    return

  ref: ASTNode .= prependStatementExpressionBlock(initializer!, parent)

  if ref
    Object.assign condition, {
      type: "AssignmentExpression"
      children: [ref]
      pattern
      ref
      statementDeclaration: true
    }
  else
    { expression } := initializer
    ref = maybeRef expression
    simple := ref is expression
    let children
    if simple
      ref = insertTrimmingSpace ref, ""
      children = [ref]
    else
      children = [ref, initializer]
      // Wrap declaration that is a plain assignment (no pattern-matching) and the immediate grandchild of an `if` or `while`
      // to satisfy eslint's no-cond-assign rule
      // More complex conditions (triggered by pattern matching or `until`/`unless`) don't need double parens
      grandparent := condition.parent?.parent
      if pattern.type is "Identifier" and (grandparent?.type is "IfStatement" or grandparent?.type is "IterationStatement") and not nullCheck
        children.unshift "("
        children.push ")"

    // `x? := ...` as a condition means `x := ..., x?`
    if nullCheck
      children.unshift "("
      children.push ") != null"
      suffix = undefined

    Object.assign condition, {
      type: "AssignmentExpression"
      children
      hoistDec: unless simple
        type: "Declaration"
        children: ["let ", ref, suffix]
        names: []
      pattern
      ref
    }

  // condition wasn't previously a child, so now needs parent pointers
  updateParentPointers condition, parent

  rootCondition.blockPrefix = getPatternBlockPrefix(pattern, ref, decl, suffix)

function processDeclarationConditions(node: ASTNode): void
  gatherRecursiveAll node, (n) =>
    n.type is "IfStatement" or n.type is "IterationStatement" or n.type is "SwitchStatement"
  .forEach (s) =>
    processDeclarationConditionStatement s

/**
 * Processes adding additional conditions when declarations are used as a condition in IfStatements, WhileStatements, and SwitchStatements.
 * Also does additional processing for IfStatements that used to be in the parser (inserting semi-colon on bare-block consequent with else).
 */
function processDeclarationConditionStatement(s: IfStatement | IterationStatement | SwitchStatement): void
  { condition } := s
  return unless condition?.expression
  { expression } .= condition
  // Support for negated conditions built by unless/until
  switch expression
    {type: 'UnaryExpression', children: ['!', {type: 'ParenthesizedExpression', expression: expression2}]}
      expression = expression2
  processDeclarationCondition expression, condition.expression, s

  { ref, pattern } := expression

  if pattern
    conditions := getPatternConditions(pattern, ref)
    .filter (c) =>
      switch c
        // We already check whether the ref is truthy, so it's non-null
        [^ref, " != null"]
          false
        // Keep top-level object checks to be consistent with pattern matching
        // (e.g. exclude {length} := s from matching a string)
        //["typeof ", ^ref, " === 'object'"]
        else
          true

    if conditions#
      condition.children.unshift "("
      conditions.forEach (c) =>
        condition.children.push " && ", c
      condition.children.push ")"

  switch s.type
    when "IfStatement"
      { else: e} := s
      block := blockWithPrefix(condition.expression.blockPrefix, s.then)

      if block.bare and e and not block.semicolon
        block.children.push block.semicolon = ";"

      // Replace then block with prefixed block
      s.children = s.children.map (c) =>
        if c is s.then
          block
        else
          c
      s.then = block

      // Update parent pointers since declaration conditions have expanded
      updateParentPointers(block, s)

    when "IterationStatement"
      { children, block } := s
      newBlock := blockWithPrefix(condition.expression.blockPrefix, block)
      s.children = children.map (c) => c?.type is "BlockStatement" ? newBlock : c

      // Update parent pointers since declaration conditions have expanded
      updateParentPointers(newBlock, s)

    when "SwitchStatement"
      { blockPrefix, ref, statementDeclaration } := condition.expression as! { blockPrefix: StatementTuple[], ref: ASTRef, statementDeclaration: boolean}
      return unless blockPrefix

      newCondition :=
        type: "ParenthesizedExpression"
        children: ["(", ref, ")"]
        expression: ref
        parent: s

      // @ts-ignore
      s.children = s.children.map (c) ->
        if c is s.condition
          newCondition
        else
          c

      // @ts-ignore
      s.condition = newCondition
      updateParentPointers s

      if statementDeclaration
        // Hacky way to make sure the declaration is after the hoisted statement declaration
        // TODO better unify this with hoistDec mechanics
        block := makeEmptyBlock()
        replaceBlockExpression(s.parent as BlockStatement, s, block)
        block.expressions.push ["", s]
        s.children.splice s.children.findIndex(.token is "switch"), 0, blockPrefix
        s.parent = block
      else
        // wraps the entire switch statement
        block := blockWithPrefix [["", [{
          type: "Declaration",
          children: ["let ", ...condition.expression.children],
        }], ";"], ...blockPrefix], makeEmptyBlock()
        updateParentPointers block, s.parent

        replaceBlockExpression(s.parent as BlockStatement, s, block)
        block.expressions.push ["", s]
        s.parent = block

// Convert FromClause into arguments for dynamic import
function dynamizeFromClause(from)
  from = from[1..]  // remove 'from'
  from = insertTrimmingSpace from, ""
  if from.-1?.type is "ImportAssertion"
    assert := from.pop()
    from.push ", {", assert.keyword, ":", assert.object, "}"
  ["(", ...from, ")"]

function dynamizeImportDeclaration(decl)
  { imports } := decl
  { star, binding, specifiers } .= imports
  justDefault := binding and not specifiers and not star
  pattern := do
    if binding
      if specifiers
        makeRef()
      else
        binding
    else
      convertNamedImportsToObject(imports, true)
  c := "const"
  expression := [
    if justDefault then "("
    {type: "Await", children: ["await"]}
    " "
    decl.children[0] // import
    dynamizeFromClause decl.from
    if justDefault then ").default"
  ]
  initializer: Initializer := {
    type: "Initializer"
    expression
    children: [" ", "= ", expression]
  }
  bindings := [{
    type: "Binding"
    names: pattern.names
    pattern
    initializer
    children: [pattern, initializer]
  }]
  if binding and specifiers
    // import x, {y} --> const ref = await import(...), x = ref.default, {y} = ref
    pattern2 := binding
    exp2 := [
      pattern
      ".default"
    ]
    initializer2: Initializer := {
      type: "Initializer"
      expression
      children: [" ", "= ", exp2]
    }
    bindings.push
      type: "Binding"
      names: binding.names
      pattern: pattern2
      initializer: initializer2
      children: [pattern2, initializer2]
    pattern3 := convertNamedImportsToObject(imports.children.at(-1), true)
    initializer3: Initializer := {
      type: "Initializer"
      expression: pattern
      children: [" ", "= ", pattern]
    }
    bindings.push
      type: "Binding"
      names: specifiers.names
      pattern: pattern3
      initializer: initializer3
      children: [pattern3, initializer3]
  {
    type: "Declaration"
    names: imports.names
    bindings
    decl: c
    children: [
      c, " "
      bindings.flatMap (binding, i) => i > 0 ? [", ", binding] : [binding]
    ]
  }

function dynamizeImportDeclarationExpression($0)
  [imp, ws1, named, ws2, from] := $0
  object := convertNamedImportsToObject(named)
  dot := "."
  processCallMemberExpression {
    type: "CallExpression",
    children: [
      { type: "Await", children: "await" }, " ",
      imp,
      insertTrimmingSpace(ws2, ""),
      dynamizeFromClause(from),
      {
        type: "PropertyGlob",
        dot,
        object,
        children: [ws1, dot, object],
        reversed: true,
      }
    ]
  }

export {
  dynamizeImportDeclaration
  dynamizeImportDeclarationExpression
  prependStatementExpressionBlock
  processAssignmentDeclaration
  processDeclarationConditions
  processDeclarations
}
