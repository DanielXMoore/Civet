import {
  ASTLeaf
  ASTNode
  Binding
  Children
  Initializer
  StatementTuple
  TypeSuffix
  WSNode
} from ./types.civet

import {
  blockWithPrefix
  makeEmptyBlock
  replaceBlockExpression
} from ./block.civet

import {
  gatherRecursiveAll
} from ./traversal.civet

import {
  getPatternConditions
} from ./pattern-matching.civet

import {
  addParentPointers
  convertOptionalType
  makeNode
  makeRef
  updateParentPointers
} from ./util.civet

import {
  assignResults
  wrapIterationReturningResults
} from ./function.civet

import {
  gatherBindingCode
} from ./binding.civet

function processAssignmentDeclaration(decl: ASTLeaf, pattern: Binding["pattern"], suffix: TypeSuffix, ws: WSNode, assign: ASTLeaf, e: ASTNode)
  // Adjust position to space before assignment to make TypeScript remapping happier
  decl = {
    ...decl,
    $loc:
      pos: assign.$loc.pos - 1
      length: assign.$loc.length + 1
  }

  [splices, assignments] .= gatherBindingCode pattern

  splices = splices.map (s) => [", ", s]
  thisAssignments := assignments.map (a) => ["", a, ";"] as const

  initializer := [ws, assign, e]
  binding := makeNode {
    type: "Binding",
    pattern,
    initializer,
    splices,
    suffix,
    thisAssignments,
    children: [pattern, suffix, initializer]
  }

  children := [decl, binding]

  makeNode {
    type: "Declaration",
    pattern.names,
    decl,
    bindings: [binding],
    splices,
    thisAssignments,
    children,
  }

function processDeclarations(statements: StatementTuple[]): void
  // @ts-ignore
  gatherRecursiveAll statements, .type is "Declaration"
  // @ts-ignore
  .forEach (statement: DeclarationStatement) =>
    { bindings } := statement as DeclarationStatement
    bindings?.forEach (binding) =>
      suffix := binding.suffix
      if suffix and suffix.optional and suffix.t
        // Convert `let x?: T` to `let x: undefined | T`
        convertOptionalType suffix

      { initializer } := binding
      if initializer
        prependStatementExpressionBlock initializer, statement

function prependStatementExpressionBlock(initializer: Initializer, statement: {children: Children}): void
  exp .= initializer[2]

  // Handle nested statement expression
  let ws
  if Array.isArray(exp)
    ws = exp[0]
    exp = exp[1]!

  return unless exp.type is "StatementExpression"

  pre: ASTNode[] := []
  statementExp := exp.statement
  blockStatement: StatementTuple := ["", statementExp]

  if statementExp.type is "IterationExpression"
    // Async iterations remain inline wrapped with IIFE
    return if statementExp.async

    statement := statementExp.statement
    blockStatement[1] = statement

    wrapIterationReturningResults statement, children: blockStatement, ->
    initializer[2] = statement.resultsRef
  else
    ref := initializer[2] = makeRef()

    assignResults blockStatement, (resultNode) =>
      //@ts-ignore
      makeNode
        type: "AssignmentExpression",
        children: [ref, " = ", resultNode]

    refDec :=
      type: "Declaration",
      children: ["let ", ref, ";"],

    pre.unshift refDec
    //@ts-ignore
    pre.push ws if ws

  // insert statement before the declaration
  //@ts-ignore
  statement.children.unshift(pre, blockStatement, ";")

  updateParentPointers blockStatement, statement

function processDeclarationCondition(condition, rootCondition, parent): void
  return unless condition.type is "DeclarationCondition"
  ref := makeRef()

  { decl, bindings } := condition.declaration as DeclarationStatement
  // TODO: Add support for `let` and `const` declarations with multiple bindings in conditions
  binding := bindings[0]
  { pattern, suffix, initializer, splices, thisAssignments } := binding

  grandparent := condition.parent?.parent
  children :=
    // Check that the declaration is a plain assignment (no pattern-matching) and the immediate grandchild of an `if` or `while`
    // More complex conditions (triggered by pattern matching or `until`/`unless`) don't need double parens
    // @ts-ignore Just because pattern might not have a type at runtime doesn't mean it's unsafe
    if pattern.type is "Identifier" and (grandparent?.type is "IfStatement" or grandparent?.type is "WhileStatement")
      ["(", ref, initializer, ")"]
    else
      [ref, initializer]

  Object.assign condition, {
    type: "AssignmentExpression"
    children
    hoistDec:
      type: "Declaration"
      children: ["let ", ref, suffix]
      names: []
    pattern
    ref
  }

  // condition wasn't previously a child, so now needs parent pointers
  addParentPointers condition, parent

  Object.assign rootCondition,
    blockPrefix: [
      ["", [ decl, pattern, suffix, " = ", ref, ...splices ], ";"],
      ...thisAssignments
    ]

function processDeclarationConditions(node: ASTNode): void
  gatherRecursiveAll node, (n) =>
    n.type is "IfStatement" or n.type is "IterationStatement" or n.type is "SwitchStatement"
  .forEach processDeclarationConditionStatement

/**
 * Processes adding additional conditions when declarations are used as a condition in IfStatements, WhileStatements, and SwitchStatements.
 * Also does additional processing for IfStatements that used to be in the parser (inserting semi-colon on bare-block consequent with else).
 */
function processDeclarationConditionStatement(s: IfStatement | IterationStatement | SwitchStatement): void
  { condition } := s
  return unless condition?.expression
  { expression } .= condition
  // Support for negated conditions built by unless/until
  switch expression
    {type: 'UnaryExpression', children: ['!', {type: 'ParenthesizedExpression', expression: expression2}]}
      expression = expression2
  processDeclarationCondition expression, condition.expression, s

  { ref, pattern } := expression

  if pattern
    conditions .= []
    getPatternConditions(pattern, ref, conditions)

    conditions = conditions.filter (c) =>
      !(c.length is 3 and c[0] is "typeof " and c[1] is ref and c[2] is " === 'object'") and
      !(c.length is 2 and c[0] is ref and c[1] is " != null")

    if conditions.length
      condition.children.unshift "("
      conditions.forEach (c) ->
        condition.children.push " && ", c
      condition.children.push ")"

  switch s.type
    when "IfStatement"
      { else: e} := s
      block := blockWithPrefix(condition.expression.blockPrefix, s.then)
      s.then = block

      if block.bare and e and not block.semicolon
        block.children.push block.semicolon = ";"

      s.children.splice(2, 1, block)

      // Update parent pointers since declaration conditions have expanded
      updateParentPointers(block, s)

    when "IterationStatement"
      { children, block } := s
      newBlock := blockWithPrefix(condition.expression.blockPrefix, block)
      s.children = children.map (c) => c?.type is "BlockStatement" ? newBlock : c

      // Update parent pointers since declaration conditions have expanded
      updateParentPointers(newBlock, s)

    when "SwitchStatement"
      { blockPrefix, ref } := condition.expression
      return unless blockPrefix

      s.condition =
        type: "ParenthesizedExpression"
        children: ["(", ref, ")"]
        expression: ref
        parent: s
      s.children[1] = s.condition
      updateParentPointers s

      // wraps the entire switch statement
      block := blockWithPrefix [["", [{
        type: "Declaration",
        children: ["let ", ...condition.expression.children],
      }], ";"], ...blockPrefix], makeEmptyBlock()
      updateParentPointers block, s.parent

      replaceBlockExpression(s.parent as BlockStatement, s, block)
      block.expressions.push ["", s]
      s.parent = block

export {
  processAssignmentDeclaration
  processDeclarationConditions
  processDeclarations
}
