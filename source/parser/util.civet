import type {
  ASTLeaf,
  ASTNode,
  ASTNodeBase,
  TypeIdentifierNode,
  TypeNode
} from ./types.civet

import {
  gatherRecursiveWithinFunction
} from ./traversal.civet

function isEmptyBareBlock(node: ASTNode): boolean {
  if (node?.type !== "BlockStatement") return false
  const { bare, expressions } = node
  return bare &&
    (expressions.length is 0 ||
      (expressions.length is 1 &&
        expressions[0][1]?.type is "EmptyStatement"))
}

function isFunction(node: ASTNode): boolean {
  const { type } = node
  return type is "FunctionExpression" or type is "ArrowFunction" ||
    type is "MethodDefinition" or node.async
  // do blocks can be marked async to prevent automatic await
}

/**
 * Returns true if the StringLiteral node is a template literal.
 */
function isTemplateLiteral(node: ASTNode): boolean {
  let s = node
  while (s and s[0] and !s.token) s = s[0]
  return s.token?.startsWith?.('`')
}

function isVoidType(t?: TypeNode): boolean
  return t?.type is "LiteralType" and t.t.type is "VoidType"

function isPromiseVoidType(t?: TypeIdentifierNode): boolean
  return t?.type is "IdentifierType" and t.raw is "Promise" &&
    t.args?.types?.length is 1 and isVoidType(t.args.types[0])

function isGeneratorVoidType(t?: TypeIdentifierNode): boolean
  return t?.type is "IdentifierType" and
    (t.raw is "Iterator" or t.raw is "Generator") and
    t.args?.types?.length >= 2 and isVoidType(t.args.types[1])

function isAsyncGeneratorVoidType(t?: TypeIdentifierNode): boolean
  return t?.type is "IdentifierType" and
    (t.raw is "AsyncIterator" or t.raw is "AsyncGenerator") and
    t.args?.types?.length >= 2 and isVoidType(t.args.types[1])

function isWhitespaceOrEmpty(node): boolean {
  if (!node) return true
  if (node.type is "Ref") return false
  if (node.token) return node.token.match(/^\s*$/)
  if (node.children) node = node.children
  if (!node.length) return true
  if (typeof node is "string") return node.match(/^\s*$/)
  if (Array.isArray(node)) return node.every(isWhitespaceOrEmpty)
}

/**
 * Does this statement force exit from normal flow, implying that the
 * line after this one can never execute?
 */
function isExit(node: ASTNode): boolean
  node?.type is in [
    "ReturnStatement",
    "ThrowStatement",
    "BreakStatement",
    "ContinueStatement"
  ]

/**
 * Detects Comma, CommaDelimiter, and ParameterElementDelimiter
 * with an explicit comma, as should be at the top level of
 * a "Call" node's `args` array.
 * Returns the node whose `token` is ",", or else undefined.
 */
function isComma(node: ASTNode): (ASTLeaf & { token: "," }) | undefined
  if node?.token is ","
    node
  else if Array.isArray(node) and node.-1?.token is ","
    node.-1

/**
 * Trims the first single space from the spacing array or node's children if present
 * Inserts string `c` in the first position.
 * maintains $loc for source maps
 */
function insertTrimmingSpace(target: ASTNode, c: string): ASTNode
  return target unless target

  if Array.isArray target
    return c if target.length is 0

    return target.map (e, i) =>
      return insertTrimmingSpace(e, c) if i is 0
      return e

  if target.children
    return {
      ...target
      children: insertTrimmingSpace(target.children, c)
    }

  if target.token
    return {
      ...target
      token: target.token.replace(/^ ?/, c)
    }

  return target

// Returns leading space as a string, or undefined if none
function getTrimmingSpace(target: ASTNode) {
  if (!target) return
  if (Array.isArray(target)) return getTrimmingSpace(target[0])
  if (target.children) return getTrimmingSpace(target.children[0])
  if (target.token) return target.token.match(/^ ?/)[0]
}

function startsWith(target: ASTNodeBase, value: RegExp)
  if (!target) return
  if Array.isArray target
    let i = 0
    let l = target.length
    while i < l
      const t = target[i]
      break if t and (t.length or t.token or t.children)
      i++
    if i < l
      return startsWith target[i], value
  if (target.children) return startsWith target.children, value
  if (target.token) return value.test target.token
  if (typeof target is "string") return value.test target

/**
 * Does this expression have an `await` in it and thus needs to be `async`?
 */
function hasAwait(exp)
  gatherRecursiveWithinFunction(exp, ({ type }) => type is "Await").length > 0

function hasYield(exp)
  gatherRecursiveWithinFunction(exp, ({ type }) => type is "Yield").length > 0

export {
  getTrimmingSpace,
  hasAwait,
  hasYield,
  insertTrimmingSpace,
  isAsyncGeneratorVoidType,
  isComma,
  isEmptyBareBlock,
  isExit,
  isFunction,
  isGeneratorVoidType,
  isPromiseVoidType,
  isTemplateLiteral,
  isVoidType,
  isWhitespaceOrEmpty,
  startsWith
}
