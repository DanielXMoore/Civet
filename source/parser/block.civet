import type {
  ASTNode
  ASTNodeObject
  BlockStatement
  FunctionNode
  ObjectExpression
  ParenthesizedExpression
  StatementTuple
} from ./types.civet

import {
  isToken
  replaceNode
  startsWith
  updateParentPointers
} from ./util.civet

import {
  findAncestor
  findChildIndex
  gatherRecursiveAll
  gatherRecursive
} from ./traversal.civet

import {
  processReturn
} from ./function.civet

import {
  assert
} from ./util.civet

/**
 * Duplicate a block and attach statements prefixing the block.
 * Adds braces if the block is bare.
 *
 * @returns the duplicated block with prefix statements attached or the unchanged block.
 */
function blockWithPrefix(prefixStatements: StatementTuple[] | undefined, block: BlockStatement)
  if prefixStatements and prefixStatements.length
    const expressions = [...prefixStatements, ...block.expressions]
    // blockPrefix wasn't previously a child, so now needs parent pointers
    updateParentPointers prefixStatements, block

    block = {
      ...block,
      expressions,
      children: block.children is block.expressions ? expressions :
        block.children.map((c) => c is block.expressions ? expressions : c),
    }
    braceBlock block

    updateParentPointers block

  return block

/** Add braces if block lacks them */
function braceBlock(block: BlockStatement): void
  if block.bare and not block.root
    if block.children is block.expressions
      block.children = [block.expressions]
    block.children.unshift " {"
    block.children.push "}"
    { implicitlyReturned } := block
    block.bare = block.implicitlyReturned = false
    if implicitlyReturned
      processReturn block.parent as FunctionNode, true

/** Undo any bracing done by braceBlock */
function unbraceBlock(block: BlockStatement): void
  return if block.bare
  if block.children[0] is " {" and block.children.-1 is "}"
    block.children.shift()
    block.children.pop()
    block.bare = true

function duplicateBlock(block: BlockStatement): BlockStatement
  expressions := [...block.expressions]
  let children
  if block.children is block.expressions
    children = expressions
  else
    children = [...block.children]
    children.splice(children.indexOf(block.expressions), 1, expressions)
  return {
    ...block,
    expressions,
    children,
  }

/** Non-destructive braceBlock */
function bracedBlock(block: BlockStatement): BlockStatement
  block = duplicateBlock block
  braceBlock block
  block

function makeEmptyBlock(): BlockStatement
  const expressions = []
  return {
    type: "BlockStatement",
    expressions,
    children: ["{", expressions, "}"],
    bare: false,
    empty: true,
  }

/**
 * Replace `child` with `replacement` inside the `block`.
 * Assumes a `StatementTuple[]` for `block.expressions`.
 * Preserves the indentation and delimiter of the StatementTuple
 * containing `child`.
 */
function replaceBlockExpression(node: BlockStatement, child: ASTNodeObject, replacement: ASTNodeObject): void
  found .= false

  { expressions } := node

  for each statement of expressions
    [, s,] := statement

    if s is child
      statement[1] = replacement
      replacement.parent = node
      found = true
      break

  throw new Error("Could not find child to replace") unless found

/**
 * Gets the indentation node from a statement. Includes newline,
 * excludes comments, strips location info.
 */
function getIndent(statement: StatementTuple)
  let indent = statement?.[0]
  if Array.isArray(indent)
    indent = indent.flat(Infinity)

    return indent.filter((n) => n and !(n.type is "Comment")).map((n) => {
      if (typeof n is "string") return n
      if (n.token != null) return n.token
      return ""
    })
  return indent

function hoistRefDecs(statements: StatementTuple[]): void
  gatherRecursiveAll(statements, (s) => s.hoistDec)
    .forEach (node) =>
      { hoistDec } := node
      node.hoistDec = null

      { ancestor, child } := findAncestor node, (ancestor) =>
        ancestor.type is "BlockStatement" and (!ancestor.bare or ancestor.root)

      if ancestor
        insertHoistDec(ancestor, child, hoistDec)
      else
        throw new Error("Couldn't find block to hoist declaration into.")

      return

function insertHoistDec(block: BlockStatement, node: ASTNode | StatementTuple, dec: ASTNode): void
  statement: StatementTuple := [ "", dec, ";" ]
  insertBeforeInBlock block, node, statement

/**
 * Insert one or more statements into a block immediately before the given statement.
 * The target can be a StatementTuple or the expression inside that tuple.
 */
function insertBeforeInBlock(block: BlockStatement, node: ASTNode | StatementTuple, ...statements: StatementTuple[]): void
  index := findChildIndex block.expressions, node
  if index < 0
    throw new Error "insertBeforeInBlock couldn't find existing statement in block"

  insertBlockStatements block, index, ...statements

/**
 * Insert one or more statements into a block at the given index,
 * before the statement currently at that index.
 * Moves indentation of that statement to the first inserted statement.
 */
function insertBlockStatements(block: BlockStatement, index: number, ...statements: StatementTuple[]): void
  return unless statements#
  // NOTE: This is more accurately 'statements'
  { expressions } := block
  // Inserting just before this statement:
  before := expressions[index]
  // Move leading whitespace to before inserted statements
  if statements[0][0] and before?[0] // join whitespace
    statements[0][0] = [statements[0][0]] unless Array.isArray statements[0][0]
    before[0] = [before[0]] unless Array.isArray before[0]
    statements[0][0] = [...before[0], ...statements[0][0]]
  else
    statements[0][0] or= before?[0]
  before[0] = ""
  expressions.splice index, 0, ...statements
  updateParentPointers block

  // Add braces if block was previously just a bare statement
  braceBlock block

function processBlocks(statements: StatementTuple[]): void
  insertSemicolon statements

  for each block of gatherRecursive statements, .type is "BlockStatement"
    // Unwrap blocks that got wrapped in parentheses and possibly braces because
    // they contained what might have been an object literal,
    // but we haven't already wrapped them in `return` at this point,
    // so they're used as statements not expressions
    if block.unwrapObject and block.expressions# is 1 and
       block.expressions[0][1] is like {
         type: "ParenthesizedExpression"
         implicit: true
         expression: {
           type: "ObjectExpression"
         }
       }
      object := (block.expressions[0][1] as ParenthesizedExpression).expression as ObjectExpression
      // Don't process `...spread` or `name: value` or `method() ...`
      continue unless for every prop of object.properties
        prop.type is "Property" and prop.implicitName
      // Unwrap parentheses
      block.expressions[0][1] =
        (block.expressions[0][1] as ParenthesizedExpression).expression
      // Unwrap braces
      unbraceBlock block
      // Remove implicit names added to props
      for each prop, i of object.properties
        // Remove implicit square brackets around e.g. template strings
        if prop.name is like {type: "ComputedPropertyName", implicit: true}
          replaceNode prop.name, prop.name.expression, prop
        // Remove implicit commas between properties
        if prop.delim?.implicit
          if needsPrecedingSemicolon object.properties[i+1]
            prop.delim.token = ";"
          else
            replaceNode prop.delim, undefined, prop
            prop.delim = undefined
        // Remove implicit `name: ` added to properties
        colon := prop.children.indexOf ": "
        continue if colon < 0
        continue unless prop.children[colon-1] is prop.name
        prop.children.splice colon-1, 2

    processBlocks block.expressions

/**
* Automatic Semicolon Insertion (ASI):
* Avoid automatic continuation onto lines that start with
* certain characters by adding an explicit semicolon. See
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion
*/
function insertSemicolon(statements: StatementTuple[]): void
  l := statements#
  for each s, i of statements
    if i < l - 1
      if needsPrecedingSemicolon(statements[i + 1][1])
        delim := s[2]
        if !delim
          s[2] = ";"
        // If delim is an object assume it already has a semicolon
        // TODO: trailing comments might violate this assumption
        else if typeof delim is "string" and !delim.match(/;/)
          s[2] = `;${delim}`

function needsPrecedingSemicolon(exp: ASTNode)
  return false unless exp

  if Array.isArray exp // for chained conditionals
    // Recurse into first non-null element of array
    for each child of exp
      continue unless child?
      return needsPrecedingSemicolon child
    return false
  
  exp = exp.token if isToken exp
  if exp <? "string"
    return /^\s*[\(\[\`\+\-\/]/.test exp

  switch exp.type
    when "ParenthesizedExpression", "ArrayExpression", "ArrowFunction", "TemplateLiteral", "RegularExpressionLiteral", "RangeExpression", "ComputedPropertyName"
      true
    when "AssignmentExpression"
      startsWith(exp, /^(\[|\()/)
    when "Literal"
      exp.raw?.startsWith('-') or exp.raw?.startsWith('+')
    when "PipelineExpression", "UnwrappedExpression"
      // skip first child which is whitespace
      needsPrecedingSemicolon exp.children[1]
    else
      // descend into children for things like:
      // IterationExpression
      //   CallExpression
      //     ParenthesizedExpression
      if exp.children
        needsPrecedingSemicolon exp.children

/**
Is this node a top-level statement in its block? (i.e. not an expression)
If so, return the containing block, the index into expressions containing
the statement, and the child that is in that expression.
*/
function blockContainingStatement(exp: ASTNodeObject)
  child .= exp
  parent .= exp.parent
  // Skip over StatementExpression and UnwrappedExpression wrappers,
  // and (top-level) PipelineExpression wrapper
  while parent? and parent.type is like "StatementExpression", "PipelineExpression", "UnwrappedExpression"
    child = parent
    parent = parent.parent
  return unless parent?.type is "BlockStatement"
  index := findChildIndex parent.expressions, child
  assert.notEqual index, -1, "Could not find statement in parent block"
  return unless parent.expressions[index][1] is child
  {
    block: parent
    index
    child
  }

export {
  blockWithPrefix
  braceBlock
  bracedBlock
  duplicateBlock
  getIndent
  blockContainingStatement
  hoistRefDecs
  insertBeforeInBlock
  insertBlockStatements
  makeEmptyBlock
  processBlocks
  replaceBlockExpression
  unbraceBlock
}
