import {
  ASTNodeBase,
  BlockStatement,
  StatementTuple,
} from types.civet

import {
  addParentPointers,
  updateParentPointers,
} from util.civet

/**
 * Duplicate a block and attach statements prefixing the block.
 * Adds braces if the block is bare.
 *
 * @returns the duplicated block with prefix statements attached or the unchanged block.
 */
function blockWithPrefix(prefixStatements: StatementTuple[] | undefined, block: BlockStatement)
  if prefixStatements and prefixStatements.length
    const indent = getIndent(block.expressions[0])
    // Match prefix statements to block indent level
    if indent
      //@ts-ignore
      prefixStatements = prefixStatements.map (statement) =>
        [indent, ...statement.slice(1)]

    const expressions = [...prefixStatements, ...block.expressions]
    // blockPrefix wasn't previously a child, so now needs parent pointers
    addParentPointers prefixStatements, block

    block = {
      ...block,
      expressions,
      children: block.children is block.expressions ? expressions :
        block.children.map((c) => c is block.expressions ? expressions : c),
    }
    // Add braces if block lacked them
    if block.bare
      // Now copied, so mutation is OK
      block.children = [[" {"], ...block.children, "}"]
      block.bare = false

    updateParentPointers block

  return block

function braceBlock(block: BlockStatement)
  if block.bare
    block.children.unshift(" {")
    block.children.push("}")
    block.bare = false

function makeEmptyBlock(): BlockStatement
  const expressions = []
  return {
    type: "BlockStatement",
    expressions,
    children: ["{", expressions, "}"],
    bare: false,
    empty: true,
  }

/**
 * Replace `child` with `replacement` inside the `block`.
 * Assumes a `StatementTuple[]` for `block.expressions`
 */
function replaceBlockExpression(node: BlockStatement, child: ASTNodeBase, replacement: ASTNodeBase): void
  found .= false

  { expressions } := node

  for (let i = 0, l = expressions.length; i < l; i++)
    statement := expressions[i]
    [, s,] := statement

    if s is child
      statement[1] = replacement
      replacement.parent = node
      found = true
      break

  throw new Error("Could not find child to replace") unless found

/**
 * Gets the indentation node from a statement. Includes newline,
 * excludes comments, strips location info.
 */
function getIndent(statement: StatementTuple) {
  let indent = statement?.[0]
  if (Array.isArray(indent)) {
    indent = indent.flat(Infinity)

    return indent.filter((n) => n and !(n.type is "Comment")).map((n) => {
      if (typeof n is "string") return n
      if (n.token != null) return n.token
      return ""
    })
  }
  return indent
}

export {
  blockWithPrefix
  braceBlock
  getIndent
  makeEmptyBlock
  replaceBlockExpression
}
