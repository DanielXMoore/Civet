import type {
  ASTNodeBase
  ASTNode
  BinaryOp
} from ./types.civet

import {
  insertTrimmingSpace
  makeLeftHandSideExpression
} from ./util.civet

// Binary operator precedence, from low to high
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence#table
// NOTE: Added ^^ between || and &&, just like ^ is between | and &
precedenceOrder := [
  ['||', '??']
  ['^^']
  ['&&']
  ['|']
  ['^']
  ['&']
  // NOTE: Equality and inequality merged because of relational chaining
  ['==', '!=', '===', '!==',
   '<', '<=', '>', '>=', 'in', 'instanceof']
  // NOTE: Extra in-between level for default custom operators
  ['custom']
  ['<<', '>>', '>>>']
  ['+', '-']
  ['*', '/', '%']
  ['**']
]

precedenceMap := new Map<string | undefined, number>
for each ops, prec of precedenceOrder
  for each op of ops
    precedenceMap.set op, prec

precedenceStep := 1/64
precedenceRelational := precedenceMap.get("==")!
precedenceCustomDefault := precedenceMap.get("custom")!

function getPrecedence(op: BinaryOp): number
  // "&&" generated by expandChainedComparisons
  if typeof op === "string"
    precedenceMap.get(op) ??
    throw new Error `Unknown operator: ${op}`
  else if typeof op.prec === "number"
    op.prec
  else
    precedenceMap.get(op.prec ?? op.token) ??
    if op.relational then precedenceRelational else precedenceCustomDefault

function processBinaryOpExpression($0)
  return recurse expandChainedComparisons($0)

  // Expanded ops is [a, __, op1, __, b, __, op2, __, c, __, op3, __, d], etc.
  // NOTE: all operators of higher precedence than relational have been merged into the operand expressions
  function recurse(expandedOps)
    let i = 2
    while i < expandedOps.length
      let op: BinaryOp = expandedOps[i]
      // a not instanceof b -> !(a instanceof b)
      // Above is high precedence; below are relational so low precedence.
      // a in b -> indexOf.call(b, a) >= 0
      // a is in b -> b.includes(a)
      // a not in b -> indexOf.call(b, a) < 0
      // a is not in b -> !b.includes(a)
      if op.special
        let start = i - 2, end = i + 2
        prec := getPrecedence op

        // Grow argument range left or right, and return whether next
        // operator is at the same precedence level as op.
        function advanceLeft(allowEqual: boolean): boolean
          while start >= 4
            prevPrec := getPrecedence expandedOps[start - 2]
            unless prevPrec > prec or (allowEqual and prevPrec is prec)
              return prevPrec is prec
            start -= 4
          false
        function advanceRight(allowEqual: boolean): boolean
          while end + 4 < expandedOps.length
            nextPrec := getPrecedence expandedOps[end + 2]
            unless nextPrec > prec or (allowEqual and nextPrec is prec)
              return nextPrec is prec
            end += 4
          false

        let error
        switch op.assoc
          when "left", undefined
            advanceLeft true
            advanceRight false
          when "right"
            advanceLeft false
            advanceRight true
          when "nonassoc"
            if advanceLeft(false) or advanceRight(false)
              error =
                type: "Error"
                message: `nonassoc operator ${op.token} used at same precedence level without parenthesization`
          when "multiarg"
            if advanceLeft false
              error =
                type: "Error"
                message: `multiarg operator ${op.token} used at same precedence level as ${expandedOps[start - 2].token} to the left`
            advanceRight true
          else
            throw new Error `Unsupported associativity: ${op.assoc}`

        let a = start === i - 2
          ? expandedOps[start]
          : expandedOps.slice(start, i - 1)
        let wsOp = expandedOps[i - 1]
        //let op = expandedOps[i]
        let wsB = expandedOps[i + 1]
        let b = end === i + 2
          ? expandedOps[i + 2]
          : expandedOps.slice(i + 2, end + 1)
        if op.assoc is "multiarg"
          i .= 2
          while i < b.length
            if prec is getPrecedence b[i]
              unless b[i].token is op.token
                error ?=
                  type: "Error"
                  message: `multiarg operator ${op.token} used at same precedence level as ${b[i].token} to the right`
              b[i] = ","
            i += 4
        else
          b = recurse b

        // typeof shorthand: x instanceof "String" -> typeof x === "string"
        if op.token === "instanceof" and b.type === "Literal" and
           b.children?.[0]?.type === "StringLiteral"
          a = ["typeof ", makeLeftHandSideExpression(a)]
          if op.negated
            op = { ...op, token: "!==", negated: false }
          else
            op = { ...op, token: "===" }

        if op.asConst
          a = makeAsConst a
          b = makeAsConst b

        let children
        if op.call
          wsOp = insertTrimmingSpace(wsOp, "")

          if op.reversed
            wsB = insertTrimmingSpace(wsB, "")
            children = [wsOp, op.call, "(", wsB, b, ", ", a, ")", op.suffix]
          else
            children = [wsOp, op.call, "(", a, ",", wsB, b, ")", op.suffix]
        else if op.method
          wsOp = insertTrimmingSpace(wsOp, "")
          wsB = insertTrimmingSpace(wsB, "")
          if op.reversed
            if (end !== i + 2) b = makeLeftHandSideExpression b
            b = dotNumericLiteral b
            children = [wsB, b, wsOp, ".", op.method, "(", a, ")"]
          else
            if start !== i - 2 or a.type === "NumericLiteral"
              a = makeLeftHandSideExpression a
            a = dotNumericLiteral a
            children = [a, wsOp, ".", op.method, "(", wsB, b, ")"]
        else if op.token
          children = [a, wsOp, op, wsB, b]
          if (op.negated) children = ["(", ...children, ")"]
        else
          throw new Error("Unknown operator: " + JSON.stringify(op))
        if (op.negated) children.unshift("!")
        children.push error if error?

        expandedOps.splice(start, end - start + 1, {
          children
        })
        i = start + 2
      else
        i += 4
    expandedOps

/** Add dot after numeric literal if needed for method calls. */
function dotNumericLiteral(literal: ASTNode)
  if literal?.type is "Literal" and
     /^[+-]?(?:0|[1-9](?:_[0-9]|[0-9])*)$/.test literal.raw
    literal.children.push "."
    literal.raw += "."
  literal

const asConst =
  ts: true,
  children: [" as const"]

function makeAsConst(node: ASTNode)
  // TS allows "as const" assertions for string, number, boolean, array,
  // and object literals (and enum members), but not for null/undefined.
  if Array.isArray(node) and node.length is 1
    // Unwrap length-1 arrays created by expandChainedComparisons
    node = node[0]
  if (node.type is "Literal" and node.raw is not "null") or
      node.type is "ArrayExpression" or node.type is "ObjectExpression"
    { ...node, children: [...node.children, asConst] }
  else
    node

function isExistence(exp: ASTNodeBase)
  if exp.type is "ParenthesizedExpression" and exp.implicit
    exp = exp.expression
  if exp.type is "Existence"
    return exp

function isRelationalOp(op: BinaryOp)
  op.relational or getPrecedence(op) is precedenceRelational

/**
* binops is an array of [__, op, __, exp] tuples
* first is an expression
*/
function expandChainedComparisons([first, binops]: [unknown, [unknown, BinaryOp, unknown, unknown][]])
  // TODO: add refs to ensure middle expressions are evaluated only once

  results := []

  i .= 0
  l := binops.length

  start .= 0
  // indexes of chainable ops
  chains .= []
  let op

  while i < l
    ([, op] = binops[i])

    // NOTE: Treat Coffee `in` and `not in` ops as relational.
    if isRelationalOp op
      chains.push i
    else if getPrecedence(op) < precedenceRelational
      // end of the chain
      processChains op
      first = undefined

    i++

  processChains op if op?

  return results

  function processChains(op: BinaryOp): void
    if first and isRelationalOp op
      first = expandExistence first

    if chains.length > 1
      chains.forEach (index, k) =>
        if (k > 0) {
          // NOTE: Inserting ws tokens to keep even operator spacing in the resulting array
          results.push(" ", "&&", " ")
        }

        binop := binops[index]
        [ , , , exp] .= binop
        exp = binop[3] = expandExistence(exp)

        let endIndex
        if (k < chains.length - 1) {
          endIndex = chains[k + 1]
        } else {
          endIndex = i + 1
        }

        results.push(first, ...binops.slice(start, endIndex).flat())
        first = [exp].concat(binops.slice(index + 1, endIndex))
        start = endIndex
    else
      // Advance start if there was no chain
      results.push first if first
      results.push ...binops[start...i + 1].flat()
      start = i + 1

    chains.length = 0

  function expandExistence(exp)
    // Expand existence operator like x?
    const existence = isExistence(exp)
    if existence
      results.push(existence, " ", "&&", " ")
      return existence.expression

    return exp
  ;

export {
  getPrecedence
  precedenceStep
  processBinaryOpExpression
}
