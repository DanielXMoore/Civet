import type {
  ASTNode
  BinaryOp
  ChainOp
  Existence
} from ./types.civet

import {
  assert
  makeLeftHandSideExpression
  replaceNode
  trimFirstSpace
} from ./util.civet

import {
  processPatternTest
} from ./pattern-matching.civet

import {
  maybeRefAssignment
} from ./ref.civet

// Binary operator precedence, from low to high
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence#table
// NOTE: Added ^^ between || and &&, just like ^ is between | and &
precedenceOrder := [
  ['||', '??']
  ['^^']
  ['&&']
  ['|']
  ['^']
  ['&']
  // NOTE: Extra in-between level for &&ing together relational chains
  ['chain']
  // NOTE: Equality and inequality merged because of relational chaining
  ['==', '!=', '===', '!==',
   '<', '<=', '>', '>=', 'in', 'instanceof']
  // NOTE: Extra in-between level for default custom operators
  ['custom']
  ['<<', '>>', '>>>']
  ['+', '-']
  ['*', '/', '%']
  ['**']
]

precedenceMap := new Map<string | undefined, number>
for each ops, prec of precedenceOrder
  for each op of ops
    precedenceMap.set op, prec

precedenceStep := 1/64
precedenceAnd := precedenceMap.get("&&")!
precedenceRelational := precedenceMap.get("==")!
precedenceCustomDefault := precedenceMap.get("custom")!

function getPrecedence(op: BinaryOp): number
  // "&&" generated by expandChainedComparisons
  if op <? "string"
    precedenceMap.get(op) ??
    throw new Error `Unknown operator: ${op}`
  else if op.type is "PatternTest"
    precedenceRelational
  else if op.prec <? "number"
    op.prec
  else
    precedenceMap.get(op.prec ?? op.token) ??
    if op.relational then precedenceRelational else precedenceCustomDefault

function processBinaryOpExpression($0)
  return recurse expandChainedComparisons($0)

  // Expanded ops is [a, __, op1, __, b, __, op2, __, c, __, op3, __, d], etc.
  // NOTE: all operators of higher precedence than relational have been merged into the operand expressions
  function recurse(expandedOps)
    let i = 2
    while i < expandedOps.length
      let op: BinaryOp = expandedOps[i]
      // a not instanceof b -> !(a instanceof b)
      // Above is high precedence; below are relational so low precedence.
      // a in b -> indexOf.call(b, a) >= 0
      // a is in b -> b.includes(a)
      // a not in b -> indexOf.call(b, a) < 0
      // a is not in b -> !b.includes(a)
      if op.special
        let start = i - 2, end = i + 2
        prec := getPrecedence op

        // Grow argument range left or right, and return whether next
        // operator is at the same precedence level as op.
        function advanceLeft(allowEqual: boolean): boolean
          while start >= 4
            prevPrec := getPrecedence expandedOps[start - 2]
            unless prevPrec > prec or (allowEqual and prevPrec is prec)
              return prevPrec is prec
            start -= 4
          false
        function advanceRight(allowEqual: boolean): boolean
          while end + 4 < expandedOps.length
            nextPrec := getPrecedence expandedOps[end + 2]
            unless nextPrec > prec or (allowEqual and nextPrec is prec)
              return nextPrec is prec
            end += 4
          false

        let error
        switch op.assoc
          when "left", undefined
            advanceLeft true
            advanceRight false
          when "right"
            advanceLeft false
            advanceRight true
          when "non"
            if advanceLeft(false) or advanceRight(false)
              error =
                type: "Error"
                message: `non-associative operator ${op.token} used at same precedence level without parenthesization`
          when "arguments"
            if advanceLeft false
              error =
                type: "Error"
                message: `arguments operator ${op.token} used at same precedence level as ${expandedOps[start - 2].token} to the left`
            advanceRight true
          else
            throw new Error `Unsupported associativity: ${op.assoc}`

        let a = start === i - 2
          ? expandedOps[start]
          : expandedOps.slice(start, i - 1)
        let wsOp = expandedOps[i - 1]
        //let op = expandedOps[i]
        let wsB = expandedOps[i + 1]
        let b = end === i + 2
          ? expandedOps[i + 2]
          : expandedOps.slice(i + 2, end + 1)
        if op.assoc is "arguments"
          i .= 2
          while i < b.length
            if prec is getPrecedence b[i]
              unless b[i].token is op.token
                error ?=
                  type: "Error"
                  message: `arguments operator ${op.token} used at same precedence level as ${b[i].token} to the right`
              b[i] = ","
            i += 4
        else
          b = recurse b

        if op.token is "instanceof"
          // Ensure space around `instanceof`
          if wsOp.length is 0
            wsOp = " "
          if wsB.length is 0
            wsB = " "

          // typeof shorthand: x instanceof "string" -> typeof x === "string"
          if b is like {
            type: "Literal"
            children: [ {type: "StringLiteral"}, ... ]
          }
            a = ["typeof ", makeLeftHandSideExpression(a)]
            if op.negated
              op = { ...op, token: "!==", negated: false }
            else
              op = { ...op, token: "===" }

        if op.asConst
          a = makeAsConst a
          b = makeAsConst b

        let children, type: string?
        if op.type is "PatternTest"
          children = [processPatternTest a, b]
        else if op.type is "ChainOp"
          children = [a, wsOp, "&&", wsB, b]
          // Parenthesize chain if it is surrounded by operator with precedence
          // in between && (where this will end up being) and relational
          // (which the chain should simulate).
          if (start-2 >= 0 and
              getPrecedence(expandedOps[start-2]) >= precedenceAnd and
              expandedOps[start-2].token is not '&&') or
             (end+2 < expandedOps.length and
              getPrecedence(expandedOps[end+2]) >= precedenceAnd and
              expandedOps[end+2].token is not '&&')
            children = ["(", ...children, ")"]
        else if op.call
          wsOp = trimFirstSpace wsOp
          if op.reversed
            wsB = trimFirstSpace wsB
            children = [wsOp, op.call, "(", wsB, b, ", ", a, ")", op.suffix]
          else
            children = [wsOp, op.call, "(", a, ",", wsB, b, ")", op.suffix]
          type = "CallExpression"
        else if op.method
          wsOp = trimFirstSpace wsOp
          wsB = trimFirstSpace wsB
          if op.reversed
            b = makeLeftHandSideExpression b unless b.type is "CallExpression"
            b = dotNumericLiteral b
            children = [wsB, b, wsOp, ".", op.method, "(", a, ")"]
          else
            a = makeLeftHandSideExpression a unless a.type is "CallExpression"
            a = dotNumericLiteral a
            children = [a, wsOp, ".", op.method, "(", wsB, b, ")"]
          type = "CallExpression"
        else if op.token
          children = [a, wsOp, op, wsB, b]
          if (op.negated) children = ["(", ...children, ")"]
        else
          throw new Error("Unknown operator: " + JSON.stringify(op))
        if (op.negated) children.unshift("!")
        children.push error if error?

        expandedOps.splice(start, end - start + 1, {
          type
          children
        })
        i = start + 2
      else
        i += 4
    expandedOps

/** Add dot after numeric literal if needed for method calls. */
function dotNumericLiteral(literal: ASTNode)
  if literal?.type is "Literal" and
     /^[+-]?(?:0|[1-9](?:_[0-9]|[0-9])*)$/.test literal.raw
    literal.children.push "."
    literal.raw += "."
  literal

const asConst =
  ts: true,
  children: [" as const"]

function makeAsConst(node: ASTNode)
  // TS allows "as const" assertions for string, number, boolean, array,
  // and object literals (and enum members), but not for null/undefined.
  if Array.isArray(node) and node.length is 1
    // Unwrap length-1 arrays created by expandChainedComparisons
    node = node[0]
  if (node.type is "Literal" and node.raw is not "null") or
      node.type is "ArrayExpression" or node.type is "ObjectExpression"
    { ...node, children: [...node.children, asConst] }
  else
    node

function isExistence(exp: ASTNode): Existence?
  if exp?.type is "ParenthesizedExpression" and exp.implicit
    exp = exp.expression
  if exp?.type is "Existence"
    return exp

function isRelationalOp(op: BinaryOp)
  op.relational or getPrecedence(op) is precedenceRelational

// chainOp is a special BinaryOp that is implemented by JavaScript's &&,
// but has precedence 'chain' just below relational operators, so in some
// situations needs to be wrapped in parentheses to simulate that precedence.
chainOp: ChainOp :=
  type: 'ChainOp'
  special: true
  prec: precedenceMap.get('chain')!
  assoc: 'right'

/**
* first is an expression
* binops is an array of [__, op, __, exp] tuples
*/
function expandChainedComparisons([first, binops]: [ASTNode, [ASTNode, BinaryOp, ASTNode, ASTNode][]])
  return [first] unless binops.length

  results: ASTNode[] := []

  start .= 0
  // indexes of chainable ops
  chains: number[] := []

  var i = 0
  for each var [, op], var i of binops
    // NOTE: Treat Coffee `in` and `not in` ops as relational.
    if isRelationalOp op
      chains.push i
    else if getPrecedence(op) < precedenceRelational
      // end of the chain
      processChains()
      first = results.pop()

  processChains()

  return results

  function processChains: void
    if chains# > 0
      // At least one relational op, so expand any existence operators `x?`
      first = expandExistence first
      for each index, k of chains
        if k > 0
          // NOTE: Inserting ws tokens to keep even operator spacing in the resulting array
          results.push " ", chainOp, " "

        binop := binops[index]
        exp := binop[3] = expandExistence binop[3]

        results.push first
        // If there's more to the chain, ref the right-hand side of this
        // relation (which is the left-hand side of the next op)
        if k+1 < chains#
          endIndex := chains[k + 1]
          rhs :=
            index + 1 < endIndex ? [exp] ++ binops[index + 1...endIndex] : exp
          { ref, refAssignment } := maybeRefAssignment rhs
          // TODO: do we need to recurse on the binary ops here?
          binops[index][3] = makeLeftHandSideExpression refAssignment ?? rhs
          results.push ...binops[start...index + 1].flat()
          first = ref
          start = endIndex
        else
          results.push ...binops[start...i + 1].flat()
    else
      // Advance start if there was no chain
      results.push first
      results.push ...binops[start...i + 1].flat()
    start = i + 1

    chains.length = 0

  function expandExistence(exp: ASTNode): ASTNode
    // Expand existence operator like x?
    if existence := isExistence(exp)
      { ref, refAssignment } := maybeRefAssignment existence.expression
      if refAssignment?
        replaceNode
          existence.expression
          makeLeftHandSideExpression refAssignment
          existence
      results.push existence, " ", chainOp, " "
      ref
    else
      exp

export {
  getPrecedence
  precedenceStep
  processBinaryOpExpression
}
