import {
  ASTNode
} from ./types.civet

import {
  insertTrimmingSpace
  makeLeftHandSideExpression
} from ./util.civet

function processBinaryOpExpression($0)
  expandedOps := expandChainedComparisons($0)

  // Expanded ops is [a, __, op1, __, b, __, op2, __, c, __, op3, __, d], etc.
  // NOTE: all operators of higher precedence than relational have been merged into the operand expressions
  let i = 2
  while (i < expandedOps.length) {
    let op = expandedOps[i]
    // a not instanceof b -> !(a instanceof b)
    // Above is high precedence; below are relational so low precedence.
    // a in b -> indexOf.call(b, a) >= 0
    // a is in b -> b.includes(a)
    // a not in b -> indexOf.call(b, a) < 0
    // a is not in b -> !b.includes(a)
    if (op.special) {
      let start = i - 2, end = i + 2
      if (isRelationalOp(op)) {
        while (start >= 4 and !isLowerThanRelationalOp(expandedOps[start - 2])) {
          start -= 4
        }
        while (end + 4 < expandedOps.length and !isLowerThanRelationalOp(expandedOps[end + 2])) {
          end += 4
        }
      }

      let a = start is i - 2
        ? expandedOps[start]
        : expandedOps.slice(start, i - 1)
      let wsOp = expandedOps[i - 1]
      //let op = expandedOps[i]
      let wsB = expandedOps[i + 1]
      let b = end is i + 2
        ? expandedOps[i + 2]
        : expandedOps.slice(i + 2, end + 1)

      // typeof shorthand: x instanceof "String" -> typeof x is "string"
      if (op.token is "instanceof" and b.type is "Literal" &&
        b.children?.[0]?.type is "StringLiteral") {
        a = ["typeof ", makeLeftHandSideExpression(a)]
        if (op.negated) {
          op = { ...op, token: "!==", negated: false }
        } else {
          op = { ...op, token: "===" }
        }
      }

      if (op.asConst) {
        a = makeAsConst(a)
        b = makeAsConst(b)
      }

      let children
      if (op.call) {
        wsOp = insertTrimmingSpace(wsOp, "")

        if (op.reversed) {
          wsB = insertTrimmingSpace(wsB, "")
          children = [wsOp, op.call, "(", wsB, b, ", ", a, ")", op.suffix]
        } else {
          children = [wsOp, op.call, "(", a, ",", wsB, b, ")", op.suffix]
        }
      } else if (op.method) {
        wsOp = insertTrimmingSpace(wsOp, "")
        wsB = insertTrimmingSpace(wsB, "")
        if op.reversed
          if (end !== i + 2) b = makeLeftHandSideExpression b
          b = dotNumericLiteral b
          children = [wsB, b, wsOp, ".", op.method, "(", a, ")"]
        else
          if start !== i - 2 or a.type is "NumericLiteral"
            a = makeLeftHandSideExpression a
          a = dotNumericLiteral a
          children = [a, wsOp, ".", op.method, "(", wsB, b, ")"]
      } else if (op.token) {
        children = [a, wsOp, op, wsB, b]
        if (op.negated) children = ["(", ...children, ")"]
      } else {
        throw new Error("Unknown operator: " + JSON.stringify(op))
      }
      if (op.negated) children.unshift("!")

      expandedOps.splice(start, end - start + 1, {
        children
      })
    } else {
      i += 4
    }
  }

  return expandedOps

/** Add dot after numeric literal if needed for method calls. */
function dotNumericLiteral(literal: ASTNode)
  if literal?.type is "Literal" and
     /^[+-]?(?:0|[1-9](?:_[0-9]|[0-9])*)$/.test literal.raw
    literal.children.push "."
    literal.raw += "."
  literal

const asConst =
  ts: true,
  children: [" as const"]

function makeAsConst(node)
  // TS allows "as const" assertions for string, number, boolean, array,
  // and object literals (and enum members), but not for null/undefined.
  if Array.isArray(node) and node.length is 1
    // Unwrap length-1 arrays created by expandChainedComparisons
    node = node[0]
  if (node.type is "Literal" and node.raw is not "null") or
      node.type is "ArrayExpression" or node.type is "ObjectExpression"
    { ...node, children: [...node.children, asConst] }
  else
    node

function isExistence(exp) {
  if (exp.type is "ParenthesizedExpression" and exp.implicit) {
    exp = exp.expression
  }
  if (exp.type is "Existence") {
    return exp
  }
}

// all relational operators could be chained in theory, including in and instanceof
relationalOps := ["==", "===", "!=", "!==", "<", "<=", ">", ">=", "in"]

function isRelationalOp(op)
  relationalOps.includes(op.token) or op.relational

// lower precedence than comparisons, but ignoring assignments and comma
// which are handled separately
lowerThanRelationalOps := ["&", "^", "|", "&&", "||", "??"]

function isLowerThanRelationalOp(op)
  // "&&" without wrapper is generated by expandedChainedComparisons
  op is "&&" or lowerThanRelationalOps.includes(op.token) or isRelationalOp(op)

/**
* binops is an array of [__, op, __, exp] tuples
* first is an expression
*/
function expandChainedComparisons([first, binops]: [unknown, [unknown, ASTLeaf, unknown, unknown][]])
  // TODO: add refs to ensure middle expressions are evaluated only once

  // short circuit/bitwise ops have lower precedence than comparison ops
  // so we only need to look for chains in the sections between them
  lowerPrecedenceOps := ["??", "&&", "||", "&", "|", "^"]

  // shift/arithmetic ops have higher precedence, they will bind to expressions inside the chains
  // const higherPrecedenceOps = ["<<", ">>", ">>>", "+", "-", "*", "**", "/", "%"]

  results := []

  i .= 0
  l := binops.length

  start .= 0
  // indexes of chainable ops
  chains .= []
  let op

  while i < l
    ([, op] = binops[i])

    // NOTE: Treat Coffee `in` and `not in` ops as relational.
    if isRelationalOp op
      chains.push i
    else if lowerPrecedenceOps.includes op.token
      // end of the chain
      processChains op
      first = undefined

    i++

  processChains op

  return results

  function processChains(op): void
    if first and isRelationalOp op
      first = expandExistence first

    if chains.length > 1
      chains.forEach (index, k) =>
        if (k > 0) {
          // NOTE: Inserting ws tokens to keep even operator spacing in the resulting array
          results.push(" ", "&&", " ")
        }

        binop := binops[index]
        [ , , , exp] .= binop
        exp = binop[3] = expandExistence(exp)

        let endIndex
        if (k < chains.length - 1) {
          endIndex = chains[k + 1]
        } else {
          endIndex = i + 1
        }

        results.push(first, ...binops.slice(start, endIndex).flat())
        first = [exp].concat(binops.slice(index + 1, endIndex))
        start = endIndex
    else
      // Advance start if there was no chain
      results.push first if first
      results.push ...binops[start...i + 1].flat()
      start = i + 1

    chains.length = 0

  function expandExistence(exp)
    // Expand existence operator like x?
    const existence = isExistence(exp)
    if existence
      results.push(existence, " ", "&&", " ")
      return existence.expression

    return exp
  ;

export {
  processBinaryOpExpression
}
