# Civet: A successor to CoffeeScript and alternative to TypeScript
# much more 1-to-1 with es6

# ECMA Reference
# https://262.ecma-international.org/13.0/

```
import {
  addPostfixStatement,
  adjustBindingElements,
  adjustIndexAccess,
  attachPostfixStatementAsExpression,
  append,
  blockWithPrefix,
  convertNamedImportsToObject,
  convertObjectToJSXAttributes,
  convertWithClause,
  dedentBlockString,
  dedentBlockSubstitutions,
  deepCopy,
  dynamizeImportDeclaration,
  dynamizeImportDeclarationExpression,
  expressionizeTypeIf,
  forRange,
  gatherBindingCode,
  gatherBindingPatternTypeSuffix,
  gatherRecursive,
  getHelperRef,
  getIndentLevel,
  getPrecedence,
  getTrimmingSpace,
  hasAwait,
  hasYield,
  insertTrimmingSpace,
  isComma,
  isWhitespaceOrEmpty,
  lastAccessInCallExpression,
  literalValue,
  makeAmpersandFunction,
  makeEmptyBlock,
  makeExpressionStatement,
  makeGetterMethod,
  makeLeftHandSideExpression,
  makeRef,
  maybeRef,
  maybeRefAssignment,
  modifyString,
  negateCondition,
  prepend,
  processAssignmentDeclaration,
  processBinaryOpExpression,
  processCallMemberExpression,
  processCoffeeDo,
  processCoffeeInterpolation,
  processForInOf,
  processProgram,
  processProgramAsync,
  processRangeExpression,
  processTryBlock,
  processUnaryExpression,
  processUnaryNestedExpression,
  quoteString,
  reorderBindingRestProperty,
  replaceNodes,
  skipImplicitArguments,
  stripTrailingImplicitComma,
  trimFirstSpace,
  typeOfJSX,
  wrapTypeInPromise,
} from "./parser/lib.civet"

/**
 * Globals
 */
let filename;             // filename currently being parsed
let initialConfig;        // input for parser config
let config;               // current parser config after directives
let sync;                 // synchronous mode: as much as possible without await
export const state = {};  // parser state

export const getState = () => state;
export const getConfig = () => config;
export const getInitialConfig = () => initialConfig;
export const getFilename = () => filename;
export const getSync = () => sync;

Object.defineProperties(state, {
  currentIndent: {
    get() {
      const {indentLevels: l} = state
      return l[l.length-1]
    },
  },
  classImplicitCallForbidden: {
    get() {
      const {forbidClassImplicitCall: s} = state
      return s[s.length-1]
    },
  },
  indentedApplicationForbidden: {
    get() {
      const {forbidIndentedApplication: s} = state
      return s[s.length-1]
    },
  },
  bracedApplicationForbidden: {
    get() {
      const {forbidBracedApplication: s} = state
      return s[s.length-1]
    },
  },
  trailingMemberPropertyForbidden: {
    get() {
      const {forbidTrailingMemberProperty: s} = state
      return s[s.length-1]
    },
  },
  nestedBinaryOpForbidden: {
    get() {
      const {forbidNestedBinaryOp: s} = state
      return s[s.length-1]
    },
  },
  newlineBinaryOpForbidden: {
    get() {
      const {forbidNewlineBinaryOp: s} = state
      return s[s.length-1]
    },
  },
  pipelineForbidden: {
    get() {
      const {forbidPipeline: s} = state
      return s[s.length-1]
    },
  },
  currentJSXTag: {
    get() {
      const {JSXTagStack: s} = state
      return s[s.length-1]
    },
  },
})

export function getStateKey() {
  const stateInt =
    ((state.currentIndent.level % 256) << 8) |
    (state.classImplicitCallForbidden << 7) |
    (state.indentedApplicationForbidden << 6) |
    (state.bracedApplicationForbidden << 5) |
    (state.trailingMemberPropertyForbidden << 4) |
    (state.nestedBinaryOpForbidden << 3) |
    (state.newlineBinaryOpForbidden << 2) |
    (state.pipelineForbidden << 1) |
    // This is slightly different than the rest of the state,
    // since it is affected by the directive prologue and may be hit
    // by the EOL rule early in the parse. Later if we wanted to
    // allow block scoping of the compat directives we would need to
    // add them all here.
    (config.coffeeComment << 0)

  return [stateInt, state.currentJSXTag]
}

export function parseProgram(input, options) {
  filename = options?.filename
  initialConfig = options?.parseOptions
  sync = options?.sync
  const root = parse(input, options)
  if (sync) {
    filename = initialConfig = sync = null
    return root
  } else {
    return processProgramAsync(root)
    .then(() => {
      filename = initialConfig = sync = null
      return root
    })
  }
}

const wellKnownSymbols = [
  "asyncIterator",
  "hasInstance",
  "isConcatSpreadable",
  "iterator",
  "match",
  "matchAll",
  "replace",
  "search",
  "species",
  "split",
  "toPrimitive",
  "toStringTag",
  "unscopables",
]

export { ParseError }

```

Program
  # EOS allows for initial comment blocks and newlines,
  # when Init didn't already consume them.
  Reset:reset Init:init EOS?:ws1 TopLevelStatements:statements __:ws2 ->
    // NOTE: Wrap top level statements in a bare block so they have a parent
    const program = {
      type: "BlockStatement",
      expressions: statements,
      children: [reset, init, ws1, statements, ws2],
      bare: true,
      root: true,
      topLevelAwait: hasAwait(statements),
    }
    processProgram(program)
    return program

TopLevelStatements
  # If first line is strictly indented, require all lines to be equally so
  # Use TrackIndented instead of PushIndent to avoid requiring leading EOS
  TrackIndented:indent TopLevelSingleLineStatements:first NestedTopLevelStatements*:rest PopIndent ->
    return [
      [indent, ...first[0]],
      ...first.slice(1).map(s => ["", ...s]),
      ...rest.flat(),
    ]
  # Unindented case: rely on initial indentLevel of 0
  TopLevelSingleLineStatements:first NestedTopLevelStatements*:rest ->
    return [
      ...first.map(s => ["", ...s]),
      ...rest.flat(),
    ]
  # Empty case
  "" -> []

NestedTopLevelStatements
  Nested:nested TopLevelSingleLineStatements:statements ->
    return [
      [nested, ...statements[0]],
      ...statements.slice(1).map(s => ["", ...s]),
    ]

# Multiple top-level semicolon-separated statements
TopLevelSingleLineStatements
  TopLevelStatement+

TopLevelStatement
  # NOTE: !EOS forces semicolon after all but last statement, forbids leading __
  # NOTE: _? allows for leading inline comments
  !EOS _?:ws ModuleItem:statement StatementDelimiter:delimiter ->
    statement = prepend(ws, statement)
    return [statement, delimiter]

# Expressions with If and Switch, but no comma operator
Expression
  AssignmentExpression

SingleLineExpression
  SingleLineAssignmentExpression

NonPipelineExpression
  NonPipelineAssignmentExpression

NestedExpressionizedStatement
  &EOS PushIndent ( Nested ExpressionizedStatementWithTrailingCallExpressions )?:expression PopIndent AllowedTrailingCallExpressions?:trailing ->
    if (!expression) return $skip
    if (!trailing) return expression
    return {
      type: "CallExpression",
      children: [ expression, ...trailing.flat() ]
    }

ExpressionizedStatementWithTrailingCallExpressions
  ExpressionizedStatement AllowedTrailingCallExpressions? ->
    if (!$2) return $1
    // Some expressionized statements, such as `if`s,
    // need to be wrapped in parens
    return {
      type: "CallExpression",
      children: [
        makeLeftHandSideExpression($1),
        $2,
      ],
    }

ExpressionizedStatement
  # perf: assertion to exit early
  /(?=async|debugger|if|unless|comptime|do|for|loop|until|while|switch|throw|try)/ StatementExpression:statement ->
    return {
      type: "StatementExpression",
      statement,
      children: [statement],
    }

StatementExpression
  DebuggerStatement
  IfStatement ->
    // Forbid expressionizing `if condition` with no then or else clause,
    // because it might be a postfix `if`
    if (!$1.else && $1.then.implicit) return $skip
    return $1
  IterationExpression
  SwitchStatement
  ThrowStatement
  TryStatement

# https://262.ecma-international.org/#prod-Expression
CommaExpression
  # CommaOperator
  # https://262.ecma-international.org/#sec-comma-operator
  # NOTE: Eliminated left recursion
  AssignmentExpression ( CommaDelimiter AssignmentExpression )* ->
    if($2.length == 0) return $1
    return $0

# https://262.ecma-international.org/#prod-Arguments
Arguments
  ExplicitArguments

  # Space / indentation based function application
  # Function application:
  # a b => a(b)
  # a b, c, d => a(b, c, d)
  # x y z => x(y(z))
  ForbidTrailingMemberProperty ImplicitArguments?:args RestoreTrailingMemberProperty ->
    if (args) return args
    return $skip

ImplicitArguments
  ApplicationStart InsertOpenParen:open Trimmed_?:ws ForbidNestedBinaryOp ForbidPipeline ArgumentList?:args RestorePipeline RestoreNestedBinaryOp InsertCloseParen:close ->
    if (!args) return $skip
    // Don't treat as call if this is a postfix for/while/until/if/unless
    if (skipImplicitArguments(args)) return $skip

    return {
      type: "Call",
      args,
      children: [open, ws, args, close]
    }

ExplicitArguments
  OpenParen:open AllowAll ( ArgumentList ( __ Comma )? )?:args __:ws RestoreAll CloseParen:close ->
    if (args) {
      if (args[1]) { // trailing comma
        args = [ ...args[0], args[1] ]
      } else { // no trailing comma
        args = args[0]
      }
    } else { // no arguments
      args = []
    }
    return {
      type: "Call",
      args,
      children: [open, args, ws, close],
    }

# Start of function application, inserts an open parenthesis, maintains spacing and comments when possible
ApplicationStart
  # Indented argument cannot start with a binary operator or a
  # trailing member expression
  IndentedApplicationAllowed &( IndentedFurther !IdentifierBinaryOp !ReservedBinary ) !IndentedTrailingMemberExpression
  !EOS &( _ ( BracedApplicationAllowed / !"{" ) !ForbiddenImplicitCalls )

ForbiddenImplicitCalls
  # Reserved words that prevent spaced implicit function application
  # eg: the 'of' in 'for x of ...'
  ReservedBinary
  # NOTE: Don't allow non-heregex regexes that begin with a space as first argument without parens
  "/ "
  # NOTE: Exclude binary & operator with argument
  # (which could otherwise be interpreted as an ampersand function),
  # unless the argument starts with & that itself looks like a binary operator
  &( /&(?=\s)/ !( NotDedented ReservedBinary ) !( &( NotDedented Ampersand ( IndentedFurther / !EOS ) ) BinaryOpRHS ) ( IndentedFurther / !EOS ) ) BinaryOpRHS
  # Don't treat @@decorator @@decorator class ... as implicit calls
  ClassImplicitCallForbidden ( Class / AtAt )
  Identifier "=" Whitespace
  # NOTE: Custom operators created via `operator`
  Identifier:id !"(" ->
    if (state.operators.has(id.name)) return $0
    return $skip
  OmittedNegation _? Identifier:id ->
    if (state.operators.has(id.name)) return $0
    return $skip
  PostfixStatement NoBlock
  # `x ... y` is reserved for a range, but `x ...y` is an implicit call
  "... "

# Binary operators that are reserved in that context
ReservedBinary
  /(as|of|by|satisfies|then|when|implements|xor|xnor)(?!\p{ID_Continue}|[\u200C\u200D$])/

ArgumentsWithTrailingMemberExpressions
  Arguments:args AllowedTrailingMemberExpressions:trailing ->
    return [ args, ...trailing ]

TrailingMemberExpressions
  MemberExpressionRest* IndentedTrailingMemberExpression* ->
    return [...$1, ...$2]

IndentedTrailingMemberExpression
  # NOTE: Assert "." to not match "?" or "!" as a member expression on the following line
  IndentedAtLeast:ws &( "?"? "." ![0-9] ) MemberExpressionRest:rest ->
    return prepend(ws, rest)

AllowedTrailingMemberExpressions
  TrailingMemberPropertyAllowed TrailingMemberExpressions -> $2
  MemberExpressionRest*

TrailingCallExpressions
  # NOTE: Assert "." to not match "?" or "!" or string literal
  # as a call expression on the following line
  ( IndentedAtLeast &( "?"? "." ![0-9] ) CallExpressionRest+ )+

AllowedTrailingCallExpressions
  TrailingMemberPropertyAllowed TrailingCallExpressions -> $2

CommaDelimiter
  NotDedented Comma

OptionalCommaDelimiter
  CommaDelimiter
  &EOS InsertComma -> $2

# https://262.ecma-international.org/#prod-ArgumentList
# NOTE: Return value should always be an array alternating
#   argument, comma, argument, comma, ..., argument, [comma],
# where each comma is a Comma token or an array [whitespace, commaToken]
# (like CommaDelimiter)
ArgumentList
  !EOS ArgumentPart ( CommaDelimiter !EOS _? ArgumentPart )* ( CommaDelimiter NestedArguments ) ( OptionalCommaDelimiter NestedArguments )* ->
    return [
      $2,
      ...$3.flatMap(([comma, eos, ws, arg]) => [comma, prepend(ws, arg)]),
      ...(Array.isArray($4[1]) ? [$4[0], ...$4[1]] : $4),
      ...$5.flatMap(([comma, args]) =>
        Array.isArray(args) ? [comma, ...args] : [comma, args]
      ),
    ]
  # NOTE: Added nested arguments on separate new lines
  NestedArguments ( OptionalCommaDelimiter NestedArguments )* ->
    if (!Array.isArray($1)) $1 = [$1]
    return [
      ...trimFirstSpace($1),
      ...$2.flatMap(([comma, args]) =>
        Array.isArray(args) ? [comma, ...args] : [comma, args]
      ),
    ]
  # NOTE: Eliminated left recursion
  _? ArgumentPart ( CommaDelimiter _? ArgumentPart )* ->
    return [
      prepend($1, $2),
      ...$3.flatMap(([comma, ws, arg]) => [comma, prepend(ws, arg)]),
    ]

NestedArguments
  NestedBulletedArray
  NestedImplicitObjectLiteral
  NestedArgumentList

NestedArgumentList
  PushIndent AllowPipeline AllowTrailingMemberProperty NestedArgument*:args RestoreTrailingMemberProperty RestorePipeline PopIndent ->
    if (!args.length) return $skip
    return stripTrailingImplicitComma(args.flat())

NestedArgument
  Nested:indent !Bullet SingleLineArgumentExpressions:args ParameterElementDelimiter:comma ->
    // Attach indentation to first argument in SingleLineArgumentExpressions
    let [ arg0, ...rest ] = args
    arg0 = prepend(indent, arg0)
    return [ arg0, ...rest, comma ]

SingleLineArgumentExpressions
  WArgumentPart ( ( _? Comma ) WArgumentPart )* ->
    return [ $1, ...$2.flat() ]

WArgumentPart
  _? ArgumentPart ->
    return prepend($1, $2)

ArgumentPart
  # NOTE: Allow leading or trailing dots for argument splats like CoffeeScript
  DotDotDot:spread Expression:expression ->
    return {
      type: "Argument",
      children: $0,
      expression,
      spread,
    }
  Expression:expression DotDotDot?:spread ->
    return {
      type: "Argument",
      children: spread ? [ spread, expression ] : [ expression ],
      expression,
      spread,
    }

BinaryOpExpression
  UnaryExpression BinaryOpRHS* ->
    if (!$2.length) return $1
    return processBinaryOpExpression($0)

BinaryOpNotDedented
  !NewlineBinaryOpAllowed _? -> $2
  NewlineBinaryOpAllowed ( NestedBinaryOpAllowed / !Nested ) NotDedented -> $2

BinaryOpRHS
  BinaryOpNotDedented:ws1 IsLike:op _?:ws2 PatternExpressionList:patterns ->
    return [ ws1, op, ws2, patterns ]
  # Snug binary ops a+b
  BinaryOp:op RHS:rhs ->
    // Insert empty whitespace placeholder to maintain structure
    return [[], op, [], rhs]
  # Spaced binary ops a + b
  # a
  # + b
  # Does not match
  # a
  # +b
  NewlineBinaryOpAllowed NotDedentedBinaryOp:op WRHS:rhs ->
    // NOTE: Flatten NotDedentedBinaryOp into whitespace and operator
    return [...op, ...rhs]
  !NewlineBinaryOpAllowed SingleLineBinaryOpRHS -> $2

IsLike
  Is _? ( OmittedNegation _? )?:not Like ->
    return {
      type: "PatternTest",
      children: $0,
      special: true,
      negated: !!not,
    }

# Whitespace followed by RHS
WRHS
  PushIndent ( ( Nested _? ) RHS )?:wrhs PopIndent ->
    if (!wrhs) return $skip
    return wrhs
  ( ( EOS __ ) / _ ) RHS

SingleLineBinaryOpRHS
  # NOTE: It's named single line but that's only for the operator, the RHS can be after a newline
  # This is to maintain compatibility with CoffeeScript conditions
  _?:ws1 BinaryOp:op ( ( EOS __ ) / _ ):ws2 RHS:rhs ->
    return [ws1 || [], op, ws2, rhs]

RHS
  # NOTE: Check for comptime block first, to avoid matching as function call
  ExpressionizedStatementWithTrailingCallExpressions
  UnaryExpression

# https://262.ecma-international.org/#prod-UnaryExpression
UnaryExpression
  # NOTE: Added nested/array case, for e.g. indented await argument
  IndentedApplicationAllowed UnaryOp+:pre ( ArrayLiteral / NestedArgumentList ):args !CallExpressionRest UnaryPostfix?:post ->
    return processUnaryNestedExpression(pre, args, post) ?? $skip

  # NOTE: Merged AwaitExpression with UnaryOp
  # https://262.ecma-international.org/#prod-AwaitExpression
  # NOTE: Eliminated left recursion
  UnaryOp*:pre UnaryBody:exp UnaryPostfix?:post ->
    return processUnaryExpression(pre, exp, post)

UnaryWithoutParenthesizedAssignment
  UnaryOp*:pre UnaryWithoutParenthesizedAssignmentBody:exp UnaryPostfix?:post ->
    return processUnaryExpression(pre, exp, post)

UnaryBody
  CoffeeDoEnabled Do MaybeNestedCoffeeDoBody:body ->
    return processCoffeeDo(...body)

  ParenthesizedAssignment
  ExpressionizedStatementWithTrailingCallExpressions
  # NOTE: ExpressionizedStatement needs to come before UpdateExpression
  # to prevent `async do ...` from being parsed as a function call `async(...)`
  UpdateExpression
  NestedExpressionizedStatement

MaybeNestedCoffeeDoBody
  PushIndent ( Nested CoffeeDoBody )? PopIndent ->
    if (!$2) return $skip
    return $2
  _? CoffeeDoBody

CoffeeDoBody
  # NOTE: This is a little hacky to match CoffeeScript's behavior
  # https://coffeescript.org/#try:do%20x%20%2B%20y%0Ado%20x%20%3D%20y%0Ado%20-%3E%20x%20%3D%201
  ArrowFunction / ( LeftHandSideExpression !( __ AssignmentOpSymbol ) ) / Expression

UnaryWithoutParenthesizedAssignmentBody
  UpdateExpression
  ExpressionizedStatementWithTrailingCallExpressions
  NestedExpressionizedStatement

# NOTE: Parts of AssignmentExpression (specifically AssignmentExpressionTail)
# that make sense as a UnaryBody, e.g. as the RHS of a binary op like `??`
ParenthesizedAssignment
  InsertOpenParen ( ActualAssignment / ArrowFunction ) InsertCloseParen

UnaryPostfix
  QuestionMark
  TypePostfix+

TypePostfix
  _:ws NWTypePostfix:postfix ->
    return prepend(ws, postfix)
  &EOS BinaryOpNotDedented:indent _?:ws NWTypePostfix:postfix ->
    // TODO: Preserve comments in indent
    return prepend(ws || " ", postfix)

Tuple
  "tuple" NonIdContinue ->
    return {
      $loc,
      token: "readonly unknown[] | []"
    }

NWTypePostfix
  As _ Tuple ->
    return {
      ts: true,
      children: [{ $loc: $1.$loc, token: "satisfies" }, $2, $3]
    }

  As:as ExclamationPoint?:ex ( Type / ( __ Const ) ):type ->
    let children
    if (ex) {
      children = [{ $loc: ex.$loc, token: "as unknown " }, as, type]
    } else {
      children = [as, type]
    }

    return { ts: true, children }

  Satisfies Type ->
    return { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-UpdateExpression
UpdateExpression
  # NOTE: Not allowing whitespace betwen prefix and postfix increment operators and operand
  UpdateExpressionSymbol UnaryWithoutParenthesizedAssignment ->
    return {
      type: "UpdateExpression",
      assigned: $2,
      children: $0,
    }
  LeftHandSideExpression ( UpdateExpressionSymbol /(?!\p{ID_Start}|[_$0-9(\[{])/ )? ->
    if (!$2) return $1
    return {
      type: "UpdateExpression",
      assigned: $1,
      children: [$1, $2[0]],
    }

UpdateExpressionSymbol
  "++" / "--" ->
    return { $loc, token: $1 }
  "⧺" ->
    return { $loc, token: "++" }
  "—" ->
    return { $loc, token: "--" }

# https://262.ecma-international.org/#prod-AssignmentExpression
AssignmentExpression
  # NOTE: ActualAssignment has highest precedence:
  # `x = y |> z` parses as `x = (y |> z)` not `(x = y) |> z`
  _?:ws ActualAssignment:assign ->
    return prepend(ws, assign)
  # NOTE: It is important for pipeline to have higher precedence than
  # usual binary operators, so that x |> & + 2 |> & * 3
  # is equivalent to x |> (& + 2) |> (& * 3)
  PipelineExpression
  # TODO If NonPipelineAssignmentExpression or SingleLineAssignmentExpression is used here then behavior changes

  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  SingleLineAssignmentExpression
  # TODO: Ideally this wouldn't be needed.
  ( EOS _? ) AssignmentExpressionTail
  # NonPipelineAssignmentExpression

NonPipelineAssignmentExpression
  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  NonPipelineSingleLineAssignmentExpression
  ( EOS _? ) NonPipelineAssignmentExpressionTail

SingleLineAssignmentExpression
  _?:ws AssignmentExpressionTail:tail ->
    return prepend(ws, tail)

NonPipelineSingleLineAssignmentExpression
  _?:ws NonPipelineAssignmentExpressionTail:tail ->
    return prepend(ws, tail)

AssignmentExpressionTail
  YieldExpression
  ArrowFunction
  ActualAssignment
  ConditionalExpression

NonPipelineAssignmentExpressionTail
  YieldExpression
  ArrowFunction
  NonPipelineActualAssignment
  ConditionalExpression

# An assignment that actually includes an assignment operator, not just passing down to a ConditionalExpression
ActualAssignment
  # NOTE: Eliminated left recursion
  # NOTE: Consolidated assignment ops
  # NOTE: UpdateExpression instead of LeftHandSideExpression to allow
  # e.g. ++x *= 2 which we later convert to ++x, x *= 2
  ( NotDedented UpdateExpression WAssignmentOp )+ MaybeNestedExpression ->
    $1 = $1.map(x => [x[0], x[1], ...x[2]])
    $0 = [$1, $2]
    return {
      type: "AssignmentExpression",
      children: $0,
      // NOTE: This null marks the assignment for later processing to distinguish it
      // from fake assignments that only add a name to a scope
      names: null,
      lhs: $1,
      assigned: $1[0][1],
      expression: $2,
    }

NonPipelineActualAssignment
  # NOTE: Eliminated left recursion
  # NOTE: Consolidated assignment ops
  # NOTE: UpdateExpression instead of LeftHandSideExpression to allow
  # e.g. ++x *= 2 which we later convert to ++x, x *= 2
  ( NotDedented UpdateExpression WAssignmentOp )+ MaybeNestedNonPipelineExpression ->
    $1 = $1.map((x) => [x[0], x[1], ...x[2]])
    $0 = [$1, $2]
    return {
      type: "AssignmentExpression",
      children: $0,
      // NOTE: This null marks the assignment for later processing to distinguish it
      // from fake assignments that only add a name to a scope
      names: null,
      lhs: $1,
      assigned: $1[0][1],
      expression: $2,
    }

# https://262.ecma-international.org/#prod-YieldExpression
YieldExpression
  Yield ( ( _? Star )? MaybeParenNestedExpression )? ->
    if ($2) {
      const [ star, expression ] = $2
      return {
        type: "YieldExpression",
        star,
        expression,
        children: [ $1, star, expression ],
      }
    }
    return {
      type: "YieldExpression",
      children: [ $1 ],
    }

# https://262.ecma-international.org/#prod-ArrowFunction
ArrowFunction
  ThinArrowFunction
  ( Async _ )?:async ArrowParameters:parameters ReturnTypeSuffix?:returnType FatArrow:arrow FatArrowBody:expOrBlock ->
    if (!async) async = []

    return {
      type: "ArrowFunction",
      signature: {
        modifier: {
          async: !!async.length,
        },
        returnType,
      },
      parameters,
      returnType,
      async,
      block: expOrBlock,
      children: [async, parameters, returnType, arrow, expOrBlock ],
    }

FatArrow
  # Ensures at least one space before arrow
  _?:ws FatArrowToken:arrow ->
    if (!ws) ws = " "
    return [ ws, arrow ]

FatArrowToken
  "=>" / "⇒" ->
    return { $loc, token: "=>" }

TrailingOperator
  _? ( BinaryOp / AssignmentOp / Dot / QuestionMark )
  _ OperatorAssignmentOp
  TrailingDeclaration

TrailingDeclaration
  _? ( ConstAssignment / LetAssignment )

TrailingPipe
  _? Pipe

TrailingPostfix
  _? PostfixStatement

# NOTE Different from
# https://262.ecma-international.org/#prod-ConciseBody
FatArrowBody
  # If same-line single expression, avoid wrapping in braces
  # NOTE: Skip expressionized statements, so they get braced instead
  !EOS !( _? ExpressionizedStatement ) NonPipelineExpression:exp !TrailingDeclaration !TrailingPipe !TrailingPostfix !SemicolonDelimiter ->
    // Ensure object literal is wrapped in parens
    if (exp.type === "ObjectExpression") {
      exp = makeLeftHandSideExpression(exp)
    }
    const expressions = [["", exp]]
    return {
      type: "BlockStatement",
      bare: true,
      expressions,
      children: [expressions],
      implicitlyReturned: true,
    }
  # Otherwise, wrap block body in braces and insert returns
  NoCommaBracedOrEmptyBlock

# https://262.ecma-international.org/#prod-ConditionalExpression
ConditionalExpression
  ShortCircuitExpression TernaryRest? ->
    if ($2) {
      return [$1, ...$2]
    }
    return $1

TernaryRest
  NestedTernaryRest
  # NOTE: Ternary `a ? b : c` is disabled if CoffeeScript binary existential `a ? b` is enabled
  !CoffeeBinaryExistentialEnabled &[ \t] _ QuestionMark MaybeNestedExpression __ Colon MaybeNestedExpression ->
    return $0.slice(2)

NestedTernaryRest
  # ?/: on following line at same indentation level
  Nested QuestionMark MaybeNestedExpression Nested Colon MaybeNestedExpression
  # Indented ?/:
  PushIndent (Nested QuestionMark MaybeNestedExpression Nested Colon MaybeNestedExpression)? PopIndent ->
    if ($2) return $2
    return $skip

# https://262.ecma-international.org/#prod-ShortCircuitExpression
ShortCircuitExpression
  # NOTE: We don't need to track the precedence of all the binary operators so they all collapse into this
  BinaryOpExpression

PipelineExpression
  PipelineAllowed _?:ws PipelineHeadItem:head PipelineExpressionBody:body ->
    if (head.type === "ArrowFunction" && head.ampersandBlock) {
      const expressions = [ {
        type: "PipelineExpression",
        children: [ ws, head.block.expressions[0], body ],
      } ]
      const block = { ...head.block, expressions, children: [expressions] }
      return {
        ...head,
        block,
        body: expressions,
        children: [ ...head.children.slice(0, -1), block ],
      }
    }

    return {
      type: "PipelineExpression",
      children: [ws, head, body]
    }

PipelineExpressionBody
  # First check for properly indented chain of |>s,
  # in which case we use PushIndent to track this indentation level.
  PipelineExpressionBodySameLine:first PushIndent ( ( Nested Pipe __ PipelineTailItem ) PipelineExpressionBodySameLine )*:rest PopIndent ->
    if (!rest.length) return $skip
    return [
      ...first,
      ...rest.map(([nested, line]) => [nested, ...line]).flat()
    ]

  # Otherwise allow for any not-dedented chain
  ( NotDedented Pipe __ PipelineTailItem )+

PipelineExpressionBodySameLine
  ( _? Pipe __ PipelineTailItem )*

PipelineHeadItem
  # Needed to avoid left recursion
  NonPipelineExpression
  # Allow a pipeline to be part of first step if within parenthesis
  ParenthesizedExpression

PipelineTailItem
  ( AwaitOp / Yield / Return / Throw ) !AccessStart !MaybeParenNestedExpression -> $1
  "import" !AccessStart ->
    return {
      type: "Identifier",
      children: [ $1 ],
    }
  NWTypePostfix TypePostfix* ->
    return makeAmpersandFunction({
      body: [" ", $1, ...$2],
    })
  PipelineHeadItem -> $1

# https://262.ecma-international.org/#prod-PrimaryExpression
PrimaryExpression
  ObjectLiteral
  # NOTE: ObjectLiteral needs to be before ArrayLiteral to support `[x]: y`
  ArrayLiteral
  ThisLiteral
  TemplateLiteral
  # NOTE: TemplateLiteral must be before Literal, so that CoffeeScript
  # interpolated strings get checked first before StringLiteral.
  Literal
  FunctionExpression # NOTE: Must be before IdentiferExpression so `async function ...` isn't parsed as `async(function ...)`
  IdentifierReference # NOTE: Must be below ObjectLiteral for inline objects `a: 1, b: 2` to not be shadowed by matching the first identifier
  ClassExpression
  RegularExpressionLiteral
  ParenthesizedExpression
  Placeholder
  SymbolLiteral
  # https://facebook.github.io/jsx/#sec-jsx-PrimaryExpression
  # NOTE: Modified to parse multiple JSXElement/JSXFragments as one fragment
  JSXImplicitFragment

# https://262.ecma-international.org/#prod-ParenthesizedExpression
ParenthesizedExpression
  # NOTE: Currently ignoring early error checking in https://262.ecma-international.org/#prod-CoverParenthesizedExpressionAndArrowParameterList
  OpenParen:open AllowAll ( PostfixedCommaExpression __ CloseParen )? RestoreAll ->
    if (!$3) return $skip
    const [exp, ws, close] = $3
    switch (exp.type) {
      case "StatementExpression":
        if (exp.statement.type !== "IterationExpression") break
      case "IterationExpression":
        // Avoid extra parenthetical wrapping in `(for x in y ...)`
        // TODO: losing comments in `ws`
        return exp
      case "ParenthesizedExpression":
        if (exp.implicit) {
          return {
            ...exp,
            children: [open, exp.expression, ws, close],
            implicit: false,
          }
        }
        break
    }
    return {
      type: "ParenthesizedExpression",
      children: [ open, exp, ws, close ],
      expression: exp,
    }

Placeholder
  # Partial function application: f(., x) -> $ => f($, x)
  Dot:dot !/\p{ID_Continue}|[\u200C\u200D$.#{=]/ PlaceholderTypeSuffix?:typeSuffix ->
    return {
      type: "Placeholder",
      subtype: ".",
      typeSuffix,
      children: [ dot ],
    }
  # Ruby/Crystal style block shorthand: &+1 -> $ => $+1
  Ampersand:amp ![&=] PlaceholderTypeSuffix?:typeSuffix ->
    return {
      type: "Placeholder",
      subtype: "&",
      typeSuffix,
      children: [ amp ],
    }
  # .x -> &.x
  # NOTE: !NumericLiteral is so we don't match on `.1` etc.
  # NOTE: ExplicitAccessStart so ?.x and !.x work, but not !x (negation)
  &ExplicitAccessStart &( PropertyAccess / PropertyGlob ) !NumericLiteral ->
    return {
      type: "Placeholder",
      subtype: "&",
      children: [ { token: "&" } ],
    }

# One case of TypeSuffix, with no space before ?/: (for ternary ?:), and
# Type replaced by TypePrimary: require parens where type operators
# might be regular operators, like |, &, and ?: ternary
PlaceholderTypeSuffix
  QuestionMark?:optional Colon MaybeNestedTypePrimary:t -> {
    type: "TypeSuffix",
    ts: true,
    optional,
    t,
    children: $0,
  }

# https://262.ecma-international.org/#prod-ClassDeclaration
ClassDeclaration
  # NOTE: skipping syntax directed operation for now
  # Wrap nameless function declarations with parens, as needed in JS.
  ClassExpression ->
    if ($1.id) return $1
    return makeLeftHandSideExpression($1)

# https://262.ecma-international.org/#prod-ClassExpression
ClassExpression
  Decorators?:decorators ( Abstract __ )?:abstract Class !":" ClassBinding?:binding ClassHeritage?:heritage ClassBody:body ->
    return {
      type: "ClassExpression",
      decorators,
      abstract,
      binding,
      id: binding?.[0],
      name: binding?.[0].name,
      heritage,
      body,
      children: $0,
    }

ClassBinding
  !EOS BindingIdentifier TypeParameters? -> [$2, $3]

# https://262.ecma-international.org/#prod-ClassHeritage
ClassHeritage
  ExtendsClause:extendsClause WithClause?:withClause ImplementsClause?:implementsClause ->
    if (withClause) {
      extendsClause = convertWithClause(withClause, extendsClause)
    }
    return [ extendsClause, implementsClause ]

  WithClause?:withClause ImplementsClause?:implementsClause ->
    if (withClause) return [ convertWithClause(withClause), implementsClause ]
    if (implementsClause) return implementsClause
    return $skip

ExtendsClause
  ExtendsToken __ ExtendsTarget

# with for mixin shorthand
# class A extends B with C, D -> class A extends D(C(B))
WithClause
  __ With __:ws ExtendsTarget:t ( "," __ ExtendsTarget )*:rest ->
    return {
      type: "WithClause",
      children: $0,
      targets: [[ws, t], ...rest.map(([_comma, ws, target]) => [ws, target])],
    }

ExtendsToken
  # NOTE: Added "<" extends shorthand
  Loc:l _?:ws ExtendsShorthand:t " "? ->
    return {
      type: "Extends",
      children: [
        ws || { $loc: l.$loc, token: " " },
        t,
      ],
    }
  _? Extends ->
    return {
      type: "Extends",
      children: $0,
    }

ExtendsShorthand
  "<" ->
    return { $loc, token: "extends " }

NotExtendsToken
  Loc:l _?:ws1 OmittedNegation:ws2 ExtendsShorthand:t " "? ->
    const ws = ws1 && ws2 ? [ws1, ws2] : ws1 || ws2 ||
      { $loc: l.$loc, token: " " }
    return {
      type: "Extends",
      negated: true,
      children: [ ws, t ],
    }
  _? OmittedNegation Extends ->
    return {
      type: "Extends",
      negated: true,
      children: $0,
    }

OmittedNegation
  ExclamationPoint -> ""
  Not " "? _? -> $3

ExtendsTarget
  LeftHandSideExpressionWithObjectApplicationForbidden:exp ->
    return makeLeftHandSideExpression(exp)

ImplementsClause
  ImplementsToken ImplementsTarget ( Comma ImplementsTarget )* ->
    return {
      ts: true,
      children: $0,
    }

ImplementsToken
  # NOTE: Added "<:" implements shorthand
  Loc:l __:ws ImplementsShorthand:token " "? ->
    const children = [ ...ws, token ]

    if (!ws.length) {
      children.unshift({ $loc: l.$loc, token: " " })
    }

    return { children }

  __ "implements" NonIdContinue ->
    $2 = { $loc, token: $2 }
    return [$1, $2]

ImplementsShorthand
  "<:" ->
    return { $loc, token: "implements " }

ImplementsTarget
  __ IdentifierName (Dot IdentifierName)* TypeArguments?

# https://262.ecma-international.org/#prod-ClassBody
# NOTE: Nesting and indentation sensitive
ClassBody
  __:ws1 OpenBrace:open AllowAll ClassBracedContent?:expressions RestoreAll __:ws2 CloseBrace:close  ->
    if (!expressions) expressions = []
    return {
      type: "BlockStatement",
      subtype: "ClassBody",
      children: [ws1, open, expressions, ws2, close],
      expressions,
    }
  InsertOpenBrace NestedClassElements?:expressions InsertNewline InsertIndent InsertCloseBrace ->
    if (!expressions) expressions = $0[1] = []
    return {
      type: "BlockStatement",
      subtype: "ClassBody",
      children: $0,
      expressions,
    }

# based on BracedContent
ClassBracedContent
  NestedClassElements
  # based on SingleLineStatements
  ForbidNewlineBinaryOp ( ( _? !EOS ) ClassElement StatementDelimiter )*:stmts RestoreNewlineBinaryOp ->
    if (!stmts) return $skip
    return stmts

NestedClassElements
  PushIndent NestedClassElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassElement
  Nested ClassElement StatementDelimiter

# https://262.ecma-international.org/#prod-ClassElement
ClassElement
  # NOTE: Combined optional static and Method/Field definition
  Decorators?:decorators AccessModifier? ( Static _? )? ( Override _? )? ClassElementDefinition:definition ->
    if (definition.type === "MultiMethodDefinition") {
      // If shorthand method definition has multiple expansions each one should get the decorators
      return {
        ...definition,
        children: definition.children.map((c) => {
          return {
            ...c,
            children: [ decorators, ...c.children ],
          }
        })
      }
    }
    return {
      ...definition,
      children: [decorators, $2, $3, $4, ...definition.children],
    }
  # ClassStaticBlock
  Static BracedBlock ->
    return {
      type: "ClassStaticBlock",
      children: $0,
    }
  EmptyStatement

ClassElementDefinition
  ( MethodDefinition / FieldDefinition )

# `declare class` form of ClassDeclaration, where all methods are signatures
ClassSignature
  Decorators? ( Abstract __ )? Class ClassBinding? ClassHeritage? ClassSignatureBody

ClassSignatureBody
  __ OpenBrace NestedClassSignatureElements? __ CloseBrace
  InsertOpenBrace NestedClassSignatureElements? InsertNewline InsertIndent InsertCloseBrace

NestedClassSignatureElements
  PushIndent NestedClassSignatureElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassSignatureElement
  Nested ClassSignatureElement StatementDelimiter

ClassSignatureElement
  # NOTE: MethodSignature instead of MethodDefinition
  Decorators? AccessModifier? ( Static _? )? ( Override _? )? ( MethodSignature / FieldDefinition )
  Static ClassSignatureBody

AccessModifier
  ( ( Public / Private / Protected ) NotDedented )? ( Readonly NotDedented )? ->
    if (!($1 || $2)) return $skip

    return {
      ts: true,
      children: $0
    }

# https://262.ecma-international.org/#prod-FieldDefinition
FieldDefinition
  # TODO: CoffeeCompat class method fields
  # name: (param1, param2) ->
  CoffeeClassesEnabled ClassElementName:id _? Colon __ AssignmentExpression:exp ->
    switch (exp.type) {
      // TODO: => functions
      case "FunctionExpression":
        const fnTokenIndex = exp.children.findIndex(c => c?.token?.startsWith("function"))
        // copy
        const children = exp.children.slice()
        if (exp.generator) {
          // replace "function" and move generator ahead of id
          children.splice(fnTokenIndex, 2, children[fnTokenIndex+1], id)
        } else {
          // replace "function" token with id
          children.splice(fnTokenIndex, 1, id)
        }
        return {
          ...exp,
          children,
        }
      default:
        return {
          type: "FieldDefinition",
          id,
          children: [id, " = ", exp],
        }
    }

  # NOTE: Added readonly semantic equivalent of const field assignment
  InsertReadonly:r ClassElementName:id TypeSuffix?:typeSuffix __ ConstAssignment:ca MaybeNestedExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    r.children[0].$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return {
      type: "FieldDefinition",
      id,
      typeSuffix,
      children: $0,
    }

  ( Abstract _? )? ( Readonly _? )? ClassElementName:id TypeSuffix?:typeSuffix Initializer? ->
    return {
      type: "FieldDefinition",
      children: $0,
      ts: $1 ? true : undefined,
      id,
      typeSuffix,
    }

ThisLiteral
  This -> {
    type: "Identifier",
    name: "this",
    children: [ $1 ],
  }
  HashThis
  # NOTE: Added @identifier shorthand, also works for private identifiers
  # Converts 'IdentifierName' node to string so this won't interfere with refs
  AtThis:at $( Hash? IdentifierName ):id ->
    return {
      type: "MemberExpression",
      children: [at, {
        type: "PropertyAccess",
        name: id,
        children: [".", {
          $loc: {
            pos: $loc.pos + 1,
            length: $loc.length - 1,
          },
          token: id
        }],
      }],
      thisShorthand: true,
    }
  AtThis

# Adds a #id -> this.#id shorthand as a "HashThis" literal in most cases
# with the exception of keeping `#a in b` as is for branded in checks.
# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in#using_the_in_operator_to_implement_branded_checks
# This is slightly different from how https://262.ecma-international.org/#sec-relational-operators handles relational operators
# grammatically but should be equivalent in practice
HashThis
  AtThis?:at LengthShorthand:id ( &( _ ( Not __ )? ActualIn ) "" )?:beforeIn ->
    if (beforeIn != null && at == null) return [ '"', id.name, '"' ]

    return {
      type: "MemberExpression",
      children: [at ?? "this", {
        type: "PropertyAccess",
        name: id.name,
        children: [".", id],
      }],
      thisShorthand: true,
    }

  PrivateIdentifier:id &( _ ( Not __ )? ActualIn ) ->
    return id

  PrivateIdentifier:id ->
    return {
      type: "MemberExpression",
      children: ["this", {
        type: "PropertyAccess",
        name: id.name,
        children: [".", id],
      }],
      privateShorthand: true,
      privateId: id,
    }

LengthShorthand
  Hash NonIdContinue ->
    const id = "length"
    return {
      type: "Identifier",
      name: id,
      names: [id],
      children: [{
        $loc: $loc,
        token: id,
      }],
    }

# NOTE: Added '@' as a 'this' shorthand from CoffeeScript
AtThis
  At:at ->
    return {
      type: "Identifier",
      name: "this",
      children: [{ ...at, token: "this" }]
    }

# https://262.ecma-international.org/#prod-LeftHandSideExpression
LeftHandSideExpression
  # https://262.ecma-international.org/#prod-NewExpression
  # NOTE: Merged in NewExpression
  # NOTE: Changed to CallExpression to handle arguments
  # NOTE: Eliminated left recursion
  ( New !( "." / ":" ) __ )+ CallExpression:expression ->
    return {
      type: "NewExpression",
      children: $0,
      expression,
    }
  CallExpression
  # NOTE: OptionalExpression is merged into CallExpression

# https://262.ecma-international.org/#prod-CallExpression
CallExpression
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  Super ArgumentsWithTrailingMemberExpressions CallExpressionRest*:rest ->
    return processCallMemberExpression({
      type: "CallExpression",
      children: [$1, ...$2, ...rest.flat()],
    })
  # Import declaration as an expression
  Import _ NamedImports __ FromClause ->
    return dynamizeImportDeclarationExpression($0)
  FromClause:from __:fws Import:i _:iws NamedImports:imports ->
    return dynamizeImportDeclarationExpression([i, iws, imports, fws, from])
  # Dynamic import(), with optional parentheses when not used at top level.
  # (At top level, ImportDeclaration will match first.)
  "import" ArgumentsWithTrailingMemberExpressions CallExpressionRest*:rest ->
    return processCallMemberExpression({
      type: "CallExpression",
      children: [$1, ...$2, ...rest.flat()],
    })

  MemberExpression:member AllowedTrailingMemberExpressions:trailing CallExpressionRest*:rest ->
    if (rest.length || trailing.length) {
      rest = rest.flat()
      return processCallMemberExpression({
        type: "CallExpression",
        children: [member, ...trailing, ...rest]
      })
    }

    return member

CallExpressionRest
  MemberExpressionRest
  # NOTE: TypeScript instantiation expressions
  # https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#instantiation-expressions
  # But x<y>z and x<y>0 is a comparison chain.
  TypeArguments !( IdentifierName / NumericLiteral ) -> $1
  # perf: assertion to exit early
  /(?=['"`])/ ( TemplateLiteral / StringLiteral ):literal ->
    if (literal.type === "StringLiteral") {
      literal = "`" + literal.token.slice(1, -1).replace(/(`|\$\{)/g, "\\$1") + "`"
    }
    return literal
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  OptionalShorthand?:optional ArgumentsWithTrailingMemberExpressions:argsWithTrailing ->
    if (!optional) return argsWithTrailing

    const call = argsWithTrailing[0];
    return [ {
      ...call,
      children: [optional, ...call.children],
      optional,
    }, ...argsWithTrailing.slice(1) ]

# NOTE: Added shorthand x?(3) -> x?.(3)
OptionalShorthand
  # perf: assertion to exit early
  /(?=[\/?])/ InlineComment*:comments QuestionMark:q OptionalDot:d ->
    return {
      type: "Optional",
      children: [...comments, q, d],
    }

OptionalDot
  InlineComment* Dot
  InsertDot

NonNullAssertion
  # NOTE: Prevent shadowing !^ xnor operator, !<?, "!=", and "!=="
  ExclamationPoint !("^" / "<?" / "=") -> { type: "NonNullAssertion", ts: true, children: [$1] }

# https://262.ecma-international.org/#prod-MemberExpression
MemberExpression
  # NOTE: "new" MemberExpression Arguments seems to be handled fine by other rules already
  # NOTE: Eliminated left recursion
  MemberBase MemberExpressionRest*:rest ->
    if (rest.length || Array.isArray($1)) {
      return processCallMemberExpression({
        type: "MemberExpression",
        children: [$1, ...rest].flat(),
      })
    }
    return $1

ActualMemberExpression
  MemberBase MemberExpressionRest+:rest ->
    return processCallMemberExpression({
      type: "MemberExpression",
      children: [$1, ...rest].flat(),
    })

MemberBase
  PrimaryExpression
  SuperProperty
  MetaProperty

MemberExpressionRest
  # perf: assertion to exit early
  /(?=[\/\[{?.!@#'’:])/ InlineComment*:comments MemberExpressionRestBody:body ->
    if (Array.isArray(body)) return [...comments, ...body]
    return {
      ...body,
      children: [...comments, ...body.children]
    }

MemberExpressionRestBody
  # NOTE: Added shorthand x?[3] -> x?.[3]
  OptionalShorthand?:dot InlineComment*:comments MemberBracketContent:content ->
    if (!dot && !comments.length) return content
    if (dot) {
      // Optional followed by a slice expression
      if (dot.type === "Optional" && content.type === "SliceExpression") {
        // Remove '.' from optional since it is present in '.slice'
        return [...dot.children.slice(0, -1), ...comments, content]
      }
      return {
        ...content,
        children: [dot, ...comments, ...content.children],
        optional: dot,
      }
    }
    return [...comments, content]
  # NOTE: Combined Optional and Property access
  PropertyAccess
  PropertyGlob
  PropertyBind
  # NOTE: Added TypeScript '!' non-null assertion
  NonNullAssertion

# Handles indexing and slicing
MemberBracketContent
  OpenBracket:open ( SliceParameters / PostfixedExpression ):expression __:ws CloseBracket:close ->
    // Some kind of slice
    if (expression.type === "SliceParameters") {
      const {start, end, reversed, children} = expression

      return {
        type: "SliceExpression",
        start,
        end,
        reversed,
        children: [
          {...open, token: ".slice("},
          ...children,
          [...ws, {...close, token: ")"}],
        ]
      }
    }

    // Regular index `[expression]`
    return {
      type: "Index",
      children: $0,
      expression,
    }
  # NOTE: `x[i%]` shorthand for `x[i %% x.length]`
  OpenBracket:open PostfixedExpression:expression __:ws1 /%%?/ __:ws2 CloseBracket:close ->
    return {
      type: "Index",
      children: [open, expression, ws1, ws2, close],
      expression,
      mod: true,
    }

SliceParameters
  Loc:ls Expression?:start __:ws RangeDots:dots Loc:le Expression?:end ->
    const reversed = dots.increasing === false
    const sign = reversed ? "-" : "+"
    let children
    start ??= {
      $loc: ls.$loc,
      token: reversed ? "-1" : "0",
    }
    if (!end) {
      if (reversed) {
        end = {
          $loc: le.$loc,
          token: "0",
        }
      } else if (!dots.right.inclusive && !dots.triple) {
        end = {
          $loc: le.$loc,
          token: "-1",
        }
      }
    }
    if (!dots.left.inclusive) {
      start = [makeLeftHandSideExpression(start), ` ${sign} 1`]
    }
    if (end) {
      const inc = []
      if (dots.right.inclusive) {
        end = [makeLeftHandSideExpression(end), ` ${sign} 1`]
        if (!reversed) inc./**/push(" || 1/0")
      }
      children = [start, [...ws, dots.children[0], {token: ", ", $loc: dots.$loc}], [dots.children[1], end, ...inc]]
    } else {
      children = [start, ws]
    }

    return {
      type: "SliceParameters",
      start,
      end,
      reversed,
      children,
    }

  Loc:l RangeEnd:rend Expression:e ->
    let start, end, children
    if (rend.increasing) { // right end
      end = e
      if (rend.inclusive) {
        end = [makeLeftHandSideExpression(end), ` + 1`]
      }
      start = {
        $loc: l.$loc,
        token: "0",
      }
      children = [start, ", ", end]
    } else { // left end
      start = e
      if (!rend.inclusive) {
        start = [makeLeftHandSideExpression(start), ` + 1`]
      }
      children = [start]
    }
    return {
      type: "SliceParameters",
      start,
      end,
      children,
    }

AccessStart
  PropertyAccessModifier?:modifier Dot:dot ![.\s] ->
    return {
      type: "AccessStart",
      children: modifier ? [modifier, dot] : [dot],
      optional: modifier?.token === "?",
    }
  # NOTE: ?x -> ?.x, !x -> !.x shorthand
  PropertyAccessModifier:modifier InsertDot:dot ![.\s] ->
    return {
      type: "AccessStart",
      children: [modifier, dot],
      optional: modifier.token === "?",
    }

ExplicitAccessStart
  PropertyAccessModifier?:modifier Dot:dot !Dot ->
    return {
      type: "AccessStart",
      children: modifier ? [modifier, dot] : [dot],
      optional: modifier?.token === "?",
    }

ImplicitAccessStart
  PropertyAccessModifier?:modifier InsertDot:dot !Dot ->
    return {
      type: "AccessStart",
      children: modifier ? [modifier, dot] : [dot],
      optional: modifier?.token === "?",
    }

PropertyAccessModifier
  QuestionMark
  NonNullAssertion

PropertyAccess
  # NOTE: Added shorthand x."string" -> x["string"]
  # NOTE: Added shorthand x.3 -> x[3]
  # NOTE: Added shorthand x.:symbol -> x[Symbol.for("symbol")]
  AccessStart:dot ( TemplateLiteral / StringLiteral / IntegerLiteral / SymbolLiteral ):literal ->
    return {
      type: "Index",
      children: [
        adjustIndexAccess(dot),
        literal,
        "]",
      ]
    }

  # NOTE: Added shorthand x.-1 -> x[x.length-1]
  AccessStart:dot "-":neg IntegerLiteral:num ->
    const len = {
      children: []
    },

    children = [
      adjustIndexAccess(dot),
      len,
      neg,
      num,
      "]"
    ]

    return {
      type: "NegativeIndex",
      children,
      len,
    }

  AccessStart:dot InlineComment*:comments ( IdentifierName / PrivateIdentifier / LengthShorthand ):id ->
    return {
      type: "PropertyAccess",
      name: id.name,
      dot,
      children: [ dot, ...comments, ...id.children ],
    }

  ImplicitAccessStart:dot ( PrivateIdentifier / LengthShorthand ):id ->
    return {
      type: "PropertyAccess",
      name: id.name,
      dot,
      children: [ dot, ...id.children ],
    }

  # NOTE: Added CoffeeScript :: prototype shorthand only when enabled
  CoffeePrototypeEnabled PropertyAccessModifier?:modifier DoubleColon:p IdentifierName?:id ->
    const dot = {token: ".", $loc: p.$loc}
    // Based on AccessStart
    const start = {
      type: "AccessStart",
      children: modifier ? [modifier, dot] : [dot],
      optional: modifier?.token === "?",
    }
    if (id) {
      return {
        type: "PropertyAccess",
        name: id.name,
        dot: start,
        children: [ start, "prototype.", id ],
      }
    } else {
      return {
        type: "PropertyAccess",
        name: "prototype",
        dot: start,
        children: [ start, "prototype" ],
      }
    }

PropertyGlob
  # NOTE: Added shorthand obj.{a,b:c} -> {a: obj.a, c: obj.b}
  ( PropertyAccessModifier? OptionalDot ):dot InlineComment* BracedObjectLiteral:object ->
    return {
      type: "PropertyGlob",
      dot,
      object,
      children: $0,
    }

PropertyBind
  # NOTE: foo@.bar and foo@bar shorthand for foo.bar.bind(foo)
  PropertyAccessModifier?:modifier At OptionalDot:dot ( IdentifierName / PrivateIdentifier ):id Arguments?:args ->
    return {
      type: "PropertyBind",
      name: id.name,
      children: [modifier, dot, id],  // omit `@` from children
      args: args?.children.slice(1, -1) ?? [], // remove the parens from the arg list, or give an empty list
    }

SuperProperty
  Super MemberBracketContent
  Super !PropertyAccessModifier PropertyAccess

MetaProperty
  New Dot Target
  "import.meta" NonIdContinue ->
    return { $loc, token: $1 }
  ReturnValue

# NOTE: Special `return.value` (and `return =` shorthand)
# for changing the automatic return value of function
ReturnValue
  ( "return.value" NonIdContinue ) / ( Return &AfterReturnShorthand ) ->
    return { type: "ReturnValue", children: [$1[0]] }

AfterReturnShorthand
  WAssignmentOp
  UpdateExpressionSymbol
  # Allow e.g. `let return: T`
  TypeSuffix
  __ LetAssignment
  __ ConstAssignment

# https://262.ecma-international.org/#prod-FormalParameters
# The parameters in a function definition
Parameters
  NonEmptyParameters
  TypeParameters?:tp Loc:p ->
    return {
      type: "Parameters",
      children: [tp, {$loc: p.$loc, token: "()"}],
      tp,
      names: [],
      implicit: true,
    }

# Allow for [a, b] => ... or {a, b} -> ...
ShortArrowParameters
  ( ObjectBindingPattern / ArrayBindingPattern ):binding ->
    // Based on ParameterElement
    const { typeSuffix } = binding
    return {
      type: "Parameter",
      children: [ binding, typeSuffix ],
      names: binding.names,
      typeSuffix,
    }

ArrowParameters
  ShortArrowParameters ->
    return {
      type: "Parameters",
      children: ["(", $1, ")"],
      names: $1.names,
    }
  Parameters

NonEmptyParameters
  TypeParameters?:tp OpenParen:open ParameterList:params ( __ CloseParen ):close ->
    // Categorize arguments to put any ThisType in front, and split remaining
    // arguments into before and after the rest parameter.
    let tt, before = [], rest, after = [], errors = []
    function append(p) {
      (rest ? after : before).push(p)
    }
    for (const param of params) {
      switch (param.type) {
        case "ThisType":
          if (tt) {
            append({
              type: "Error",
              message: "Only one typed this parameter is allowed",
            })
            append(param)
          } else {
            tt = trimFirstSpace(param)
            if (before.length || rest) { // moving ThisType to front
              let delim = tt.children.at(-1)
              if (Array.isArray(delim)) delim = delim.at(-1)
              if (delim?.token !== ",") {
                tt = {
                  ...tt,
                  children: [...tt.children, ", "],
                }
              }
            }
          }
          break
        case "FunctionRestParameter":
          if (rest) {
            append({
              type: "Error",
              message: "Only one rest parameter is allowed",
            })
            append(param)
          } else {
            rest = param
          }
          break
        default:
          append(param)
      }
    }

    const names = before.flatMap(p => p.names)
    if (rest) {
      const restIdentifier = rest.binding.ref || rest.binding
      names.push(...rest.names || [])

      let blockPrefix
      if (after.length) {
        blockPrefix = {
          children: ["[", trimFirstSpace(after), "] = ", restIdentifier, ".splice(-", after.length.toString(), ")"],
          names: after.flatMap(p => p.names)
        }
      }

      return {
        type: "Parameters",
        children: [
          tp,
          open,
          tt,
          ...before,
          // Remove delimiter
          {...rest, children: rest.children.slice(0, -1)},
          close,
        ],
        tp,
        names,
        blockPrefix,
      }
    }

    return {
      type: "Parameters",
      children: [tp, open, tt, ...before, close],
      names,
      tp,
    }

ParameterList
  # Nested case: Allow for one line of parameters followed by a nested list
  Parameter* NestedParameterList ->
    return [...$1, ...$2]
  # Otherwise, try parsing while ignore indentation
  ( __ Parameter )* ->
    return $1.map(([eos, p]) => ({
      ...p,
      children: [eos, ...p.children],
    }))

NestedParameterList
  PushIndent NestedParameter*:params PopIndent ->
    if (!params.length) return $skip
    return params

NestedParameter
  # Allow one or more parameters on one line
  Nested:ws Parameter+:params ->
    // Attach whitespace to first parameter
    params = [...params]
    params[0] = prepend(ws, params[0])
    return params

Parameter
  ThisType
  ParameterElement
  FunctionRestParameter

# https://262.ecma-international.org/#prod-FunctionRestParameter
FunctionRestParameter
  # BindingRestElement has a leading _?
  # but also sometimes invokes __ via BindingIdentifier
  !EOS BindingRestElement:id TypeSuffix? ParameterElementDelimiter ->
    return {
      type: "FunctionRestParameter",
      children: $0.slice(1),
      names: id.names,
      binding: id.binding,
    }

# NOTE: Similar to BindingElement but appears in formal parameters list
ParameterElement
  _? AccessModifier?:accessModifier _? ( NWBindingIdentifier / BindingPattern ):binding TypeSuffix?:typeSuffix Initializer?:initializer ParameterElementDelimiter:delim ->
    typeSuffix ??= binding.typeSuffix
    return {
      type: "Parameter",
      children: [ $1, accessModifier, $3, binding, typeSuffix, initializer, delim ],
      names: binding.names,
      typeSuffix,
      accessModifier,
      initializer,
      delim,
      binding,
    }

ParameterElementDelimiter
  _? Comma
  &( __ [)}] )
  &EOS InsertComma -> $2

# https://262.ecma-international.org/#prod-BindingIdentifier
BindingIdentifier
  # NOTE: Added @param for binding identifiers
  # The parser will allow them in const/let/var declarations but JS/TS doesn't allow them there
  __:ws NWBindingIdentifier:identifier ->
    return prepend(ws, identifier)

# Non-whitespace version of BindingIdentifier
NWBindingIdentifier
  # NOTE: Added @param for binding identifiers
  # The parser will allow them in const/let/var declarations but JS/TS doesn't allow them there
  At AtIdentifierRef:ref ->
    return {
      type: "AtBinding",
      children: [ref],
      ref,
    }
  # Likewise for private identifiers
  Hash AtIdentifierRef:ref ->
    ref = { ...ref, id: `#${ref.id}` }
    return {
      type: "AtBinding",
      children: [ref],
      ref,
    }
  Identifier:id
  # NOTE: Support for return := 1 and let return: number
  ReturnValue ->
    return { children: [$1], names: [] }

AtIdentifierRef
  ReservedWord:r ->
    return makeRef(`_${r}`, r)
  IdentifierName:id ->
    return makeRef(id.name)

PinPattern
  Caret SingleLineExpressionWithIndentedApplicationForbidden:expression ->
    return {
      type: "PinPattern",
      children: $0,
      expression,
    }
  ActualMemberExpression:expression ->
    return {
      type: "PinPattern",
      children: [expression],
      expression,
    }
  # Handle unary numeric in switch patterns
  ([+-] NumericLiteral):expression ->
    return {
      type: "PinPattern",
      children: [expression],
      expression,
    }
  # Handle undefined in switch patterns
  Undefined:expression ->
    return {
      type: "PinPattern",
      children: [expression],
      expression,
    }

# https://262.ecma-international.org/#prod-BindingPattern
BindingPattern
  ObjectBindingPattern
  ArrayBindingPattern
  PinPattern
  Literal
  RegularExpressionLiteral

# https://262.ecma-international.org/#prod-ObjectBindingPattern
# NOTE: Simplified from spec
ObjectBindingPattern
  _?:ws1 OpenBrace:open ObjectBindingPatternContent:c __:ws2 CloseBrace:close ->
    const properties = c.children
    return gatherBindingPatternTypeSuffix({
      type: "ObjectBindingPattern",
      children: [ws1, open, properties, ws2, close],
      names: c.names,
      properties,
    })

ObjectBindingPatternContent
  # NOTE: Added indentation based binding properties
  NestedBindingProperties
  BindingPropertyList?:props ->
    if (!props) return { children: [], names: [] }

    return reorderBindingRestProperty(props)

BindingPropertyList
  ( BindingProperty ObjectPropertyDelimiter )+:props ->
    return props.map(([prop, delim]) => {
      return {
        ...prop,
        delim,
        children: [...prop.children, delim],
      }
    })

# https://262.ecma-international.org/#prod-ArrayBindingPattern
# NOTE: Simplified from spec
ArrayBindingPattern
  _?:ws1 OpenBracket:open ArrayBindingPatternContent:c __:ws2 CloseBracket:close ->
    return gatherBindingPatternTypeSuffix({
      ...c, // names, blockPrefix, length
      type: "ArrayBindingPattern",
      elements: c.children,
      children: [ws1, open, c.children, ws2, close],
    })

ArrayBindingPatternContent
  # NOTE: Added indentation based binding elements
  NestedBindingElements
  BindingElementList?:elements ->
    if (!elements) return { children: [], names: [], length: 0 }

    return adjustBindingElements(elements)

# children is an array of tuples of the form [ws, element, delim]
BindingElementList
  ( BindingElement ArrayElementDelimiter )+:elements ->
    return elements.map(([element, delim]) => {
      return {
        ...element,
        delim,
        // BindingElement.children is a tuple of the form [ws, element]
        children: [...element.children, delim],
      }
    })

NestedBindingElementList
  Nested:indent BindingElementList:elements ->
    // Attach whitespace to first element
    return elements.map( (element, i) => {
      if (i > 0) return element
      return {
        ...element,
        children: [indent, ...element.children.slice(1)], // replace ws wth indent
      }
    })

# https://262.ecma-international.org/#prod-Elision
Elision
  # NOTE: The repetition is handled from outside rather than using left recursion here
  __ Comma

NestedBindingProperties
  PushIndent NestedBindingPropertyList*:props PopIndent ->
    if (!props.length) return $skip

    return reorderBindingRestProperty(props.flat())

NestedBindingPropertyList
  Nested:ws BindingPropertyList:props ->
    // Attach whitespace to first property
    return props.map( (prop, i) => {
      if (i > 0) return prop
      return prepend(ws, prop)
    })

# https://262.ecma-international.org/#prod-BindingProperty
BindingProperty
  # NOTE: Merged in BindingRestProperty
  # TS will mark errors about invalid multiple rest properties
  # NOTE: Must be checked first to pick up trailing "..." form
  BindingRestProperty

  # NOTE: Allow ::T type suffix before value
  _? PropertyName:name _? Colon _? ( BindingIdentifier / BindingPattern ):value BindingTypeSuffix?:typeSuffix Initializer?:initializer ->
    return {
      type: "BindingProperty",
      children: [$1, name, $3, $4, $5, value, initializer],  // omit typeSuffix
      name,
      value,
      typeSuffix,
      initializer,
      names: value.names,
    }

  _?:ws Caret?:pin BindingIdentifier:binding BindingTypeSuffix?:typeSuffix Initializer?:initializer ->
    let children = [ws, binding, initializer]  // omit pin and typeSuffix

    // TODO make this work with pin
    if (binding.type === "AtBinding") {
      return {
        type: "AtBindingProperty",
        children,
        binding,
        typeSuffix,
        ref: binding.ref,
        initializer,
        names: [],
      }
    }

    if (pin) {
      children = [ws, binding]
      if (typeSuffix) {
        children.push({
          type: "Error",
          message: "Pinned properties cannot have type annotations",
        })
      }
      if (initializer) {
        children.push({
          type: "Error",
          message: "Pinned properties cannot have initializers",
        })
      }
      return {
        type: "PinProperty",
        children,
        name: binding,
        value: {
          type: "PinPattern",
          expression: binding,
        },
      }
    }

    return {
      type: "BindingProperty",
      children,
      name: binding,
      value: undefined,
      typeSuffix,
      initializer,
      names: binding.names,
      identifier: binding,
    }

# https://262.ecma-international.org/#prod-BindingRestProperty
BindingRestProperty
  _?:ws DotDotDot:dots BindingIdentifier:id BindingTypeSuffix?:typeSuffix ->
    return {
      ...id,
      type: "BindingRestProperty",
      typeSuffix,
      children: [...(ws || []), dots, ...id.children],
    }

  _?:ws BindingIdentifier:id DotDotDot:dots ->
    return {
      ...id,
      type: "BindingRestProperty",
      typeSuffix: undefined,
      children: [...(ws || []), dots, ...id.children],
    }

BindingTypeSuffix
  _? QuestionMark?:optional _? DoubleColonAsColon:colon MaybeNestedType:t ->
    return {
      type: "TypeSuffix",
      ts: true,
      optional,
      t,
      children: $0,
    }

NestedBindingElements
  PushIndent NestedBindingElementList*:elements PopIndent ->
    if (!elements.length) return $skip

    // Each item of elements is a list of BindingElements;
    // combine into one big array
    return adjustBindingElements(elements.flat())

# https://262.ecma-international.org/#prod-BindingElement
# children is an array of tuples of the form [ws, element]
BindingElement
  BindingRestElement

  # NOTE: Merged in SingleNameBinding
  _?:ws ( BindingIdentifier / BindingPattern ):binding BindingTypeSuffix?:typeSuffix Initializer?:initializer ->
    // NOTE: RegExpLiteral doesn't have children so it will lose the initializer
    // for now
    if (binding.children) {
      binding = {
        ...binding,
        initializer,
        children: [...binding.children, initializer],
      }
    }

    return {
      type: "BindingElement",
      names: binding.names,
      typeSuffix,
      binding,
      children: [ws, binding],
    }

  # NOTE: Merged in ElisionElement
  &( _? "," ) ->
    return {
      type: "ElisionElement",
      children: [""],
      names: [],
    }

# https://262.ecma-international.org/#prod-BindingRestElement
BindingRestElement
  _?:ws DotDotDot:dots ( BindingIdentifier / BindingPattern / EmptyBindingPattern ):binding BindingTypeSuffix?:typeSuffix ->
    return {
      type: "BindingRestElement",
      children: [ws, [dots, binding]],
      dots,
      binding,
      typeSuffix,
      name: binding.name,
      names: binding.names,
      rest: true,
    }

  _?:ws ( BindingIdentifier / BindingPattern ):binding DotDotDot:dots ->
    return {
      type: "BindingRestElement",
      children: [...(ws || []), dots, binding],
      dots,
      binding,
      name: binding.name,
      names: binding.names,
      rest: true,
    }

# NOTE: Allows for empty binding rest pattern like in CoffeeScript
EmptyBindingPattern
  "" ->
    const ref = makeRef()
    return {
      type: "EmptyBinding",
      children: [ref],
      names: [],
      ref,
    }

# https://262.ecma-international.org/#prod-FunctionDeclaration
FunctionDeclaration
  # Wrap nameless function declarations with parens, as needed in JS.
  FunctionExpression ->
    // Do not treat ArrowFunctions, as generated by & and (+), as declarations
    if ($1.type !== "FunctionExpression") return $skip
    if ($1.id) return $1
    return makeLeftHandSideExpression($1)

FunctionSignature
  # NOTE: Merged in async and generator with optionals
  ( Async _ )?:async Function:func ( _? Star )?:generator ( _? NWBindingIdentifier )?:wid _?:w Parameters:parameters ReturnTypeSuffix?:returnType ->
    if (!async) async = []
    if (!generator) generator = []

    const id = wid?.[1]
    return {
      type: "FunctionSignature",
      id,
      name: id?.name,
      parameters,
      returnType,
      async,
      generator,
      modifier: {
        async: !!async.length,
        generator: !!generator.length,
      },
      block: null,
      children: !parameters.implicit
        ? [ async, func, generator, wid, w, parameters, returnType ]
        : [ async, func, generator, wid, parameters, w, returnType ],
          // move whitespace w to after implicit () in parameters
    }

# https://262.ecma-international.org/#prod-FunctionExpression
FunctionExpression
  # NOTE: block isn't actually optional in FunctionExpression only in declarations/TS overloads
  FunctionSignature:signature BracedBlock?:block ->
    // TS Function overloads
    if (!block) {
      return {
        ...signature,
        type: "FunctionExpression",
        signature,
        ts: true,
      }
    }

    // Attach the block
    return {
      ...signature,
      type: "FunctionExpression",
      signature,
      children: [...signature.children, block],
      block,
    }

  # BinaryOp function shorthand
  !ArrowFunction OpenParen:open BinaryOp:op CloseParen:close ->
    // (foo) doesn't need an arrow wrapper; just foo suffices
    if (op.special && op.call && !op.negated) return op.call

    const refA = makeRef("a"),
      refB = makeRef("b"),
      body = processBinaryOpExpression([refA, [
        [[], op, [], refB] // BinaryOpRHS
      ]])

    const parameters = {
      type: "Parameters",
      children: ["(", refA, ",", refB, ")"],
      names: [],
    }

    const block = {
      expressions: [body],
    }

    return {
      type: "ArrowFunction",
      signature: {
        modifier: {},
      },
      children: [open, parameters, " => ", body, close],
      body,
      parenthesized: true,
      parenthesizedOp: op,
      block,
      parameters,
    }

  # Haskell-style sections
  OpenParen:open NonPipelineAssignmentExpression:lhs __:ws1 BinaryOp:op __:ws2 CloseParen:close ->
    const refB = makeRef("b")
    const fn = makeAmpersandFunction({
      ref: refB,
      body: processBinaryOpExpression([lhs, [
        [ws1, op, ws2, refB] // BinaryOpRHS
      ]])
    })
    return {
      type: "ParenthesizedExpression",
      children: [ open, fn, close ],
      expression: fn,
    }
  # Assignment version based on ActualAssignment rule
  OpenParen:open ( NotDedented UpdateExpression WAssignmentOp )+:lhs __:ws2 CloseParen:close ->
    lhs = lhs.map(x => [x[0], x[1], ...x[2]])
    const refB = makeRef("b")
    const fn = makeAmpersandFunction({
      ref: refB,
      body: {
        type: "AssignmentExpression",
        children: [ lhs, ws2, refB ],
        names: null,
        lhs,
        assigned: lhs[0][1],
        expression: refB,
      },
    })
    return {
      type: "ParenthesizedExpression",
      children: [ open, fn, close ],
      expression: fn,
    }
  OpenParen:open __:ws1 IsLike:op __:ws2 PatternExpressionList:rhs CloseParen:close ->
    const refA = makeRef("a")
    const fn = makeAmpersandFunction({
      ref: refA,
      body: processBinaryOpExpression([refA, [
        [ws1, op, ws2, rhs] // BinaryOpRHS
      ]])
    })
    return {
      type: "ParenthesizedExpression",
      children: [ open, fn, close ],
      expression: fn,
    }
  OpenParen:open __:ws1 !/\+\+|--|[\+\-&]\S/ BinaryOp:op __:ws2 NonPipelineAssignmentExpression:rhs CloseParen:close ->
    const refA = makeRef("a")
    const fn = makeAmpersandFunction({
      ref: refA,
      body: processBinaryOpExpression([refA, [
        [ws1, op, ws2, rhs] // BinaryOpRHS
      ]])
    })
    return {
      type: "ParenthesizedExpression",
      children: [ open, fn, close ],
      expression: fn,
    }

# NOTE: Dynamic infix operators
OperatorDeclaration
  # `operator {x, y} := ...` declaration while blessing
  Operator:op OperatorBehavior?:behavior _:w LexicalDeclaration:decl ->
    decl.names.forEach((name) => state.operators.set(name, behavior))
    return {
      ...decl,
      children: [ trimFirstSpace(w), ...decl.children ]
    }
  # `operator id(a, b) {...}` defines a function
  OperatorSignature:signature BracedBlock:block ->
    state.operators.set(signature.id.name, signature.behavior)
    return {
      ...signature,
      type: "FunctionExpression",
      signature,
      children: [...signature.children, block],
      block,
      operator: true,
    }
  # `operator id` alone blesses `id` as an operator
  Operator:op _:w1 Identifier:id OperatorBehavior?:behavior ( CommaDelimiter _? Identifier OperatorBehavior? )*:ids ->
    state.operators.set(id.name, behavior)
    ids.forEach(([, , id2, behavior2]) => state.operators.set(id2.name, behavior2))
    return {
      id,
      children: [],
    }

# NOTE: Like FunctionSignature, but no async or star or @,
# and parameters are required (to be useful).
OperatorSignature
  ( Async _ )?:async Operator:op ( _ Function )?:func ( _? Star )?:generator _:w1 Identifier:id OperatorBehavior?:behavior _?:w2 NonEmptyParameters:parameters ReturnTypeSuffix?:returnType ->
    if (!async) async = []
    if (!generator) generator = []
    // Add "function" (if not already one) to replace "operator"
    if (!func) {
      func = { $loc: op.$loc, token: "function" }
    } else {
      func = [ trimFirstSpace(func[0]), func[1] ]
    }
    return {
      type: "FunctionSignature",
      id,
      name: id.name,
      parameters,
      returnType,
      async,
      generator,
      modifier: {
        async: !!async.length,
        generator: !!generator.length,
      },
      block: null,
      children: [ async, func, generator, w1, id, w2, parameters, returnType ],
      behavior,
    }

OperatorBehavior
  OperatorPrecedence OperatorAssociativity? ->
    return { ...$1, ...$2 }
  OperatorAssociativity OperatorPrecedence? ->
    return { ...$1, ...$2 }

OperatorPrecedence
  # inspired by https://docs.raku.org/language/functions#Precedence
  _? ( "tighter" / "looser" / "same" ):mod NonIdContinue _? ( Identifier / ( OpenParen BinaryOp CloseParen ) ):op ->
    let prec = op.type === "Identifier"
      ? state.operators.get(op.name).prec
      : getPrecedence(op[1])
    switch (mod) {
      case "tighter": prec += 1/64; break
      case "looser": prec -= 1/64; break
    }
    return {prec}

OperatorAssociativity
  # inspired by https://docs.raku.org/language/functions#Associativity
  _? ( "left" / "right" / "non" / "relational" / "arguments" ):assoc NonIdContinue ->
    if (assoc === "relational") {
      return { relational: true, assoc: "non" }
    }
    return { assoc }

ThinArrowFunction
  ( Async _ )?:async ArrowParameters:parameters ReturnTypeSuffix?:returnType _? Arrow:arrow NoCommaBracedOrEmptyBlock:block ->
    if (!async) async = []
    const generator = []

    return {
      type: "FunctionExpression",
      id: undefined,
      parameters,
      returnType,
      async,
      generator,
      block,
      signature: {
        name: undefined,
        async,
        generator,
        modifier: {
          async: !!async.length,
          generator: !!generator.length,
        },
        returnType,
      },
      children: [
        async,
        { $loc: arrow.$loc, token: "function" },
        generator,
        parameters,
        returnType,
        block
      ],
    }

Arrow
  "->" / "→" ->
    return { $loc, token: "->" }

ExplicitBlock
  # Allow single-line block only when the block starts on the same line
  _?:ws1 OpenBrace:open AllowAll ( NestedBlockStatements / SingleLineStatements / EmptyBracedContent )?:block RestoreAll __:ws2 CloseBrace:close ->
    if (!block) return $skip
    return {
      ...block,
      children: [ws1, open, ...block.children, ws2, close],
      bare: false,
    }
  # For backward compatibility with JavaScript, allow open brace to start on
  # the next line, as long as it's followed by a newline or close brace
  IndentedAtLeast:ws1 OpenBrace:open AllowAll ( NestedBlockStatements / EmptyBracedContent )?:block RestoreAll __:ws2 CloseBrace:close ->
    if (!block) return $skip
    return {
      ...block,
      children: [ws1, open, ...block.children, ws2, close],
      bare: false,
    }

EmptyBracedContent
  &( __ "}" ) ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      empty: true,
    }

ImplicitNestedBlock
  # NOTE: Check &EOS needed by eventual PushIndent to skip work if not needed
  &EOS InsertOpenBrace:open AllowAll ( NestedBlockStatements InsertNewline InsertIndent InsertCloseBrace )? RestoreAll ->
    if (!$4) return $skip
    const [block, ...tail] = $4
    return {
      ...block,
      children: [open, ...block.children, ...tail],
      bare: false,
    }

# NOTE: This is the body of if/else/for/when etc.
Block
  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock
  # NOTE: Explicit block after implicit block so that a properly indented `{}`
  # gets treated like an object literal, not an empty block.
  ExplicitBlock

  ThenClause
  # NOTE: !EOS prevents capturing a following unindented Statement
  _?:ws !EOS DeclarationOrStatement:s ->
    const expressions = [[ws, s]]
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }

BareNestedBlock
  # NOTE: Check &EOS needed by eventual PushIndent to skip work if not needed
  &EOS AllowAll NestedBlockStatements? RestoreAll ->
    if (!$3) return $skip
    return $3

# NOTE: This is the body of a case, where no braces are necessary.
# Essentially `Block` but with ImplicitNestedBlock replaced by BareNestedBlock,
# and allowing EmptyBareBlock.
BareBlock
  BareNestedBlock
  # NOTE: Explicit block after implicit block so that a properly indented `{}`
  # gets treated like an object literal, not an empty block.
  ExplicitBlock

  ThenClause
  # NOTE: !EOS prevents capturing a following unindented Statement
  _?:ws !EOS Statement:s ->
    const expressions = [[ws, s]]
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }
  EmptyBareBlock

ThenClause
  Then SingleLineStatements -> $2

BracedThenClause
  &Then InsertOpenBrace:open ThenClause:exp InsertCloseBrace:close ->
    const expressions = [exp]
    return {
      type: "BlockStatement",
      expressions,
      children: [open, expressions, " ", close],
      bare: false,
    }

# A block that must include braces (function body, try/catch/finally)
BracedOrEmptyBlock
  BracedBlock
  EmptyBlock

NoCommaBracedOrEmptyBlock
  NoCommaBracedBlock
  EmptyBlock

NoPostfixBracedOrEmptyBlock
  NoPostfixBracedBlock
  EmptyBlock

EmptyBlock
  # Implied empty block
  InsertOpenBrace InsertCloseBrace ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [$1, expressions, $2],
      bare: false,
      empty: true,
      implicit: true,
    }

# NOTE: We allow loop bodies to be empty, in which case they get a ; body
BlockOrEmptyStatement
  Block
  NoBlock EmptyStatementBareBlock -> $2

# NOTE: We allow if/else bodies to be empty, in which case they get a {} body
# (`;` would also make sense, but TypeScript doesn't allow them.)
BlockOrEmpty
  Block
  NoBlock EmptyBlock -> $2

EmptyStatementBareBlock
  # Implied empty block with empty statement (;). Used for empty loop bodies.
  InsertEmptyStatement:s ->
    const expressions = [["", s]]
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
      empty: true,
      implicit: true,
      semicolon: s.children[0],
    }

EmptyBareBlock
  # Implied empty block with no braces. Used in case statements.
  "" ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
      empty: true,
      implicit: true,
    }

NoBlock
  # Check that there isn't a block here. Used for empty loop bodies.
  &EOS !IndentedFurther !( Nested Then )
  ClosingDelimiter

# A nonempty block that must include braces
# This version allows same-line postfixes like `while cond`.
BracedBlock
  NonSingleBracedBlock
  # Nonempty one liner
  InsertOpenBrace:o !EOS PostfixedSingleLineStatements:s InsertSpace:ws InsertCloseBrace:c ->
    if (!s.children.length) return $skip
    return {
      type: "BlockStatement",
      expressions: s.expressions,
      // Remove !EOS assertion
      children: [o, s.children, ws, c],
    }

# This version forbids same-line postfixes like `while cond`, e.g., in do/try.
NoPostfixBracedBlock
  NonSingleBracedBlock
  # Nonempty one liner
  InsertOpenBrace:o !EOS SingleLineStatements:s InsertSpace:ws InsertCloseBrace:c ->
    if (!s.expressions.length) return $skip
    return {
      type: "BlockStatement",
      expressions: s.expressions,
      // Remove !EOS assertion
      children: [o, s.children, ws, c],
    }

# This version forbids top-level , operator in one-liners
NoCommaBracedBlock
  NonSingleBracedBlock
  # Nonempty one liner
  InsertOpenBrace:o !EOS PostfixedSingleLineNoCommaStatements:s InsertSpace:ws InsertCloseBrace:c ->
    if (!s.children.length) return $skip
    return {
      type: "BlockStatement",
      expressions: s.expressions,
      // Remove !EOS assertion
      children: [o, s.children, ws, c],
    }

NonSingleBracedBlock
  !EOS ExplicitBlock !TrailingOperator -> $2

  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock

  # Immediate nested array/object literal
  InsertOpenBrace:o ( NestedBulletedArray / NestedImplicitObjectLiteral ):s InsertCloseBrace:c ->
    const expressions = [s]
    return {
      type: "BlockStatement",
      expressions,
      children: [o, expressions, c],
    }

DeclarationOrStatement
  Declaration
  Statement

# NOTE: SingleLineStatements includes the empty case
SingleLineStatements
  # NOTE: Statement can start with __ via AssignmentExpression.
  # Force staying on the same line via !/\n/ assertion.
  ForbidNewlineBinaryOp ( ( _? !EOS ) DeclarationOrStatement SemicolonDelimiter )*:stmts ( ( _? !EOS ) DeclarationOrStatement SemicolonDelimiter? )?:last RestoreNewlineBinaryOp ->
    const expressions = [...stmts]
    if (last) expressions.push(last)

    // check for trailing comment
    const maybeComment = expressions.at(-1)?.[2]?.children?.[2]?.at(-1)
    const hasTrailingComment =
      maybeComment?.type === "Comment" && maybeComment.token.startsWith("//")

    const children = [expressions]
    if (hasTrailingComment) children.push("\n")

    return {
      type: "BlockStatement",
      expressions,
      children,
      bare: true,
    }

PostfixedSingleLineStatements
  ( ( _? !EOS ) StatementListItem SemicolonDelimiter )*:stmts ( ( _? !EOS ) StatementListItem SemicolonDelimiter? )?:last ->
    const children = [...stmts]
    if (last) children.push(last)

    return {
      type: "BlockStatement",
      expressions: children,
      children,
      bare: true,
    }

PostfixedSingleLineNoCommaStatements
  ( ( _? !EOS ) NoCommaStatementListItem SemicolonDelimiter )*:stmts ( ( _? !EOS ) NoCommaStatementListItem SemicolonDelimiter? )?:last ->
    const children = [...stmts]
    if (last) children.push(last)

    return {
      type: "BlockStatement",
      expressions: children,
      children,
      bare: true,
    }

NestedBlockStatements
  PushIndent NestedBlockStatement*:statements PopIndent ->
    if (!statements.length) return $skip

    // Each element of statements is a list of same-line statements. Flatten.
    statements = statements.flat()

    return {
      type: "BlockStatement",
      expressions: statements,
      children: [statements],
      bare: true,
    }

NestedBlockStatement
  Nested:nested BlockStatementPart+:statements ->
    return [
      [nested, ...statements[0]],
      ...statements.slice(1).map(s => ["", ...s]),
    ]

BlockStatementPart
  # NOTE: !EOS forces semicolon after all but last statement, forbids leading __
  # NOTE: _? allows for leading inline comments
  !EOS _?:ws StatementListItem:statement StatementDelimiter:delimiter ->
    if (ws) statement = prepend(ws, statement)
    return [statement, delimiter]

# https://262.ecma-international.org/#prod-Literal
Literal
  /(?=[0-9.'"tfyno])/ LiteralContent:literal ->
    return {
      type: "Literal",
      subtype: literal.type,
      children: [ literal ],
      raw: literal.token,
    }

LiteralContent
  NullLiteral
  BooleanLiteral
  NumericLiteral
  StringLiteral

# https://262.ecma-international.org/#prod-NullLiteral
NullLiteral
  "null" NonIdContinue ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-BooleanLiteral
BooleanLiteral
  # perf: assertion to exit early
  /(?=true|false|yes|no|on|off)/ _BooleanLiteral -> $2

_BooleanLiteral
  CoffeeBooleansEnabled CoffeeScriptBooleanLiteral -> $2
  ( "true" / "false" ) NonIdContinue ->
    return { $loc, token: $1 }

CoffeeScriptBooleanLiteral
  ( "yes" / "on" ) NonIdContinue ->
    return { $loc, token: "true" }
  ( "no" / "off" ) NonIdContinue ->
    return { $loc, token: "false" }

# NOTE: Added :symbol shorthand for Symbol.symbol or Symbol.for("symbol")
SymbolLiteral
  Colon:colon ( IdentifierName / StringLiteral ):id ->
    let name, token
    if (id.type === "Identifier") {
      ({ name, children: [ token ] } = id)
    } else {
      name = literalValue({
        type: "Literal",
        subtype: "StringLiteral",
        raw: id.token,
        children: [id],
      })
      token = id
    }
    if (config.symbols.includes(name)) { // well-known symbol
      return {
        type: "SymbolLiteral",
        children:
          id.type === "Identifier" ? [
            { ...colon, token: "Symbol." },
            token,
          ] : [
            { ...colon, token: "Symbol[" },
            token,
            "]",
          ],
        name,
      }
    } else { // use global symbol registry
      return {
        type: "SymbolLiteral",
        children: [
          { ...colon, token: 'Symbol.for(' },
          id.type === "Identifier" ? [ '"', token, '"' ] : token,
          ')'
        ],
        name,
      }
    }

# :symbol as element of object or class
SymbolElement
  SymbolLiteral -> [ "[", $1, "]" ]

# https://262.ecma-international.org/#prod-Identifier
Identifier
  # perf: assertion to exit early
  /(?=\p{ID_Start}|[_$])/ !ReservedWord IdentifierName:id -> id

# https://262.ecma-international.org/#prod-IdentifierName
IdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$])*/ ->
    return {
      type: "Identifier",
      name: $0,
      names: [$0],
      children: [{
        $loc: $loc,
        token: $0,
      }],
    }

# https://262.ecma-international.org/#prod-IdentifierReference
IdentifierReference
  Identifier

UpcomingAssignment
  &( __ "=" !( "=" / ">" ) )

# https://262.ecma-international.org/#prod-ArrayLiteral
ArrayLiteral
  # perf: assertion to exit early
  /(?=\[|\s*[.•])/ _ArrayLiteral -> $2

_ArrayLiteral
  # NOTE: Check ArrayBindingPattern case of lhs destructuring
  ArrayBindingPattern UpcomingAssignment -> $1
  OpenBracket:open AllowAll ( ArrayLiteralContent __ CloseBracket )? RestoreAll ->
    if (!$3) return $skip
    const [ content, ws, close ] = $3

    if (content.type === "RangeExpression") {
      return prepend(ws, content)
    }

    let children
    if (Array.isArray(content)) {
      children = [open, ...content, ...ws, close]
    } else {
      children = [open, content, ...ws, close]
    }

    // Gather names when ArrayLiteral is used as a destructuring pattern
    const names = children.flatMap((c) => c?.names || [])

    return {
      type: "ArrayExpression",
      children,
      names,
    }
  NestedBulletedArray

RangeDots
  DotDotDot ->
    return { ...$1,
      type: "RangeDots",
      left: { inclusive: true, raw: "" },
      right: { inclusive: false, raw: "." },
      increasing: undefined,
      triple: true,
      children: [],
    }
  OptionalRangeEnd:left _?:ws1 DotDot:dots _?:ws2 OptionalRangeEnd:right ->
    // Inherit increasing flag from either side
    const increasing = left.increasing ?? right.increasing
    if (left.increasing != null && right.increasing != null &&
        left.increasing !== right.increasing) {
      const error = {
        type: "Error",
        message: `${left.raw}..${right.raw} uses inconsistent < vs. >`,
        $loc: dots.$loc,
      }
      return {
        ...dots, left, right, increasing, error, type: "RangeDots",
        children: [error]
      }
    }
    return {
      ...dots, left, right, increasing, type: "RangeDots",
      children: [ws1, ws2]
    }

OptionalRangeEnd
  RangeEnd
  "" -> { increasing: undefined, inclusive: true, raw: "" }

RangeEnd
  /([<>])(=?)|([≤≥])/ ->
    let dir = $1, equal = $2, unicode = $3
    if (unicode) {
      equal = "="
      if (unicode === "≤") {
        dir = "<"
      } else if (unicode === "≥") {
        dir = ">"
      }
    }
    return {
      increasing: dir === "<",
      inclusive: equal === "=",
      raw: $0,
    }

RangeExpression
  Expression:start __:ws RangeDots:range Expression:end ->
    return processRangeExpression(start, ws, range, end)

  # NOTE: [x..] range to infinity, valid only in for loops
  Expression:s __:ws DotDot &( __ CloseBracket ) ->
    return {
      type: "RangeExpression",
      children: ["[]", {
        type: "Error",
        message: "Infinite range [x..] is only valid in for loops",
      }],
      start: s,
      end: {
        type: "Identifier",
        name: "Infinity",
        children: ["Infinity"],
      },
      left: { inclusive: true, raw: "" },
      right: { inclusive: true, raw: "" },
      increasing: true,
    }

ArrayLiteralContent
  RangeExpression
  # NOTE: No longer need to special-case implicit object literals separated
  # by dedented commas
  #NestedImplicitObjectLiteral ( __ Comma NestedImplicitObjectLiteral )*
  # First check for properly indented list items
  NestedElementList &( __ CloseBracket )
  # Next check for a line of items followed by properly indented list items;
  # first line should not use indented applications because they may be
  # lines of list items
  ElementListWithIndentedApplicationForbidden:list ArrayElementDelimiter:delimiter NestedElementList?:nested &( __ CloseBracket ) ->
    if (!nested) return list
    return [...list, delimiter, ...nested]
  # As fallback, ignore indentation altogether, forbidding indented applications
  ( __ ElementListWithIndentedApplicationForbidden ArrayElementDelimiter )* ->
    return $1.flat()

# "Properly nested" element lists all start at the same indentation,
# but we allow (via ArrayElementDelimiter) dedented commas between lists.
NestedElementList
  PushIndent NestedElement*:elements PopIndent ->
    if (elements.length)
      return elements.flat()
    return $skip

NestedElement
  Nested:indent ElementList:list ArrayElementDelimiter:delimiter ->
    const {length} = list
    if (!length) return $skip
    // Prepend indent to first element and append delimiter to last element
    return list.map((e, i) => {
      if (i === 0) e = prepend(indent, e)
      if (i === length - 1) e = append(e, delimiter)
      return e
    })

# Delimiter after ElementList (not within ElementList which just uses Comma)
ArrayElementDelimiter
  # NOTE: Allow arbitrary whitespace before comma to allow for breaking
  # outside indentation to separate e.g. implicit object literals
  __ Comma
  # NOTE: Don't insert comma before closing bracket
  # Ideally it would be nice to insert a trailing comma before newline followed by closing bracket, but in practice
  # it is difficult to keep the correct number of commas for elision elements. This is also closer to keeping source
  # verbatim.
  &( __ "]" )
  &EOS InsertComma -> $2

ElementListWithIndentedApplicationForbidden
  ForbidIndentedApplication ElementList? RestoreIndentedApplication ->
    if ($2) return $2
    return $skip

# https://262.ecma-international.org/#prod-ElementList
# NOTE: Modified and simplified from the spec
ElementList
  BulletedArray -> [$1]
  # NOTE: Forbid EOS to prevent eating indentation in Expression
  !EOS ArrayElementExpression:first ElementListRest*:rest ->
    if (!rest.length) return [first]
    return [
      append(first, rest[0][0])
    ].concat(
      rest.map(([_, e], i) => append(e, rest[i+1]?.[0]))
    )

ElementListRest
  # NOTE: Within ElementList, forbid newlines (EOS) before and after comma,
  # to correctly handle indentation and nested lists
  ( _? Comma !EOS ) ArrayElementExpression

# NOTE: Modified and simplified from the spec
ArrayElementExpression
  # NOTE: Prevent multiple JSX tags from combining implicitly into a fragment
  JSXTag
  ImplicitObjectLiteral &ArrayElementDelimiter -> $1
  # NOTE: Allow for postfix splat like CoffeeScript
  Expression:exp _?:ws DotDotDot:dots &ArrayElementDelimiter ->
    if (!exp) {
      exp = { ...makeRef(), names: [] }
    }

    return {
      type: "SpreadElement",
      children: [ws, dots, exp],
      expression: exp,
      names: exp.names,
    }

  # NOTE: Using PostfixedExpression, a superset of Expression to allow If/Switch expressions
  # and also allow for postfix if/for/while
  ( ( __ DotDotDot __ )? PostfixedExpression )?:expMaybeSpread &ArrayElementDelimiter ->
    if (expMaybeSpread) {
      const [spread, exp] = expMaybeSpread

      if(!spread) {
        return {
          type: "ArrayElement",
          children: [exp],
          expression: exp,
          names: exp.names,
        }
      } else {
        return {
          type: "SpreadElement",
          children: [...spread, exp],
          expression: exp,
          names: exp.names,
        }
      }
    }

    return {
      type: "ElisionElement",
      children: [],
    }

# NOTE: Nested bulleted array starts with an indentation.
NestedBulletedArray
  ( InsertSpace InsertOpenBracket ):open PushIndent AllowPipeline NestedArrayBullet*:content RestorePipeline InsertCloseBracket:close PopIndent ->
    if (!content.length) return $skip
    content = content.flat() // combine bullets into one array

    // Remove implicit comma from last element
    const last = content[content.length - 1]
    if (last.children?.at(-1)?.implicit) {
      last.children = last.children.slice(0, -1)
    }

    return {
      type: "ArrayExpression",
      children: [...open, ...content, close],
    }

# NOTE: Bulleted array intended for beginning of lines,
# when leading indentation has already been consumed.
BulletedArray
  InsertOpenBracket:open ( ArrayBullet NestedArrayBullet* )?:content InsertCloseBracket:close ->
    if (!content) return $skip
    content = [
      ...trimFirstSpace(content[0]), // replace first space with bracket
      ...content[1].flat(),
    ]

    // Remove implicit comma from last element
    let last = content[content.length - 1]
    if (last.children?.at(-1)?.implicit) {
      content[content.length - 1] = last =
        { ...last, children: last.children.slice(0, -1) }
    }

    return {
      type: "ArrayExpression",
      children: [open, ...content, close],
    }

NestedArrayBullet
  Nested:indent ArrayBullet:list ->
    // Prepend indent to first element
    return list.map((e, i) => i === 0 ? prepend(indent, e) : e)

ArrayBullet
  BulletIndent:bullet ( ElementList ArrayBulletDelimiter )?:content PopIndent ->
    if (!content) return $skip
    let [ list, delimiter ] = content
    if (!list.length) return $skip
    // Prepend bullet to first element and append delimiter to last element
    list = list.slice()
    list[0] = prepend(bullet, list[0])
    if (delimiter) {
      const last = list.length - 1
      list[last] = append(list[last], delimiter)
    }
    return list

# Like ArrayElementDelimiter but without `__ Comma` which eats unindented commas
ArrayBulletDelimiter
  _? Comma
  &EOS InsertComma -> $2

# NOTE: Unicode bullet doesn't need a space, but ASCII bullet does
BulletIndent
  Bullet ->
    const [ bullet, ws ] = $1
    const indent = {
      token: " " + ws,
      $loc,
      level: getIndentLevel(" ".repeat(state.currentIndent.level) + bullet + ws, config.tab)
    }
    if (config.verbose) console.log("pushing bullet indent", indent)
    state.indentLevels.push(indent)
    return indent

Bullet
  "•" [ \t]*
  "." [ \t]+

BulletedArrayWithTrailing
  BulletedArray:array AllowedTrailingCallExpressions?:trailing ( NotDedented Pipe __ PipelineTailItem )*:pipeline ->
    if (trailing) {
      array = [ array, trailing ]
    }
    if (pipeline.length) {
      array = {
        type: "PipelineExpression",
        children: [ undefined, array, pipeline ],
      }
    }
    return array

# https://262.ecma-international.org/#prod-ObjectLiteral
# NOTE: Slightly simplified from spec
ObjectLiteral
  # NOTE: Check for object binding pattern in case of destructuring to an object lhs
  ObjectBindingPattern UpcomingAssignment -> $1
  BracedObjectLiteral
  NestedImplicitObjectLiteral
  InlineObjectLiteral

BracedObjectLiteral
  OpenBrace:open AllowAll ( BracedObjectLiteralContent __ CloseBrace )? RestoreAll ->
    if (!$3) return $skip
    const [ properties, ...close ] = $3

    return {
      type: "ObjectExpression",
      children: [open, properties, close],
      names: properties.flatMap((c) => c.names || []),
      properties,
    }

BracedObjectLiteralContent
  # Allow unnested comma-separated properties on first line, optionally
  # followed by nested comma-separated properties on further lines
  ( PropertyDefinition ObjectPropertyDelimiter )*:line NestedPropertyDefinitions?:nested ->
    line = line.flatMap(([prop, delim]) => {
      // Allow each prop to be a single Property object or an array of such
      prop = Array.isArray(prop) ? prop : [prop]
      let last = prop[prop.length-1]
      if (!last) return []
      last = {
        ...last,
        delim,
        children: [ ...last.children, delim ]
      }
      return [...prop.slice(0, prop.length-1), last]
    })
    return line.concat(nested || [])
  # As a backup, allow for arbitrary untracked indentation
  ( __ PropertyDefinition ObjectPropertyDelimiter )+ ->
    return $0.flatMap(([ws, prop, delim]) => {
      // Allow each prop to be a single Property object or an array of such
      prop = Array.isArray(prop) ? prop : [prop]
      let last = prop[prop.length-1]
      last = {
        ...last,
        delim,
        // __ will consume all whitespace that _? in PropertyDefinition could,
        // so replace _? (via slice) with __
        children: [ ws, ...last.children.slice(1), delim ]
      }
      return [...prop.slice(0, prop.length-1), last]
    })

# NOTE: Nested implicit object literal starts with an indentation.
# All properties can be spaced out and must have a colon.
NestedImplicitObjectLiteral
  InsertOpenBrace PushIndent AllowPipeline NestedImplicitPropertyDefinitions?:properties RestorePipeline PopIndent InsertNewline InsertIndent InsertCloseBrace ->
    if (!properties) return $skip
    return {
      type: "ObjectExpression",
      properties,
      children: $0,
    }

NestedImplicitPropertyDefinitions
  NestedImplicitPropertyDefinition+:defs ->
    return defs.flat()

NestedImplicitPropertyDefinition
  Nested:indent ( _? NamedProperty ObjectPropertyDelimiter )+:props ->
    return props.map(([ws, prop, delimiter], i) => ({
      ...prop,
      children: [
        ...(i === 0 ? [indent, ws] : [ws]),
        ...prop.children,
        delimiter
      ],
    }))

NestedPropertyDefinitions
  PushIndent NestedPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs.flat()

NestedPropertyDefinition
  # TODO: This may be a little weird/ambiguous with single identifier shorthand
  Nested:ws ( PropertyDefinition ObjectPropertyDelimiter )+:inlineProps ->
    return inlineProps.flatMap( ([prop, delim], i) => {
      // Allow each prop to be a single Property object or an array of such
      if (!Array.isArray(prop)) prop = [prop]
      if (i === 0) {
        const [first, ...rest] = prop
        prop = [ prepend(ws, first), ...rest ]
      }
      const last = prop[prop.length-1]
      prop = [
        ...prop.slice(0, prop.length-1),
        {
          ...last,
          delim,
          children: [ ...last.children, delim ]
        }
      ]
      return prop
    })

# NOTE: Implicit object literals are intended for beginnings of lines,
# but where the indentation has already been consumed.
# They can span multiple lines at the same indentation level.
# They must start with a snug property, and all properties must have a colon.
ImplicitObjectLiteral
  InsertInlineOpenBrace:open SnugNamedProperty:first ( ImplicitObjectPropertyDelimiter NamedProperty )*:rest ( _? Comma )?:trailing InsertCloseBrace:close ->
    return {
      type: "ObjectExpression",
      children: [open, first, ...rest, trailing, close],
    }

# This is different from ObjectPropertyDelimiter because the braces are implicit so we can't look ahead to find the closing one
# Instead we see if the next line matches a NamedProperty and if so we insert a comma
ImplicitObjectPropertyDelimiter
  _? Comma ( NotDedented / _? )
  &( Nested NamedProperty ) InsertComma Nested -> [$2, $3]

# NOTE: Inline object literals are intended for within expressions.
# They can only go onto another line if there's a trailing comma.
# They must start with a snug property, and all properties must have a colon.
InlineObjectLiteral
  InsertInlineOpenBrace:open SnugNamedProperty:first ( InlineObjectPropertyDelimiter NamedProperty )*:rest ( _? Comma &Dedented )?:trailing InsertCloseBrace:close ->
    return {
      type: "ObjectExpression",
      children: [open, first, ...rest, trailing, close],
    }

InlineObjectPropertyDelimiter
  _? Comma ( NotDedented / _? )

ObjectPropertyDelimiter
  _? Comma
  # Object closing delimits the property
  &( __ "}" )
  &EOS InsertComma -> $2

# https://262.ecma-international.org/#prod-PropertyDefinition
# NOTE: Must start on same line
PropertyDefinition
  _?:ws NamedProperty:prop ->
    return prepend(ws, prop)

  # NOTE: Added LiveScript flagging shorthand {+x, -y} -> {x: true, y: false}
  # NOTE: extended to allow {!y} -> {y: false}
  # NOTE: Must be after NamedProperty
  _?:ws $[!+-]?:toggle PropertyName:id &ObjectPropertyDelimiter ->
    if (toggle) {
      const value = toggle === "+" ? "true" : "false"
      return {
        type: "Property",
        children: [ws, id, ": ", value],
        name: id,
        names: id.names,
        value,
      }
    }

    return {
      type: "Property",
      children: [ws, id],
      name: id,
      names: id.names,
      value: id,
    }

  _?:ws MethodDefinition:def ->
    // Add commas between multiple method definitions (from globs)
    if (def.type === "MultiMethodDefinition") {
      return {
        children: def.children.flatMap((c, i) => i ? [",", c] : [c])
      }
    }
    // NOTE: Forbidding EmptyBlock in MethodDefinition to allow `foo()`
    // shorthand for `foo: foo()`
    if (!def.block || def.block.empty) return $skip
    return prepend(ws, def)
  _?:ws DotDotDot:dots Expression:exp ->
    return {
      type: "SpreadProperty",
      children: [ws, dots, exp],
      names: exp.names,
      dots,
      value: exp,
    }

  # NOTE: Added `{x.y?.z()}` shorthand for `{z: x.y?.z()}`
  # NOTE: this needs to be at the bottom to prevent shadowing NamedProperty
  # NOTE: Prevent `.x` from expanding to `x: $ => $.x`
  _?:ws !( EOS / "." ) UnaryOp*:pre CallExpression:value UnaryPostfix?:post ->
    if (!pre.length && !post) {
      switch (value.type) {
        // `{identifier}` remains `{identifier}`, the one shorthand JS supports
        case "Identifier":
          return prepend(ws, value)
        // PropertyGlob like x.{a,b} turns into ObjectExpression {a: x.a, b: x.b}
        // (via `processCallMemberExpression`)
        case "ObjectExpression":
          let first = value.properties[0]
          if (first) {
            first = {
              ...first,
              children: [ws, ...first.children],
              hoistDec: value.hoistDec
            }
          }
          return [ first, ...value.properties.slice(1) ]
      }
    }
    const last = lastAccessInCallExpression(value)
    if (!last) return $skip

    let name, ref, refAssignment
    const { expression, type } = last
    if (type === "Index") {
      // TODO: If `last` is a suitable string literal, could use it for `name`.
      ({ ref, refAssignment } = maybeRefAssignment(expression))
      if (refAssignment) {
        name = {
          type: "ComputedPropertyName",
          children: [last.children[0], "(", refAssignment, ",", ref, ")", ...last.children.slice(-2)],
        }

        value = {
          ...value,
          children: value.children.map((c) => {
            if (c === last) return {
              type: "Index",
              children: ["[", ref, "]"],
            }
            return c
          })
        }
      } else {
        name = {
          type: "ComputedPropertyName",
          children: last.children,
        }
      }
    } else {
      ({name} = last)
      if (!name) return $skip
    }

    // Private name becomes public
    if (name[0] === "#") name = name.slice(1)

    return {
      type: "Property",
      children: [ws, name, ": ", processUnaryExpression(pre, value, post)],
      name,
      names: [],
      value,
    }
  # NOTE: basic identifiers are now part of the rule above
  #_?:ws IdentifierReference:id ->
  #  return prepend(ws, id)
  InsertDotDotDot:dots IterationExpression:exp ->
    let { statement } = exp

    // immutably set exp.statement.object = true
    statement = { ...statement, object: true }
    exp = {
      ...exp,
      statement,
      children: exp.children.map(($) => $ === exp.statement ? statement : $),
    }

    const children = [dots, exp]
    if (statement.reduction) {
      children.unshift({
        type: "Error",
        message: "Reduction loops are forbidden in object literals",
      })
    }

    return {
      type: "SpreadProperty",
      children,
      names: exp.names,
      dots,
      value: exp,
    }

NamedProperty
  # NOTE: CoverInitializedName early error doesn't seem necessary with this parser
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  PropertyName:name _? Colon PostfixedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      name: name,
      names: exp.names || [],
      value: exp,
    }

# Named property but doesn't allow any space between name and colon
# used to distinguish between braceless inline objects and ternary expression conditions
# Allow postfixed expression only if this first property isn't the last
SnugNamedProperty
  PropertyName:name Colon:colon MaybeNestedExpression:expression ( ( _? PostfixStatement ) &( Nested NamedProperty ) )?:post ->
    if (post) {
      // post[0] drops the lookahead assertion
      expression = attachPostfixStatementAsExpression(expression, post[0])
    }
    return {
      type: "Property",
      children: [name, colon, expression],
      name,
      names: expression.names || [],
    }

PropertyName
  # https://262.ecma-international.org/#prod-LiteralPropertyName
  NumericLiteral
  ComputedPropertyName
  # NOTE: ComputedPropertyName must be before StringLiteral,
  # so that CoffeeScript interpolated strings get checked first.
  StringLiteral
  # NOTE: Content-Type -> "Content-Type"
  $(IdentifierName? "-" /(?:\p{ID_Continue}|[\u200C\u200D$-])*/) ->
    return {
      token: `"${$1}"`,
      $loc,
    }
  IdentifierName
  LengthShorthand
  SymbolElement

ComputedPropertyName
  # https://262.ecma-international.org/#prod-ComputedPropertyName
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  OpenBracket PostfixedExpression:expression __ CloseBracket ->
    return {
      type: "ComputedPropertyName",
      children: $0,
      expression,
    }
  # NOTE: Extending to allow template literals without brackets
  InsertOpenBracket TemplateLiteral:expression InsertCloseBracket ->
    // Check for CoffeeScript interpolated double-quote string
    // without interpolation
    if ($2.type === "StringLiteral") return $2
    return {
      type: "ComputedPropertyName",
      children: $0,
      expression,
      implicit: true,
    }
  InsertOpenBracket [+-] NumericLiteral InsertCloseBracket ->
    const expression = [ $2, $3 ]
    return {
      type: "ComputedPropertyName",
      expression,
      children: [ $1, expression, $4 ],
      implicit: true,
    }

Decorator
  # Might want to disallow import, super, and return CallExpressions
  AtAt CallExpression

Decorators
  ForbidClassImplicitCall ( __ Decorator )*:decorators __ RestoreClassImplicitCall ->
    if (!decorators.length) return $skip
    return $0

# https://262.ecma-international.org/#prod-MethodDefinition
MethodDefinition
  Abstract __ MethodSignature:signature ->
    return {
      type: "MethodDefinition",
      children: $0,
      name: signature.name,
      abstract: true,
      signature,
      parameters: signature.parameters,
      ts: true
    }
  # NOTE: Not adding extra validation using PropertySetParameterList
  # NOTE: If this node layout changes, be sure to update `convertMethodTOFunction`
  MethodSignature:signature !(PropertyAccess / UnaryPostfix / NonNullAssertion) BracedBlock?:block ->
    let children = $0
    let generatorPos = 0
    let { modifier } = signature

    if (hasAwait(block)) {
      generatorPos++
      children = children.slice()
      // get or set
      if (modifier?.get || modifier?.set) {
        children.push({
          type: "Error",
          message: "Getters and setters cannot be async",
        })
      } else if(modifier?.async) {
        // Do nothing, already async
      } else {
        // Insert implicit async
        children.unshift("async ")
        modifier = { ...modifier, async: true }
        signature = { ...signature, modifier }
      }
    }

    if (hasYield(block)) {
      if (children === $0) children = children.slice()

      // get or set
      if (modifier?.get || modifier?.set) {
        children.push({
          type: "Error",
          message: "Getters and setters cannot be generators",
        })
      } else if(modifier?.generator) {
        // Do nothing, already generator
      } else {
        // Insert implicit generator
        children.splice(generatorPos, 0, "*")
        modifier = { ...modifier, generator: true }
        signature = { ...signature, modifier }
      }
    }

    return {
      type: "MethodDefinition",
      children,
      name: signature.name,
      signature,
      block,
      parameters: signature.parameters,
    }

  # shorthand get method definition
  GetOrSet:kind _?:ws ForbidIndentedApplication ( MemberBase CallExpressionRest* ReturnTypeSuffix? )?:content RestoreIndentedApplication BracedBlock?:block ->
    if (!content) return $skip
    const [ base, rest, returnType ] = content
    const value = [ base, rest ]

    if (!rest.length) {
      let name
      if (base.type === "MemberExpression") {
        const lastAccess = lastAccessInCallExpression(base)
        if (lastAccess) {
          ({ name } = lastAccess)
        }
      }

      if (!name) ({ name } = base)
      if (!name) return $skip

      // Remove leading # from private identifier since it makes no
      // sense for a private getter to point to itself
      if (name[0] === "#") name = name.slice(1)

      // Skip autoReturn for identifiers with an explicit block like `get foo { true }`
      const autoReturn = !block || base.type !== "Identifier"
      return makeGetterMethod(name, ws, base, returnType, block, kind, autoReturn)
    }

    let last = rest[rest.length-1]
    while (Array.isArray(last)) {
      last = last[last.length-1]
    }

    switch(last.type) {
      case "Call":
        return $skip
      case "PropertyAccess":
        const { name } = last
        return makeGetterMethod(name, ws, value, returnType, block, kind)
      case "PropertyGlob":
        return {
          type: "MultiMethodDefinition",
          children: last.object.properties.map((p) => {
            const { name, type } = p
            let v
            switch (type) {
              case "Identifier":
                v = trimFirstSpace(p)
                break
              case "Property":
                const { value } = p
                if (value.privateShorthand) {
                  v = value.privateId
                } else {
                  v = trimFirstSpace(value)
                }
                break
            }
            const exp = processCallMemberExpression({
              type: "CallExpression",
              children: [base, ...rest.slice(0, -1), {
                type: "PropertyAccess",
                children: [last.dot, {
                  ...v,
                  children: [ v.children.slice(0, 2) ] // Remove potential delimiter
                }],
              }],
            })

            return makeGetterMethod(name, ws, exp, returnType, block, kind)
          })
        }
    }

    const lastAccess = lastAccessInCallExpression({children: rest})
    const { name } = lastAccess

    return makeGetterMethod(name, ws, value, returnType, block, kind)

MethodModifier
  # NOTE: Merged get/set definitions
  GetOrSet:kind _? &ClassElementName ->
    return {
      type: "MethodModifier",
      async: false,
      generator: false,
      get: kind.token === "get",
      set: kind.token === "set",
      children: $0,
    }
  # NOTE: Merged async and generator into MethodModifier
  ( Async __ ) ( Star __ )? ->
    return {
      type: "MethodModifier",
      async: true,
      get: false,
      set: false,
      generator: !!$2,
      children: $0,
    }
  Star __ ->
    return {
      type: "MethodModifier",
      async: false,
      get: false,
      set: false,
      generator: true,
      children: $0,
    }

# TypeScript method signature
MethodSignature
  ConstructorShorthand NonEmptyParameters:parameters ->
    return {
      type: "MethodSignature",
      children: $0,
      name: $1.token,
      modifier: {},
      returnType: undefined,
      parameters,
    }

  # NOTE: If this node layout changes, be sure to update
  # `convertMethodToFunction` and `[3]` in code below
  MethodModifier?:modifier ClassElementName:name _? QuestionMark?:optional _? NonEmptyParameters:parameters ReturnTypeSuffix?:returnType ->
    // Normalize name so we can check if it is `constructor`
    if (name.name) {
      name = name.name
    } else if (name.token) {
      name = name.token.match(/^(?:"|')/) ? name.token.slice(1, -1) : name.token
    }

    // TypeScript supports optional methods with bodies; remove ? from JS output
    if (optional) $0[3] = optional = { ...optional, ts: true }

    modifier = modifier || {}

    return {
      type: "MethodSignature",
      children: $0,
      name,
      optional,
      modifier, // get/set/async/generator
      returnType,
      parameters,
    }

ClassElementName
  PropertyName
  LengthShorthand
  PrivateIdentifier
  SymbolElement

PrivateIdentifier
  $(Hash IdentifierName):id ->
    return {
      type: "Identifier",
      name: id,
      names: [id],
      children: [{
        $loc: $loc,
        token: id,
      }],
    }

# https://262.ecma-international.org/#prod-GeneratorDeclaration
# https://262.ecma-international.org/#prod-GeneratorExpression
# NOTE: Merged GeneratorExpression and GeneratorDeclaration into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncFunctionDeclaration
# https://262.ecma-international.org/#prod-AsyncFunctionExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorDeclaration
# https://262.ecma-international.org/#prod-AsyncGeneratorExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorMethod
# https://262.ecma-international.org/#prod-AsyncGeneratorBody
# https://262.ecma-international.org/#prod-AsyncMethod
# https://262.ecma-international.org/#prod-AsyncFunctionBody
# https://262.ecma-international.org/#prod-GeneratorMethod
# https://262.ecma-international.org/#prod-GeneratorBody
# NOTE: Merged into MethodDefinition

# NOTE: Allow arbitrary whitespace before regular assignment,
# but only allow non-newline whitespace before operator assignment.
WAssignmentOp
  __ AssignmentOp
  _? OperatorAssignmentOp

# https://262.ecma-international.org/#prod-AssignmentOperator
AssignmentOp
  AssignmentOpSymbol _? ->
    if ($2?.length) {
      if (typeof $1 !== "string") {
        return { ...$1, children: [...$1.children, $2] }
      }
      return {
        token: $1,
        children: [$1, ...$2]
      }
    }

    if (typeof $1 !== "string") return $1
    return { $loc, token: $1 }

# NOTE: x foo= y expands to x = foo(x, y)
# This is separate from AssignmentOp because it only works in certain contexts
# (in particular, not at the beginning of a line).
OperatorAssignmentOp
  Xor Equals _? ->
    return {
      special: true,
      call: getHelperRef("xor"),
      children: [$2, ...$3 || []]
    }
  Xnor Equals _? ->
    return {
      special: true,
      call: getHelperRef("xnor"),
      children: [$2, ...$3 || []]
    }
  # NOTE: //= needs to be here because otherwise __ before AssignmentOp
  # consumes // as a JS comment
  CoffeeDivEnabled "//" Equals _? ->
    return {
      special: true,
      call: getHelperRef("div"),
      children: [$3, ...$4 || []],
    }
  Identifier Equals _? ->
    return {
      special: true,
      call: $1,
      children: [$2, ...$3 || []]
    }

AssignmentOpSymbol
  "**="
  "*="
  # NOTE: CoffeeScript //= is in OperatorAssignmentOp
  ( "%/" / "÷" ) Equals ->
    return {
      special: true,
      call: getHelperRef("div"),
      children: [$2],
    }
  "%%" Equals ->
    return {
      special: true,
      call: getHelperRef("modulo"),
      children: [$2],
    }
  "/="
  "%="
  ( "++" / "⧺" ) Equals ->
    return {
      special: true,
      call: getHelperRef("concatAssign"),
      omitLhs: true,
      children: [$2],
    }
  "+="
  "-="
  "<<="
  "≪=" -> "<<="
  ">>>="
  "⋙=" -> ">>>="
  ">>="
  "≫=" -> ">>="
  "&&="
  "&="
  "^="
  "||="
  "‖=" -> "||="
  "|="
  "??="
  "⁇=" -> "??="
  "?=" -> "??="
  # NOTE: assertion to avoid matching part of a comparison op or arrow
  "=" ![=>] -> $1
  CoffeeWordAssignmentOp -> $1

CoffeeWordAssignmentOp
  "and=" -> "&&="
  "or=" -> "||="

# NOTE: Similar to `NotDedented BinaryOp`,
# but forbid Nested with custom infix operators
NotDedentedBinaryOp
  IndentedFurther?:ws1 _?:ws2 BinaryOp:op ->
    const ws = []
    if (ws1) ws.push(...ws1)
    if (ws2) ws.push(...ws2)
    return [ ws, op ]
  NestedBinaryOpAllowed Nested:ws1 _?:ws2 !Identifier ( !"*" / !ImportDeclaration ) BinaryOp:op ->
    const ws = [...ws1]
    if (ws2) ws.push(...ws2)
    return [ ws, op ]

IdentifierBinaryOp
  Identifier:id ->
    if (state.operators.has(id.name)) return id
    return $skip

BinaryOp
  /(?=\p{ID_Start}|[_$^≪≫⋙≤≥∈∋∉∌≣≡≢≠=⩶⩵‖⁇&|*\/!?%÷<>⧺+-])/ _BinaryOp:op -> op

_BinaryOp
  BinaryOpSymbol ->
    if (typeof $1 === "string") return { $loc, token: $1 }
    return $1
  Identifier:id ->
    if (!state.operators.has(id.name)) return $skip
    return {
      token: id.name,
      call: id,
      special: true,
      ...state.operators.get(id.name),
    }
  OmittedNegation __ Identifier:id ->
    if (!state.operators.has(id.name)) return $skip
    return {
      token: id.name,
      call: id,
      special: true,
      negated: true,
      ...state.operators.get(id.name),
    }

# NOTE: Condensed binary operator symbols into one rule
BinaryOpSymbol
  "**"
  "*"
  "%/" / "÷" / ( CoffeeDivEnabled "//" ) ->
    return {
      call: getHelperRef("div"),
      special: true,
      prec: '/',
    }
  "%%" ->
    return {
      call: getHelperRef("modulo"),
      special: true,
      prec: '%',
    }
  # NOTE: %/ and %% must be above %
  # NOTE: // must be above /
  "/"
  "%"
  "++" / "⧺" ->
    return {
      method: "concat",
      special: true,
    }
  # NOTE: ++ must be above +
  "+"
  "-"
  "<="
  "≤" -> "<="
  ">="
  "≥" -> ">="
  # NOTE: added <? instanceof shorthand
  "<?" ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
    }
  "!<?" ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
      negated: true,
    }
  "<<"
  "≪" -> "<<"
  "<"
  ">>>"
  "⋙" -> ">>>"
  ">>"
  "≫" -> ">>"
  ">"
  "!=="
  "≢" -> "!=="
  # NOTE: CoffeeScript converts "!=" -> "!=="
  # Convert if CoffeeScript compat flag is set
  "!=" / "≠" ->
    if(config.coffeeEq) return "!=="
    return "!="
  "isnt" NonIdContinue ->
    if(config.coffeeIsnt) return "!=="
    return $skip
  "==="
  "≣" / "⩶" -> "==="
  # NOTE: CoffeeScript converts "==" -> "==="
  # Convert if CoffeeScript compat flag is set
  "==" / "≡" / "⩵" ->
    if(config.coffeeEq) return "==="
    return "=="
  "and" NonIdContinue -> "&&"
  "&&"
  "or" NonIdContinue -> "||"
  "||"
  "‖" -> "||"
  # NOTE: ^^ must be above ^
  "^^" / ( "xor" NonIdContinue ) ->
    return {
      call: getHelperRef("xor"),
      special: true,
      prec: '^^',
    }
  /!\^\^?/ / ( "xnor" NonIdContinue ) ->
    return {
      call: getHelperRef("xnor"),
      special: true,
      prec: '^^',
    }
  "??"
  "⁇" -> "??"
  "?" CoffeeBinaryExistentialEnabled -> "??"
  "instanceof" NonIdContinue ->
    return {
      $loc,
      token: $1,
      relational: true,
      special: true, // for typeof shorthand
    }
  CoffeeOfEnabled CoffeeOfOp:op -> op
  OmittedNegation __ NotOp:op ->
    return { ...op, $loc }
  ( Is __ In ) / "∈" ->
    return {
      method: "includes",
      relational: true,
      reversed: true,
      special: true,
    }
  "∋" ->
    return {
      method: "includes",
      relational: true,
      special: true,
    }
  "∌" ->
    return {
      method: "includes",
      relational: true,
      special: true,
      negated: true,
    }
  ( Is __ OmittedNegation __ In ) / "∉" ->
    return {
      method: "includes",
      relational: true,
      reversed: true,
      special: true,
      negated: true,
    }
  # NOTE: "is not" must come after "is not in"
  !CoffeeNotEnabled Is __ Not ->
    if (config.objectIs) {
      return {
        call: getHelperRef("is"),
        relational: true,
        special: true,
        asConst: true,
        negated: true,
      }
    }
    return "!=="
  # NOTE: "is" must come after "is not" and "is in"
  Is ->
    if (config.objectIs) {
      return {
        call: getHelperRef("is"),
        relational: true,
        special: true,
        asConst: true,
      }
    }
    return "==="
  In
  "&"
  "^"
  "|"

ActualIn
  CoffeeOfEnabled Of -> $2
  !CoffeeOfEnabled In -> $2

CoffeeOfOp
  Of -> "in"
  In ->
    return {
      call: [getHelperRef("indexOf"), ".call"],
      relational: true,
      reversed: true,
      suffix: " >= 0",
      special: true,
    }
  OmittedNegation __ Of NonIdContinue ->
    return {
      $loc,
      token: "in",
      special: true,
      negated: true,
    }
  OmittedNegation __ In ->
    return {
      call: [getHelperRef("indexOf"), ".call"],
      relational: true,
      reversed: true,
      suffix: " < 0",
      special: true,
    }

NotOp
  "instanceof" NonIdContinue ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
      negated: true,
    }
  In ->
    return {
      $loc,
      token: "in",
      special: true,
      negated: true,
    }

Xor
  "^^" / ( "xor" NonIdContinue )
Xnor
  /!\^\^?/ / "xnor"

UnaryOp
  # Lookahead to prevent unary operators from overriding update operators
  # ++/-- or block unary operator shorthand
  /(?!\+\+|--)[!~+-](?!\s)/ ->
    return { $loc, token: $0 }
  AwaitOp
  ( Delete / Void / Typeof ):op ![:.] _?:ws ->
    if (!ws) return [op, [" "]]
    return [op, ws]
  Not ![:.] " "? _? -> [$1, $4]

# https://github.com/tc39/proposal-await.ops
AwaitOp
  Await:a ( Dot IdentifierName )?:op _?:ws ->
    return {
      ...a,
      op,
      children: [a, ...(ws || [" "])],
    }

# https://262.ecma-international.org/#prod-ModuleItem
ModuleItem
  IsBare ( ImportDeclaration / ExportDeclaration ) -> $2
  StatementListItem

# https://262.ecma-international.org/#prod-StatementListItem
StatementListItem
  Declaration
  # NOTE: Allow bulleted array literals as top-level statements.
  BulletedArrayWithTrailing:array
  # NOTE: Allow multi-line implicit object literals as top-level statements.
  ImplicitObjectLiteral ->
    return makeLeftHandSideExpression($1)
  # NOTE: Added postfix conditionals/loops
  PostfixedStatement

PostfixedStatement
  Statement:statement ( _? PostfixStatement )?:post ->
    if (post) return addPostfixStatement(statement, ...post)
    return statement

NoCommaStatementListItem
  Declaration
  # NOTE: Added postfix conditionals/loops
  PostfixedNoCommaStatement

PostfixedNoCommaStatement
  NoCommaStatement:statement ( _? PostfixStatement )?:post ->
    if (post) return addPostfixStatement(statement, ...post)
    return statement

PostfixedExpression
  Expression:expression ( _? PostfixStatement )?:post ->
    if (post) return attachPostfixStatementAsExpression(expression, post)
    return expression

# Expression with postfixes *or* comma operators (mixing seems ambiguous)
PostfixedCommaExpression
  PostfixedExpression:expression ( ( _? PostfixStatement ) / ( CommaDelimiter AssignmentExpression )* ):post ->
    if (!post.length) return $1
    if (post.length === 2 && !Array.isArray(post[1])) {
      return attachPostfixStatementAsExpression(expression, post)
    }
    return $0

PostfixStatement
  /(?=for|if|loop|unless|until|while)/ _PostfixStatement -> $2

_PostfixStatement
  ForClause
  IfClause
  LoopClause
  WhileClause

# https://262.ecma-international.org/#prod-Statement
Statement
  KeywordStatement
  VariableStatement
  IfStatement !ShouldExpressionize -> $1
  IterationStatement !ShouldExpressionize ->
    // Leave generator forms for IterationExpression
    if ($1.generator) return $skip
    // Leave `for` reductions for IterationExpression
    if ($1.reduction) return $skip
    return $1
  SwitchStatement !ShouldExpressionize -> $1
  TryStatement !ShouldExpressionize -> $1

  EmptyStatement

  LabelledStatement

  CommaExpressionStatement

  # NOTE: Block statement is after expression statement because valid ObjectLiterals should take priority over blocks
  BlockStatement

  # NOTE: no WithStatement

# NOTE: Leave statement with trailing call expressions or pipe operator
# to be expressionized by
# ExpressionizedStatementWithTrailingCallExpressions
ShouldExpressionize
  AllowedTrailingCallExpressions
  NotDedented Pipe
  BinaryOpRHS
  UnaryPostfix

# Variant of Statement to forbid , operator (CommaExpression)
NoCommaStatement
  KeywordStatement
  VariableStatement
  IfStatement
  IterationStatement
  SwitchStatement
  TryStatement
  EmptyStatement
  LabelledStatement
  ExpressionStatement
  BlockStatement

# NOTE: EmptyStatement handled differently than spec, consuming inline whitespace and comments then asserting following semi-colon
EmptyStatement
  _? &";" ->
    return { type: "EmptyStatement", children: $1 || [] }

InsertEmptyStatement
  InsertSemicolon ->
    return { type: "EmptyStatement", children: [$1], implicit: true }

# https://262.ecma-international.org/#prod-BlockStatement
BlockStatement
  # NOTE: Added lookahead for `=` to allow for destructuring assignment without parens
  ExplicitBlock !( __ "=" ) -> $1

# https://262.ecma-international.org/#prod-LabelledStatement
LabelledStatement
  Label:label LabelledItem:statement ->
    return {
      type: "LabelledStatement",
      label,
      statement,
      children: $0,
    }

Label
  # NOTE: `:label` instead of `label:` to not clash with implicit object literal
  Colon:colon Identifier:id Whitespace:w ->
    return {
      type: "Label",
      name: id.name,
      children: [ id, colon, w ]
    }

# Argument to break/continue, which can include colon or not in input,
# but should not have colon in output
LabelIdentifier
  Colon? Identifier:id -> id

LabelledItem
  Statement
  FunctionDeclaration

# https://262.ecma-international.org/#prod-IfStatement
IfStatement
  # NOTE: Allow indentation in condition when there's an explicit `then` clause
  ( If / Unless ):kind _?:ws BoundedCondition:condition Then BlockOrEmpty:block ElseClause?:e ->
    if (kind.negated) {
      kind = { ...kind, token: "if" }
      condition = negateCondition(condition)
    }
    // Ensure semicolon separating single line from `else`
    if (block.bare && e) {
      const semicolon = ";"
      block = {
        ...block,
        semicolon,
        children: [...block.children, semicolon],
      }
    }
    return {
      type: "IfStatement",
      children: [ kind, ws, condition, block, e],
      condition,
      negated: kind.negated,
      then: block,
      else: e,
    }
  # NOTE: Block isn't Statement so we can handle implied braces by nesting
  IfClause:clause BlockOrEmpty:block ElseClause?:e ->
    // Ensure semicolon separating single line from `else`
    if (block.bare && e) {
      block = {
        ...block,
        semicolon: ";",
        children: [...block.children, ";"],
      }
    }
    return {
      type: "IfStatement",
      children: [...clause.children, block, e],
      condition: clause.condition,
      negated: clause.negated,
      then: block,
      else: e,
    }

ElseClause
  ( Nested / _? ) Else BlockOrEmpty:block -> {
    type: "ElseClause",
    children: $0,
    block,
  }

IfClause
  ( If / Unless ):kind _?:ws Condition:condition ->
    if (kind.negated) {
      kind = { ...kind, token: "if" }
      condition = negateCondition(condition)
    }

    return {
      type: "IfStatement",
      children: [ kind, ws, condition ],
      condition,
      negated: kind.negated,
    }

# https://262.ecma-international.org/#prod-IterationStatement
IterationStatement
  /(?=loop|comptime|do|for|until|while)/ _IterationStatement -> $2

_IterationStatement
  # NOTE: Added `loop` from CoffeeScript
  LoopStatement
  !CoffeeDoEnabled DoWhileStatement -> $2
  # DoStatement must come after DoWhile statement
  !CoffeeDoEnabled DoStatement -> $2
  ComptimeStatement
  WhileStatement
  ForStatement

IterationExpression
  ( Async __ )?:async IterationStatement:statement ->
    return {
      type: "IterationExpression",
      subtype: statement.type,
      children: [statement],
      block: statement.block,
      statement,
      async,
      generator: statement.generator
    }

# NOTE: Added from CoffeeScript
LoopStatement
  LoopClause:clause BlockOrEmptyStatement:block ->
    return {
      ...clause,
      type: "IterationStatement",
      children: [...clause.children, block],
      block,
    }

LoopClause
  Loop:kind ( _? Star )?:generator ->
    const expression = {
      type: "Literal",
      children: ["true"],
      raw: "true",
    }
    const condition = {
      type: "ParenthesizedExpression",
      children: [ "(", expression, ")" ],
      expression,
    }
    return {
      type: "IterationStatement",
      subtype: kind.token,
      children: [kind, condition],
      condition,
      generator,
    }

# https://262.ecma-international.org/#prod-DoWhileStatement
DoWhileStatement
  # NOTE: Condition provides optional parens
  Do:d ( _? Star )?:generator NoPostfixBracedOrEmptyBlock:block __:ws WhileClause:clause ->
    return {
      ...clause,
      type: "IterationStatement",
      subtype: "do-while",
      children: [ d, block, ws, clause ],
      block,
      generator,
    }

DoStatement
  Do:d ( _? Star )?:generator NoPostfixBracedOrEmptyBlock:block ->
    block = trimFirstSpace(block)
    return {
      type: "DoStatement",
      children: [block],
      block,
      generator,
    }

ComptimeStatement
  Comptime NoPostfixBracedOrEmptyBlock:t ElseClause?:e ->
    // Wrap the else block if present and comptime is off
    let block = !initialConfig.comptime && e?.block || t
    block = trimFirstSpace(block)
    return {
      type: "ComptimeStatement",
      children: [block],
      block,
      // In case we want access to the original blocks:
      then: t,
      else: e,
    }

# https://262.ecma-international.org/#prod-WhileStatement
WhileStatement
  # NOTE: Condition provides optional parens
  WhileClause:clause BlockOrEmptyStatement:block ->
    return {
      ...clause,
      children: [...clause.children, block],
      block,
    }

WhileClause
  ( While / Until ):kind ( _? Star )?:generator _?:ws Condition:condition ->
    if (kind.negated) {
      kind = { ...kind, token: "while" }
      condition = negateCondition(condition)
    }

    return {
      type: "IterationStatement",
      subtype: kind.token,
      children: [ kind, ws, condition ],
      condition,
      generator,
      negated: kind.negated,
    }

# https://262.ecma-international.org/#prod-ForStatement
# https://262.ecma-international.org/#prod-ForInOfStatement
# NOTE: Merged into single rule
ForStatement
  ForClause:clause BlockOrEmptyStatement:block ->
    block = blockWithPrefix(clause.blockPrefix, block)

    return {
      ...clause,
      children: [...clause.children, block],
      block,
    }

ForClause
  For ( _? Star )?:generator __ ForStatementControlWithWhen:c  ->
    const {children, declaration} = c

    return {
      type: "ForStatement",
      children: [$1, ...$3, ...children],
      declaration,
      block: null,
      blockPrefix: c.blockPrefix,
      hoistDec: c.hoistDec,
      reduction: c.reduction,
      generator,
    }

ForStatementControlWithWhen
  ForStatementControlWithReduction:control WhenCondition?:condition ->
    if (!condition) return control
    const expressions = [["", {
      type: "ContinueStatement",
      children: ["continue"]
    }]]
    const block = {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }
    return {
      ...control,
      blockPrefix: [...control.blockPrefix ?? [],
        ["", {
          type: "IfStatement",
          then: block,
          children: ["if (!", makeLeftHandSideExpression(trimFirstSpace(condition)), ") ", block],
        }, ";"]
      ],
    }

ForStatementControlWithReduction
  # Try without reduction first, to allow sum/count/etc as variables
  ForStatementControl
  ForReduction:reduction ForStatementControl:control ->
    return { ...control, reduction }

ForReduction
  ( "some" / "every" / "count" / "sum" / "product" / "min" / "max" ):subtype NonIdContinue __:ws ->
    return {
      type: "ForReduction",
      subtype,
      children: [ ws ],
    }

ForStatementControl
  !CoffeeForLoopsEnabled ForStatementParameters -> $2
  CoffeeForLoopsEnabled CoffeeForStatementParameters -> $2

WhenCondition
  __ When ExpressionWithObjectApplicationForbidden:exp -> exp

CoffeeForStatementParameters
  # NOTE: Coffee for loops can't have parens
  ( Await __ )? InsertOpenParen:open CoffeeForDeclaration:declaration CoffeeForIndex?:index __ ( In / Of / From ):kind ExpressionWithObjectApplicationForbidden:exp ( _? By ExpressionWithObjectApplicationForbidden )?:step InsertCloseParen:close ->
    let blockPrefix = []
    exp = trimFirstSpace(exp)
    declaration = trimFirstSpace(declaration)

    if (kind.token === "from") {
      if (step) {
        throw new Error("Can't use 'by' with 'from' in CoffeeScript for loops")
      }
      kind = { ...kind, token: "of" }
    } else if (kind.token === "of") {
      if (step) {
        throw new Error("Can't use 'by' with 'of' in CoffeeScript for loops")
      }

      // TODO: Exp ref if exp is not a literal or identifier

      if (declaration.own) {
        const hasPropRef = getHelperRef("hasProp")

        blockPrefix./**/push(["", ["if (!", hasPropRef, "(", exp, ", ", declaration, ")) continue"], ";"])
      }

      // index is actually value in Coffee "for of", y = z[x]
      if (index) {
        blockPrefix./**/push(["", {
          type: "AssignmentExpression",
          children: [index, " = ", exp, "[", declaration, "]"],
          names: index.names,
        }, ";"])
      }

      kind.token = "in"
    } else if (kind.token === "in") { // CoffeeScript loop comprehensions
      const counterRef = makeRef("i")
      const lenRef = makeRef("len")

      if (exp.type === "RangeExpression") {
        return forRange(open, declaration, exp, step && prepend(trimFirstSpace(step[0]), trimFirstSpace(step[2])), close)
      }

      // If exp isn't a simple identifier use a ref
      const expRef = maybeRef(exp)

      const varRef = declaration
      let increment = "++",
        indexAssignment,
        assignmentNames = [...varRef.names]

      if (index) {
        index = trimFirstSpace(index)
        indexAssignment = [index, "="]
        assignmentNames./**/push(...index.names)
      }

      const expRefDec = (expRef !== exp)
        // Trim a single leading space if present
        ? [expRef, " = ", trimFirstSpace(exp), ", "]
        : []

      blockPrefix./**/push(["", {
        type: "AssignmentExpression",
        children: [varRef, " = ", expRef, "[", indexAssignment, counterRef, "]"],
        names: assignmentNames,
      }, ";"])

      declaration = {
        type: "Declaration",
        children: ["let ", ...expRefDec, counterRef, " = 0, ", lenRef, " = ", expRef, ".length"],
        names: []
      }

      let condition = [counterRef, " < ", lenRef, "; "]

      if (step) {
        let [stepWs, , stepExp] = step
        stepWs = trimFirstSpace(stepWs)
        if (stepExp.type === "Literal") {
          increment = [" +=", ...stepWs, stepExp]
          // Negative step loops are reversed
          if ( stepExp.raw[0] === "-") {
            declaration = {
              type: "Declaration",
              children: ["let ", ...expRefDec, counterRef, " = ", expRef, ".length - 1"],
              names: []
            }
            condition = [counterRef, " >= 0; "]
          }
        } else {
          throw new Error("TODO: Support non-literal step in CoffeeScript for loops")
        }

        return {
          declaration,
          children: [$1, open, declaration, "; ", ...condition, counterRef, increment, close],
          blockPrefix,
        }
      }

      return {
        declaration,
        children: [$1, open, declaration, "; ", ...condition, counterRef, increment, close],
        blockPrefix,
      }
    }

    return {
      declaration,
      children: [$1, open, declaration, $5, kind, " ", exp, close],
      blockPrefix,
    }
  ForRangeParameters

CoffeeForIndex
  _?:ws1 Comma _?:ws2 BindingIdentifier:id ->
    ws2 = trimFirstSpace(ws1)

    return {
      ...id,
      children: [...(ws1 || []), ...(ws2 || []), ...id.children]
    }

CoffeeForDeclaration
  # NOTE: Coffee doesn't allow expression bindings like `for a.x in b`
  ( __ Own )?:own ForBinding:binding ->
    return {
      type: "AssignmentExpression",
      own: Boolean(own),
      children: [$2],
      names: $2.names,
    }

ForStatementParameters
  # https://262.ecma-international.org/#prod-ForStatement
  OpenParen __ ( LexicalDeclaration / VariableStatement / CommaExpression? ):declaration __ Semicolon CommaExpression? Semicolon CommaExpression? __ CloseParen ->
    return {
      declaration,
      children: $0,
    }
  # NOTE: Added optional parens
  InsertOpenParen __ ( LexicalDeclaration / VariableStatement / CommaExpression? ):declaration __ Semicolon CommaExpression? Semicolon (!EOS ExpressionWithIndentedApplicationForbidden)? InsertCloseParen ->
    return {
      declaration,
      children: $0,
    }

  # https://262.ecma-international.org/#prod-ForInOfStatement
  # NOTE: Consolidated declarations
  # NOTE: Consolidated optional 'await'
  # NOTE: &OpenParen is to fill the spot normally taken by each/own
  ( Await __ )? &OpenParen ( OpenParen __ ) ForInOfDeclaration ( __ Comma __ ForInOfDeclaration )? __ ( In / Of ) ExpressionWithObjectApplicationForbidden ( __ By ExpressionWithObjectApplicationForbidden )? ( __ CloseParen ) ->
    return processForInOf($0)
  # NOTE: Added optional each/own modifiers,
  # which are tried second to allow them to still work as identifiers
  ( Await __ )? ( (Each / Own) __ )? ( OpenParen __ ) ForInOfDeclaration ( __ Comma __ ForInOfDeclaration )? __ ( In / Of ) ExpressionWithObjectApplicationForbidden ( __ By ExpressionWithObjectApplicationForbidden )? ( __ CloseParen ) ->
    return processForInOf($0)
  # NOTE: Added optional parens
  # NOTE: &ForInOfDeclaration is to fill the spot normally taken by each/own
  ( Await __ )? &ForInOfDeclaration InsertOpenParen ForInOfDeclaration ( __ Comma __ ForInOfDeclaration )? __ ( In / Of ) ExpressionWithObjectApplicationForbidden ( __ By ExpressionWithObjectApplicationForbidden )? InsertCloseParen ->
    return processForInOf($0)
  ( Await __ )? ( (Each / Own) __ )? InsertOpenParen ForInOfDeclaration ( __ Comma __ ForInOfDeclaration )? __ ( In / Of ) ExpressionWithObjectApplicationForbidden ( __ By ExpressionWithObjectApplicationForbidden )? InsertCloseParen ->
    return processForInOf($0)
  ForRangeParameters

ForRangeParameters
  # NOTE: CoffeeScript-style `for [start..end] by step` without declaration
  ( Await __ )? OpenParen:open OpenBracket RangeExpression:exp CloseBracket ( __ By ExpressionWithObjectApplicationForbidden )?:step CloseParen:close ->
    return forRange(open, null, exp, step, close)
  ( Await __ )? InsertOpenParen:open OpenBracket RangeExpression:exp CloseBracket ( __ By ExpressionWithObjectApplicationForbidden )?:step InsertCloseParen:close ->
    return forRange(open, null, exp, step, close)

# NOTE: Consolidated declarations
ForInOfDeclaration
  ForDeclaration
  LeftHandSideExpression

# https://262.ecma-international.org/#prod-ForDeclaration
ForDeclaration
  LetOrConstOrVar:c ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      decl: c.token,
      binding,
      names: binding.names,
    }
  # NOTE: Added default implicit const to for bindings
  # But don't add for member expressions like a.x,
  # which parse as a pinned pattern; leave those for LeftHandSideExpression
  InsertConst:c !ActualMemberExpression ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      decl: c.token,
      binding,
      names: binding.names,
    }

# https://262.ecma-international.org/#prod-ForBinding
ForBinding
  ( BindingPattern / BindingIdentifier ):pattern TypeSuffix?:typeSuffix ->
    typeSuffix ??= pattern.typeSuffix
    return {
      type: "Binding",
      children: [ pattern, typeSuffix ],
      names: pattern.names,
      pattern,
      typeSuffix,
      splices: [],
      thisAssignments: [],
    }

# https://262.ecma-international.org/#prod-SwitchStatement
SwitchStatement
  Switch:s ForbidNewlineBinaryOp ( EmptyCondition / Condition )?:condition RestoreNewlineBinaryOp CaseBlock:caseBlock ->
    if (!condition) return $skip
    if (condition.type === "EmptyCondition") {
      // Negate all case condition expressions. This converts them to booleans
      // and is slightly smaller than switch(true) {case: !!exp ... }
      caseBlock.clauses.forEach(({cases}) => {
        if (cases) {
          cases.forEach((c) => {
            const exp = c[1]
            switch(exp.type) {
              case "Identifier":
              case "Literal":
                c.splice(1, 0, "!")
                break;
              default:
               c.splice(1, 1, "!(", exp, ")")
            }
          })
        }
      })
    }

    return {
      type: "SwitchStatement",
      children: [ s, condition, caseBlock ], // omit NewlineBinaryOp control
      condition,
      caseBlock,
    }

EmptyCondition
  &EOS ->
    return {
      type: "EmptyCondition",
      children: [{
        $loc,
        token: " (false)",
      }]
    }

# https://262.ecma-international.org/#prod-CaseBlock
CaseBlock
  ( Nested / _ )? OpenBrace NestedCaseClauses:clauses __ CloseBrace ->
    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

  # NOTE: Added optional braces with nesting
  InsertOpenBrace NestedCaseClauses:clauses InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

NestedCaseClauses
  PushIndent NestedCaseClause*:clauses PopIndent ->
    if (clauses.length) return clauses
    return $skip

NestedCaseClause
  Nested:indent CaseClause:clause ->
    return {
      ...clause,
      // Bring the indent into the clause
      children: [indent, ...clause.children],
    }

# https://262.ecma-international.org/#prod-CaseClause
CaseClause
  PatternExpressionList:patterns ( ThenClause / BareBlock ):block ->
    return {
      type: "PatternClause",
      children: $0,
      patterns,
      block,
    }
  Case CaseExpressionList:cases IgnoreColon ( ThenClause / BareBlock ):block -> {
    type: "CaseClause",
    children: $0,
    cases,
    block,
  }
  # NOTE: Added "when" from CoffeeScript. `when` always inserts `break;`.
  When CaseExpressionList:cases IgnoreColon InsertOpenBrace ( ThenClause / BareBlock ):block InsertBreak:b InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "WhenClause",
      children: $0,
      cases,
      block,
      break: b,
    }
  # NOTE: Merged in default clause
  Default ImpliedColon ( ThenClause / BareBlock):block ->
    return {
      type: "DefaultClause",
      block,
      children: $0
    }
  # NOTE: Added else from CoffeeScript
  Else:e ImpliedColon:colon ( ThenClause / BracedBlock / EmptyBlock ):block ->
    e = { ...e, token: "default" }
    return {
      type: "DefaultClause",
      block,
      children: [ e, colon, block ]
    }

PatternExpressionList
  PatternExpression:first ( _? Comma ( Nested / _ )? PatternExpression )*:rest ->
    return [first, ...rest.map(([, , , p]) => p)]

PatternExpression
  BindingPattern
  ForbidIndentedApplication ( SingleLineBinaryOpRHS+ )?:pattern RestoreIndentedApplication ->
    if (!pattern) return $skip

    return {
      type: "ConditionFragment",
      children: pattern,
    }

CaseExpressionList
  ( _? CaseExpression InsertColon ):first ( __ Comma CaseExpression InsertColon )*:rest ->
    // Convert comma separated expression list to `case <exp>:`
    const result = rest.map(([ws, _comma, exp, col]) => {
      exp = trimFirstSpace(exp)

      if (ws.length) return [insertTrimmingSpace("case ", ws), exp, col]
      return ["case ", exp, col]
    })
    result./**/unshift(first)

    return result

CaseExpression
  # NOTE: Explicitly matching `case foo:` to prevent this from looking like
  # an object literal, but treat `case [foo]:` like an array literal
  PropertyName:value &( _? Colon ) ->
    if (value.type === "ComputedPropertyName") {
      if (value.implicit) return value.expression
      return {...value, type: "ArrayExpression"}
    }
    return value
  ExpressionWithObjectApplicationForbidden

ImpliedColon
  _? Colon
  InsertColon

# Optionally match Colon and throw it away
IgnoreColon
  ( _? Colon )? ->
    if ($1) return $1[0]

# https://262.ecma-international.org/#prod-TryStatement
TryStatement
  Try !":" NoPostfixBracedOrEmptyBlock CatchClause* ElseClause? FinallyClause? ->
    return processTryBlock($0)

# https://262.ecma-international.org/#prod-Catch
CatchClause
  ( Nested / _ ) Catch CatchBinding?:binding ( BracedThenClause / BracedOrEmptyBlock ):block ->
    return {
      type: "CatchClause",
      children: $0,
      block,
      binding,
    }

# NOTE: Added optional parentheses to catch binding
CatchBinding
  _?:ws1 OpenParen:open __:ws2 AllowAll CatchParameter?:parameter RestoreAll __:ws3 CloseParen:close ->
    if (!parameter) return $skip
    return {
      type: "CatchBinding",
      parameter,
      children: [ ws1, open, ws2, parameter, ws3, close ],
    }
  _:ws InsertOpenParen:open !EOS ForbidIndentedApplication CatchParameter?:parameter RestoreIndentedApplication InsertCloseParen:close ->
    if (!parameter) return $skip
    return {
      type: "CatchBinding",
      parameter,
      children: [ ws, open, parameter, close ]
    }

# https://262.ecma-international.org/#prod-Finally
FinallyClause
  ( Nested / _ ) Finally ( BracedThenClause / BracedOrEmptyBlock ):block ->
    return {
      type: "FinallyClause",
      children: $0,
      block,
    }

# https://262.ecma-international.org/#prod-CatchParameter
CatchParameter
  BindingIdentifier:binding TypeSuffix?:typeSuffix ->
    return {
      type: "CatchParameter",
      binding,
      typeSuffix,
      children: $0,
    }
  ( ObjectBindingPattern / ArrayBindingPattern ):binding TypeSuffix:typeSuffix ->
    return {
      type: "CatchParameter",
      binding,
      typeSuffix,
      children: [ binding, typeSuffix ],
    }
  PatternExpressionList ->
    return {
      type: "CatchPattern",
      children: $0,
      patterns: $1,
    }

# An expression with explicit or implied parentheses, for use in if/while/switch
Condition
  # NOTE: DeclarationCondition must come before the ExpressionCondition because we need to look ahead to potentially match `:=` or `.=`
  OpenParen:open _?:ws DeclarationCondition:expression CloseParen:close ->
    return {
      type: "ParenthesizedExpression",
      children: [open, ws, expression, close],
      expression,
    }
  ParenthesizedExpression !TrailingOperator -> $1
  # NOTE: DeclarationCondition must come before the ExpressionCondition because we need to look ahead to potentially match `:=` or `.=`
  InsertOpenParen:open DeclarationCondition:expression InsertCloseParen:close ->
    return {
      type: "ParenthesizedExpression",
      children: [open, expression, close],
      expression,
    }

  # NOTE: Indented condition allows for further nested function application
  PushIndent InsertOpenParen:open ( Nested Expression )?:expression InsertCloseParen:close PopIndent ->
    if (!expression) return $skip
    return {
      type: "ParenthesizedExpression",
      children: [open, expression, close],
      expression,
    }
  # NOTE: Added paren-less condition
  # NOTE: Unindented condition forbids nested function application
  # to avoid ambiguity with 'then' clause
  InsertOpenParen:open ExpressionWithObjectApplicationForbidden:expression InsertCloseParen:close ->
    // Don't double wrap parethesized expressions
    if (expression.type === "ParenthesizedExpression") return expression
    expression = trimFirstSpace(expression)
    return {
      type: "ParenthesizedExpression",
      children: [open, expression, close],
      expression,
    }

# Variation of Condition where there's a trailing token (e.g. `then`)
# that is guaranteed afterward, so we can use indented application.
BoundedCondition
  InsertOpenParen:open Expression:expression InsertCloseParen:close ->
    // Don't double wrap parethesized expressions
    if (expression.type === "ParenthesizedExpression") return expression
    expression = trimFirstSpace(expression)
    return {
      type: "ParenthesizedExpression",
      children: [open, expression, close],
      expression,
    }

DeclarationCondition
  ForbidBracedApplication ForbidIndentedApplication ForbidNewlineBinaryOp LexicalDeclaration?:declaration RestoreNewlineBinaryOp RestoreBracedApplication RestoreIndentedApplication ->
    if (!declaration) return $skip

    return {
      type: "DeclarationCondition",
      declaration,
      children: [declaration],
    }

ExpressionWithIndentedApplicationForbidden
  ForbidIndentedApplication ForbidNewlineBinaryOp Expression?:exp RestoreNewlineBinaryOp RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

SingleLineExpressionWithIndentedApplicationForbidden
  ForbidIndentedApplication ForbidNewlineBinaryOp SingleLineAssignmentExpression?:exp RestoreNewlineBinaryOp RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

# NOTE: Forbid both explicit (braced) and implicit indented object literals
# as arguments to implicit function calls.  This is useful in the context of
# an `if` or `class` line where we don't want to treat the body as an object.
ExpressionWithObjectApplicationForbidden
  ForbidBracedApplication ForbidIndentedApplication Expression?:exp RestoreBracedApplication RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

LeftHandSideExpressionWithObjectApplicationForbidden
  ForbidBracedApplication ForbidIndentedApplication ForbidNewlineBinaryOp LeftHandSideExpression?:exp RestoreNewlineBinaryOp RestoreBracedApplication RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

ForbidClassImplicitCall
  "" ->
    state.forbidClassImplicitCall.push(true)

AllowClassImplicitCall
  "" ->
    state.forbidClassImplicitCall.push(false)

RestoreClassImplicitCall
  "" ->
    state.forbidClassImplicitCall.pop()

ClassImplicitCallForbidden
  "" ->
    if (!state.classImplicitCallForbidden) return $skip
    return

ForbidBracedApplication
  "" ->
    state.forbidBracedApplication.push(true)

AllowBracedApplication
  "" ->
    state.forbidBracedApplication.push(false)

RestoreBracedApplication
  "" ->
    state.forbidBracedApplication.pop()

BracedApplicationAllowed
  "" ->
    if (config.verbose) {
      console.log("forbidBracedApplication:", state.forbidBracedApplication)
    }
    if (state.bracedApplicationForbidden) return $skip
    return

ForbidIndentedApplication
  "" ->
    state.forbidIndentedApplication.push(true)

AllowIndentedApplication
  "" ->
    state.forbidIndentedApplication.push(false)

RestoreIndentedApplication
  "" ->
    state.forbidIndentedApplication.pop()

IndentedApplicationAllowed
  "" ->
    if (config.verbose) {
      console.log("forbidIndentedApplication:", state.forbidIndentedApplication)
    }
    if (state.indentedApplicationForbidden) return $skip
    return

ForbidTrailingMemberProperty
  "" ->
    state.forbidTrailingMemberProperty.push(true)

AllowTrailingMemberProperty
  "" ->
    state.forbidTrailingMemberProperty.push(false)

RestoreTrailingMemberProperty
  "" ->
    state.forbidTrailingMemberProperty.pop()

TrailingMemberPropertyAllowed
  "" ->
    if (config.verbose) {
      console.log("forbidTrailingMemberProperty:", state.forbidTrailingMemberProperty)
    }
    if (state.trailingMemberPropertyForbidden) return $skip

AllowNestedBinaryOp
  "" ->
    state.forbidNestedBinaryOp.push(false)

ForbidNestedBinaryOp
  "" ->
    state.forbidNestedBinaryOp.push(true)

RestoreNestedBinaryOp
  "" ->
    state.forbidNestedBinaryOp.pop()

NestedBinaryOpAllowed
  "" ->
    if (config.verbose) {
      console.log("forbidNestedBinaryOp:", state.forbidNestedBinaryOp)
    }
    if (state.nestedBinaryOpForbidden) return $skip

AllowNewlineBinaryOp
  "" ->
    state.forbidNewlineBinaryOp.push(false)

ForbidNewlineBinaryOp
  "" ->
    state.forbidNewlineBinaryOp.push(true)

RestoreNewlineBinaryOp
  "" ->
    state.forbidNewlineBinaryOp.pop()

NewlineBinaryOpAllowed
  "" ->
    if (config.verbose) {
      console.log("forbidNewlineBinaryOp:", state.forbidNewlineBinaryOp)
    }
    if (state.newlineBinaryOpForbidden) return $skip

AllowPipeline
  "" ->
    state.forbidPipeline.push(false)

ForbidPipeline
  "" ->
    state.forbidPipeline.push(true)

RestorePipeline
  "" ->
    state.forbidPipeline.pop()

PipelineAllowed
  "" ->
    if (config.verbose) {
      console.log("forbidPipeline:", state.forbidPipeline)
    }
    if (state.pipelineForbidden) return $skip

AllowAll
  AllowTrailingMemberProperty AllowBracedApplication AllowIndentedApplication AllowClassImplicitCall AllowNestedBinaryOp AllowNewlineBinaryOp AllowPipeline

RestoreAll
  RestoreTrailingMemberProperty RestoreBracedApplication RestoreIndentedApplication RestoreClassImplicitCall RestoreNestedBinaryOp RestoreNewlineBinaryOp RestorePipeline

# https://262.ecma-international.org/#prod-ExpressionStatement
CommaExpressionStatement
  # NOTE: semi-colons are being handled elsewhere
  # NOTE: Shouldn't need negative lookahead if shadowed in the proper order
  # NOTE: CommaExpression allows , operator
  CommaExpression ->
    // Wrap object literal with parens to disambiguate from block statements.
    // Also wrap nameless functions from `->` expressions with parens
    // as needed in JS.
    return makeExpressionStatement($1)

# CommaExpressionStatement, but forbidding comma operator
ExpressionStatement
  IterationExpression
  # NOTE: AssignmentExpression forbids , operator
  AssignmentExpression ->
    return makeExpressionStatement($1)

KeywordStatement
  # https://262.ecma-international.org/#prod-BreakStatement
  # NOTE: Also allow `break :label` for symmetry
  Break ( _ LabelIdentifier )? ( _ With MaybeNestedExpression )? ->
    const children = [ $1 ]
    if ($2) children.push($2)
    if ($3) children.push({
      type: "Error",
      subtype: "Warning",
      message: "'break with' outside of loop that returns a value",
    })
    return {
      type: "BreakStatement",
      label: $2?.[1],
      with: $3?.[2],
      children,
    }

  # NOTE: `continue switch` for fallthrough
  Continue _ Switch ->
    return {
      type: "ContinueStatement",
      special: $3.token,
      children: [],
    }

  # https://262.ecma-international.org/#prod-ContinueStatement
  # NOTE: Also allow `continue :label` for symmetry
  Continue ( _ LabelIdentifier )? ( _ With MaybeNestedExpression )? ->
    const children = [ $1 ]
    if ($2) children.push($2)
    if ($3) children.push({
      type: "Error",
      subtype: "Warning",
      message: "'continue with' outside of loop that returns a value",
    })
    return {
      type: "ContinueStatement",
      label: $2?.[1],
      with: $3?.[2],
      children,
    }

  DebuggerStatement

  # https://262.ecma-international.org/#prod-ReturnStatement
  # NOTE: Modified to leave room for `return.value` and `return =`
  # NOTE: Stop parsing if there's a postfix if/etc.
  Return:ret !(":" / "." / AfterReturnShorthand) MaybeParenNestedExpression?:expression -> {
    type: "ReturnStatement",
    expression,
    children: [ ret, expression ],
  }

  ThrowStatement

# https://262.ecma-international.org/#sec-debugger-statement
DebuggerStatement
  Debugger -> {
    type: "DebuggerStatement",
    children: $0,
  }

# https://262.ecma-international.org/#prod-ThrowStatement
ThrowStatement
  Throw MaybeParenNestedExpression -> {
    type: "ThrowStatement",
    children: $0,
  }

Break
  "break" NonIdContinue ->
    return { $loc, token: $1 }

Continue
  "continue" NonIdContinue ->
    return { $loc, token: $1 }

Debugger
  "debugger" NonIdContinue ->
    return { $loc, token: $1 }

MaybeNestedNonPipelineExpression
  NestedBulletedArray
  PushIndent ( Nested NonPipelineExpression )? PopIndent ->
    if ($3) return $3
    return $skip
  NonPipelineExpression

MaybeNestedPostfixedExpression
  NestedBulletedArray
  PushIndent ( Nested PostfixedExpression )? PopIndent ->
    if ($3) return $3
    return $skip
  PostfixedExpression

MaybeNestedExpression
  NestedBulletedArray
  PushIndent ( Nested Expression )? PopIndent ->
    if ($3) return $3
    return $skip
  Expression

NestedExpression
  NestedBulletedArray
  PushIndent ( Nested Expression )? PopIndent ->
    if ($3) return $3
    return $skip

# MaybeNestedExpression but where expression needs to be output with
# parentheses if indented, so that the expression starts on the same line.
# (e.g. for `return` or `yield`)
# This also doesn't allow initial __ (whereas MaybeNestedExpression does)
MaybeParenNestedExpression
  # Skip if there's a postfix if/etc.
  &( _? PostfixStatement NoBlock ) -> ""
  # Not nested case
  !EOS Expression -> $2
  # Avoid wrapping array/object return value in parentheses.
  &EOS ( ArrayLiteral / ObjectLiteral ) -> $2
  # Value after `return` needs to be wrapped in parentheses
  # if it starts on another line.
  &EOS InsertSpace InsertOpenParen PushIndent ( Nested Expression ):exp PopIndent InsertNewline InsertIndent InsertCloseParen ->
    if (!exp) return $skip
    return $0.slice(1)

# https://262.ecma-international.org/#prod-ImportDeclaration
ImportDeclaration
  # NOTE: TypeScript's CommonJS import syntax
  # https://www.typescriptlang.org/docs/handbook/modules/reference.html#export--and-import--require
  Import _ Identifier _? Equals __ "require" NonIdContinue Arguments ->
    // Replace `import` with `const` in JS output
    const imp = [
      { ...$1, ts: true },
      { ...$1, token: "const", js: true },
    ]
    return {
      type: "ImportDeclaration",
      children: [imp, $0.slice(1)],
    }
  ( ( Import __ ) / ImpliedImport ):i Operator OperatorBehavior?:behavior __:ws1 OperatorNamedImports:imports __:ws2 FromClause:from ->
    imports.specifiers.forEach((spec) => {
      state.operators.set(spec.binding.name, spec.behavior ?? behavior)
    })
    return {
      type: "ImportDeclaration",
      children: [i, trimFirstSpace(ws1), imports, ws2, from],
        // omit $2 = Operator and $3 = OperatorBehavior
      imports,
      from,
    }
  Import __ ( TypeKeyword __ )?:t ImportClause:imports __ FromClause:from ->
    return {
      type: "ImportDeclaration",
      children: $0,
      imports,
      from,
      ts: !!t,
    }
  Import __ ModuleSpecifier:module -> { type: "ImportDeclaration", children: $0, module }
  # NOTE: Added import shorthand
  # NOTE: Not adding $loc to source map here yet because it will point to the start of the identifier
  # the proper place may be to use the From location
  ImpliedImport:i ( TypeKeyword __ )?:t ImportClause:imports __:w FromClause:from ->
    // Map implied import location to `from`
    // The pos and length adjustment better match how tsc outputs to include the space before `from` with the `from` token
    i.$loc = {
      pos: from[0].$loc.pos-1,
      length: from[0].$loc.length+1,
    }
    const children = [i, t, imports, w, from]
    return { type: "ImportDeclaration", ts: !!t, children, imports, from }
  # NOTE: [from] ... import ... reverse syntax
  ImpliedFromClause:from __:fws Import:i __:iws Operator OperatorBehavior?:behavior __:ows OperatorNamedImports:imports ->
    imports.specifiers.forEach((spec) => {
      state.operators.set(spec.binding.name, spec.behavior ?? behavior)
    })
    return {
      type: "ImportDeclaration",
      children: [i, iws, trimFirstSpace(ows), imports, fws, from],
        // omit Operator and OperatorBehavior
      imports,
      from,
    }
  ImpliedFromClause:from __:fws Import:i __:iws ( TypeKeyword __ )?:t ImportClause:imports ->
    return {
      type: "ImportDeclaration",
      children: [ i, iws, t, imports, fws, from ],
      imports,
      from,
      ts: !!t,
    }

ImpliedImport
  "" ->
    return { $loc, token: "import " }

# https://262.ecma-international.org/#prod-ImportClause
ImportClause
  ImportedBinding:binding ( __ Comma __ ( NameSpaceImport / NamedImports ) )?:rest ->
    if (rest) {
      return {
        type: "Declaration",
        children: [binding, ...rest],
        names: [...binding.names, ...rest[3].names],
        binding,
        specifiers: rest[3].specifiers,
      }
    }

    return {
      type: "Declaration",
      children: [binding],
      names: binding.names,
      binding,
    }
  NameSpaceImport
  NamedImports

# https://262.ecma-international.org/#prod-NameSpaceImport
NameSpaceImport
  Star:star ImportAsToken __ ImportedBinding:binding  ->
    return {
      type: "Declaration",
      children: $0,
      names: binding.names,
      binding,
      star,
    }

# https://262.ecma-international.org/#prod-NamedImports
NamedImports
  OpenBrace TypeAndImportSpecifier*:specifiers ( __ Comma )? __ CloseBrace ->
    const names = specifiers.flatMap(({binding}) => binding.names)

    return {
      type: "Declaration",
      children: $0,
      names,
      specifiers,
    }

OperatorNamedImports
  OpenBrace OperatorImportSpecifier*:specifiers __ CloseBrace ->
    const names = specifiers.flatMap(({binding}) => binding.names)

    return {
      type: "Declaration",
      children: $0,
      names,
      specifiers,
    }

# https://262.ecma-international.org/#prod-FromClause
FromClause
  From __ ModuleSpecifier:module ->
    if (!Array.isArray(module)) return $0
    return [ $1, $2, ...module ]

ImpliedFromClause
  ( ( From __ ) / ImpliedFrom ) ModuleSpecifier:module ->
    if (!Array.isArray(module)) return $0
    return [ $1, ...module ]

ImpliedFrom
  "" ->
    return { $loc, token: "from " }

# https://github.com/tc39/proposal-import-assertions
# https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#import-assertions
# https://github.com/tc39/proposal-import-attributes
# https://devblogs.microsoft.com/typescript/announcing-typescript-5-3/#import-attributes
# NOTE: Forbid newline before `with` which could mean a function call
ImportAssertion
  _? ( "with" / "assert" ):keyword NonIdContinue _? ObjectLiteral:object ->
    return {
      type: "ImportAssertion",
      keyword,
      object,
      children: $0,
    }

# https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports
TypeAndImportSpecifier
  ( __ TypeKeyword )? ImportSpecifier ->
    if (!$1) return $2
    return { ts: true, children: $0, binding: $2.binding }
  # `operator id` blesses `id` as operator; doesn't make sense with `type`
  __:ws Operator OperatorImportSpecifier:spec ->
    if (spec.binding.type !== "Identifier") {
      throw new Error("Expected identifier after `operator`")
    }
    state.operators.set(spec.binding.name, spec.behavior)
    return {
      ...spec,
      children: [
        ws, trimFirstSpace(spec[0]),
        spec.children.slice(1),
      ],
    }

# https://262.ecma-international.org/#prod-ImportSpecifier
ImportSpecifier
  __ ModuleExportName:source ImportAsToken __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      source,
      binding,
      children: $0,
    }
  __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      source: binding,
      binding,
      children: $0,
    }

OperatorImportSpecifier
  __ ModuleExportName OperatorBehavior?:behavior ImportAsToken __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding,
      behavior,
      children: [$1, $2, $4, $5, $6, $7],
    }
  __ ImportedBinding:binding OperatorBehavior?:behavior ObjectPropertyDelimiter ->
    return {
      binding,
      behavior,
      children: [$1, $2, $4],
    }

ImportAsToken
  __ As
  # NOTE: Allowing ':' in place of 'as', a preliminary step towards unifying
  # imports and destructuring.
  Loc:l __:ws Colon:c " "? ->
    const children = [
      ...ws,
      { ...c, token: "as " },
    ]

    if (!ws.length) {
      children.unshift({ $loc: l.$loc, token: " " })
    }

    return {
      children,
    }

# https://262.ecma-international.org/#prod-ModuleExportName
ModuleExportName
  StringLiteral
  IdentifierName

# https://262.ecma-international.org/#prod-ModuleSpecifier
ModuleSpecifier
  UnprocessedModuleSpecifier ImportAssertion?:a ->
    let { token } = $1
    if (config.rewriteTsImports) {
      // Workaround to fix:
      // https://github.com/microsoft/TypeScript/issues/42151
      // import t.ts
      // "An import path cannot end with a '.ts' extension. Consider importing './t.js' instead."
      // convert .[mc]?ts to .[mc]?js
      token = token.replace(/\.([mc])?ts(['"])$/, ".$1js$2")
    }
    if (config.rewriteCivetImports) {
      token = token.replace(/\.civet(['"])$/,
        `${config.rewriteCivetImports.replace(/\$/g, '$$')}$1`)
    }

    if (a)
      return [{ ...$1, token }, a]

    return { ...$1, token }

UnprocessedModuleSpecifier
  StringLiteral
  UnquotedSpecifier

UnquotedSpecifier
  # Currently allowing most non-whitespace characters
  # Forbidding ; (statement separator), = (assignment), > (function arrow)
  # It may make sense to restrict this to only allow characters that are valid in a module specifier
  # Also consider URLs
  /[^;"\s=>]+/:spec ->
    return { $loc, token: `"${spec}"` }

# https://262.ecma-international.org/#prod-ImportedBinding
ImportedBinding
  BindingIdentifier

# https://262.ecma-international.org/#prod-ExportDeclaration
ExportDeclaration
  # NOTE: TypeScript's CommonJS export syntax
  # https://www.typescriptlang.org/docs/handbook/modules/reference.html#export--and-import--require
  Export _? Equals MaybeNestedExpression ->
    // Replace `export` with `module.exports` in JS output
    const exp = [
      { ...$1, ts: true },
      { ...$1, token: "module.exports", js: true },
    ]
    return {
      type: "ExportDeclaration",
      children: [exp, $0.slice(1)],
    }
  # NOTE: export default for all Declarations not supported by TS export default
  # NOTE: Avoid matching `f := ->`, leaving that for the next rule.
  Decorators? Export __ Default __ !FunctionDeclaration ( LexicalDeclaration / VariableStatement / TypeAliasDeclaration / NamespaceDeclaration / EnumDeclaration / OperatorDeclaration ):declaration ->
    let id, error
    if (declaration.id) {
      id = declaration.id
    } else if (declaration.names) {
      if (declaration.names.length !== 1) {
        error = {
          type: "Error",
          message: `export default with ${declaration.names.length} variable declaration (should be 1)`
        }
      }
      id = declaration.names[0]
    } else {
      throw new Error("Could not find name of declaration in export default")
    }
    return [
      declaration,
      { children: [";"], ts: declaration.ts },
      error ??
      { type: "ExportDeclaration", declaration: id, ts: declaration.ts,
        children: [ ...$0.slice(0, -2), id ] }
    ]
  # NOTE: This covers all forms that can be directly export defaulted in TS.
  # NOTE: Using Expression to allow If/Switch expressions
  Decorators? Export __ Default __ ( HoistableDeclaration / ClassDeclaration / InterfaceDeclaration / MaybeNestedExpression ):declaration ->
    return { type: "ExportDeclaration", declaration, ts: declaration.ts, children: $0 }
  Export __ ExportFromClause:exports __ FromClause ->
    return { type: "ExportDeclaration", ts: exports.ts, children: $0 }
  # NOTE: [from] ... export ... reverse syntax
  ImpliedFromClause:from __:fws Export:e __:ews ExportFromClause:exports ->
    return {
      type: "ExportDeclaration",
      ts: exports.ts,
      children: [ e, ews, exports, " ", from, trimFirstSpace(fws) ],
    }
  # NOTE: Declaration and VariableStatement should come before NamedExports
  # so that NamedExports doesn't grab function, async, type, var, etc.
  # NOTE: TS decorators come before `export` keyword but TC39 stage 3 decorators proposal come after
  Decorators? Export __ ( Declaration / VariableStatement / TypeAndNamedExports / ExportVarDec ):declaration ->
    return { type: "ExportDeclaration", declaration, ts: declaration.ts, children: $0 }

# CoffeeScript style `export x = 3` -> `export var x = 3`
ExportVarDec
  InsertVar VariableDeclarationList ->
    return {
      ...$2,
      children: [$1, ...$2.children]
    }

# https://262.ecma-international.org/#prod-ExportFromClause
ExportFromClause
  Star ( __ As __ ModuleExportName )?
  TypeAndNamedExports

# https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports
TypeAndNamedExports
  ( TypeKeyword __ )? NamedExports ->
    if (!$1) return $2
    return { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-NamedExports
NamedExports
  OpenBrace ExportSpecifier* (__ Comma )? __ CloseBrace
  # Unbraced version: export x, y
  InsertInlineOpenBrace:open ImplicitExportSpecifier:first ( ImplicitObjectPropertyDelimiter ImplicitExportSpecifier )*:rest InsertCloseBrace:close &( StatementDelimiter / ( __ From )) ->
    return [open, first, ...rest, close]

# https://262.ecma-international.org/#prod-ExportSpecifier
ExportSpecifier
  __ ( TypeKeyword __ )? ModuleExportName ( __ As __ ModuleExportName )? ObjectPropertyDelimiter ->
    if (!$2) return $0
    return { ts: true, children: $0 }

ImplicitExportSpecifier
  !Default ModuleExportName ( __ As __ ModuleExportName )?

# https://262.ecma-international.org/#prod-Declaration
Declaration
  ImportDeclaration:decl ->
    if (decl.ts || decl.module || !decl.imports || !decl.from) return $skip
    const { imports } = decl
    if (!imports.binding && !imports.specifiers) return $skip
    return dynamizeImportDeclaration(decl)
  HoistableDeclaration
  ClassDeclaration
  LexicalDeclaration:d ->
    if (d.thisAssignments?.length)
      return {
        ...d,
        children: [...d.children, ...d.splices, ";", ...d.thisAssignments]
      }
    if (d.splices?.length)
      return {
        ...d,
        children: [...d.children, ...d.splices]
      }
    return d
  TypeDeclaration
  EnumDeclaration
  OperatorDeclaration
  UsingDeclaration

# https://262.ecma-international.org/#prod-HoistableDeclaration
HoistableDeclaration
  FunctionDeclaration

# https://262.ecma-international.org/#prod-LexicalDeclaration
LexicalDeclaration
  # NOTE: Eliminated left recursion
  LetOrConst:decl LexicalBinding:binding ( __ Comma __ LexicalBinding )*:tail ->
    const bindings = [binding].concat(tail.map(([,,,b]) => b))

    return {
      type: "Declaration",
      children: $0,
      names: bindings.flatMap(b => b.names),
      bindings,
      decl,
      splices: bindings.flatMap(b => b.splices),
      thisAssignments: bindings.flatMap(b => b.thisAssignments),
    }
  # NOTE: Added const/let shorthands
  # NOTE: Using Expression to allow for If/SwitchExpressions
  # NOTE: Using PostfixExpression to allow postfix if/unless/for
  Loc:loc ( BindingPattern / BindingIdentifier ) TypeSuffix? __ ( ConstAssignment / LetAssignment ):assign MaybeNestedPostfixedExpression ->
    return processAssignmentDeclaration(
      { $loc: loc, token: assign.decl }, // like InsertConst or InsertLet
      ...$0.slice(1)
    )

ConstAssignment
  ":=" / "≔" ->
    return { $loc, token: "=", decl: "const " }

LetAssignment
  ".=" ->
    return { $loc, token: "=", decl: "let " }

TypeAssignment
  "::=" ->
    return { $loc, token: "=" }

# https://262.ecma-international.org/#prod-LexicalBinding
# merged with https://262.ecma-international.org/#prod-VariableDeclaration
LexicalBinding
  BindingPattern:pattern TypeSuffix?:typeSuffix Initializer:initializer ->
    const [splices, thisAssignments] = gatherBindingCode(pattern)
    typeSuffix ??= pattern.typeSuffix

    return {
      type: "Binding",
      children: [ pattern, typeSuffix, initializer ],
      names: pattern.names,
      pattern,
      typeSuffix,
      initializer,
      splices: splices.map(s => [",", s]),
      thisAssignments: thisAssignments.map(s => ["", s, ";"]),
    }

  BindingIdentifier:pattern TypeSuffix?:typeSuffix Initializer?:initializer ->
    return {
      type: "Binding",
      children: $0,
      names: pattern.names,
      pattern,
      typeSuffix,
      initializer,
      splices: [],
      thisAssignments: [],
    }

# https://262.ecma-international.org/#prod-Initializer
Initializer
  __ Equals MaybeNestedExpression:expression -> {
    type: "Initializer",
    expression,
    children: $0,
  }

# https://262.ecma-international.org/#prod-VariableStatement
VariableStatement
  Var __ VariableDeclarationList ->
    return {
      ...$3,
      names: $3.names,
      children: [$1, ...$2, ...$3.children],
      decl: "var",
    }

# https://262.ecma-international.org/#prod-VariableDeclarationList
VariableDeclarationList
  LexicalBinding:binding ( __ Comma __ LexicalBinding )*:tail ->
    const bindings = [binding].concat(tail.map(([,,,b]) => b))

    return {
      type: "Declaration",
      children: [binding, ...tail],
      bindings,
      names: bindings.flatMap(b => b.names),
    }

# https://262.ecma-international.org/#prod-NumericLiteral
# NOTE: No leading minus sign
NumericLiteral
  # perf: short circuit if no possibility of being a number
  /(?=[0-9.])/ NumericLiteralKind:token ->
    return { type: "NumericLiteral", $loc, token }

NumericLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral
  DecimalLiteral

# https://262.ecma-international.org/#prod-DecimalBigIntegerLiteral
DecimalBigIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)n/
  # /[_0-9]*n/

# https://262.ecma-international.org/#prod-DecimalLiteral
DecimalLiteral
  # NOTE: Not matching the dot as part of a number if it is followed by a valid JS identifier so that it will match as a property access
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?=\.(?:\p{ID_Start}|[_$]))/ ) ->
    // Insert an extra dot to make property access work
    return $1 + "."
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?:\.(?:[0-9](?:_[0-9]|[0-9])*))?/ ExponentPart? )
  $( /(?:\.[0-9](?:_[0-9]|[0-9])*)/ ExponentPart? )

ExponentPart
  /(?:[eE][+-]?[0-9]+(?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-BinaryIntegerLiteral
BinaryIntegerLiteral
  /0[bB][01](?:[01]|_[01])*n?/

# https://262.ecma-international.org/#prod-OctalIntegerLiteral
OctalIntegerLiteral
  /0[oO][0-7](?:[0-7]|_[0-7])*n?/

# https://262.ecma-international.org/#prod-HexIntegerLiteral
HexIntegerLiteral
  /0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_[0-9a-fA-F])*n?/

# NOTE: Integer variation of NumericLiteral
IntegerLiteral
  # perf: short circuit if no possibility of being an integer
  /(?=[0-9])/ IntegerLiteralKind:token ->
    return { $loc, token }

IntegerLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral
  DecimalIntegerLiteral

DecimalIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-StringLiteral
# NOTE: This includes unprocessed double-quoted strings.  If you might want to
# accept a template literal in the form of a CoffeeScript double-quoted string
# interpolation, be sure to check TemplateLiteral before StringLiteral.
StringLiteral
  DoubleQuote DoubleStringCharacters:str DoubleQuote ->
    return {
      type: "StringLiteral",
      token: `"${modifyString(str.token)}"`,
      $loc,
    }

  SingleQuote SingleStringCharacters:str SingleQuote ->
    return {
      type: "StringLiteral",
      token: `'${modifyString(str.token)}'`,
      $loc,
    }

DoubleStringCharacters
  /(?:\\.|[^"])*/ ->
    return { $loc, token: $0 }

SingleStringCharacters
  /(?:\\.|[^'])*/ ->
    return { $loc, token: $0 }

TripleDoubleStringCharacters
  /(?:"(?!"")|#(?!\{)|\\.|[^#"])+/ ->
    return { $loc, token: $0 }

TripleSingleStringCharacters
  /(?:'(?!'')|\\.|[^'])*/ ->
    return { $loc, token: $0 }

CoffeeStringSubstitution
  CoffeeSubstitutionStart AllowAll ( PostfixedExpression __ CloseBrace )? RestoreAll ->
    if (!$3) return $skip
    return [$1, ...$3]

CoffeeInterpolatedDoubleQuotedString
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringSubstitution )*:parts DoubleQuote:e ->
    return processCoffeeInterpolation(s, parts, e, $loc)

CoffeeDoubleQuotedStringCharacters
  /(?:\\.|#(?!\{)|[^"#])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#prod-RegularExpressionLiteral
RegularExpressionLiteral
  HeregexLiteral
  $("/" RegularExpressionBody "/" RegularExpressionFlags) ->
    return { type: "RegularExpressionLiteral", $loc, token: $1 }

RegularExpressionClass
  $(OpenBracket RegularExpressionClassCharacters CloseBracket) ->
    return { $loc, token: $1 }

RegularExpressionClassCharacters
  /(?:\\.|[^\]])*/ ->
    return { $loc, token: $0 }

HeregexLiteral
  TripleSlash:open HeregexBody:body TripleSlash:close RegularExpressionFlags:flags ->
    let hasSubstitutions = body.some((part) => part.type === "Substitution")

    if (hasSubstitutions) {
      const children = [
        {...open, token: "RegExp(`"},
        // Escape backticks, backslashes, and '$' in the body text
        body.map(e => e.type === "Substitution"
          ? e
          : {
            ...e,
            token: e.token.replace(/`|\\|\$/g, "\\$&"),
          }
        ),
        "`"
      ]

      if (flags.length) {
        children.push(
          ", ",
          JSON.stringify(flags)
        )
      }
      children.push( {...close, token: ")" })
      return {
        type: "RegularExpressionLiteral",
        children,
      }
    }

    return {
      type: "RegularExpressionLiteral",
      children: $0,
    }

HeregexBody
  !TripleSlash HeregexPart* -> $2

HeregexPart
  RegularExpressionClass

  CoffeeStringSubstitution -> { type: "Substitution", children: $1 }
  TemplateSubstitution -> { type: "Substitution", children: $1 }

  /(?:\\.)/ ->
    let token = $0
    switch ($0[1]) {
      case "\n": token = "\\n"; break
      case "\r": token = "\\r"; break
      case " ": token =   " "; break
    }
    return { $loc, token }

  HeregexComment ->
    return { $loc, token: "" }
  # NOTE: CoffeeScript strips out all unescaped whitespace chars
  # but Python doesn't strip out whitespace inside character classes
  # or inside '(?' groups and assertions
  # TODO: this behavior should be toggled by a coffeeCompat directive
  /[\s]+/ ->
    return { $loc, token: "" }
  # Escape forward slashes (that aren't part of a triple slash)
  /\/(?!\/\/)/ ->
    return { $loc, token: "\\/" }
  /[^[\/\s#\\]+/ ->
    return { $loc, token: $0 }

HeregexComment
  # NOTE: CoffeeScript doesn't treat JS comments as regex comments
  # TODO: this behavior should be toggled by a coffeeCompat directive
  JSSingleLineComment
  CoffeeSingleLineComment

# https://262.ecma-international.org/#prod-RegularExpressionBody
# NOTE: Simplified a little from the spec, ignoring <PS>, <LS>
RegularExpressionBody
  ![*\/\r\n] RegExpPart*

RegExpPart
  RegularExpressionClass
  RegExpCharacter

RegExpCharacter
  /(?:\\.|[^[\/\r\n])+/

# https://262.ecma-international.org/#prod-RegularExpressionFlags
RegularExpressionFlags
  /(?:\p{ID_Continue}|[\u200C\u200D$])*/

# https://262.ecma-international.org/#prod-TemplateLiteral
# NOTE: Simplified template grammar
TemplateLiteral
  # perf: assertion to exit early
  /(?=[`'"])/ _TemplateLiteral -> $2

_TemplateLiteral
  TripleTick ( TemplateBlockCharacters / TemplateSubstitution )* TripleTick ->
    return dedentBlockSubstitutions($0, config.tab)

  Backtick ( TemplateCharacters / TemplateSubstitution )* Backtick ->
    return {
      type: "TemplateLiteral",
      children: $0,
    }

  # NOTE: actual CoffeeScript """ string behaviors are pretty weird, this is simplified
  TripleDoubleQuote ( TripleDoubleStringCharacters / CoffeeStringSubstitution )* TripleDoubleQuote ->
    return dedentBlockSubstitutions($0, config.tab)

  # NOTE: ''' don't have interpolation so could be converted into a regular
  # String, but currently we use `template`s so the output looks similar to
  # the input.  Also, this enables tagged template literals such as tag'''x''',
  # which CoffeeScript also allows.
  TripleSingleQuote:s TripleSingleStringCharacters:str TripleSingleQuote:e ->
    return {
      type: "TemplateLiteral",
      children: [s, dedentBlockString(str, config.tab), e]
    }

  # CoffeeScript Interpolation is enabled when "civet coffee-compat" or "civet coffee-interpolation" directive is present
  CoffeeInterpolatedDoubleQuotedString

# NOTE: Simplified grammar
TemplateSubstitution
  SubstitutionStart AllowAll ( PostfixedExpression __ CloseBrace )? RestoreAll ->
    if (!$3) return $skip
    return [$1, ...$3]

# https://262.ecma-international.org/#prod-TemplateCharacter
TemplateCharacters
  /(?:\$(?!\{)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

TemplateBlockCharacters
  /(?:\$(?!\{)|`(?!``)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#sec-comments
ReservedWord
  /(?:on|off|yes|no)(?!\p{ID_Continue})/ CoffeeBooleansEnabled
  /(?:isnt)(?!\p{ID_Continue})/ CoffeeIsntEnabled
  /(?:by)(?!\p{ID_Continue})/ CoffeeForLoopsEnabled
  /(?:of)(?!\p{ID_Continue})/ CoffeeOfEnabled
  # NOTE: Added `let`, Civet assumes strict mode
  /(?:and|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|import|in|instanceof|interface|is|let|loop|new|not|null|or|private|protected|public|return|static|super|switch|this|throw|true|try|typeof|unless|until|var|void|while|with|yield)(?!\p{ID_Continue})/

# https://262.ecma-international.org/#sec-comments
Comment
  # perf: assertion to exit early
  /(?=\/|#)/ _Comment -> $2

_Comment
  MultiLineComment
  SingleLineComment

# https://262.ecma-international.org/#prod-SingleLineComment
# This is more accurately called "RestOfLineComment"
SingleLineComment
  JSSingleLineComment
  CoffeeCommentEnabled CoffeeSingleLineComment

JSSingleLineComment
  # JS Comments are two slashes not followed by a third (because that is a heregex)
  /\/\/(?!\/)[^\r\n]*/ ->
    return { type: "Comment", $loc, token: $0 }

# https://262.ecma-international.org/#prod-MultiLineComment
MultiLineComment
  JSMultiLineComment
  # NOTE: Added CoffeeScript style ### multiline comments
  CoffeeMultiLineComment

JSMultiLineComment
  $( "/*" (!"*/" . )* "*/" ) ->
    return { type: "Comment", $loc, token: $1 }

CoffeeSingleLineComment
  # NOTE: CoffeeScript style single line comments
  /#(?!##(?!#))([^\r\n]*)/ ->
    return { type: "Comment", $loc, token: `//${$1}` }

CoffeeMultiLineComment
  CoffeeHereCommentStart $/[^]*?###/ ->
    $2 = $2.slice(0, $2.length-3).replace(/\*\//g, "* /")
    return { type: "Comment", $loc, token: `/*${$2}*/` }

CoffeeHereCommentStart
  /###(?!#)/

# InlineComment is a multi-line comment with no line separators
InlineComment
  /\/\*(?:(?!\*\/)[^\r\n])*\*\// ->
    return { $loc, token: $0 }

RestOfLine
  ( NonNewlineWhitespace / Comment )* EOL

# Matches any whitespace optionally followed by a rest of line comment
# This will always succeed since each part is optional that's why it
# doesn't have `?` when used in other rules.
TrailingComment
  _? SingleLineComment?

# Non-newline "white space" (includes inline comments)
# TODO: Allow for inline Coffee comments when enabled
_
  # perf: assertion to exit early
  /(?=[ \t\/\\])/ ( NonNewlineWhitespace / InlineComment )+ -> $2

NonNewlineWhitespace
  [ \t]+ ->
    return { $loc, token: $0 }
  "\\" CoffeeLineContinuationEnabled EOL -> " "

# Whitespace / comments with a single leading space trimmed off if possible
Trimmed_
  _:ws ->
    return trimFirstSpace(ws)

# Optional whitespace including newlines and comments
__
  # perf: assertion to skip checking
  /(?=\s|\/|#)/ ( Whitespace / Comment )* -> $2
  ""

Whitespace
  [\s]+ ->
    return { $loc, token: $0 }

# Fake a blocklike form for single expressions
ExpressionDelimiter
  _? Semicolon InsertComma TrailingComment ->
    // Replace semicolon with comma
    return [$1, $3, $4]
  &EOS InsertComma -> $2

SimpleStatementDelimiter
  &EOS
  SemicolonDelimiter

StatementDelimiter
  &EOS
  SemicolonDelimiter
  # Allow for closing a block within the same line as a nested statement
  ClosingDelimiter

ClosingDelimiter
  &( __ ( "}" / ")" / "]" ) )

SemicolonDelimiter
  _? Semicolon TrailingComment ->
    return {
      type: "SemicolonDelimiter",
      children: $0
    }

NonIdContinue
  /(?!\p{ID_Continue})/

Loc
  "" ->
    return { $loc, token: "" }

## Tokens

Abstract
  $("abstract" NonIdContinue " "?) ->
    return { $loc, token: $1, ts: true }

Ampersand
  "&" ->
    return { $loc, token: $1 }

As
  "as" NonIdContinue ->
    return { $loc, token: $1 }

At
  "@" ->
    return { $loc, token: $1 }

# hack for experimentalDecorators
# Since `@` is premium real estate we use `@@` for decorators with all the shame that entails.
AtAt
  "@@" ->
    return { $loc, token: "@" }

Async
  "async" NonIdContinue ->
    return { $loc, token: $1, type: "Async" }

Await
  "await" NonIdContinue ->
    return { $loc, token: $1, type: "Await" }

Backtick
  "`" ->
    return { $loc, token: $1 }

By
  "by" NonIdContinue ->
    return { $loc, token: $1 }

Caret
  "^" ->
    return { $loc, token: $1 }

Case
  "case" NonIdContinue ->
    return { $loc, token: $1 }

Catch
  "catch" NonIdContinue ->
    return { $loc, token: $1 }

Class
  "class" NonIdContinue ->
    return { $loc, token: $1 }

CloseAngleBracket
  ">" ->
    return { $loc, token: $1 }

CloseBrace
  "}" ->
    return { $loc, token: $1 }

CloseBracket
  "]" ->
    return { $loc, token: $1 }

CloseParen
  ")" ->
    return { $loc, token: $1 }

CoffeeSubstitutionStart
  "#{" ->
    return { $loc, token: "${" }

Colon
  ":" ![=:] ->
    return { $loc, token: $1 }

Comma
  "," ->
    return { $loc, token: $1 }

Comptime
  "comptime" NonIdContinue !":" ->
    return { $loc, token: $1 }

ConstructorShorthand
  "@" ->
    return { $loc, token: "constructor" }

Declare
  "declare" NonIdContinue ->
    return { $loc, token: $1 }

Default
  "default" NonIdContinue ->
    return { $loc, token: $1 }

Delete
  "delete" NonIdContinue ->
    return { $loc, token: $1 }

Do
  "do" NonIdContinue ->
    return { $loc, token: $1 }

Dot
  "." ->
    return { $loc, token: $1 }
  # English possessive
  /['’]s/ Trimmed_:ws ->
    return [
      { $loc, token: "." },
      ws,
    ]

DotDot
  ".." !"." ->
    return { $loc, token: $1 }
  "‥" ->
    return { $loc, token: ".." }

DotDotDot
  "..." ->
    return { $loc, token: $1 }
  "…" ->
    return { $loc, token: "..." }

InsertDotDotDot
  "" ->
    return { $loc, token: "..." }

DoubleColon
  "::" ->
    return { $loc, token: $1 }

DoubleColonAsColon
  "::" ->
    return { $loc, token: ":" }

DoubleQuote
  "\"" ->
    return { $loc, token: $1 }

Each
  "each" NonIdContinue ->
    return { $loc, token: $1 }

Else
  "else" NonIdContinue ->
    return { $loc, token: $1 }

Equals
  "=" ->
    return { $loc, token: $1 }

ExclamationPoint
  "!" ->
    return { $loc, token: $1 }

Export
  "export" NonIdContinue ->
    return { $loc, token: $1 }

Extends
  "extends" NonIdContinue ->
    return { $loc, token: $1 }

Finally
  "finally" NonIdContinue ->
    return { $loc, token: $1 }

For
  "for" NonIdContinue ->
    return { $loc, token: $1 }

From
  "from" NonIdContinue ->
    return { $loc, token: $1 }

Function
  "function" NonIdContinue ->
    return { $loc, token: $1 }

GetOrSet
  ( "get" / "set" ) NonIdContinue ->
    return { $loc, token: $1, type: 'GetOrSet' }

Hash
  "#" ->
    return { $loc, token: $1 }

If
  # NOTE: Pull a single space into the 'if ' token so if it is replaced
  # with a ternary in expressions it doesn't add an extra space
  $("if" NonIdContinue " "?) ->
    return { $loc, token: $1 }

Import
  # NOTE: this is a hack so import.meta will parse correctly
  "import" &/\s/ ->
    return { $loc, token: $1 }

In
  "in" NonIdContinue ->
    return { $loc, token: $1 }

Infer
  "infer" NonIdContinue ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-LetOrConst
LetOrConst
  ( "let" / "const" ) NonIdContinue ->
    return { $loc, token: $1 }

Const
  "const" NonIdContinue ->
    return { $loc, token: $1 }

Is
  "is" NonIdContinue ->
    return { $loc, token: $1 }

LetOrConstOrVar
  ( "let" / "const" / "var" ) NonIdContinue ->
    return { $loc, token: $1 }

Like
  "like" NonIdContinue ->
    return { $loc, token: $1 }

Loop
  # NOTE: loop becomes while
  "loop" NonIdContinue ->
    return { $loc, token: "while" }

New
  "new" NonIdContinue ->
    return { $loc, token: $1 }

Not
  "not" NonIdContinue !( _? ":" ) ->
    return { $loc, token: "!" }

Of
  "of" NonIdContinue ->
    return { $loc, token: $1 }

OpenAngleBracket
  "<" ->
    return { $loc, token: $1 }

OpenBrace
  "{" ->
    return { $loc, token: $1 }

OpenBracket
  "[" ->
    return { $loc, token: $1 }

OpenParen
  "(" ->
    return { $loc, token: $1 }

Operator
  "operator" NonIdContinue ->
    return { $loc, token: $1 }

Override
  "override" NonIdContinue ->
    return { $loc, token: $1, ts: true }

Own
  "own" NonIdContinue ->
    return { $loc, token: $1 }

Public
  "public" NonIdContinue ->
    return { $loc, token: $1 }

Private
  "private" NonIdContinue ->
    return { $loc, token: $1 }

Protected
  "protected" NonIdContinue ->
    return { $loc, token: $1 }

Pipe
  "||>" / "|▷" ->
    return { $loc, token: "||>" }

  "|>=" / "▷=" ->
    return { $loc, token: "|>=" }

  "|>" / "▷" ->
    return { $loc, token: "|>" }

QuestionMark
  "?" ->
    return { $loc, token: $1 }

Readonly
  "readonly" NonIdContinue ->
    return { $loc, token: $1, ts: true }

Return
  "return" NonIdContinue ->
    return { $loc, token: $1 }

Satisfies
  "satisfies" NonIdContinue ->
    return { $loc, token: $1 }

Semicolon
  ";" ->
    return { $loc, token: $1 }

SingleQuote
  "'" ->
    return { $loc, token: $1 }

Star
  "*" ->
    return { $loc, token: $1 }

Static
  "static" NonIdContinue ->
    return { $loc, token: $1 }
  # NOTE: In ClassElements @ is a shorthand for 'static'
  # NOTE: added negative assertion to prevent overlapping constructor shorthand and `@@` decorator syntax
  "@" !( "(" / "@" ) ->
    return { $loc, token: "static " }

SubstitutionStart
  "${" ->
    return { $loc, token: $1 }

Super
  "super" NonIdContinue ->
    return { $loc, token: $1 }

Switch
  "switch" NonIdContinue ->
    return { $loc, token: $1 }

Target
  "target" NonIdContinue ->
    return { $loc, token: $1 }

Then
  # TODO: comments/whitespace get lost here
  __ "then" NonIdContinue ->
    return { $loc, token: "" }

This
  "this" NonIdContinue ->
    return { $loc, token: $1 }

Throw
  "throw" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: These become a single backtick, to properly escape "s and newlines
# and in case there are interpolations
TripleDoubleQuote
  "\"\"\"" ->
    return { $loc, token: "`" }

# NOTE: These become a single backtick, to properly escape 's and newlines
TripleSingleQuote
  "'''" ->
    return { $loc, token: "`" }

# Used in Heregex
TripleSlash
  "///" ->
    return { $loc, token: '/' }

TripleTick
  "```" ->
    return { $loc, token: "`" }

Try
  "try" NonIdContinue ->
    return { $loc, token: $1 }

Typeof
  "typeof" NonIdContinue ->
    return { $loc, token: $1 }

Undefined
  "undefined" NonIdContinue ->
    return { $loc, token: $1 }

Unless
  "unless" NonIdContinue ->
    return { $loc, token: $1, negated: true }

Until
  "until" NonIdContinue ->
    return { $loc, token: $1, negated: true }

Using
  "using" NonIdContinue ->
    return { $loc, token: $1 }

Var
  "var" NonIdContinue ->
    return { $loc, token: $1 }

Void
  "void" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: When maps to 'case'
When
  "when" NonIdContinue ->
    return { $loc, token: "case" }

While
  "while" NonIdContinue ->
    return { $loc, token: $1 }

With
  "with" NonIdContinue ->
    return { $loc, token: $1 }

Yield
  "yield" NonIdContinue ->
    return { $loc, token: $1, type: "Yield" }

## JSX

JSXImplicitFragment
  JSXTag ( Nested JSXTag )* ->
    const jsx = $2.length === 0 ? $1 : {
      type: "JSXFragment",
      children: [
        "<>\n",
        state.currentIndent.token,
        ...$0,
        "\n",
        state.currentIndent.token,
        "</>",
      ],
      jsxChildren: [$1].concat($2.map(([, tag]) => tag)),
    }
    const type = typeOfJSX(jsx, config)
    return type ? [
      { ts: true, children: ["("] },
      jsx,
      { ts: true, children: [" as any as ", type, ")"] }
    ] : jsx

JSXTag
  # perf: assertion to exit early
  /(?=[<])/ _JSXTag -> $2

_JSXTag
  JSXElement
  JSXFragment
  JSXComment

# https://facebook.github.io/jsx/#prod-JSXElement
JSXElement
  JSXSelfClosingElement
  # NOTE: In default JSX mode, JSX children must be properly indented,
  # and closing tags are optional (but still allowed).
  !CoffeeJSXEnabled PushJSXOpeningElement:open JSXMixedChildren?:children JSXOptionalClosingElement:close PopJSXStack ->
    if (!children) return $skip
    let parts
    $0 = $0.slice(1)
    if (close) {
      parts = $0
    } else if (children.jsxChildren.length) {
      parts = [
        ...$0,
        "\n", // InsertNewline
        state.currentIndent.token, // InsertIndent
        ["</", open[1], ">"],
      ]
    } else {
      parts = [open.slice(0, -1), " />"]
    }
    return { type: "JSXElement", children: parts, tag: open[1] }
  # NOTE: In CoffeeScript JSX mode, JSX children do not need to be properly
  # indented, but tags must be explicitly closed.
  CoffeeJSXEnabled JSXOpeningElement:open JSXChildren? Whitespace? JSXClosingElement:close ->
    $0 = $0.slice(1)
    // Check that tags match
    if (open[1] !== close[2]) return $skip
    return { type: "JSXElement", children: $0, tag: open[1] }

# https://facebook.github.io/jsx/#prod-JSXSelfClosingElement
JSXSelfClosingElement
  "<" JSXElementName TypeArguments? JSXAttributes? Whitespace? "/>" ->
    return { type: "JSXElement", children: $0, tag: $2 }

PushJSXOpeningElement
  JSXOpeningElement ->
    state.JSXTagStack.push($1[1])
    return $1

PopJSXStack
  "" ->
    state.JSXTagStack.pop()

# https://facebook.github.io/jsx/#prod-JSXOpeningElement
JSXOpeningElement
  "<" JSXElementName TypeArguments? JSXAttributes? Whitespace? ">"

JSXOptionalClosingElement
  Whitespace? JSXClosingElement:close ->
    if (state.currentJSXTag !== close[2]) return $skip
    return $0
  ""

# https://facebook.github.io/jsx/#prod-JSXClosingElement
JSXClosingElement
  "</" Whitespace? JSXElementName Whitespace? ">"

# https://facebook.github.io/jsx/#prod-JSXFragment
JSXFragment
  # NOTE: In default JSX mode, JSX children must be properly indented,
  # and closing tags are optional (but still allowed).
  !CoffeeJSXEnabled PushJSXOpeningFragment:open JSXMixedChildren?:children JSXOptionalClosingFragment:close PopJSXStack ->
    if (!children) return $skip
    $0 = $0.slice(1)
    const parts = close ? $0 :
      [
        ...$0,
        "\n", // InsertNewline
        state.currentIndent.token, // InsertIndent
        "</>",
      ]
    return { type: "JSXFragment", children: parts, jsxChildren: children.jsxChildren }
  # NOTE: In CoffeeScript JSX mode, JSX children do not need to be properly
  # indented, but tags must be explicitly closed.
  CoffeeJSXEnabled "<>" JSXChildren?:children Whitespace? JSXClosingFragment ->
    $0 = $0.slice(1)
    return {
      type: "JSXFragment",
      children: $0,
      jsxChildren: children ? children.jsxChildren : []
    }

PushJSXOpeningFragment
  "<>" ->
    state.JSXTagStack.push("")
    return $1

JSXOptionalClosingFragment
  Whitespace? JSXClosingFragment ->
    if (state.currentJSXTag !== "") return $skip
    return $0
  ""

JSXClosingFragment
  "</>"

# https://facebook.github.io/jsx/#prod-JSXElementName
JSXElementName
  # Implicit element name
  &( ( "#" / Dot ) JSXShorthandString ) ->
    return config.defaultElement
  # Merged in https://facebook.github.io/jsx/#prod-JSXNamespacedName
  # Merged in https://facebook.github.io/jsx/#prod-JSXMemberExpression
  $( JSXIdentifierName ( (Colon JSXIdentifierName) / ( Dot JSXIdentifierName )* ) )

# NOTE: Like IdentifierName but includes hyphens after start
# NOTE: Combined from recursive https://facebook.github.io/jsx/#prod-JSXIdentifier definition
JSXIdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$-])*/

# https://facebook.github.io/jsx/#prod-JSXAttributes
JSXAttributes
  ( Whitespace? JSXAttribute )* ->
    // Extract all .class shorthands into `classes` array
    const classes = []
    let attrs = $0.filter((pair) => {
      const [, attr] = pair
      if (attr.type === "JSXClass") {
        classes.push(attr.class)
        return false
      }
      return true
    })
    if (classes.length) {
      // Check for non-shorthand class or className attribute
      let className = config.react ? "className" : "class"
      attrs = attrs.filter((pair) => {
        const [, attr] = pair
        if ((attr[0][0] === "class" || attr[0][0] === "className") &&
            !attr[0][1]) {
          className = attr[0][0]
          classes.push(attr[1][attr[1].length-1])
          return false
        }
        return true
      })
      function isBraced(c) {
        return c[0] === "{" || c[0]?.token === "{"
      }
      function unbrace(c) {
        // Remove leading "{" and trailing "}" tokens
        return c.slice(1, -1)
      }
      function parseClass(c) {
        c = c.token || c
        if (c.startsWith("'")) {
          c = '"' +
            c.slice(1, -1)
            .replace(/\\*"/g, (m) => m.length % 2 == 0 ? m : "\\"+m) +
            '"'
        }
        return JSON.parse(c)
      }
      const strings = [], exprs = []
      classes.forEach((c) => {
        if (isBraced(c)) {
          exprs.push(unbrace(c))
          exprs.push(", ")
        } else {
          strings.push(parseClass(c))
        }
      })
      const stringPart = strings.filter(Boolean).join(" ")
      let classValue
      if (exprs.length) { // some expressions
        exprs.pop()  // remove trailing comma
        if (stringPart) { // some strings too
          exprs.unshift(JSON.stringify(stringPart), ", ")
        }
        if (exprs.length === 1) {
          // Single expression doesn't need array, filter, or join.
          let root = exprs[0]
          // Remove trailing whitespace, e.g. in JSXShorthandString rule
          while (root.length &&
                 isWhitespaceOrEmpty(root[root.length-1])) {
            root = root.slice(0, -1)
          }
          // Unwrap possibly resulting singleton arrays
          while (root?.length === 1) root = root[0]
          // processUnaryExpression wraps in {children: [...]}
          if (root?.children) root = root.children
          if (root?.[0]?.token === "`") {
            // Template literals work just as-is.
            classValue = ["{", ...exprs, "}"]
          } else {
            // Other expressions get `|| ""` to avoid e.g. `undefined` class.
            classValue = ["{(", ...exprs, ") || \"\"}"]
          }
        } else {
          // In general, wrap expressions in array and filter out falsy values,
          // to avoid accidental e.g. `undefined` classes.
          classValue = ["{[", ...exprs, "].filter(Boolean).join(\" \")}"]
        }
      } else { // strings only
        if (!stringPart.includes('&') && !stringPart.includes('"')) {
          classValue = `"${stringPart}"`
        } else if (!stringPart.includes('&') && !stringPart.includes("'")) {
          classValue = `'${stringPart}'`
        } else {
          classValue = `{${JSON.stringify(stringPart)}}`
        }
      }
      attrs.splice(0, 0, [" ", [className, ["=", classValue]]])
    }
    return attrs.map((pair) => {
      const [space, attr] = pair
      // Sometimes JSXAttribute adds a leading space to separate from previous.
      // Remove that space if there's already whitespace here.
      if (space && attr[0] === " ") {
        pair = [space, attr.slice(1)]
      }
      return pair
    })

# NOTE: Merged SpreadAttribute and Attribute
JSXAttribute
  # https://facebook.github.io/jsx/#prod-JSXSpreadAttribute
  # allows something like
  #   OpenBrace __ DotDotDot Expression __ CloseBrace
  # (where Expression additionally allows If/Switch expressions).
  # More generally, we allow any braced object literal:
  # {foo} is equivalent to foo={foo}, and
  # {foo, bar: baz} is equivalent to foo={foo} and bar={baz}.
  # {...foo} is a special case.
  BracedObjectLiteral ->
    return convertObjectToJSXAttributes($1)

  # https://facebook.github.io/jsx/#prod-JSXAttribute
  JSXAttributeName:name ( JSXAttributeInitializer / &JSXAttributeSpace ):value ->
    if (name.type === "ComputedPropertyName") {
      if (value) {
        // Strip off equals sign and whitespace from JSXAttributeInitializer
        value = value[value.length-1]
        // Strip off braces if present
        if (value[0]?.token === "{" &&
            value[value.length-1]?.token === "}") {
          value = value.slice(1, -1)
        }
      } else {
        // React and SolidJS define a bare attribute to mean setting it to true.
        // We need to specify a value here, so this seems a reasonable choice.
        value = "true"
      }
      return ["{...{", name, ": ", value, "}}"]
    } else {
      return $0
    }

  # NOTE: Adding ...foo shorthand for {...foo}
  InsertInlineOpenBrace DotDotDot InlineJSXAttributeValue InsertCloseBrace &JSXAttributeSpace

  # NOTE: @foo and @@foo shorthands
  # for foo={this.foo} and foo={this.foo.bind(this)}
  AtThis:at Identifier?:id InlineJSXCallExpressionRest*:rest &JSXAttributeSpace ->
    const children = [ at, ...rest.flat() ]
    if (id) {
      children.splice(1, 0, {
        type: "PropertyAccess",
        children: [".", id],
        name: id,
      })
    }
    const expr = processCallMemberExpression({
      type: "CallExpression",
      children,
    })
    const last = lastAccessInCallExpression(expr)
    if (!last) return $skip
    let name
    if (last.type === "Index") {
      return [
        "{...{",
        {...last, type: "ComputedPropertyName"},
        ": ", expr, "}}"
      ]
    } else if (last.name) {
      return [last.name, "={", expr, "}"]
    }
    return $skip

  # NOTE: foo(), foo.bar, foo?.bar, foo!, foo[bar], foo@bar don't need braces
  Identifier:id InlineJSXCallExpressionRest+:rest &JSXAttributeSpace ->
    const expr = processCallMemberExpression({
      type: "CallExpression",
      children: [ id, ...rest.flat() ],
    })
    if (expr.type === "ObjectExpression") {  // glob
      return convertObjectToJSXAttributes(expr)
    }
    const last = lastAccessInCallExpression(expr)
    if (!last) return $skip
    let name
    if (last.type === "Index") {
      return [
        "{...{",
        {...last, type: "ComputedPropertyName"},
        ": ", expr, "}}"
      ]
    } else if (last.name) {
      return [last.name, "={", expr, "}"]
    }
    return $skip

  # NOTE: #id shorthand
  "#" JSXShorthandString ->
    return [ " ", "id=", $2 ]
  Dot JSXShorthandString ->
    return {
      type: "JSXClass",
      class: $2,
    }

  # NOTE: Matching LiveScript flagging shorthand in addition +x -y !z -> x={true} y={false} z={false}
  $[!+-]:toggle JSXAttributeName:id &JSXAttributeSpace ->
    const value = toggle === "+" ? "true" : "false"
    return [ " ", id, "={", value, "}" ]

JSXAttributeSpace
  /[\s>]|\/>/

JSXShorthandString
  /(?:[\w\-:]+|\([^()]*\)|\[[^\[\]]*\])+/ ->
    return quoteString($0)
  TemplateLiteral ->
    return [ "{", $1, "}" ]
  # NOTE: TemplateLiteral must be before StringLiteral,
  # so that CoffeeScript interpolated strings get checked first.
  StringLiteral
  OpenBrace PostfixedExpression Whitespace? CloseBrace

# https://facebook.github.io/jsx/#prod-JSXAttributeName
JSXAttributeName
  # NOTE: Merged JSXIdentifier and JSXNamespacedName
  JSXIdentifierName ( Colon JSXIdentifierName )?
  ComputedPropertyName

# https://facebook.github.io/jsx/#prod-JSXAttributeInitializer
JSXAttributeInitializer
  # Outside CoffeeScript compatibility mode,
  # allow attribute value to be an indented expression
  !CoffeeJSXEnabled Whitespace?:ws1 Equals:equals &( NonNewlineWhitespace* EOL ):ws2 InsertInlineOpenBrace:open PushIndent:indent PostfixedExpression?:expression PopIndent InsertCloseBrace:close ->
    if (!expression) return $skip
    return [ ws1, equals, ws2, open, indent, expression, close ]
  Whitespace? Equals Whitespace? JSXAttributeValue

# https://facebook.github.io/jsx/#prod-JSXAttributeValue
JSXAttributeValue
  # https://facebook.github.io/jsx/#prod-JSXDoubleStringCharacters
  # https://facebook.github.io/jsx/#prod-JSXSingleStringCharacters
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  OpenBrace PostfixedExpression Whitespace? CloseBrace
  JSXElement
  JSXFragment
  InsertInlineOpenBrace:open InlineJSXAttributeValue:value InsertCloseBrace:close &JSXAttributeSpace ->
    // Check for string literal resulting from CoffeeScript interpolated
    // double-quoted string that didn't end up actually interpolating.
    if (value.type === "StringLiteral") {
      // Instead parse using the following string literal rule,
      // which avoids e.g. converting newlines into \n.
      return $skip
    }
    return [open, value, close]  // omit &JSXAttributeSpace
  # NOTE: InlineJSXAttributeValue which contains TemplateLiteral must be before
  # StringLiteral, so that CoffeeScript interpolated strings get checked first.
  # NOTE: JSX strings allow newlines, and they get passed through as-is.
  /"[^"]*"|'[^']*'/

# JSX shorthand to avoid explicit braces when unnecessary (no whitespace)
InlineJSXAttributeValue
  InlineJSXUnaryExpression InlineJSXBinaryOpRHS* ->
    if ($2.length) return processBinaryOpExpression($0)
    return $1

# BinaryOpRHS without whitespace and without ExpressionizedStatement,
# forbidding operators starting with < or > (possible JSX tags),
# and forbidding implicitly parenthesized assignments.
InlineJSXBinaryOpRHS
  ![<>] BinaryOp:op InlineJSXUnaryExpression:rhs ->
    // NOTE: Inserting empty whitespace arrays to be compatible with BinaryOpRHS and `processBinaryOpExpression`
    return [[], op, [], rhs]

# JSXUnaryExpression, with InlineJSX prefixes and no Do (which has whitespace)
InlineJSXUnaryExpression
  InlineJSXUnaryOp*:pre InlineJSXUpdateExpression:exp InlineJSXUnaryPostfix?:post ->
    return processUnaryExpression(pre, exp, post)

# UnaryOp, restricted to whitespace-free symbol operators
InlineJSXUnaryOp
  /[!~+-](?!\s|[!~+-]*&)/ ->
    return { $loc, token: $0 }

# UnaryPostfix, restricted to whitespace-free symbol operators
InlineJSXUnaryPostfix
  QuestionMark

# UpdateExpression, with LeftHandSideExpression -> InlineJSXCallExpression
InlineJSXUpdateExpression
  UpdateExpressionSymbol UnaryExpression
  InlineJSXCallExpression UpdateExpressionSymbol? ->
    if ($2) return $0
    return $1

# CallExpression, with only explicit function calls.
# This also acts as a replacement for LeftHandSideExpression
# (we don't allow New because that has whitespace).
InlineJSXCallExpression
  Super ExplicitArguments:args InlineJSXCallExpressionRest*:rest ->
    return processCallMemberExpression({
      type: "CallExpression",
      children: [
        $1,
        args,
        ...rest.flat()
      ],
    })
  "import" ExplicitArguments:args InlineJSXCallExpressionRest*:rest ->
    return processCallMemberExpression({
      type: "CallExpression",
      children: [
        $1,
        args,
        ...rest.flat()
      ],
    })
  InlineJSXMemberExpression:member InlineJSXCallExpressionRest*:rest ->
    if (rest.length) {
      rest = rest.flat()
      return processCallMemberExpression({
        type: "CallExpression",
        children: [member, ...rest]
      })
    }
    return member

# CallExpressionRest, with only explicit function calls.
InlineJSXCallExpressionRest
  InlineJSXMemberExpressionRest
  TemplateLiteral / StringLiteral ->
    if ($1.type === "StringLiteral") {
      return "`" + $1.token.slice(1, -1).replace(/(`|\$\{)/g, "\\$1") + "`"
    }
    return $1
  OptionalShorthand? ExplicitArguments:args ->
    if (!$1) return args
    return [ $1, args ]

# MemberExpression, with PrimaryExpression -> InlineJSXPrimaryExpression
InlineJSXMemberExpression
  ( InlineJSXPrimaryExpression / SuperProperty / MetaProperty ) InlineJSXMemberExpressionRest*:rest ->
    if (rest.length || Array.isArray($1)) {
      return processCallMemberExpression({
        type: "MemberExpression",
        children: [$1, ...rest].flat(),
      })
    }
    return $1

# MemberExpressionRest without optional IndentFurther before PropertyAccess
InlineJSXMemberExpressionRest
  OptionalShorthand?:dot InlineComment*:comments MemberBracketContent:content ->
    if (!dot && !comments.length) return content
    if (dot) {
      // Optional followed by a slice expression
      if (dot.type === "Optional" && content.type === "SliceExpression") {
        // Remove '.' from optional since it is present in '.slice'
        return [...dot.children.slice(0, -1), ...comments, content]
      }
      return [dot, ...comments, content]
    }
    return [...comments, content]
  PropertyAccess
  PropertyGlob
  PropertyBind
  NonNullAssertion

# Subset of PrimaryExpression; omissions documented below.
InlineJSXPrimaryExpression
  NullLiteral
  BooleanLiteral
  NumericLiteral
  TemplateLiteral
  # Omitting StringLiteral already matched in JSXAttributeValue
  ThisLiteral
  ArrayLiteral
  # Requiring braces on ObjectLiteral; this allows {a, b} even though `a, b` doesn't work as an inline object
  BracedObjectLiteral
  IdentifierReference
  # Omitting FunctionExpression and ClassExpression which have whitespace
  RegularExpressionLiteral
  ParenthesizedExpression
  # Omitting JSXElement and JSXFragment which don't need braces

JSXMixedChildren
  # NOTE: c1 matches "same-line" children, while c2 matches indented children
  # Used in indentation-based JSX
  JSXSameLineChildren:c1 JSXNestedChildren:c2 ->
    return {
      children: c1.concat(c2),
      jsxChildren: c1.concat(c2.jsxChildren),
    }

JSXSameLineChildren
  # NOTE: In jsxCodeSameLine mode, we discard leading whitespace on same-line
  # children, which just serves to separate JSX tag from code.
  JSXCodeSameLineEnabled ( NonNewlineWhitespace? !EOL JSXChildForcedCode )*:children ->
    return children.map(([, , c]) => c)
  !JSXCodeSameLineEnabled JSXChildForcedNoCode*:children -> children

# https://facebook.github.io/jsx/#prod-JSXChildren
# JSX eats whitespace around newlines
JSXChildren
  ( ( NonNewlineWhitespace? EOL NonNewlineWhitespace? )* JSXChild )* ->
    return {
      children: $1,
      jsxChildren: $1.map(children => children[1]),
    }

JSXNestedChildren
  PushIndent ( JSXNested JSXChild+ )* PopIndent ->
    if ($2.length) {
      return {
        children: $2,
        jsxChildren: [].concat(...$2.map(nestedChildren => nestedChildren[1])),
      }
    }
    return $skip
  # NOTE: Empty JSXNestedChildren can be from newline or unmatched close brace
  # (e.g. when used in an attribute) or a following closing tag.
  &( JSXEOS / "}" / JSXClosingElement / JSXClosingFragment ) ->
    return { children: [], jsxChildren: [] }

# NOTE: Special variations of EOS and Nested that forbid end-of-line JS
# comments, as JS comments are not allowed in JSX (they get treated as text).
JSXEOS
  ( NonNewlineWhitespace? EOL )+

JSXNested
  JSXEOS:eos Indent:indent ->
    const { level } = indent
    const currentIndent = state.currentIndent
    if (level !== currentIndent.level) return $skip
    return $0

# https://facebook.github.io/jsx/#prod-JSXChild
JSXChild
  JSXChildGeneral
  JSXCodeNestedEnabled JSXCodeChild -> $2
  # NOTE: JSXText must come after attempt to match ArrowFunction
  !JSXCodeNestedEnabled JSXText -> $2

# Simulate JSXChild with JSXCodeEnabled forced true (for same-line children)
JSXChildForcedCode
  JSXChildGeneral
  JSXCodeChild

# Simulate JSXChild with JSXCodeEnabled forced false (for same-line children)
JSXChildForcedNoCode
  JSXChildGeneral
  JSXText

JSXChildGeneral
  JSXElement
  JSXFragment
  # NOTE: Adding support for XML comments
  JSXComment
  OpenBrace IndentedJSXChildExpression:expression __ CloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  OpenBrace JSXChildExpression?:expression __ CloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  # NOTE: Adding support for arrow functions without wrapping braces
  InsertInlineOpenBrace ArrowFunction:expression InsertCloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  # NOTE: >expression to avoid braces
  JSXAngleChild

# XML comments: https://www.w3.org/TR/xml/#sec-comments
JSXComment
  "<!--" JSXCommentContent "-->" ->
    return [ "{/*", $2, "*/}" ]

JSXCommentContent
  /(?:-[^-]|[^-]*)*/ ->
    return { $loc, token: $0.replace(/\*\//g, "* /") }

# https://facebook.github.io/jsx/#prod-JSXText
JSXText
  # NOTE: not currently excluding https://facebook.github.io/jsx/#prod-HTMLCharacterReference
  # NOTE: additionally excluding newlines to leave the next indentation;
  # leading whitespace will actually be consumed by JSXChildren or
  # JSXNestedChildren (where it's used for indentation).
  [^{}<>\r\n]+ ->
    return {
      type: "JSXText",
      token: $0,
      $loc,
    }

# https://facebook.github.io/jsx/#prod-JSXChildExpression
JSXChildExpression
  # NOTE: Added lexical declaration, which gets hoisted,
  # converted into an assignment, and voided to avoid rendering.
  Whitespace? LexicalDeclaration:d ->
    // Add refs from thisAssignments to list of names
    let names = d.names.concat(
      d.thisAssignments.map(a => a[1][1])
    )
    // Remove duplicate names
    names.sort()
    names = names.filter((name, i) => i === 0 || name !== names[i-1])
    d = {
      ...d,
      hoistDec: {
        type: "Declaration",
        children: [
          "let ",
          names.map((n, i) => i === 0 ? [n] : [",", n]).flat()
        ],
      },
      children: d.children.slice(1),  // drop LetOrConst
    }
    if (d.thisAssignments?.length) {
      d.children.push(...d.splices, ",", ...d.thisAssignments.map(
        (a, i) => a[a.length-1] === ';' ? [
          ...a.slice(0, -1),
          i === d.thisAssignments.length-1 ? "" : ",",
        ] : a
      ))
    } else if (d.splices?.length) {
      d.children.push(...d.splices)
    }
    d.children.push(",void 0")
    return d
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  Whitespace? ( DotDotDot Whitespace? )? PostfixedExpression

IndentedJSXChildExpression
  PushIndent NestedJSXChildExpression? PopIndent ->
    if (!$2) return $skip
    return $2

NestedJSXChildExpression
  JSXNested JSXChildExpression

# > followed by expression or indented block is a way to avoid wrapping
# JSX code children in braces
JSXAngleChild
  CloseAngleBracket JSXCodeChild -> $2

JSXCodeChild
  InsertInlineOpenBrace:open JSXCodeChildExpression:expression InsertCloseBrace:close ->
    if (!expression) return $skip
    return [ open, expression, close ]  // omit >

JSXCodeChildExpression
  # First check for unindented expression (same line)
  !JSXEOS ForbidNewlineBinaryOp JSXChildExpression?:expression RestoreNewlineBinaryOp ->
    if (!expression) return $skip
    return expression
  # Next check for indented block, which we wrap in an expressionized `do`
  &JSXEOS ImplicitNestedBlock:block ->
    if (!block) return $skip
    const statement = {
      type: "DoStatement",
      children: [block],
      block,
    }
    return {
      type: "StatementExpression",
      statement,
      children: [statement],
    }

## Using Declaration

UsingDeclaration
  Using:decl _? UsingBinding:binding ( __ Comma __ UsingBinding )*:tail UsingJSModeError ->
    const bindings = [binding].concat(tail.map(([,,,b]) => b))

    return {
      type: "Declaration",
      children: $0,
      names: bindings.flatMap(b => b.names),
      bindings,
      decl,
      splices: bindings.flatMap(b => b.splices),
      thisAssignments: bindings.flatMap(b => b.thisAssignments),
    }

UsingBinding
  BindingIdentifier:pattern TypeSuffix?:typeSuffix Initializer:initializer ->
    return {
      type: "Binding",
      children: $0,
      names: pattern.names,
      pattern,
      typeSuffix,
      initializer,
      splices: [],
      thisAssignments: [],
    }

UsingJSModeError
  "" ->
    return {
      type: "Error",
      js: true,
      message: "`using` is not currently transpiled in JS mode."
    }

## Type Stuff

TypeDeclaration
  # NOTE: First check for forms with a `declare` keyword present
  ( Export _? )? ( Declare _? ) TypeLexicalDeclaration:d ->
    return {
      type: "Declaration",
      ts: true,
      children: $0,
      names: d.names ?? [],
    }
  ( Export _? )?:export_ ( Declare _? )?:declare TypeDeclarationRest:t ->
    return {
      ...t,
      ts: true,
      export: export_,
      declare,
      children: [ export_, declare, ...t.children ]
    }

# NOTE: These are declarations even without a `declare` prefix
TypeDeclarationRest
  TypeAliasDeclaration
  InterfaceDeclaration
  NamespaceDeclaration
  FunctionSignature

TypeAliasDeclaration
  # TODO: ( __ Type ) can be refined further to check for consistently nested binary ops, etc.
  TypeKeyword _? IdentifierName:id TypeParameters? OptionalEquals ( MaybeNestedType / ( __ Type ) ) ->
    return {
      type: "TypeDeclaration",
      id,
      children: $0,
      ts: true,
    }

  InsertType IdentifierName:id TypeParameters? __ TypeAssignment ( MaybeNestedType / ( __ Type ) ) ->
    return {
      type: "TypeDeclaration",
      id,
      children: $0,
      ts: true,
    }

InterfaceDeclaration
  Interface _? IdentifierName:id TypeParameters? InterfaceExtendsClause? InterfaceOrEmptyBlock ->
    return {
      type: "InterfaceDeclaration",
      id,
      children: $0,
      ts: true,
    }

NamespaceDeclaration
  Namespace _? IdentifierName:id ModuleOrEmptyBlock ->
    return {
      type: "NamespaceDeclaration",
      id,
      children: $0,
      ts: true,
    }

OptionalEquals
  __ Equals
  &IndentedFurther InsertSpaceEquals -> $2

# NOTE: These are all guaranteed to be preceded by a `declare` keyword
TypeLexicalDeclaration
  TypeLetOrConstDeclaration
  __ EnumDeclaration
  ClassSignature
  Namespace _? IdentifierName DeclareBlock
  Module _ StringLiteral DeclareBlock?
  Global DeclareBlock?

TypeLetOrConstDeclaration
  __ LetOrConstOrVar TypeDeclarationBinding:first ( CommaDelimiter __ TypeDeclarationBinding )*:rest ->
    const names = first.names.concat(...rest.map(b => b[2].names))
    return {
      type: "TypeLexicalDeclaration",
      children: $0,
      ts: true,
      names,
    }

TypeDeclarationBinding
  # NOTE: This is almost the same as LexicalBinding except it cannot have an initializer
  ( BindingPattern / BindingIdentifier ) TypeSuffix? ->
    return {
      type: "TypeDeclarationBinding",
      children: $0,
      names: $1.names,
    }

InterfaceExtendsClause
  ExtendsToken InterfaceExtendsTarget ( Comma InterfaceExtendsTarget )*

InterfaceExtendsTarget
  ImplementsTarget

TypeKeyword
  "type" NonIdContinue ->
    return { $loc, token: $1 }

Enum
  "enum" NonIdContinue ->
    return { $loc, token: $1 }

Interface
  "interface" NonIdContinue ->
    return { $loc, token: $1 }

Global
  "global" NonIdContinue ->
    return { $loc, token: $1 }

Module
  "module" NonIdContinue ->
    return { $loc, token: $1 }

Namespace
  "namespace" NonIdContinue ->
    return { $loc, token: $1 }

InterfaceOrEmptyBlock
  InterfaceBlock
  EmptyBlock

InterfaceBlock
  __ OpenBrace NestedInterfaceProperties __ CloseBrace
  __ OpenBrace ( __ InterfaceProperty )* __ CloseBrace
  # NOTE: Added indentation based implied braces
  NestedInterfaceBlock

NestedInterfaceBlock
  InsertOpenBrace NestedInterfaceProperties InsertNewline InsertIndent InsertCloseBrace

NestedInterfaceProperties
  PushIndent NestedInterfaceProperty*:props PopIndent ->
    if (props.length) return props
    return $skip

NestedInterfaceProperty
  Nested InterfaceProperty

InterfaceProperty
  BasicInterfaceProperty
  NonEmptyParameters TypeSuffix InterfacePropertyDelimiter
  MethodSignature InterfacePropertyDelimiter

BasicInterfaceProperty
  ( TypeIndexSignature / TypeProperty ) _? TypeSuffix InterfacePropertyDelimiter

InterfacePropertyDelimiter
  _? ( Semicolon / Comma )
  &( __ CloseBrace )
  &EOS

# Namespace blocks are like self-contained modules
ModuleOrEmptyBlock
  __ OpenBrace NestedModuleItems __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedModuleItems InsertNewline InsertIndent InsertCloseBrace
  EmptyBlock

NestedModuleItems
  PushIndent NestedModuleItem*:items PopIndent ->
    if (items.length) return items
    return $skip

# Based on TopLevelStatement
NestedModuleItem
  Nested ModuleItem StatementDelimiter

DeclareBlock
  __ OpenBrace NestedDeclareElements __ CloseBrace
  __ OpenBrace ( __ DeclareElement InterfacePropertyDelimiter)* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedDeclareElements InsertNewline InsertIndent InsertCloseBrace

NestedDeclareElements
  PushIndent NestedDeclareElement*:decs PopIndent ->
    if (decs.length) return decs
    return $skip

NestedDeclareElement
  Nested DeclareElement InterfacePropertyDelimiter

# NOTE: Variation on TypeDeclaration where Declare already applied.
DeclareElement
  Decorators? Export __ Default __ ( Identifier / ClassSignature / InterfaceDeclaration ):declaration
  Decorators? ( Export _? )? TypeLexicalDeclaration -> { ts: true, children: $0 }
  ( Export _? )? TypeDeclarationRest    -> { ts: true, children: $0 }

EnumDeclaration
  ( Const _ )?:isConst Enum _? IdentifierName:id EnumBlock:block ->
    const ts = {
      ts: true,
      children: $0,
    }
    // In TypeScript const enums do not generate any JavaScript code
    // but we don't yet do the same post-processing to completely
    // erase the enum from the output. So we just use a simpler
    // but less optimized output for raw js.
    // if (isConst) return ts
    // Generate JS output for enum similar to how TypeScript does
    const names = new Set(block.properties.map(p => p.name.name))
    return {
      type: "EnumDeclaration",
      id,
      children: [ts, {
        js: true,
        children: [
          ["let ", id, " = {};\n"],
          ...block.properties.map((property, i) => {
            let init, isString
            if (property.initializer) {
              // Replace references to other enum members.
              // TS further restricts this to past enum members,
              // but we don't need to enforce that here.
              init = replaceNodes(deepCopy(property.initializer),
                n => n.type === "Identifier" && names.has(n.name),
                n => [id, '["', n.name, '"]'])
              const value = init[init.length - 1]
              isString = value.type === "TemplateLiteral" ||
                (value.type === "Literal" && value.subtype === "StringLiteral")
            } else {
              // Default initializer is previous property + 1, or 0 if first.
              // TS further restricts this to when previous property is
              // constant, but we don't need to enforce that here.
              init = i === 0 ? " = 0" :
                [" = ", id, '["', block.properties[i-1].name, '"] + 1']
            }
            // String enums do not get back references
            if (isString) {
              return [
                id, '["', property.name, '"]', init, ";\n",
              ]
            } else {
              return [
                id, "[", id, '["', property.name, '"]', init,
                '] = "', property.name, '";\n',
              ]
            }
          }),
        ],
      }]
    }

EnumBlock
  __ OpenBrace NestedEnumProperties:props __ CloseBrace ->
    return {
      properties: props.properties,
      children: $0,
    }
  __ OpenBrace ( __ EnumProperty )*:props __ CloseBrace ->
    return {
      properties: props.map(p => p[1]),
      children: $0,
    }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedEnumProperties:props InsertNewline InsertIndent InsertCloseBrace ->
    return {
      properties: props.properties,
      children: $0,
    }

NestedEnumProperties
  PushIndent NestedEnumPropertyLine*:props PopIndent ->
    if (!props.length) return $skip
    return {
      properties: props.flat().map((p) => p.property),
      children: $0,
    }

NestedEnumPropertyLine
  ( Nested EnumProperty ) ( _? EnumProperty )* ->
    return [$1, ...$2].map(pair => ({
      property: pair[1],
      children: pair,
    }))

EnumProperty
  Identifier:name ( __ Equals MaybeNestedExpression )?:initializer ObjectPropertyDelimiter ->
    return {
      type: "EnumProperty",
      name,
      initializer,
      children: $0,
    }

TypeProperty
  ( Readonly NotDedented )? PropertyName

TypeIndexSignature
  # NOTE: QuestionMark will be parsed by following TypeSuffix
  ( [+-]? Readonly NotDedented )? OpenBracket TypeIndex CloseBracket ( __ [+-] &( _? QuestionMark ) )?

TypeIndex
  __ Identifier TypeSuffix
  __ PropertyName __ In Type ( __ As Type )?

# NOTE: TypeScript allows ? only in some circumstances (function parameters
# and class properties, but not let/const) and ! only in some circumstances
# (let/const and class properties, but not function parameters), and can't
# parse both (?!).  For simplicity, we allow either in all cases.
# In some cases (e.g. let/const), we transpile them away later.
TypeSuffix
  _? QuestionMark?:optional _? Colon MaybeNestedType:t -> {
    type: "TypeSuffix",
    ts: true,
    optional,
    t,
    children: $0,
  }
  _? QuestionMark:optional _? -> {
    type: "TypeSuffix",
    ts: true,
    optional,
    children: $0,
  }
  # TypeScript has a special error for ! without : ("Declarations with definite
  # assignment assertions must also have type annotations.") but we parse it
  # so that the user can get this more useful error message.
  NonNullAssertion:nonnull _? (Colon MaybeNestedType)?:ct ->
    const [colon, t] = ct ?? []
    return {
      type: "TypeSuffix",
      ts: true,
      nonnull,
      t,
      children: [ $1, $2, colon, t ],
    }

MaybeNestedType
  NestedTypeBulletedTuple
  # NOTE: Let InterfaceBlock take first crack at an indented block
  # But don't prevent parsing a braced type with unary suffix like {}[]
  NestedInterfaceBlock
  # NOTE: Next check for consistently indented binary operations (e.g. |)
  # at beginning of each line.
  NestedTypeBinaryChain
  PushIndent ( Nested Type )? PopIndent ->
    if (!$2) return $skip
    return $2
  Type

MaybeNestedTypePrimary
  NestedTypeBulletedTuple
  # NOTE: Let InterfaceBlock take first crack at an indented block
  # But don't prevent parsing a braced type with unary suffix like {}[]
  NestedInterfaceBlock
  # NOTE: Next check for consistently indented binary operations (e.g. |)
  # at beginning of each line.
  NestedTypeBinaryChain
  PushIndent ( Nested Type )? PopIndent ->
    if (!$2) return $skip
    return $2
  TypePrimary

MaybeNestedTypeUnary
  NestedTypeBulletedTuple
  # NOTE: Let InterfaceBlock take first crack at an indented block
  # But don't prevent parsing a braced type with unary suffix like {}[]
  NestedInterfaceBlock
  # NOTE: Next check for consistently indented binary operations (e.g. |)
  # at beginning of each line.
  NestedTypeBinaryChain
  PushIndent ( Nested Type )? PopIndent ->
    if (!$2) return $skip
    return $2
  NotDedented TypeUnary

ReturnTypeSuffix
  _? QuestionMark?:optional _? Colon ReturnType:t ->
    return {
      ...t,
      optional,
      children: [ $1, optional, $3, $4, ...t.children ]
    }

ReturnType
  ( __ "asserts" NonIdContinue )?:asserts ForbidIndentedApplication TypePredicate?:t RestoreIndentedApplication ->
    if (!t) return $skip
    if (asserts) {
      t = {
        type: "TypeAsserts",
        t,
        children: [asserts[0], asserts[1], t],
        ts: true,
      }
    }

    return {
      type: "ReturnTypeAnnotation",
      children: [t],
      t,
      ts: true,
    }

TypePredicate
  MaybeNestedType:lhs ( __ Is Type )?:rhs ->
    if (!rhs) return lhs
    return {
      type: "TypePredicate",
      lhs,
      rhs: rhs[3],
      children: [lhs, ...rhs],
    }

Type
  TypeWithPostfix

TypeBinary
  ( NotDedented TypeBinaryOp __ )?:optionalPrefix TypeUnary:t ( NotDedented TypeBinaryOp MaybeNestedTypeUnary )*:ops ->
    if (!ops.length && !optionalPrefix) return t
    if (!ops.length) return [optionalPrefix, t]
    if (!optionalPrefix) return [t, ...ops]
    return [optionalPrefix, t, ops]

NestedTypeBinaryChain
  PushIndent NestedTypeBinary* PopIndent ->
    if (!$2.length) return $skip
    return $2

NestedTypeBinary
  Nested:indent TypeBinaryOp:op PushExtraIndent1 TypeUnary?:t PopIndent ->
    if (!t) return $skip
    return [ indent, op, t ]

TypeUnary
  ( __ TypeUnaryOp )*:prefix TypePrimary:t TypeUnarySuffix*:suffix ->
    if (!prefix.length && !suffix.length) return t
    return {
      type: "TypeUnary",
      prefix,
      suffix,
      t,
      // omit empty prefix for trimming space
      children: prefix.length ? $0 : [t, suffix],
    }

TypeUnarySuffix
  TypeIndexedAccess
  QuestionMark
  NonNullAssertion

TypeUnaryOp
  "keyof" NonIdContinue
  "readonly" NonIdContinue

TypeIndexedAccess
  OpenBracket Type? __ CloseBracket
  # NOTE: Added shorthand T."string" -> T["string"] and T.0 -> T[0]
  Dot:dot ( TemplateLiteral / StringLiteral / IntegerLiteral ):literal ->
    const open = { ...dot, token: "[" }
    return [
      open,
      literal,
      "]"
    ]
  # NOTE: Extension of coffeePrototype syntax: T::x -> T["x"]
  CoffeePrototypeEnabled DoubleColon:p ( IdentifierName / LengthShorthand )?:id ->
    const open = { ...p, token: '["' }
    return [
      open,
      id,
      '"]'
    ]

UnknownAlias
  "???" ->
    return { $loc, token: "unknown" }

TypePrimary
  # NOTE: https://github.com/microsoft/TypeScript/blob/ae27e55b027c66bf5b80f596da866f8485ac491d/src/compiler/parser.ts#L4724-L4745
  _? Infer _? IdentifierName ( NotDedented ExtendsToken Type )?
  # NOTE: typeof also parses as an identifier, so check for it early
  # NOTE: typeof takes a unary expression, as in
  # https://github.com/microsoft/TypeScript/blob/ae27e55b027c66bf5b80f596da866f8485ac491d/src/compiler/parser.ts#L5666-L5669
  # (binary expression can accidentally grab closing ">" of type arguments)
  _? Typeof _? UnaryExpression ->
    return {
      type: "TypeofType",
      children: $0,
    }
  _? TypeTuple ->
    return prepend($1, $2)
  InterfaceBlock
  _? TypeFunction
  _? InlineInterfaceLiteral
  _? ImportType:t ->
    return {
      type: "ImportType",
      t,
      children: $0,
    }
  _? TypeLiteral:t ->
    return {
      type: "TypeLiteral",
      t,
      children: $0,
    }
  _? UnknownAlias ->
    return {
      type: "TypeIdentifier",
      children: $0,
      raw: $2.token,
      args: undefined
    }
  _? Identifier (Dot IdentifierName)* ( TypeArguments / ImplicitTypeArguments )?:args ->
    return {
      type: "TypeIdentifier",
      children: $0,
      raw: [$2.name, ...$3.map(([dot, id]) => dot.token + id.name), ].join(''),
      args,
    }
  # NOTE: Check TypeFunction before parenthesized in order to distinguish between (a: T) => U and
  # A parenthesized inline interface (a: T) ---> ({a: T})
  # NOTE: Check Type before ( EOS Type ) to find implicit nested interfaces first. EOS would swallow the
  # newline so Nested wouldn't match otherwise.
  _? OpenParen AllowAll ( Type / ( EOS Type ) )? RestoreAll __ CloseParen ->
    if (!$4) return $skip
    return {
      type: "TypeParenthesized",
      children: [ $1, $2, $4, $6, $7 ],  // omit AllowAll/RestoreAll
    }

ImportType
  "import" OpenParen __ StringLiteral __ CloseParen ( Dot IdentifierName )? TypeArguments?
  # NOTE: Added implicit import without parens
  "import" InsertOpenParen Trimmed_? StringLiteral InsertCloseParen

TypeTuple
  OpenBracket:open AllowAll TypeTupleContent?:elements RestoreAll __:ws CloseBracket:close ->
    if (!elements) return $skip
    return {
      type: "TypeTuple",
      elements,
      children: [ open, elements, ws, close ],
    }

TypeTupleContent
  # First check for properly indented list items
  NestedTypeElementList &( __ CloseBracket )
  # Next check for a line of items followed by properly indented list items;
  # first line should not use indented applications because they may be
  # lines of list items
  TypeElementListWithIndentedApplicationForbidden:list ArrayElementDelimiter:delimiter NestedTypeElementList?:nested &( __ CloseBracket ) ->
    if (!nested) return list
    return [...list, delimiter, ...nested]
  # As fallback, ignore indentation altogether, forbidding indented applications
  ( __ TypeElementListWithIndentedApplicationForbidden ArrayElementDelimiter )* ->
    return $1.flat()

TypeElementListWithIndentedApplicationForbidden
  ForbidIndentedApplication TypeElementList? RestoreIndentedApplication ->
    if ($2) return $2
    return $skip

TypeElementList
  TypeBulletedTuple -> [$1]
  !EOS TypeElement:first ( ( _? Comma !EOS ) TypeElement )*:rest ->
    if (!rest.length) return [first]
    return [
      append(first, rest[0][0])
    ].concat(
      rest.map(([_, e], i) => append(e, rest[i+1]?.[0]))
    )

TypeElement
  # NOTE: Allow for postfix splat like CoffeeScript
  # NOTE: Match named form first, to avoid matching `foo: bar,` as Type
  # and then DotDotDot from next entry.
  __:ws ( DotDotDot __ )?:dots1 IdentifierName:name ( _? DotDotDot )?:dots2 (__ (QuestionMark _?)? Colon __):colon Type:type ->
    let dots = dots1 || (dots2 && [dots2[1], dots2[0]] /* space at end */)
    if (dots1 && dots2) {
      dots = [dots, {
        type: "Error",
        message: "... both before and after identifier",
      }]
    }
    return {
      type: "TypeElement",
      name,
      t: type,
      children: [ ws, dots, name, colon, type ],
    }
  __ DotDotDot __ Type:type
  Type:type ( _? DotDotDot )?:spaceDots ->
    if (spaceDots) {
      const [ space, dots ] = spaceDots
      const ws = getTrimmingSpace(type)
      spaceDots = [ ws, dots, space ]
      type = trimFirstSpace(type)
    }
    return {
      type: "TypeElement",
      t: type,
      children: [ spaceDots, type ],
    }

NestedTypeElementList
  PushIndent NestedTypeElement*:types PopIndent ->
    if (types.length)
      return types
    return $skip

NestedTypeElement
  Nested:indent TypeElementList:list ArrayElementDelimiter:delimiter ->
    const {length} = list
    if (!length) return $skip
    // Prepend indent to first element and append delimiter to last element
    return list.map((e, i) => {
      if (i === 0) e = prepend(indent, e)
      if (i === length - 1) e = append(e, delimiter)
      return e
    })

# NOTE: Nested bulleted tuple starts with an indentation.
NestedTypeBulletedTuple
  ( InsertSpace InsertOpenBracket ):open PushIndent NestedTypeBullet*:content InsertCloseBracket:close PopIndent ->
    if (!content.length) return $skip
    content = content.flat() // combine bullets into one array

    // Remove implicit comma from last element
    const last = content[content.length - 1]
    let children = Array.isArray(last) ? last : last?.children
    if (children?.at(-1).implicit) {
      children = children.slice(0, -1)
      if (Array.isArray(last)) {
        content[content.length - 1] = children
      } else {
        content[content.length - 1] = { ...last, children }
      }
    }

    return {
      type: "TypeTuple",
      children: [...open, ...content, close],
    }

# NOTE: Bulleted tuple intended for beginning of lines,
# when leading indentation has already been consumed.
TypeBulletedTuple
  InsertOpenBracket:open ( TypeBullet NestedTypeBullet* )?:content InsertCloseBracket:close ->
    if (!content) return $skip
    content = [
      ...trimFirstSpace(content[0]), // replace first space with bracket
      ...content[1].flat(),
    ]

    // Remove implicit comma from last element
    const last = content[content.length - 1]
    let children = Array.isArray(last) ? last : last?.children
    if (children?.at(-1).implicit) {
      children = children.slice(0, -1)
      if (Array.isArray(last)) {
        content[content.length - 1] = children
      } else {
        content[content.length - 1] = { ...last, children }
      }
    }

    return {
      type: "TypeTuple",
      children: [open, ...content, close],
    }

NestedTypeBullet
  Nested:indent TypeBullet:list ->
    // Prepend indent to first element
    return list.map((e, i) => i === 0 ? prepend(indent, e) : e)

TypeBullet
  BulletIndent:bullet ( TypeElementList ArrayBulletDelimiter )?:content PopIndent ->
    if (!content) return $skip
    let [ list, delimiter ] = content
    if (!list.length) return $skip
    // Prepend bullet to first element and append delimiter to last element
    list = list.slice()
    list[0] = prepend(bullet, list[0])
    if (delimiter) {
      const last = list.length - 1
      list[last] = append(list[last], delimiter)
    }
    return list

TypeWithPostfix
  TypeConditional:t ( SameLineOrIndentedFurther TypeIfClause )?:postfix ->
    if (!postfix) return t
    return prepend(postfix[0],
      expressionizeTypeIf([ ...postfix[1], $1, undefined ]))

TypeConditional
  _? /(?=if|unless)/ TypeIfThenElse ->
    return prepend($1, expressionizeTypeIf($3))
  TypeCondition NotDedented QuestionMark __ Type __ Colon __ Type ->
    if ($1.negated) return [ $1, $2, $3, $4, $9, $6, $7, $8, $5 ]
    return $0
  TypeBinary

TypeCondition
  # NOTE: Type after `extends` needs to forbid TypePostfix,
  # or it could end up matching the "then" clause of an if/then/else
  TypeBinary IndentedFurther? ( ExtendsToken / NotExtendsToken ) TypeConditional ->
    return {
      type: "TypeCondition",
      negated: $3.negated,
      children: $0,
    }

TypeIfThenElse
  TypeIfClause TypeBlock TypeElse? ->
    return [...$1, $2, $3]

TypeIfClause
  ( If / Unless ) OpenParen AllowAll TypeCondition?:condition RestoreAll CloseParen ->
    if (!condition) return $skip
    return [ $1, condition ]  // unwrap parentheses
  ( If / Unless ) ForbidIndentedApplication TypeCondition?:condition RestoreIndentedApplication ->
    if (!condition) return $skip
    return [ $1, condition ]

TypeElse
  NotDedented Else TypeBlock

TypeBlock
  Then Type -> $2
  !EOS Type -> $2
  NestedInterfaceBlock
  PushIndent ( Nested Type )? PopIndent ->
    if (!$2) return $skip
    return $2

TypeTemplateSubstitution
  SubstitutionStart Type __ CloseBrace

TypeTemplateLiteral
  Backtick ( TemplateCharacters / TypeTemplateSubstitution )* Backtick ->
    return {
      type: "TemplateLiteral",
      children: $0,
    }
  CoffeeInterpolatedDoubleQuotedTypeLiteral

CoffeeStringTypeSubstitution
  CoffeeSubstitutionStart Type __ CloseBrace

CoffeeInterpolatedDoubleQuotedTypeLiteral
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringTypeSubstitution )*:parts DoubleQuote:e ->
    return processCoffeeInterpolation(s, parts, e, $loc)

TypeLiteral
  TypeTemplateLiteral
  # NOTE: TemplateLiteral must be before Literal, so that CoffeeScript
  # interpolated strings get checked first before StringLiteral.
  Literal
  [+-]:sign NumericLiteral:num ->
    // TypeScript doesn't support + before a number literal type
    if (sign[0] === "+") return num
    return $0
  "void" NonIdContinue ->
    return { type: "VoidType", $loc, token: $1 }
  "unique" _ "symbol" NonIdContinue ->
    return { type: "UniqueSymbolType", children: $0 }
  "[]" ->
    return { $loc, token: "[]" }

InlineInterfaceLiteral
  InsertInlineOpenBrace InlineBasicInterfaceProperty ( SameLineOrIndentedFurther InlineBasicInterfaceProperty )* InsertCloseBrace

InlineBasicInterfaceProperty
  # NOTE: Not using TypeSuffix here to require a Colon, and to forbid spaces
  # before the colon (to enable conditional types like prop ? T1 : T2).
  ( TypeIndexSignature / TypeProperty ) QuestionMark? Colon Type InlineInterfacePropertyDelimiter

InlineInterfacePropertyDelimiter
  ( _? Semicolon ) / CommaDelimiter
  &( SameLineOrIndentedFurther InlineBasicInterfaceProperty ) InsertComma -> $2
  &( __  ( ":" / ")" / "]" / "}" ) )
  &EOS

TypeBinaryOp
  "|" ->
    return { $loc, token: "|" }
  "&" ->
    return { $loc, token: "&" }

TypeFunction
  ( Abstract _? )?:abstract ( Async _? )?:async ( New _? )?:new_ Parameters __ TypeFunctionArrow ( ReturnType / Loc ):returnType ->
    const children = [ abstract, ...$0.slice(2) ] // omit async
    if (abstract && !new_) {
      children[1] = {
        type: "Error",
        message: "abstract function types must be constructors (abstract new)",
      }
    }
    // Implicit void return type
    if (returnType.$loc && returnType.token === "") {
      const t = {
        type: "VoidType",
        $loc: returnType.$loc,
        token: "void",
      }
      children[children.length - 1] = returnType = {
        type: "ReturnTypeAnnotation",
        ts: true,
        t,
        children: [t],
      }
    }
    // async wraps return type in Promise<...>
    if (async) {
      const t = wrapTypeInPromise(returnType.t)
      children[children.length - 1] = returnType = {
        ...returnType, t,
        children: returnType.children.map($ => $ === returnType.t ? t : $),
      }
    }
    return {
      type: "TypeFunction",
      children,
      ts: true,
      returnType,
    }

TypeFunctionArrow
  "=>" / "⇒" / "->" / "→" ->
    return { $loc, token: "=>" }

TypeArguments
  OpenAngleBracket ( __ TypeArgumentDelimited )+:args __ CloseAngleBracket ->
    args = args.flatMap(([ws, [arg, delim]]) => [prepend(ws, arg), delim])
    args.pop() // remove last delimiter
    return {
      type: "TypeArguments",
      ts: true,
      args,
      children: $0,
    }

ImplicitTypeArguments
  TypeApplicationStart InsertOpenAngleBracket:open Trimmed_?:ws TypeArgumentList:args InsertCloseAngleBracket:close ->
    // Remove trailing comma which is forbidden in TypeScript type arguments
    const last = args[args.length - 1]
    if (isComma(last)) args = args.slice(0, -1)
    return {
      type: "TypeArguments",
      ts: true,
      args,
      children: [open, ws, args, close],
    }

TypeApplicationStart
  IndentedApplicationAllowed &( IndentedFurther !ForbiddenImplicitTypeCalls )
  !EOS &( _ !ForbiddenImplicitTypeCalls )

ForbiddenImplicitTypeCalls
  ReservedBinary
  # TypeBinaryOp, ExtendsToken, NotExtendsToken, TypeFunctionArrow
  /[|&<!=\-⇒→]/
  # Abstract, Readonly, ExtendsToken, NotExtendsToken, Is
  /(extends|not|is)(?!\p{ID_Continue}|[\u200C\u200D$])/

# Based on ArgumentList
TypeArgumentList
  # Check for same line arguments then nested arguments
  !EOS TypeArgument ( CommaDelimiter !EOS WTypeArgument )* ( CommaDelimiter ( NestedTypeBulletedTuple / NestedInterfaceBlock / NestedTypeArgumentList ) )+ ->
    return [
      $2,
      ...$3.flatMap(([comma, eos, arg]) => [comma, arg]),
      ...$4.flatMap(([comma, args]) =>
        Array.isArray(args) ? [comma, ...args] : [comma, args]
      ),
    ]
  # NOTE: Added nested arguments on separate new lines
  ( NestedTypeBulletedTuple / NestedInterfaceBlock ) ( CommaDelimiter ( NestedTypeBulletedTuple / NestedInterfaceBlock / NestedTypeArgumentList ) )* ->
    return [
      trimFirstSpace($1),
      ...$2.flatMap(([comma, args]) =>
        Array.isArray(args) ? [comma, ...args] : [comma, args]
      ),
    ]
  NestedTypeArgumentList
  # NOTE: Eliminated left recursion
  TypeArgument ( CommaDelimiter WTypeArgument )* ->
    return [
      $1,
      ...$2.flatMap(([comma, arg]) => [comma, arg]),
    ]

NestedTypeArgumentList
  PushIndent NestedTypeArgument*:args PopIndent ->
    if (!args.length) return $skip
    return args.flat()

NestedTypeArgument
  Nested:indent SingleLineTypeArgumentList:args TypeArgumentDelimiter:comma ->
    // Attach indentation to first argument in SingleLineTypeArgumentList
    let [ arg0, ...rest ] = args
    arg0 = prepend(indent, arg0)
    return [ arg0, ...rest, comma ]

SingleLineTypeArgumentList
  WTypeArgument ( ( _? Comma ) WTypeArgument )* ->
    return [ $1, ...$2 ]

WTypeArgument
  _? TypeArgument ->
    return prepend($1, $2)

TypeArgumentDelimited
  TypeArgument TypeArgumentDelimiter

TypeArgument
  Type:t -> { type: "TypeArgument", ts: true, t, children: [ t ] }

TypeArgumentDelimiter
  TypeParameterDelimiter

TypeParameters
  OpenAngleBracket TypeParameter+:parameters __ CloseAngleBracket ->
    return {
      type: "TypeParameters",
      parameters,
      ts: true,
      children: $0
    }

TypeParameter
  __ ( /const|in|out/ _ )* Identifier TypeConstraint? TypeInitializer? TypeParameterDelimiter

TypeConstraint
  __ ExtendsToken Type

TypeInitializer
  __ "=" Type

TypeParameterDelimiter
  _? Comma
  &( __ ">" )
  &EOS InsertComma -> $2

# TypeScript's this: T syntax in function parameters
ThisType
  _? ( This / AtThis ) Colon Type ParameterElementDelimiter -> {
    type: "ThisType",
    ts: true,
    children: $0
  }

## Utility

Shebang
  /#![^\r\n]*/ EOL

CivetPrologue
  [\t ]* DoubleQuote CivetPrologueContent:content DoubleQuote SimpleStatementDelimiter [ \t]* ( EOL / &RestOfLine ) -> content
  [\t ]* SingleQuote CivetPrologueContent:content SingleQuote SimpleStatementDelimiter [ \t]* ( EOL / &RestOfLine ) -> content

CivetPrologueContent
  "civet" NonIdContinue CivetOption*:options [\s]* ->
    return {
      type: "CivetPrologue",
      children: [],
      config: Object.fromEntries(options),
    }

CivetOption
  /\s+([+-]?)([a-zA-Z0-9-]+)(\s*=\s*([\p{ID_Continue}.,+-]*))?/ ->
    // Normalize option names to camelCase
    const optionName = $2.replace(/-+([a-z]?)/g, (_, l) => {
      if (l) return l.toUpperCase()
      return ""
    })
    // - is disabled, + is enabled, no prefix is enabled
    // =value sets the value to any value (used for `tab`)
    let value =
      $3 ? $4 : ($1 === "-") ? false : true
    // Some options are parsed specially
    switch (optionName) {
      case "tab":
        value = parseFloat(value)
        if (isNaN(value)) value = 0
        break
      case "globals":
      case "symbols":
        value = value.split(',').filter(Boolean)
        break
    }

    return [optionName, value]

UnknownPrologue
  # NOTE: $ is to keep source verbatim and not insert a semicolon if one was omitted
  # Can't use $EOS because it will prevent re-writing of coffee style comments
  [\t ]* StringLiteral:s $SimpleStatementDelimiter EOS

TripleSlashDirective
  # https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html
  /\/\/\/[^\r\n]*/ EOS?

DirectivePrologue
  PrologueString !( __ ( AccessStart / Pipe ) ) -> $1

PrologueString
  CivetPrologue
  UnknownPrologue

EOS
  # perf: assertion to exit early
  /(?=[ \t\r\n\/#]|$)/ RestOfLine+ -> $2

# End of line, including EOF
EOL
  /\r\n|\n|\r|$/ ->
    return { $loc, token: $0 }

DebugHere
  "" ->
    debugger

# Insertions

InsertColon
  "" ->
    return { $loc, token: ":" }

InsertSemicolon
  "" ->
    return { $loc, token: ";" }

InsertOpenParen
  "" ->
    return { $loc, token: "(" }

InsertCloseParen
  "" ->
    return { $loc, token: ")" }

InsertOpenBrace
  # NOTE: Includes a preceding space
  "" ->
    return [{ $loc, token: " " }, { $loc, token: "{" } ]

InsertInlineOpenBrace
  "" ->
    return { $loc, token: "{" }

InsertCloseBrace
  "" ->
    return { $loc, token: "}" }

InsertOpenBracket
  "" ->
    return { $loc, token: "[" }

InsertCloseBracket
  "" ->
    return { $loc, token: "]" }

InsertOpenAngleBracket
  "" ->
    return { $loc, token: "<" }

InsertCloseAngleBracket
  "" ->
    return { $loc, token: ">" }

InsertComma
  "" ->
    return { $loc, token: ",", implicit: true }

InsertSpaceEquals
  "" ->
    return { $loc, token: " =" }

InsertConst
  # NOTE: Includes a trailing space
  "" ->
    return { $loc, token: "const " }

InsertLet
  "" ->
    return { $loc, token: "let " }

InsertReadonly
  # NOTE: Includes a trailing space
  "" ->
    return { ts: true, children: [ { $loc, token: "readonly " } ] }

InsertNewline
  "" ->
    return "\n"

InsertIndent
  "" ->
    return state.currentIndent.token

InsertSpace
  "" ->
    return { $loc, token: " " }

InsertDot
  "" ->
    return { $loc, token: "." }

InsertBreak
  "" ->
    return { $loc, token: ";break;" }

InsertVar
  "" ->
    return { $loc, token: "var " }

InsertType
  "" ->
    return { $loc, token: "type " }

CoffeeBinaryExistentialEnabled
  "" ->
    if(config.coffeeBinaryExistential) return
    return $skip

CoffeeBooleansEnabled
  "" ->
    if(config.coffeeBooleans) return
    return $skip

CoffeeClassesEnabled
  "" ->
    if(config.coffeeClasses) return
    return $skip

CoffeeCommentEnabled
  "" ->
    if(config.coffeeComment) return
    return $skip

CoffeeDivEnabled
  "" ->
    if(config.coffeeDiv) return
    return $skip

CoffeeDoEnabled
  "" ->
    if(config.coffeeDo) return
    return $skip

CoffeeForLoopsEnabled
  "" ->
    if(config.coffeeForLoops) return
    return $skip

CoffeeInterpolationEnabled
  "" ->
    if(config.coffeeInterpolation) return
    return $skip

CoffeeIsntEnabled
  "" ->
    if(config.coffeeIsnt) return
    return $skip

CoffeeJSXEnabled
  "" ->
    if(config.coffeeJSX) return
    return $skip

CoffeeLineContinuationEnabled
  "" ->
    if(config.coffeeLineContinuation) return
    return $skip

CoffeeNotEnabled
  "" ->
    if(config.coffeeNot) return
    return $skip

CoffeeOfEnabled
  "" ->
    if(config.coffeeOf) return
    return $skip

CoffeePrototypeEnabled
  "" ->
    if(config.coffeePrototype) return
    return $skip

JSXCodeNestedEnabled
  "" ->
    if(config.jsxCodeNested) return
    return $skip

JSXCodeSameLineEnabled
  "" ->
    if(config.jsxCodeSameLine) return
    return $skip

ObjectIsEnabled
  "" ->
    if(config.objectIs) return
    return $skip

IsBare
  "" ->
    if(config.iife || config.repl) return $skip

# Reset module level data
Reset
  "" ->
    // Storage for PushIndent/PopIndent
    state.indentLevels = [{
      level: 0,
      token: "",
    }]

    state.forbidClassImplicitCall = [false]
    state.forbidIndentedApplication = [false]
    state.forbidBracedApplication = [false]
    state.forbidTrailingMemberProperty = [false]
    state.forbidNestedBinaryOp = [false]
    state.forbidNewlineBinaryOp = [false]
    state.forbidPipeline = [false]
    state.JSXTagStack = [undefined]

    state.operators = new Map

    state.helperRefs = {}
    state.prelude = []

    config = {
      autoConst: false,
      autoVar: false,
      autoLet: false,
      coffeeBinaryExistential: false,
      coffeeBooleans: false,
      coffeeClasses: false,
      coffeeComment: false,
      coffeeDiv: false,
      coffeeDo: false,
      coffeeEq: false,
      coffeeForLoops: false,
      coffeeInterpolation: false,
      coffeeIsnt: false,
      coffeeJSX: false,
      coffeeLineContinuation: false,
      coffeeNot: false,
      coffeeOf: false,
      coffeePrototype: false,
      defaultElement: "div",
      globals: [],
      iife: false,
      implicitReturns: true,
      jsxCode: false,
      objectIs: false,
      react: false,
      solid: false,
      client: false, // default behavior: client only
      repl: false,
      rewriteTsImports: true,
      server: false,
      strict: false,
      symbols: wellKnownSymbols,
      tab: undefined, // default behavior = same as space
      verbose: false,
    }

    Object.defineProperty(config, "deno", {
      set(b) {
        config.rewriteTsImports = !b
      }
    })
    // default to deno compatibility if running in deno
    config.deno = typeof Deno !== "undefined"

    // Expand setting coffeeCompat to the individual options
    Object.defineProperty(config, "coffeeCompat", {
      set(b) {
        for (const option of [
          "autoVar",
          "coffeeBinaryExistential",
          "coffeeBooleans",
          "coffeeClasses",
          "coffeeComment",
          "coffeeDiv",
          "coffeeDo",
          "coffeeEq",
          "coffeeForLoops",
          "coffeeInterpolation",
          "coffeeIsnt",
          "coffeeJSX",
          "coffeeLineContinuation",
          "coffeeNot",
          "coffeeOf",
          "coffeePrototype",
        ]) {
          config[option] = b
        }
        if (b) {
          config.objectIs = false
        }
      }
    })

    Object.defineProperty(config, "jsxCode", {
      set(b) {
        for (const option of [
          "jsxCodeNested",
          "jsxCodeSameLine",
        ]) {
          config[option] = b
        }
      }
    })

    // Pass in parser config from main
    Object.assign(config, initialConfig)

Init
  Shebang? Prologue:directives ->
    directives.forEach((directive) => {
      if (directive.type === "CivetPrologue") {
        Object.assign(config, directive.config)
      }
    })

    if (config.strict) {
      $0 = [...$0, '"use strict";\n']
    }

    return $0

Prologue
  ( TripleSlashDirective / ( ( JSSingleLineComment / JSMultiLineComment ) EOS ) / DirectivePrologue )*

# NOTE: Used by Playground to separate Prologue from rest of program
ProloguePrefix
  Prologue /[^]*/

# Indentation

# Holds the last indent level in `state.lastIndent`
# Can get weird with backtracking but should work out as long as
# EOS/Nested rules are used carefully and if we only compare to the
# pushed value.
Indent
  /[ \t]*/ ->
    const level = getIndentLevel($0, config.tab)

    return {
      $loc,
      token: $0,
      level
    }

# Used in PushIndent to keep track of the last indent level for nesting
TrackIndented
  Indent:indent ->
    const {level} = indent

    if (level <= state.currentIndent.level) {
      return $skip
    }
    if (config.verbose) {
      console.log("pushing indent", indent)
    }

    state.indentLevels.push(indent)
    return $1

# Indents one level deeper,
# without consuming the indentation so it can be by Nested
# Must be matched with PopIndent
PushIndent
  # TrackIndented pushes the indent level if it is deeper than the current level
  # it will skip if it is not deeper
  &( EOS TrackIndented )

PopIndent
  "" ->
    if (config.verbose) {
      console.log("popping indent", state.indentLevels[state.indentLevels.length-1], "->", state.indentLevels[state.indentLevels.length-2])
    }
    state.indentLevels./**/pop()

# "Nested" actually means "new line at current indentation level",
# where the current indentation level is set by TrackIndented / PushIndent
# (which require strictly more indentation than previous levels)
# Consumes and returns the newline and indentation
Nested
  EOS Indent:indent ->
    if (indent.level === state.currentIndent.level) return $0
    if (config.verbose) {
      console.log(`failing Nested: ${indent.level} does not match current indent level ${state.currentIndent.level}`)
    }
    return $skip

IndentedFurther
  EOS Indent:indent ->
    if (indent.level > state.currentIndent.level) return $0
    return $skip

IndentedAtLeast
  EOS Indent:indent ->
    if (indent.level >= state.currentIndent.level) return $0
    return $skip

NotDedented
  IndentedAtLeast? _? ->
    const ws = []
    if ($1) ws.push(...$1)
    if ($2) ws.push(...$2)
    return ws.flat(Infinity).filter(Boolean)

SameLineOrIndentedFurther
  IndentedFurther? _? ->
    const ws = []
    if ($1) ws.push(...$1)
    if ($2) ws.push(...$2)
    return ws.flat(Infinity).filter(Boolean)

Dedented
  !IndentedAtLeast EOS -> $2

PushExtraIndent1
  "" ->
    const indent = {
      token: "",
      $loc,
      level: state.currentIndent.level + 1,
    }
    if (config.verbose) console.log("pushing bonus indent", indent)
    state.indentLevels.push(indent)
    return indent
