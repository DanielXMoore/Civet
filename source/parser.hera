# Civet: A successor to CoffeeScript and alternative to TypeScript
# much more 1-to-1 with es6

# ECMA Reference
# https://262.ecma-international.org/13.0/

```
import {
  addPostfixStatement,
  adjustBindingElements,
  adjustIndexAccess,
  attachPostfixStatementAsExpression,
  blockWithPrefix,
  convertObjectToJSXAttributes,
  dedentBlockString,
  dedentBlockSubstitutions,
  deepCopy,
  expressionizeTypeIf,
  forRange,
  gatherBindingCode,
  gatherRecursive,
  getIndentLevel,
  getPrecedence,
  getTrimmingSpace,
  hasAwait,
  hasYield,
  insertTrimmingSpace,
  isEmptyBareBlock,
  isWhitespaceOrEmpty,
  lastAccessInCallExpression,
  literalValue,
  makeAmpersandFunction,
  makeEmptyBlock,
  makeExpressionStatement,
  makeGetterMethod,
  makeLeftHandSideExpression,
  makeRef,
  maybeRef,
  modifyString,
  negateCondition,
  processAssignmentDeclaration,
  processBinaryOpExpression,
  processCallMemberExpression,
  processCoffeeInterpolation,
  processForInOf,
  processProgram,
  processUnaryExpression,
  quoteString,
  reorderBindingRestProperty,
  replaceNodes,
  skipImplicitArguments,
  typeOfJSX,
} from "./parser/lib.civet"

/**
 * A global object to hold methods used in rule handlers
 * We can probably transition away from this now that Hera
 * supports importing from other files as well as inline JS.
 */
const module = {};
```

Program
  # EOS allows for initial comment blocks and newlines,
  # when Init didn't already consume them.
  Reset Init EOS? TopLevelStatements:statements __ ->
    // NOTE: Wrap top level statements in a bare block so they have a parent
    processProgram({
      type: "BlockStatement",
      expressions: statements,
      children: [statements],
      bare: true,
      root: true,
    }, module.config, module, ReservedWord)
    return $0

TopLevelStatements
  # If first line is strictly indented, require all lines to be equally so
  # Use TrackIndented instead of PushIndent to avoid requiring leading EOS
  TrackIndented:indent TopLevelSingleLineStatements:first NestedTopLevelStatements*:rest PopIndent ->
    return [
      [indent, ...first[0]],
      ...first.slice(1).map(s => ["", ...s]),
      ...rest.flat(),
    ]
  # Unindented case: rely on initial indentLevel of 0
  TopLevelSingleLineStatements:first NestedTopLevelStatements*:rest ->
    return [
      ...first.map(s => ["", ...s]),
      ...rest.flat(),
    ]
  # Empty case
  "" -> []

NestedTopLevelStatements
  Nested:nested TopLevelSingleLineStatements:statements ->
    return [
      [nested, ...statements[0]],
      ...statements.slice(1).map(s => ["", ...s]),
    ]

# Multiple top-level semicolon-separated statements
TopLevelSingleLineStatements
  TopLevelStatement+

TopLevelStatement
  # NOTE: !EOS forces semicolon after all but last statement, forbids leading __
  # NOTE: _? allows for leading inline comments
  !EOS _?:ws ModuleItem:statement StatementDelimiter:delimiter ->
    if (ws) {
      statement = {
        ...statement,
        children: [ws, ...statement.children],
      }
    }
    return [statement, delimiter]

# Expressions with comma operator, or expressions with If and Switch
ExtendedCommaExpression
  NonAssignmentExtendedExpression
  CommaExpression

# Expressions with If and Switch, but no comma operator
ExtendedExpression
  NonAssignmentExtendedExpression
  AssignmentExpression

SingleLineExtendedExpression
  NonAssignmentExtendedExpression
  SingleLineAssignmentExpression

NonPipelineExtendedExpression
  NonAssignmentExtendedExpression
  NonPipelineAssignmentExpression

NonAssignmentExtendedExpression
  # Check for nested expressionized statements first
  NestedNonAssignmentExtendedExpression
  __ ExpressionizedStatementWithTrailingCallExpressions ->
    if ($2.length) {
      return [...$1, ...$2]
    }
    return {...$2,
      children: [...$1, ...$2.children]
    }

NestedNonAssignmentExtendedExpression
  &EOS PushIndent ( Nested ExpressionizedStatementWithTrailingCallExpressions )?:expression PopIndent AllowedTrailingCallExpressions?:trailing ->
    if (!expression) return $skip
    if (!trailing) return expression
    return {
      type: "CallExpression",
      children: [ expression, ...trailing.flat() ]
    }

ExpressionizedStatementWithTrailingCallExpressions
  ExpressionizedStatement AllowedTrailingCallExpressions? ->
    if (!$2) return $1
    // Some expressionized statements, such as `if`s,
    // need to be wrapped in parens
    return {
      type: "CallExpression",
      children: [
        makeLeftHandSideExpression($1),
        $2,
      ],
    }

ExpressionizedStatement
  # perf: assertion to exit early
  /(?=async|debugger|if|unless|do|for|loop|until|while|switch|throw|try)/ StatementExpression:statement ->
    return {
      type: "StatementExpression",
      statement,
      children: [statement],
    }

StatementExpression
  DebuggerStatement
  IfStatement
  IterationExpression
  SwitchStatement
  ThrowStatement
  TryStatement

# https://262.ecma-international.org/#prod-Expression
CommaExpression
  # CommaOperator
  # https://262.ecma-international.org/#sec-comma-operator
  # NOTE: Eliminated left recursion
  AssignmentExpression ( CommaDelimiter AssignmentExpression )* ->
    if($2.length == 0) return $1
    return $0

# https://262.ecma-international.org/#prod-Arguments
Arguments
  ExplicitArguments

  # Space / indentation based function application
  # Function application:
  # a b => a(b)
  # a b, c, d => a(b, c, d)
  # x y z => x(y(z))
  ForbidTrailingMemberProperty ImplicitArguments?:args RestoreTrailingMemberProperty ->
    if (args) return args
    return $skip

ImplicitArguments
  ApplicationStart InsertOpenParen:open _?:ws NonPipelineArgumentList:args InsertCloseParen:close ->
    // Don't treat as call if this is a postfix for/while/until/if/unless
    if (skipImplicitArguments(args)) return $skip

    return {
      type: "Call",
      args,
      children: [open, insertTrimmingSpace(ws, ""), args, close]
    }

ExplicitArguments
  OpenParen:open ( ArgumentList ( __ Comma )? )?:args __:ws CloseParen:close ->
    if (args) {
      if (args[1]) { // trailing comma
        args = [ ...args[0], args[1] ]
      } else { // no trailing comma
        args = args[0]
      }
    } else { // no arguments
      args = []
    }
    return {
      type: "Call",
      args,
      children: [open, args, ws, close],
    }

# Start of function application, inserts an open parenthesis, maintains spacing and comments when possible
ApplicationStart
  IndentedApplicationAllowed &( IndentedFurther !IdentifierBinaryOp !AccessStart )
  !EOS &( _ ( BracedApplicationAllowed / !"{" ) !ForbiddenImplicitCalls )

ForbiddenImplicitCalls
  # Reserved words that prevent spaced implicit function application
  # ie: the 'of' in 'for x of ...'
  /(as|of|satisfies|then|when|implements|xor|xnor)(?!\p{ID_Continue}|[\u200C\u200D$])/
  # NOTE: Don't allow non-heregex regexes that begin with a space as first argument without parens
  "/ "
  # Don't treat @@decorator @@decorator class ... as implicit calls
  ClassImplicitCallForbidden ( Class / AtAt )
  Identifier "=" Whitespace
  # NOTE: Custom operators created via `operator`
  Identifier:id !"(" ->
    if (module.operators.has(id.name)) return $0
    return $skip
  OmittedNegation _? Identifier:id ->
    if (module.operators.has(id.name)) return $0
    return $skip
  # `x ... y` is reserved for a range, but `x ...y` is an implicit call
  "... "

ArgumentsWithTrailingMemberExpressions
  Arguments:args AllowedTrailingMemberExpressions:trailing ->
    return [ args, ...trailing ]

TrailingMemberExpressions
  # NOTE: Assert "." to not match "?" or "!" as a member expression on the following line
  MemberExpressionRest* ( IndentedAtLeast &( "?"? "." ![0-9] ) MemberExpressionRest )* ->
    return $1.concat($2)

AllowedTrailingMemberExpressions
  TrailingMemberPropertyAllowed TrailingMemberExpressions -> $2
  MemberExpressionRest*

TrailingCallExpressions
  # NOTE: Assert "." to not match "?" or "!" or string literal
  # as a call expression on the following line
  ( IndentedAtLeast &( "?"? "." ![0-9] ) CallExpressionRest+ )+

AllowedTrailingCallExpressions
  TrailingMemberPropertyAllowed TrailingCallExpressions -> $2

CommaDelimiter
  NotDedented Comma

# https://262.ecma-international.org/#prod-ArgumentList
# NOTE: Return value should always be an array alternating
#   argument, comma, argument, comma, ..., argument, [comma],
# where each comma is a Comma token or an array [whitespace, commaToken]
# (like CommaDelimiter)
ArgumentList
  # Check for same line arguments then nested arguments
  ArgumentPart ( CommaDelimiter !EOS ArgumentPart )* ( CommaDelimiter ( NestedImplicitObjectLiteral / NestedArgumentList ) )+ ->
    return [
      $1,
      ...$2.flatMap(([comma, eos, arg]) => [comma, arg]),
      ...$3.flatMap(([comma, args]) =>
        Array.isArray(args) ? [comma, ...args] : [comma, args]
      )
    ]
  # NOTE: Added nested arguments on separate new lines
  NestedImplicitObjectLiteral ->
    return [ insertTrimmingSpace($1, '') ]
  NestedArgumentList
  # NOTE: Eliminated left recursion
  ( _? ArgumentPart ) ( CommaDelimiter ( _? ArgumentPart ) )* ->
    return [ $1, ...$2.flat() ]

# NOTE: ArgumentList variant that forbids top-level pipeline operators
NonPipelineArgumentList
  # Check for same line arguments then nested arguments
  NonPipelineArgumentPart ( CommaDelimiter !EOS NonPipelineArgumentPart )* ( CommaDelimiter ( NestedImplicitObjectLiteral / NestedArgumentList ) )+ ->
    return [
      $1,
      ...$2.flatMap(([comma, eos, arg]) => [comma, arg]),
      ...$3.flatMap(([comma, args]) =>
        Array.isArray(args) ? [comma, ...args] : [comma, args]
      )
    ]
  # NOTE: Added nested arguments on separate new lines
  NestedImplicitObjectLiteral ->
    return [ insertTrimmingSpace($1, '') ]
  NestedArgumentList
  # NOTE: Eliminated left recursion
  ( _? NonPipelineArgumentPart ) ( CommaDelimiter ( _? NonPipelineArgumentPart ) )* ->
    return [ $1, ...$2.flat() ]

NestedArgumentList
  PushIndent NestedArgument*:args PopIndent ->
    if (!args.length) return $skip
    return args.flat()

NestedArgument
  Nested:indent SingleLineArgumentExpressions:args ParameterElementDelimiter:comma ->
    // Attach indentation to first argument in SingleLineArgumentExpressions
    let [ arg0, ...rest ] = args
    arg0 = [ indent, ...arg0 ]
    return [ arg0, ...rest, comma ]

SingleLineArgumentExpressions
  ( _? ArgumentPart ) ( ( _? Comma ) ( _? ArgumentPart ) )* ->
    return [ $1, ...$2.flat() ]

ArgumentPart
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  # NOTE: Allow leading or trailing dots for argument splats like CoffeeScript
  DotDotDot ExtendedExpression
  ExtendedExpression DotDotDot? ->
    if ($2) {
      return [$2, $1]
    }
    return $1

# NOTE: ArgumentPart variant that forbids top-level pipeline operators
NonPipelineArgumentPart
  DotDotDot NonPipelineExtendedExpression
  NonPipelineExtendedExpression DotDotDot? ->
    if ($2) {
      return [$2, $1]
    }
    return $1

BinaryOpExpression
  UnaryExpression BinaryOpRHS* ->
    if ($2.length) return processBinaryOpExpression($0)
    return $1

BinaryOpRHS
  # Snug binary ops a+b
  BinaryOp:op RHS:rhs ->
    // Insert empty whitespace placeholder to maintan structure
    return [[], op, [], rhs]
  # Spaced binary ops a + b
  # a
  # + b
  # Does not match
  # a
  # +b
  NewlineBinaryOpAllowed NotDedentedBinaryOp:op WRHS:rhs ->
    // NOTE: Flatten NotDedentedBinaryOp into whitespace and operator
    return [...op, ...rhs]
  !NewlineBinaryOpAllowed SingleLineBinaryOpRHS -> $2

# Whitespace followed by RHS
WRHS
  PushIndent ( Nested RHS )?:wrhs PopIndent ->
    if (!wrhs) return $skip
    return wrhs
  ( _ / ( EOS __ )) RHS

SingleLineBinaryOpRHS
  # NOTE: It's named single line but that's only for the operator, the RHS can be after a newline
  # This is to maintain compatibility with CoffeeScript conditions
  _?:ws1 BinaryOp:op ( _ / ( EOS __ ) ):ws2 RHS:rhs ->
    return [ws1 || [], op, ws2, rhs]

RHS
  ParenthesizedAssignment
  UnaryExpression
  ExpressionizedStatementWithTrailingCallExpressions

ParenthesizedAssignment
  InsertOpenParen ActualAssignment InsertCloseParen

# https://262.ecma-international.org/#prod-UnaryExpression
UnaryExpression
  # NOTE: Check for ampersand function expression first,
  # which can start with UnaryOps that need to be absorbed.
  AmpersandFunctionExpression

  # NOTE: Merged AwaitExpression with UnaryOp
  # https://262.ecma-international.org/#prod-AwaitExpression
  # NOTE: Eliminated left recursion
  UnaryOp*:pre UnaryBody:exp UnaryPostfix?:post ->
    return processUnaryExpression(pre, exp, post)

  # NOTE: This is a little hacky to match CoffeeScript's behavior
  # https://coffeescript.org/#try:do%20x%20%2B%20y%0Ado%20x%20%3D%20y%0Ado%20-%3E%20x%20%3D%201
  CoffeeDoEnabled Do __:ws ( ( LeftHandSideExpression !( __ AssignmentOpSymbol ) ) / ArrowFunction / ExtendedExpression ):exp ->
    ws = insertTrimmingSpace(ws, "")
    return ["(", ...ws, exp, ")()"]

UnaryWithoutParenthesizedAssignment
  UnaryOp*:pre UnaryWithoutParenthesizedAssignmentBody:exp UnaryPostfix?:post ->
    return processUnaryExpression(pre, exp, post)

UnaryBody
  ParenthesizedAssignment
  UpdateExpression
  ExpressionizedStatementWithTrailingCallExpressions
  NestedNonAssignmentExtendedExpression

UnaryWithoutParenthesizedAssignmentBody
  UpdateExpression
  ExpressionizedStatementWithTrailingCallExpressions
  NestedNonAssignmentExtendedExpression

UnaryPostfix
  QuestionMark
  TypePostfix+

TypePostfix
  _:ws NWTypePostfix:postfix ->
    return [ws, postfix]

Tuple
  "tuple" NonIdContinue ->
    return {
      $loc,
      token: "readonly unknown[] | []"
    }

NWTypePostfix
  As _ Tuple ->
    return {
      ts: true,
      children: [{ $loc: $1.$loc, token: "satisfies" }, $2, $3]
    }

  As:as ExclamationPoint?:ex Type:type ->
    let children
    if (ex) {
      children = [{ $loc: ex.$loc, token: "as unknown " }, as, type]
    } else {
      children = [as, type]
    }

    return { ts: true, children }

  Satisfies Type ->
    return { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-UpdateExpression
UpdateExpression
  # NOTE: Not allowing whitespace betwen prefix and postfix increment operators and operand
  UpdateExpressionSymbol UnaryWithoutParenthesizedAssignment ->
    return {
      type: "UpdateExpression",
      assigned: $2,
      children: $0,
    }
  LeftHandSideExpression ( UpdateExpressionSymbol /(?!\p{ID_Start}|[_$0-9(\[{])/ )? ->
    if (!$2) return $1
    return {
      type: "UpdateExpression",
      assigned: $1,
      children: [$1, $2[0]],
    }

UpdateExpressionSymbol
  "++" / "--" ->
    return { $loc, token: $1 }
  "⧺" ->
    return { $loc, token: "++" }
  "—" ->
    return { $loc, token: "--" }

# https://262.ecma-international.org/#prod-AssignmentExpression
AssignmentExpression
  # It is important for pipeline to have higher precedence than
  # usual binary operators, so that x |> & + 2 |> & * 3
  # is equivalent to x |> (& + 2) |> (& * 3)
  PipelineExpression
  # TODO If NonPipelineAssignmentExpression or SingleLineAssignmentExpression is used here then behavior changes

  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  SingleLineAssignmentExpression
  # TODO: Ideally this wouldn't be needed.
  __ AssignmentExpressionTail
  # NonPipelineAssignmentExpression

NonPipelineAssignmentExpression
  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  SingleLineAssignmentExpression
  __ AssignmentExpressionTail

SingleLineAssignmentExpression
  _?:ws AssignmentExpressionTail:tail ->
    if (ws?.length) {
      // Glom whitespace into identifiers and literals to ease checking of "simple" refs
      // NOTE: This can get weird if we depend on the specific location of children
      if (tail.children && tail.type !== "IterationExpression") {
        return {
          ...tail,
          children: [...ws, ...tail.children]
        }
      }
      return $0
    }
    return tail

AssignmentExpressionTail
  YieldExpression
  ArrowFunction
  ActualAssignment
  ConditionalExpression

# An assignment that actually includes an assignment operator, not just passing down to a ConditionalExpression
ActualAssignment
  # NOTE: Eliminated left recursion
  # NOTE: Consolidated assignment ops
  # NOTE: UpdateExpression instead of LeftHandSideExpression to allow
  # e.g. ++x *= 2 which we later convert to ++x, x *= 2
  ( NotDedented UpdateExpression WAssignmentOp )+ ExtendedExpression ->
    $1 = $1.map((x) => [x[0], x[1], ...x[2]])
    $0 = [$1, $2]
    return {
      type: "AssignmentExpression",
      children: $0,
      // NOTE: This null marks the assignment for later processing to distinguish it
      // from fake assignments that only add a name to a scope
      names: null,
      lhs: $1,
      assigned: $1[0][1],
      exp: $2,
    }

# https://262.ecma-international.org/#prod-YieldExpression
YieldExpression
  Yield YieldTail

YieldTail
  &EOS
  # NOTE: Merged optional star
  ( _? Star )? AssignmentExpression

# https://262.ecma-international.org/#prod-ArrowFunction
ArrowFunction
  ThinArrowFunction
  ( Async _ )?:async ArrowParameters:parameters ReturnTypeSuffix?:suffix FatArrow FatArrowBody:expOrBlock ->
    if (hasAwait(expOrBlock) && !async) {
      async = "async "
    }

    let error
    if (hasYield(expOrBlock)) {
      error = {
        type: "Error",
        message: "Can't use yield inside of => arrow function",
      }
    }

    return {
      type: "ArrowFunction",
      signature: {
        modifier: {
          async: !!async,
        },
        returnType: suffix,
      },
      parameters,
      returnType: suffix,
      ts: false,
      async,
      block: expOrBlock,
      children: [async, $0.slice(1), error],
    }

FatArrow
  # Ensures at least one space before arrow
  _?:ws ( "=>" / "⇒" ) ->
    if (!ws)
      return " =>"
    return [ $1, "=>" ]

TrailingDeclaration
  _? ( ConstAssignment / LetAssignment )

TrailingPipe
  _? Pipe

# NOTE Different from
# https://262.ecma-international.org/#prod-ConciseBody
FatArrowBody
  # If same-line single expression, avoid wrapping in braces
  !EOS NonPipelinePostfixedExpression:exp !TrailingDeclaration !TrailingPipe !SemicolonDelimiter ->
    // Ensure object literal is wrapped in parens
    if (exp.type === "ObjectExpression") {
      exp = makeLeftHandSideExpression(exp)
    }
    const expressions = [exp]
    return {
      type: "BlockStatement",
      bare: true,
      expressions,
      children: [expressions],
      implicitlyReturned: true,
    }
  # Otherwise, wrap block body in braces and insert returns
  NoCommaBracedOrEmptyBlock

# https://262.ecma-international.org/#prod-ConditionalExpression
ConditionalExpression
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  ShortCircuitExpression TernaryRest? ->
    if ($2) {
      return [$1, ...$2]
    }
    return $1

TernaryRest
  NestedTernaryRest
  # NOTE: Ternary `a ? b : c` is disabled if CoffeeScript binary existential `a ? b` is enabled
  !CoffeeBinaryExistentialEnabled &[ \t] _ QuestionMark ExtendedExpression __ Colon ExtendedExpression ->
    return $0.slice(2)

NestedTernaryRest
  PushIndent (Nested QuestionMark ExtendedExpression Nested Colon ExtendedExpression)? PopIndent ->
    if ($2) return $2
    return $skip

# https://262.ecma-international.org/#prod-ShortCircuitExpression
ShortCircuitExpression
  # NOTE: We don't need to track the precedence of all the binary operators so they all collapse into this
  BinaryOpExpression

PipelineExpression
  _?:ws PipelineHeadItem:head ( NotDedented Pipe __ PipelineTailItem )+:body ->
    if (head.token === "&") {
      head = makeAmpersandFunction()
    }

    if (head.type === "ArrowFunction" && head.ampersandBlock) {
      const expressions = [ {
        type: "PipelineExpression",
        children: [ ws, head.block.expressions[0], body ],
      } ]
      const block = { ...head.block, expressions, children: [expressions] }
      return {
        ...head,
        block,
        body: expressions,
        children: [ ...head.children.slice(0, -1), block ],
      }
    }

    return {
      type: "PipelineExpression",
      children: [ws, head, body]
    }

PipelineHeadItem
  # Needed to avoid left recursion
  NonPipelineExtendedExpression
  # Allow a pipeline to be part of first step if within parenthesis
  ParenthesizedExpression
  Ampersand

PipelineTailItem
  AwaitOp !AccessStart -> $1
  Yield !AccessStart -> $1
  Return !AccessStart -> $1
  NWTypePostfix TypePostfix* ->
    return makeAmpersandFunction([" ", $1, ...$2])
  AmpersandFunctionExpression
  !Ampersand PipelineHeadItem -> $2

# https://262.ecma-international.org/#prod-PrimaryExpression
PrimaryExpression
  ObjectLiteral
  ThisLiteral
  TemplateLiteral
  # NOTE: TemplateLiteral must be before Literal, so that CoffeeScript
  # interpolated strings get checked first before StringLiteral.
  Literal
  ArrayLiteral
  FunctionExpression # NOTE: Must be before IdentiferExpression so `async function ...` isn't parsed as `async(function ...)`
  IdentifierReference # NOTE: Must be below ObjectLiteral for inline objects `a: 1, b: 2` to not be shadowed by matching the first identifier
  ClassExpression
  RegularExpressionLiteral
  ParenthesizedExpression
  # https://facebook.github.io/jsx/#sec-jsx-PrimaryExpression
  # NOTE: Modified to parse multiple JSXElement/JSXFragments as one fragment
  JSXImplicitFragment

# https://262.ecma-international.org/#prod-ParenthesizedExpression
ParenthesizedExpression
  # NOTE: Currently ignoring early error checking in https://262.ecma-international.org/#prod-CoverParenthesizedExpressionAndArrowParameterList
  OpenParen:open AllowAll ( PostfixedCommaExpression __ CloseParen )? RestoreAll ->
    if (!$3) return $skip
    const [exp, ws, close] = $3
    switch (exp.type) {
      case "StatementExpression":
        if (exp.statement.type !== "IterationExpression") break
      case "IterationExpression":
        // Avoid extra parenthetical wrapping in `(for x in y ...)`
        // TODO: losing comments in `ws`
        return exp
      case "ParenthesizedExpression":
        if (exp.implicit) {
          return {
            ...exp,
            children: [open, exp.expression, ws, close],
            implicit: false,
          }
        }
        break
    }
    return {
      type: "ParenthesizedExpression",
      children: [ open, exp, ws, close ],
      expression: exp,
    }

# https://262.ecma-international.org/#prod-ClassDeclaration
ClassDeclaration
  # NOTE: skipping syntax directed operation for now
  # Wrap nameless function declarations with parens, as needed in JS.
  ClassExpression ->
    if ($1.id) return $1
    return makeLeftHandSideExpression($1)

# https://262.ecma-international.org/#prod-ClassExpression
ClassExpression
  Decorators?:decorators ( Abstract __ )?:abstract Class !":" ClassBinding?:binding ClassHeritage?:heritage ClassBody:body ->
    return {
      decorators,
      abstract,
      binding,
      id: binding?.[0],
      heritage,
      body,
      children: $0,
    }

ClassBinding
  !EOS BindingIdentifier TypeParameters? -> [$2, $3]

# https://262.ecma-international.org/#prod-ClassHeritage
ClassHeritage
  ExtendsClause ImplementsClause?
  ImplementsClause

ExtendsClause
  ExtendsToken __ ExtendsTarget

ExtendsToken
  # NOTE: Added "<" extends shorthand
  Loc:l _?:ws ExtendsShorthand:t " "? ->
    return {
      type: "Extends",
      children: [
        ws || { $loc: l.$loc, token: " " },
        t,
      ],
    }
  _? Extends ->
    return {
      type: "Extends",
      children: $0,
    }

ExtendsShorthand
  "<" ->
    return { $loc, token: "extends " }

NotExtendsToken
  Loc:l _?:ws1 OmittedNegation:ws2 ExtendsShorthand:t " "? ->
    const ws = ws1 && ws2 ? [ws1, ws2] : ws1 || ws2 ||
      { $loc: l.$loc, token: " " }
    return {
      type: "Extends",
      negated: true,
      children: [ ws, t ],
    }
  _? OmittedNegation Extends ->
    return {
      type: "Extends",
      negated: true,
      children: $0,
    }

OmittedNegation
  ExclamationPoint -> ""
  Not " "? _? -> $3

ExtendsTarget
  LeftHandSideExpressionWithObjectApplicationForbidden:exp ->
    return makeLeftHandSideExpression(exp)

ImplementsClause
  ImplementsToken ImplementsTarget ( Comma ImplementsTarget )* ->
    return {
      ts: true,
      children: $0,
    }

ImplementsToken
  # NOTE: Added "<:" implements shorthand
  Loc:l __:ws ImplementsShorthand:token " "? ->
    const children = [ ...ws, token ]

    if (!ws.length) {
      children.unshift({ $loc: l.$loc, token: " " })
    }

    return { children }

  __ "implements" NonIdContinue ->
    $2 = { $loc, token: $2 }
    return [$1, $2]

ImplementsShorthand
  "<:" ->
    return { $loc, token: "implements " }

ImplementsTarget
  __ IdentifierName (Dot IdentifierName)* TypeArguments?

# https://262.ecma-international.org/#prod-ClassBody
# NOTE: Nesting and indentation sensitive
ClassBody
  __ OpenBrace NestedClassElements?:elements __ CloseBrace  ->
    return {
      type: "ClassBody",
      children: $0,
      elements,
    }
  InsertOpenBrace NestedClassElements?:elements InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "ClassBody",
      children: $0,
      elements,
    }

NestedClassElements
  PushIndent NestedClassElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassElement
  Nested ClassElement StatementDelimiter

# https://262.ecma-international.org/#prod-ClassElement
ClassElement
  # NOTE: Combined optional static and Method/Field definition
  Decorators?:decorators AccessModifier? ( Static _? )? ClassElementDefinition:definition ->
    if (definition.type === "MultiMethodDefinition") {
      // If shorthand method definition has multiple expansions each one should get the decorators
      return {
        ...definition,
        children: definition.children.map((c) => {
          return {
            ...c,
            children: [ decorators, ...c.children ],
          }
        })
      }
    }
    return {
      ...definition,
      children: [decorators, $2, $3, ...definition.children],
    }
  # ClassStaticBlock
  Static BracedBlock ->
    return {
      type: "ClassStaticBlock",
      children: $0,
    }

ClassElementDefinition
  ( MethodDefinition / FieldDefinition )

# `declare class` form of ClassDeclaration, where all methods are signatures
ClassSignature
  Decorators? ( Abstract __ )? Class ClassBinding? ClassHeritage? ClassSignatureBody

ClassSignatureBody
  __ OpenBrace NestedClassSignatureElements? __ CloseBrace
  InsertOpenBrace NestedClassSignatureElements? InsertNewline InsertIndent InsertCloseBrace

NestedClassSignatureElements
  PushIndent NestedClassSignatureElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassSignatureElement
  Nested ClassSignatureElement StatementDelimiter

ClassSignatureElement
  # NOTE: MethodSignature instead of MethodDefinition
  Decorators? AccessModifier? ( Static _? )? ( MethodSignature / FieldDefinition )
  Static ClassSignatureBody

AccessModifier
  ( ( Public / Private / Protected ) NotDedented )? ( Readonly NotDedented )? ->
    if (!($1 || $2)) return $skip

    return {
      ts: true,
      children: $0
    }

# https://262.ecma-international.org/#prod-FieldDefinition
FieldDefinition
  # TODO: CoffeeCompat class method fields
  # name: (param1, param2) ->
  CoffeeClassesEnabled ClassElementName:id _? Colon __ AssignmentExpression:exp ->
    switch (exp.type) {
      // TODO: => functions
      case "FunctionExpression":
        const fnTokenIndex = exp.children.findIndex(c => c?.token?.startsWith("function"))
        // copy
        const children = exp.children.slice()
        if (exp.generator) {
          // replace "function" and move generator ahead of id
          children.splice(fnTokenIndex, 2, children[fnTokenIndex+1], id)
        } else {
          // replace "function" token with id
          children.splice(fnTokenIndex, 1, id)
        }
        return {
          ...exp,
          children,
        }
      default:
        return {
          type: "FieldDefinition",
          children: [id, " = ", exp],
        }
    }

  # NOTE: Added readonly semantic equivalent of const field assignment
  # NOTE: Using ExtendedExpression to allow for If/SwitchExpressions
  InsertReadonly:r ClassElementName TypeSuffix? __ ConstAssignment:ca ExtendedExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    r.children[0].$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return {
      type: "FieldDefinition",
      children: $0,
    }

  ( Abstract _? )? ( Readonly _? )? ClassElementName TypeSuffix? Initializer? ->
    if ($1) return { children: $0, ts: true }
    return {
      type: "FieldDefinition",
      children: $0,
    }

ThisLiteral
  This
  # NOTE: Added @identifier shorthand, also works for private identifiers
  # Converts 'IdentifierName' node to string so this won't interfere with refs
  AtThis:at $( Hash? IdentifierName ):id ->
    return {
      type: "MemberExpression",
      children: [at, {
        type: "PropertyAccess",
        name: id,
        children: [".", id],
      }],
      thisShorthand: true,
    }
  AtThis
  HashThis

# Adds a #id -> this.#id shorthand as a "HashThis" literal in most cases
# with the exception of keeping `#a in b` as is for branded in checks.
# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in#using_the_in_operator_to_implement_branded_checks
# This is slightly different from how https://262.ecma-international.org/#sec-relational-operators handles relational operators
# grammatically but should be equivalent in practice
HashThis
  LengthShorthand:id ( &( _+ ( ( Not __ In ) / In ) ) "" )?:beforeIn ->
    if (beforeIn != null) return [ '"', id.name, '"' ]

    return {
      type: "MemberExpression",
      children: ["this", {
        type: "PropertyAccess",
        name: id.name,
        children: [".", id],
      }],
      thisShorthand: true,
    }

  PrivateIdentifier:id &( _+ ( ( Not __ In ) / In ) ) ->
    return id

  PrivateIdentifier:id ->
    return {
      type: "MemberExpression",
      children: ["this", {
        type: "PropertyAccess",
        name: id.name,
        children: [".", id],
      }],
      privateShorthand: true,
      privateId: id,
    }

LengthShorthand
  Hash NonIdContinue ->
    const id = "length"
    return {
      type: "Identifier",
      name: id,
      names: [id],
      children: [{
        $loc: $loc,
        token: id,
      }],
    }

# NOTE: Added '@' as a 'this' shorthand from CoffeeScript
AtThis
  At:at ->
    return { ...at, token: "this" }

# https://262.ecma-international.org/#prod-LeftHandSideExpression
LeftHandSideExpression
  # https://262.ecma-international.org/#prod-NewExpression
  # NOTE: Merged in NewExpression
  # NOTE: Changed to CallExpression to handle arguments
  # NOTE: Eliminated left recursion
  ( New !( "." / ":" ) __ )+ CallExpression:expression ->
    return {
      type: "NewExpression",
      children: $0,
      expression,
    }
  CallExpression
  # NOTE: OptionalExpression is merged into CallExpression

# https://262.ecma-international.org/#prod-CallExpression
CallExpression
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  Super ArgumentsWithTrailingMemberExpressions CallExpressionRest*:rest ->
    return processCallMemberExpression({
      type: "CallExpression",
      children: [$1, ...$2, ...rest.flat()],
    })
  # Dynamic import(), with optional parentheses when not used at top level.
  # (At top level, ImportDeclaration will match first.)
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  "import" ArgumentsWithTrailingMemberExpressions CallExpressionRest*:rest ->
    return processCallMemberExpression({
      type: "CallExpression",
      children: [$1, ...$2, ...rest.flat()],
    })

  MemberExpression:member AllowedTrailingMemberExpressions:trailing CallExpressionRest*:rest ->
    if (rest.length || trailing.length) {
      rest = rest.flat()
      return processCallMemberExpression({
        type: "CallExpression",
        children: [member, ...trailing, ...rest]
      })
    }

    return member

CallExpressionRest
  MemberExpressionRest
  # NOTE: TypeScript instantiation expressions
  # https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#instantiation-expressions
  # But x<y>z and x<y>0 is a comparison chain.
  TypeArguments !( IdentifierName / NumericLiteral ) -> $1
  # perf: assertion to exit early
  /(?=['"`])/ ( TemplateLiteral / StringLiteral ):literal ->
    if (literal.type === "StringLiteral") {
      literal = "`" + literal.token.slice(1, -1).replace(/(`|\$\{)/g, "\\$1") + "`"
    }
    return literal
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  OptionalShorthand? ArgumentsWithTrailingMemberExpressions ->
    if (!$1) return $2
    return [ $1, ...$2 ]

# NOTE: Added shorthand x?(3) -> x?.(3)
OptionalShorthand
  # perf: assertion to exit early
  /(?=[\/?])/ InlineComment* QuestionMark OptionalDot ->
    return {
      type: "Optional",
      children: $0,
    }

OptionalDot
  InlineComment* Dot
  InsertDot

NonNullAssertion
  # NOTE: Prevent shadowing !^ xnor operator
  ExclamationPoint !"^" -> { type: "NonNullAssertion", ts: true, children: [$1] }

# https://262.ecma-international.org/#prod-MemberExpression
MemberExpression
  # NOTE: "new" MemberExpression Arguments seems to be handled fine by other rules already
  # NOTE: Eliminated left recursion
  MemberBase MemberExpressionRest*:rest ->
    if (rest.length || Array.isArray($1)) {
      return processCallMemberExpression({
        type: "MemberExpression",
        children: [$1, ...rest].flat(),
      })
    }
    return $1

ActualMemberExpression
  MemberBase MemberExpressionRest+:rest ->
    return processCallMemberExpression({
      type: "MemberExpression",
      children: [$1, ...rest].flat(),
    })

MemberBase
  PrimaryExpression
  SuperProperty
  MetaProperty

MemberExpressionRest
  # perf: assertion to exit early
  /(?=[\/\[{?.!@'’:])/ InlineComment*:comments MemberExpressionRestBody:body ->
    if (Array.isArray(body)) return [...comments, ...body]
    return {
      ...body,
      children: [...comments, ...body.children]
    }

MemberExpressionRestBody
  # NOTE: Added shorthand x?[3] -> x?.[3]
  OptionalShorthand?:dot InlineComment*:comments MemberBracketContent:content ->
    if (!dot && !comments.length) return content
    if (dot) {
      // Optional followed by a slice expression
      if (dot.type === "Optional" && content.type === "SliceExpression") {
        // Remove '.' from optional since it is present in '.slice'
        return [...dot.children.slice(0, -1), ...comments, content]
      }
      return [dot, ...comments, content]
    }
    return [...comments, content]
  # NOTE: Combined Optional and Property access
  PropertyAccess
  PropertyGlob
  PropertyBind
  # NOTE: Added TypeScript '!' non-null assertion
  NonNullAssertion

# Handles indexing and slicing
MemberBracketContent
  OpenBracket:open ( SliceParameters / PostfixedExpression ):expression __:ws CloseBracket:close ->
    // Some kind of slice
    if (expression.type === "SliceParameters") {
      const {start, end, children} = expression

      return {
        type: "SliceExpression",
        start,
        end,
        children: [
          {...open, token: ".slice("},
          ...children,
          [...ws, {...close, token: ")"}],
        ]
      }
    }

    // Regular index `[expression]`
    return {
      type: "Index",
      children: $0,
      expression,
    }

SliceParameters
  ExtendedExpression:start __:ws ( DotDotDot / DotDot ):sep ExtendedExpression?:end ->
    const inclusive = sep.token === ".."

    let children
    if (end) {
      const inc = []
      if (inclusive) {
        end = ["1 + ", end]
        inc./**/push(" || 1/0")
      }
      children = [start, [...ws, {...sep, token: ", "}], [end, ...inc]]
    } else {
      children = [start, ws]
    }

    return {
      type: "SliceParameters",
      start,
      end,
      children,
    }

  Loc:l __:ws ( DotDotDot / DotDot ):sep ExtendedExpression:end ->
    const inclusive = sep.token === ".."

    const inc = []
    if (inclusive) {
      end = ["1 + ", end]
      inc./**/push(" || 1/0")
    }

    const start = {
      $loc: l.$loc,
      token: "0",
    }

    return {
      type: "SliceParameters",
      start,
      end,
      children: [start, [...ws, {...sep, token: ", "}], [end, ...inc]]
    }

  Loc:l __:ws ( DotDot / DotDotDot ) &( __ CloseBracket ) ->
    const start = {
      $loc: l.$loc,
      token: "0",
    }

    return {
      type: "SliceParameters",
      start,
      end: undefined,
      children: [start, ws],
    }

AccessStart
  PropertyAccessModifier? Dot !Dot ->
    if ($1) return [$1, $2]
    return $2

PropertyAccessModifier
  QuestionMark
  NonNullAssertion

PropertyAccess
  # NOTE: Added shorthand x."string" -> x["string"]
  # NOTE: Added shorthand x.3 -> x[3]
  AccessStart:dot ( TemplateLiteral / StringLiteral / IntegerLiteral ):literal ->
    const start = adjustIndexAccess(dot)
    return {
      type: "Index",
      children: [
        start,
        literal,
        "]",
      ]
    }

  # NOTE: Added shorthand x.-1 -> x.at(-1)
  AccessStart:dot "-":neg IntegerLiteral:num ->
    const len = {
      children: []
    },

    children = [
      adjustIndexAccess(dot),
      len,
      neg,
      num,
      "]"
    ]

    return {
      type: "NegativeIndex",
      children,
      len,
    }

  AccessStart:access InlineComment*:comments ( IdentifierName / PrivateIdentifier / LengthShorthand ):id ->
    const children = [access, ...comments, ...id.children]

    return {
      type: "PropertyAccess",
      name: id.name,
      children,
    }

  # NOTE: Added CoffeeScript :: prototype shorthand only when enabled
  CoffeePrototypeEnabled DoubleColon:p IdentifierName?:id ->
    if (id) {
      return {
        type: "PropertyAccess",
        name: id.name,
        children: [ {token: ".prototype.", $loc: p.$loc}, id ],
      }
    } else {
      return {
        type: "PropertyAccess",
        name: "prototype",
        children: [ {token: ".prototype", $loc: p.$loc} ],
      }
    }

PropertyGlob
  # NOTE: Added shorthand obj.{a,b:c} -> {a: obj.a, c: obj.b}
  ( PropertyAccessModifier? OptionalDot ):dot InlineComment* BracedObjectLiteral:object ->
    return {
      type: "PropertyGlob",
      dot,
      object,
      children: $0,
    }

PropertyBind
  # NOTE: foo@.bar and foo@bar shorthand for foo.bar.bind(foo)
  PropertyAccessModifier?:modifier At OptionalDot:dot ( IdentifierName / PrivateIdentifier ):id Arguments?:args ->
    return {
      type: "PropertyBind",
      name: id.name,
      children: [modifier, dot, id],  // omit `@` from children
      args: args?.children.slice(1, -1) ?? [], // remove the parens from the arg list, or give an empty list
    }

SuperProperty
  Super MemberBracketContent
  Super !PropertyAccessModifier PropertyAccess

MetaProperty
  New Dot Target
  "import.meta" NonIdContinue ->
    return { $loc, token: $1 }
  ReturnValue

# NOTE: Special `return.value` (and `return =` shorthand)
# for changing the automatic return value of function
ReturnValue
  ( "return.value" NonIdContinue ) / ( Return &AfterReturnShorthand ) ->
    return { type: "ReturnValue", children: [$1[0]] }

AfterReturnShorthand
  WAssignmentOp
  UpdateExpressionSymbol
  # Allow e.g. `let return: T`
  TypeSuffix
  __ LetAssignment
  __ ConstAssignment

# https://262.ecma-international.org/#prod-FormalParameters
# The parameters in a function definition
Parameters
  NonEmptyParameters
  TypeParameters?:tp Loc:p ->
    return {
      type: "Parameters",
      children: [tp, {$loc: p.$loc, token: "()"}],
      tp,
      names: [],
      implicit: true,
    }

# Allow for [a, b] => ... or {a, b} -> ...
ShortArrowParameters
  ObjectBindingPattern
  ArrayBindingPattern

ArrowParameters
  ShortArrowParameters ->
    return {
      type: "Parameters",
      children: ["(", $0, ")"],
      names: $0.names,
    }
  Parameters

NonEmptyParameters
  TypeParameters?:tp OpenParen:open ParameterList:params ( __ CloseParen ):close ->
    // Categorize arguments to put any ThisType in front, and split remaining
    // arguments into before and after the rest parameter.
    let tt, before = [], rest, after = [], errors = []
    function append(p) {
      (rest ? after : before).push(p)
    }
    for (const param of params) {
      switch (param.type) {
        case "ThisType":
          if (tt) {
            append({
              type: "Error",
              message: "Only one typed this parameter is allowed",
            })
            append(param)
          } else {
            tt = insertTrimmingSpace(param, "")
            if (before.length || rest) { // moving ThisType to front
              let delim = tt.children.at(-1)
              if (Array.isArray(delim)) delim = delim.at(-1)
              if (delim?.token !== ",") {
                tt = {
                  ...tt,
                  children: [...tt.children, ", "],
                }
              }
            }
          }
          break
        case "FunctionRestParameter":
          if (rest) {
            append({
              type: "Error",
              message: "Only one rest parameter is allowed",
            })
            append(param)
          } else {
            rest = param
          }
          break
        default:
          append(param)
      }
    }

    const names = before.flatMap(p => p.names)
    if (rest) {
      const restIdentifier = rest.binding.ref || rest.binding
      names.push(...rest.names || [])

      let blockPrefix
      if (after.length) {
        blockPrefix = {
          children: ["[", insertTrimmingSpace(after, ""), "] = ", restIdentifier, ".splice(-", after.length.toString(), ")"],
          names: after.flatMap(p => p.names)
        }
      }

      return {
        type: "Parameters",
        children: [
          tp,
          open,
          tt,
          ...before,
          // Remove delimiter
          {...rest, children: rest.children.slice(0, -1)},
          close,
        ],
        tp,
        names,
        blockPrefix,
      }
    }

    return {
      type: "Parameters",
      children: [tp, open, tt, ...before, close],
      names,
      tp,
    }

ParameterList
  # Nested case: Allow for one line of parameters followed by a nested list
  Parameter* NestedParameterList ->
    return [...$1, ...$2]
  # Otherwise, try parsing while ignore indentation
  ( __ Parameter )* ->
    return $1.map(([eos, p]) => ({
      ...p,
      children: [eos, ...p.children],
    }))

NestedParameterList
  PushIndent NestedParameter*:params PopIndent ->
    if (!params.length) return $skip
    return params

NestedParameter
  # Allow one or more parameters on one line
  Nested:ws Parameter+:params ->
    // Attach whitespace to first parameter
    params = [...params]
    params[0] = {
      ...params[0],
      children: [ws, ...params[0].children],
    }
    return params

Parameter
  ThisType
  ParameterElement
  FunctionRestParameter

# https://262.ecma-international.org/#prod-FunctionRestParameter
FunctionRestParameter
  # BindingRestElement has a leading _?
  # but also sometimes invokes __ via BindingIdentifier
  !EOS BindingRestElement:id TypeSuffix? ParameterElementDelimiter ->
    return {
      type: "FunctionRestParameter",
      children: $0.slice(1),
      names: id.names,
      binding: id.binding,
    }

# NOTE: Similar to BindingElement but appears in formal parameters list
ParameterElement
  _? AccessModifier?:accessModifier _? ( NWBindingIdentifier / BindingPattern ):binding TypeSuffix? Initializer? ParameterElementDelimiter ->
    return {
      type: "Parameter",
      children: $0,
      names: binding.names,
      accessModifier,
    }

ParameterElementDelimiter
  _? Comma
  &( __ [)}] )
  &EOS InsertComma -> $2

# https://262.ecma-international.org/#prod-BindingIdentifier
BindingIdentifier
  # NOTE: Added @param for binding identifiers
  # The parser will allow them in const/let/var declarations but JS/TS doesn't allow them there
  __:ws NWBindingIdentifier:identifier ->
    return { ...identifier, children: [...ws, ...identifier.children] }

# Non-whitespace version of BindingIdentifier
NWBindingIdentifier
  # NOTE: Added @param for binding identifiers
  # The parser will allow them in const/let/var declarations but JS/TS doesn't allow them there
  At AtIdentifierRef:ref ->
    return {
      type: "AtBinding",
      children: [ref],
      ref,
    }
  # Likewise for private identifiers
  Hash AtIdentifierRef:ref ->
    ref = { ...ref, id: `#${ref.id}` }
    return {
      type: "AtBinding",
      children: [ref],
      ref,
    }
  Identifier:id
  # NOTE: Support for return := 1 and let return: number
  ReturnValue ->
    return { children: [$1], names: [] }

AtIdentifierRef
  ReservedWord:r ->
    return makeRef(`_${r}`, r)
  IdentifierName:id ->
    return makeRef(id.name)

PinPattern
  Caret SingleLineExpressionWithIndentedApplicationForbidden:expression ->
    return {
      type: "PinPattern",
      children: $0,
      expression,
    }
  ActualMemberExpression:expression ->
    return {
      type: "PinPattern",
      children: [expression],
      expression,
    }

# https://262.ecma-international.org/#prod-BindingPattern
BindingPattern
  ObjectBindingPattern
  ArrayBindingPattern
  PinPattern
  Literal
  RegularExpressionLiteral

# https://262.ecma-international.org/#prod-ObjectBindingPattern
# NOTE: Simplified from spec
ObjectBindingPattern
  _?:ws1 OpenBrace:open ObjectBindingPatternContent:c __:ws2 CloseBrace:close ->
    return {
      type: "ObjectBindingPattern",
      children: [ws1, open, c.children, ws2, close],
      names: c.names,
      properties: c.children,
    }

ObjectBindingPatternContent
  # NOTE: Added indentation based binding properties
  NestedBindingProperties
  BindingPropertyList?:props ->
    if (!props) return { children: [], names: [] }

    return reorderBindingRestProperty(props)

BindingPropertyList
  ( BindingProperty ObjectPropertyDelimiter )+:props ->
    return props.map(([prop, delim]) => {
      return {
        ...prop,
        delim,
        children: [...prop.children, delim],
      }
    })

# https://262.ecma-international.org/#prod-ArrayBindingPattern
# NOTE: Simplified from spec
ArrayBindingPattern
  _?:ws1 OpenBracket:open ArrayBindingPatternContent:c __:ws2 CloseBracket:close ->
    return {
      ...c, // names, blockPrefix, length
      type: "ArrayBindingPattern",
      elements: c.children,
      children: [ws1, open, c.children, ws2, close],
    }

ArrayBindingPatternContent
  # NOTE: Added indentation based binding elements
  NestedBindingElements
  BindingElementList?:elements ->
    if (!elements) return { children: [], names: [], length: 0 }

    return adjustBindingElements(elements)

# children is an array of tuples of the form [ws, element, delim]
BindingElementList
  ( BindingElement ArrayElementDelimiter )+:elements ->
    return elements.map(([element, delim]) => {
      return {
        ...element,
        // BindingElement.children is a tuple of the form [ws, element]
        children: [...element.children, delim],
      }
    })

NestedBindingElementList
  Nested:indent BindingElementList:elements ->
    // Attach whitespace to first element
    return elements.map( (element, i) => {
      if (i > 0) return element
      return {
        ...element,
        children: [indent, ...element.children.slice(1)], // replace ws wth indent
      }
    })

# https://262.ecma-international.org/#prod-Elision
Elision
  # NOTE: The repetition is handled from outside rather than using left recursion here
  __ Comma

NestedBindingProperties
  PushIndent NestedBindingPropertyList*:props PopIndent ->
    if (!props.length) return $skip

    return reorderBindingRestProperty(props.flat())

NestedBindingPropertyList
  Nested:ws BindingPropertyList:props ->
    // Attach whitespace to first property
    return props.map( (prop, i) => {
      if (i > 0) return prop
      return {
        ...prop,
        children: [ws, ...prop.children],
      }
    })

# https://262.ecma-international.org/#prod-BindingProperty
BindingProperty
  # NOTE: Merged in BindingRestProperty
  # TS will mark errors about invalid multiple rest properties
  # NOTE: Must be checked first to pick up trailing "..." form
  BindingRestProperty

  _? PropertyName:name _? Colon _? ( BindingIdentifier / BindingPattern ):value Initializer?:initializer ->
    return {
      type: "BindingProperty",
      children: $0,
      name,
      value,
      initializer,
      names: value.names,
    }

  _?:ws Caret?:pin BindingIdentifier:binding Initializer?:initializer ->
    // TODO make this work with pin
    if (binding.type === "AtBinding") {
      return {
        type: "AtBindingProperty",
        children: $0,
        binding,
        ref: binding.ref,
        initializer,
        names: [],
      }
    }

    if (pin) {
      return {
        type: "PinProperty",
        children: [ws, binding],
        name: binding,
        value: {
          type: "PinPattern",
          expression: binding,
        },
      }
    }

    return {
      type: "BindingProperty",
      children: $0,
      name: binding,
      value: undefined,
      initializer,
      names: binding.names,
      identifier: binding,
    }

# https://262.ecma-international.org/#prod-BindingRestProperty
BindingRestProperty
  _?:ws DotDotDot:dots BindingIdentifier:id ->
    return {
      ...id,
      type: "BindingRestProperty",
      children: [...(ws || []), dots, ...id.children],
    }

  _?:ws BindingIdentifier:id DotDotDot:dots ->
    return {
      ...id,
      type: "BindingRestProperty",
      children: [...(ws || []), dots, ...id.children],
    }

NestedBindingElements
  PushIndent NestedBindingElementList*:elements PopIndent ->
    if (!elements.length) return $skip

    // Each item of elements is a list of BindingElements;
    // combine into one big array
    return adjustBindingElements(elements.flat())

# https://262.ecma-international.org/#prod-BindingElement
# children is an array of tuples of the form [ws, element]
BindingElement
  BindingRestElement

  # NOTE: Merged in SingleNameBinding
  _?:ws ( BindingIdentifier / BindingPattern ):binding Initializer?:initializer ->
    // NOTE: RegExpLiteral doesn't have children so it will lose the initializer
    // for now
    if (binding.children) {
      binding = {
        ...binding,
        initializer,
        children: [...binding.children, initializer],
      }
    }

    return {
      names: binding.names,
      children: [ws, binding]
    }

  # NOTE: Merged in ElisionElement
  &( _? "," ) ->
    return {
      children: [{
        type: "ElisionElement",
        children: [""],
      }],
      names: [],
    }

# https://262.ecma-international.org/#prod-BindingRestElement
BindingRestElement
  _?:ws DotDotDot:dots ( BindingIdentifier / BindingPattern / EmptyBindingPattern ):binding ->
    return {
      type: "BindingRestElement",
      children: [ws, [dots, binding]],
      binding,
      name: binding.name,
      names: binding.names,
      rest: true,
    }

  _?:ws ( BindingIdentifier / BindingPattern ):binding DotDotDot:dots ->
    return {
      type: "BindingRestElement",
      children: [...(ws || []), dots, binding],
      binding,
      name: binding.name,
      names: binding.names,
      rest: true,
    }

# NOTE: Allows for empty binding rest pattern like in CoffeeScript
EmptyBindingPattern
  "" ->
    const ref = makeRef()
    return {
      type: "EmptyBinding",
      children: [ref],
      names: [],
      ref,
    }

# https://262.ecma-international.org/#prod-FunctionDeclaration
FunctionDeclaration
  # Wrap nameless function declarations with parens, as needed in JS.
  FunctionExpression ->
    // Do not treat ArrowFunctions, as generated by & and (+), as declarations
    if ($1.type !== "FunctionExpression") return $skip
    if ($1.id) return $1
    return makeLeftHandSideExpression($1)

FunctionSignature
  # NOTE: Merged in async and generator with optionals
  ( Async _ )?:async Function:func ( _? Star )?:generator ( _? NWBindingIdentifier )?:wid _?:w Parameters:parameters ReturnTypeSuffix?:suffix ->
    if (!async) async = []
    if (!generator) generator = []

    const id = wid?.[1]
    return {
      type: "FunctionSignature",
      id,
      name: id?.name,
      parameters,
      returnType: suffix,
      ts: false,
      async,
      generator,
      modifier: {
        async: !!async.length,
        generator: !!generator.length,
      },
      block: null,
      children: !parameters.implicit
        ? [ async, func, generator, wid, w, parameters, suffix ]
        : [ async, func, generator, wid, parameters, w, suffix ],
          // move whitespace w to after implicit () in parameters
    }

# https://262.ecma-international.org/#prod-FunctionExpression
FunctionExpression
  # NOTE: block isn't actually optional in FunctionExpression only in declarations/TS overloads
  FunctionSignature:signature BracedBlock?:block ->
    // TS Function overloads
    if (!block) {
      return {
        ...signature,
        type: "FunctionExpression",
        signature,
        ts: true,
      }
    }

    if (hasAwait(block) && !signature.async.length) {
      signature.async.push("async ")
      signature.modifier.async = true
    }

    if (hasYield(block) && !signature.generator.length) {
      signature.generator.push("*")
      signature.modifier.generator = true
    }

    // Attach the block
    return {
      ...signature,
      type: "FunctionExpression",
      signature,
      children: [...signature.children, block],
      block,
    }
  # Identity function shorthand
  # NOTE: Currently shadows (&) binary & operator, we might want to revisit
  "(&)" ->
    return makeAmpersandFunction()

  # BinaryOp function shorthand
  OpenParen:open BinaryOp:op CloseParen:close ->
    // (foo) doesn't need an arrow wrapper; just foo suffices
    if (op.special && op.call && !op.negated) return op.call

    const refA = makeRef("a"),
      refB = makeRef("b"),
      body = processBinaryOpExpression([refA, [
        [[], op, [], refB] // BinaryOpRHS
      ]])

    const parameters = {
      type: "Parameters",
      children: ["(", refA, ",", refB, ")"],
      names: [],
    }

    const block = {
      expressions: [body],
    }

    return {
      type: "ArrowFunction",
      signature: {
        modifier: {},
      },
      children: [open, parameters, " => ", body, close],
      body,
      parenthesized: true,
      parenthesizedOp: op,
      block,
      parameters,
    }

  # Haskell-style sections
  OpenParen:open NonPipelineAssignmentExpression:lhs __:ws1 BinaryOp:op __:ws2 CloseParen:close ->
    const refB = makeRef("b"),
      body = processBinaryOpExpression([lhs, [
        [ws1, op, ws2, refB] // BinaryOpRHS
      ]])

    const parameters = {
      type: "Parameters",
      children: ["(", refB, ")"],
      names: [],
    }

    const block = {
      expressions: [body],
    }

    return {
      type: "ArrowFunction",
      signature: {
        modifier: {},
      },
      children: [open, parameters, " => ", body, close],
      body,
      parenthesized: true,
      ampersandBlock: true,
      ref: refB,
      block,
      parameters,
    }
  OpenParen:open __:ws1 !/\+\+|--|[\+-]\S/ BinaryOp:op __:ws2 NonPipelineAssignmentExpression:rhs CloseParen:close ->
    const refA = makeRef("a"),
      body = processBinaryOpExpression([refA, [
        [ws1, op, ws2, rhs] // BinaryOpRHS
      ]])

    const parameters = {
      type: "Parameters",
      children: ["(", refA, ")"],
      names: [],
    }

    const block = {
      expressions: [body],
    }

    return {
      type: "ArrowFunction",
      signature: {
        modifier: {},
      },
      children: [open, parameters, " => ", body, close],
      body,
      parenthesized: true,
      ampersandBlock: true,
      ref: refA,
      block,
      parameters,
    }

  AmpersandFunctionExpression

  # Ruby/Crystal style block shorthand
AmpersandFunctionExpression
  # NOTE: !NumericLiteral is so we don't match on `.1` etc.
  UnaryOp*:prefix ( Ampersand / ( !NumericLiteral &( QuestionMark? Dot !Dot ) ) ) AmpersandBlockRHS?:rhs ->
    if (!prefix.length && !rhs) return $skip

    let body, ref, typeSuffix

    // Only unary ops
    if (!rhs) {
      body = ref = makeRef("$")
    } else {
      ({ref, typeSuffix} = rhs)
      if (!ref) {
        throw new Error("Could not find ref in ampersand shorthand block")
      }
      body = rhs
    }
    if (prefix.length) {
      body = {
        type: "UnaryExpression",
        children: [ processUnaryExpression(prefix, body, undefined) ]
      }
    }

    const parameters = {
      type: "Parameters",
      children: typeSuffix ? ["(", ref, typeSuffix, ")"] : [ref],
      names: [],
    }
    const expressions = [body]
    const block = {
      bare: true,
      expressions,
      children: [expressions],
    }

    const children = [ parameters, " => ", block ]
    const async = hasAwait(body)
    if (async) {
      children.unshift("async ")
    }

    return {
      type: "ArrowFunction",
      signature: {
        modifier: {
          async,
        },
      },
      children,
      ref,
      body,
      ampersandBlock: true,
      block,
      parameters,
    }

# NOTE: Dynamic infix operators
OperatorDeclaration
  # `operator {x, y} := ...` declaration while blessing
  Operator:op OperatorBehavior?:behavior _:w LexicalDeclaration:decl ->
    decl.names.forEach((name) => module.operators.set(name, behavior))
    return {
      ...decl,
      children: [ insertTrimmingSpace(w, ""), ...decl.children ]
    }
  # `operator id(a, b) {...}` defines a function
  OperatorSignature:signature BracedBlock:block ->
    module.operators.set(signature.id.name, signature.behavior)
    return {
      ...signature,
      type: "FunctionExpression",
      signature,
      children: [...signature.children, block],
      block,
      operator: true,
    }
  # `operator id` alone blesses `id` as an operator
  Operator:op _:w1 Identifier:id OperatorBehavior?:behavior ( CommaDelimiter _? Identifier OperatorBehavior? )*:ids ->
    module.operators.set(id.name, behavior)
    ids.forEach(([, , id2, behavior2]) => module.operators.set(id2.name, behavior2))
    return {
      id,
      children: [],
    }

# NOTE: Like FunctionSignature, but no async or star or @,
# and parameters are required (to be useful).
OperatorSignature
  Operator:op ( _ Function )?:func _:w1 Identifier:id OperatorBehavior?:behavior _?:w2 NonEmptyParameters:parameters ReturnTypeSuffix?:suffix ->
    // Add "function" (if not already one) to replace "operator"
    if (!func) {
      func = { $loc: op.$loc, token: "function" }
    } else {
      func = [ insertTrimmingSpace(func[0], ""), func[1] ]
    }
    return {
      type: "FunctionSignature",
      id,
      modifier: {},
      parameters,
      returnType: suffix,
      ts: false,
      block: null,
      children: [ func, w1, id, w2, parameters, suffix ],
      behavior,
    }

OperatorBehavior
  OperatorPrecedence OperatorAssociativity? ->
    return { ...$1, ...$2 }
  OperatorAssociativity OperatorPrecedence? ->
    return { ...$1, ...$2 }

OperatorPrecedence
  # inspired by https://docs.raku.org/language/functions#Precedence
  _? ( "tighter" / "looser" / "same" ):mod NonIdContinue _? ( Identifier / ( OpenParen BinaryOp CloseParen ) ):op ->
    let prec = op.type === "Identifier"
      ? module.operators.get(op.name).prec
      : getPrecedence(op[1])
    switch (mod) {
      case "tighter": prec += 1/64; break
      case "looser": prec -= 1/64; break
    }
    return {prec}

OperatorAssociativity
  # inspired by https://docs.raku.org/language/functions#Associativity
  _? ( "left" / "right" / "non" / "relational" / "arguments" ):assoc NonIdContinue ->
    if (assoc === "relational") {
      return { relational: true, assoc: "non" }
    }
    return { assoc }

AmpersandBlockRHS
  ForbidTrailingMemberProperty AmpersandBlockRHSBody? RestoreTrailingMemberProperty ->
    if (!$2) return $skip
    return $2

AmpersandTypeSuffix
  &( _? QuestionMark? _? Colon ) TypeSuffix -> $2

AmpersandBlockRHSBody
  AmpersandTypeSuffix?:typeSuffix (!_ CallExpressionRest+ )?:callExpRest UnaryPostfix?:unaryPostfix ( WAssignmentOp ( NotDedented UpdateExpression WAssignmentOp )* NonPipelineExtendedExpression )?:assign ( ![&] BinaryOpRHS+ )?:binopRHS ->
    if (!typeSuffix && !callExpRest && !binopRHS && !unaryPostfix) return $skip
    const ref = makeRef("$")

    let exp = {
      type: "AmpersandRef",
      children: [ref],
      names: [],
      ref,
    }

    if (callExpRest) {
      exp.children.push(...callExpRest[1])
    }

    if (unaryPostfix) {
      exp = processUnaryExpression([], exp, unaryPostfix)
    }

    if (assign) {
      // Based on ActualAssignment
      const [op1, more, rhs] = assign
      const lhs = [
        [undefined, exp, ...op1],
        ...more.map((x) => [x[0], x[1], ...x[2]]),
      ]
      exp = {
        type: "AssignmentExpression",
        children: [lhs, rhs],
        names: null,
        lhs,
        assigned: exp,
        exp: rhs,
      }
    }

    if (binopRHS) {
      exp = {
        children: processBinaryOpExpression([exp, binopRHS[1]]),
      }
    }

    // Put at top level for AmpersandFunctionExpression to process
    exp.ref = ref
    exp.typeSuffix = typeSuffix

    return exp

ThinArrowFunction
  ( Async _ )?:async ArrowParameters:parameters ReturnTypeSuffix?:suffix _? Arrow:arrow NoCommaBracedOrEmptyBlock:block ->
    if (hasAwait(block) && !async) {
      async = "async "
    }

    let generator
    if (hasYield(block)) {
      generator = "*"
    }

    return {
      type: "FunctionExpression",
      id: undefined,
      parameters,
      returnType: suffix,
      ts: false,
      async,
      generator,
      block,
      signature: {
        name: undefined,
        modifier: {
          async: !!async,
          generator: !!generator,
        },
        returnType: suffix,
      },
      children: [
        async,
        { $loc: arrow.$loc, token: "function" },
        generator,
        parameters,
        suffix,
        block
      ],
    }

Arrow
  "->" / "→" ->
    return { $loc, token: "->" }

ExplicitBlock
  __ OpenBrace __ CloseBrace ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [$1, $2, expressions, $3, $4],
      bare: false,
      empty: true,
    }
  __ OpenBrace NestedBlockStatements:block __ CloseBrace ->
    return {
      ...block,
      children: [$1, $2, ...block.children, $4, $5],
      bare: false,
    }

ImplicitNestedBlock
  # NOTE: Check &EOS needed by eventual PushIndent to skip work if not needed
  &EOS InsertOpenBrace:open AllowAll ( NestedBlockStatements InsertNewline InsertIndent InsertCloseBrace )? RestoreAll ->
    if (!$4) return $skip
    const [block, ...tail] = $4
    return {
      ...block,
      children: [open, ...block.children, ...tail],
      bare: false,
    }

# NOTE: This is the body of if/else/for/when etc.
Block
  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock
  # NOTE: Explicit block after implicit block so that a properly indented `{}`
  # gets treated like an object literal, not an empty block.
  ExplicitBlock

  ThenClause
  # NOTE: !EOS prevents capturing a following unindented Statement
  _?:ws !EOS Statement:s ->
    const expressions = [[ws, s]]
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }

BareNestedBlock
  # NOTE: Check &EOS needed by eventual PushIndent to skip work if not needed
  &EOS AllowAll NestedBlockStatements? RestoreAll ->
    if (!$3) return $skip
    return $3

# NOTE: This is the body of a case, where no braces are necessary.
# Essentially `Block` but with ImplicitNestedBlock replaced by BareNestedBlock,
# and allowing EmptyBareBlock.
BareBlock
  BareNestedBlock
  # NOTE: Explicit block after implicit block so that a properly indented `{}`
  # gets treated like an object literal, not an empty block.
  ExplicitBlock

  ThenClause
  # NOTE: !EOS prevents capturing a following unindented Statement
  _?:ws !EOS Statement:s ->
    const expressions = [[ws, s]]
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }
  EmptyBareBlock

ThenClause
  Then SingleLineStatements -> $2

BracedThenClause
  &Then InsertOpenBrace:open ThenClause:exp InsertCloseBrace:close ->
    const expressions = [exp]
    return {
      type: "BlockStatement",
      expressions,
      children: [open, expressions, " ", close],
      bare: false,
    }

# A block that must include braces (function body, try/catch/finally)
BracedOrEmptyBlock
  BracedBlock
  EmptyBlock

NoCommaBracedOrEmptyBlock
  NoCommaBracedBlock
  EmptyBlock

NoPostfixBracedOrEmptyBlock
  NoPostfixBracedBlock
  EmptyBlock

EmptyBlock
  # Implied empty block
  InsertOpenBrace InsertCloseBrace ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [$1, expressions, $2],
      bare: false,
      empty: true,
    }

EmptyBareBlock
  # Implied empty block with no braces. Used in case statements.
  "" ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }

# A nonempty block that must include braces
# This version allows same-line postfixes like `while cond`.
BracedBlock
  NonSingleBracedBlock
  # Nonempty one liner
  InsertOpenBrace:o !EOS PostfixedSingleLineStatements:s InsertSpace:ws InsertCloseBrace:c ->
    if (!s.children.length) return $skip
    return {
      type: "BlockStatement",
      expressions: s.expressions,
      // Remove !EOS assertion
      children: [o, s.children, ws, c],
    }

# This version forbids same-line postfixes like `while cond`, e.g., in do/try.
NoPostfixBracedBlock
  NonSingleBracedBlock
  # Nonempty one liner
  InsertOpenBrace:o !EOS SingleLineStatements:s InsertSpace:ws InsertCloseBrace:c ->
    if (!s.expressions.length) return $skip
    return {
      type: "BlockStatement",
      expressions: s.expressions,
      // Remove !EOS assertion
      children: [o, s.children, ws, c],
    }

# This version forbids top-level , operator in one-liners
NoCommaBracedBlock
  NonSingleBracedBlock
  # Nonempty one liner
  InsertOpenBrace:o !EOS PostfixedSingleLineNoCommaStatements:s InsertSpace:ws InsertCloseBrace:c ->
    if (!s.children.length) return $skip
    return {
      type: "BlockStatement",
      expressions: s.expressions,
      // Remove !EOS assertion
      children: [o, s.children, ws, c],
    }

NonSingleBracedBlock
  _?:ws1 OpenBrace:open AllowAll ( BracedContent __ CloseBrace )? RestoreAll ->
    if (!$4) return $skip
    const [block, ws2, close] = $4
    return {
      type: "BlockStatement",
      expressions: block.expressions,
      children: [ws1, open, ...block.children, ws2, close],
      bare: false,
    }
    return block

  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock

  # Immediate nested object literal
  InsertOpenBrace NestedImplicitObjectLiteral:s InsertCloseBrace ->
    return {
      type: "BlockStatement",
      expressions: [s],
      children: $0,
    }

DeclarationOrStatement
  Declaration
  Statement

# NOTE: SingleLineStatements includes the empty case
SingleLineStatements
  # NOTE: Statement can start with __ via AssignmentExpression.
  # Force staying on the same line via !/\n/ assertion.
  ForbidNewlineBinaryOp ( ( _? !EOS ) DeclarationOrStatement SemicolonDelimiter )*:stmts ( ( _? !EOS ) DeclarationOrStatement SemicolonDelimiter? )?:last RestoreNewlineBinaryOp ->
    const expressions = [...stmts]
    if (last) expressions.push(last)

    // check for trailing comment
    const maybeComment = expressions.at(-1)?.[2]?.children?.[2]?.at(-1)
    let hasTrailingComment = false
    if (maybeComment?.type === "Comment" && maybeComment.token.startsWith("//")) {
      hasTrailingComment = true
    }

    const children = [expressions]

    if (hasTrailingComment) {
      children.push("\n")
    }

    return {
      type: "BlockStatement",
      expressions,
      children,
      bare: true,
    }

PostfixedSingleLineStatements
  ( ( _? !EOS ) StatementListItem SemicolonDelimiter )*:stmts ( ( _? !EOS ) StatementListItem SemicolonDelimiter? )?:last ->
    const children = [...stmts]
    if (last) children.push(last)

    return {
      type: "BlockStatement",
      expressions: children,
      children,
      bare: true,
    }

PostfixedSingleLineNoCommaStatements
  ( ( _? !EOS ) NoCommaStatementListItem SemicolonDelimiter )*:stmts ( ( _? !EOS ) NoCommaStatementListItem SemicolonDelimiter? )?:last ->
    const children = [...stmts]
    if (last) children.push(last)

    return {
      type: "BlockStatement",
      expressions: children,
      children,
      bare: true,
    }

BracedContent
  NestedBlockStatements
  SingleLineStatements
  # Empty content
  &( __ "}" ) ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
    }

NestedBlockStatements
  PushIndent NestedBlockStatement*:statements PopIndent ->
    if (!statements.length) return $skip

    // Each element of statements is a list of same-line statements. Flatten.
    statements = statements.flat()

    return {
      type: "BlockStatement",
      expressions: statements,
      children: [statements],
      bare: true,
    }

NestedBlockStatement
  Nested:nested BlockStatementPart+:statements ->
    return [
      [nested, ...statements[0]],
      ...statements.slice(1).map(s => ["", ...s]),
    ]

BlockStatementPart
  # NOTE: !EOS forces semicolon after all but last statement, forbids leading __
  # NOTE: _? allows for leading inline comments
  !EOS _?:ws StatementListItem:statement StatementDelimiter:delimiter ->
    if (ws) {
      statement = {...statement, children: [ ws, ...statement.children ]}
    }
    return [statement, delimiter]

# https://262.ecma-international.org/#prod-Literal
Literal
  /(?=[0-9.'"tfyno])/ LiteralContent:literal ->
    return {
      type: "Literal",
      subtype: literal.type,
      children: [ literal ],
      raw: literal.token,
    }

LiteralContent
  NullLiteral
  BooleanLiteral
  NumericLiteral
  StringLiteral

# https://262.ecma-international.org/#prod-NullLiteral
NullLiteral
  "null" NonIdContinue ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-BooleanLiteral
BooleanLiteral
  # perf: assertion to exit early
  /(?=true|false|yes|no|on|off)/ _BooleanLiteral -> $2

_BooleanLiteral
  CoffeeBooleansEnabled CoffeeScriptBooleanLiteral -> $2
  ( "true" / "false" ) NonIdContinue ->
    return { $loc, token: $1 }

CoffeeScriptBooleanLiteral
  ( "yes" / "on" ) NonIdContinue ->
    return { $loc, token: "true" }
  ( "no" / "off" ) NonIdContinue ->
    return { $loc, token: "false" }

# https://262.ecma-international.org/#prod-Identifier
Identifier
  # perf: assertion to exit early
  /(?=\p{ID_Start}|[_$])/ !ReservedWord IdentifierName:id -> id

# https://262.ecma-international.org/#prod-IdentifierName
IdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$])*/ ->
    return {
      type: "Identifier",
      name: $0,
      names: [$0],
      children: [{
        $loc: $loc,
        token: $0,
      }],
    }

# https://262.ecma-international.org/#prod-IdentifierReference
IdentifierReference
  Identifier

UpcomingAssignment
  &( __ "=" !( "=" / ">" ) )

# https://262.ecma-international.org/#prod-ArrayLiteral
ArrayLiteral
  # perf: assertion to exit early
  /(?=\[)/ _ArrayLiteral -> $2

_ArrayLiteral
  # NOTE: Check ArrayBindingPattern case of lhs destructuring
  ArrayBindingPattern UpcomingAssignment -> $1
  OpenBracket:open AllowAll ( ArrayLiteralContent __ CloseBracket )? RestoreAll ->
    if (!$3) return $skip
    const [ content, ws, close ] = $3

    if (content.type === "RangeExpression") {
      return {...content,
        children: [...content.children, ...ws],
      }
    }

    let children
    if (Array.isArray(content)) {
      children = [open, ...content, ...ws, close]
    } else {
      children = [open, content, ...ws, close]
    }

    // Gather names when ArrayLiteral is used as a destructuring pattern
    const names = children.flatMap((c) => c?.names || [])

    return {
      type: "ArrayExpression",
      children,
      names,
    }

RangeExpression
  ExtendedExpression:s __:ws ( DotDotDot / DotDot ):range ExtendedExpression:e ->
    const inclusive = range.token === ".."
    range.token = ","

    if (s.type === "Literal" && e.type === "Literal") {
      const start = literalValue(s)
      const end = literalValue(e)

      if (typeof start !== typeof end) {
        throw new Error("Range start and end must be of the same type")
      }

      if (typeof start === "string") {
        if (start.length !== 1 || end.length !== 1) {
          throw new Error("String range start and end must be a single character")
        }

        const startCode = start.charCodeAt(0)
        const endCode = end.charCodeAt(0)
        const step = startCode < endCode ? 1 : -1

        const length = Math.abs(endCode - startCode) + (inclusive ? 1 : 0)
        if (length <= 26) {
          return {
            type: "RangeExpression",
            children: ["[", Array.from({ length }, (_, i) => JSON.stringify(String.fromCharCode(startCode + i * step))).join(", "), "]"],
            inclusive,
            start: s,
            end: e
          }
        } else {
          const inclusiveAdjust = inclusive ? " + 1" : ""
          const children = ["((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)", inclusiveAdjust, "}, (_, i) => String.fromCharCode(s + i * step))})(", startCode.toString(), ws, range, endCode.toString(), ")"]
          return {
            type: "RangeExpression",
            children,
            inclusive,
            start: s,
            end: e,
          }
        }
      } else if (typeof start === "number") {
        const step = end > start ? 1 : -1

        const length = Math.abs(end - start) + (inclusive ? 1 : 0)
        if (length <= 20) {
          // Use array of literal values
          return {
            type: "RangeExpression",
            children: ["[", Array.from({ length }, (_, i) => start + i * step).join(", "), "]"],
            inclusive,
            start: s,
            end: e,
          }
        }
      }
    }

    const inclusiveAdjust = inclusive ? " + 1" : ""
    const children = ["((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)", inclusiveAdjust, "}, (_, i) => s + i * step)})(", s, ws, range, e, ")"]

    return {
      type: "RangeExpression",
      children,
      inclusive,
      start: s,
      end: e,
    }

ArrayLiteralContent
  RangeExpression
  # NOTE: No longer need to special-case implicit object literals separated
  # by dedented commas
  #NestedImplicitObjectLiteral ( __ Comma NestedImplicitObjectLiteral )*
  # First check for properly indented list items
  NestedElementList &( __ CloseBracket )
  # Next check for a line of items followed by properly indented list items;
  # first line should not use indented applications because they may be
  # lines of list items
  ElementListWithIndentedApplicationForbidden:list ArrayElementDelimiter:delimiter NestedElementList?:nested &( __ CloseBracket ) ->
    if (!nested) return list
    return [...list, delimiter, ...nested]
  # As fallback, ignore indentation altogether, forbidding indented applications
  ( __ ElementListWithIndentedApplicationForbidden ArrayElementDelimiter )* ->
    return $1.flat()

# "Properly nested" element lists all start at the same indentation,
# but we allow (via ArrayElementDelimiter) dedented commas between lists.
NestedElementList
  PushIndent NestedElement*:elements PopIndent ->
    if (elements.length)
      return elements.flat()
    return $skip

NestedElement
  Nested:indent ElementList:list ArrayElementDelimiter:delimiter ->
    const {length} = list
    if (length) {
      // Prepend indent to first element and append delimiter to last element
      return list.map((e, i) => {
        if (i === 0 && i === length - 1) {
          return {...e, children: [indent, ...e.children, delimiter]}
        }
        if (i === 0) {
          return {...e, children: [indent, ...e.children]}
        }
        if (i === length - 1) {
          return {...e, children: [...e.children, delimiter]}
        }
        return e
      })
    }

# Delimiter after ElementList (not within ElementList which just uses Comma)
ArrayElementDelimiter
  # NOTE: Allow arbitrary whitespace before comma to allow for breaking
  # outside indentation to separate e.g. implicit object literals
  __ Comma
  # NOTE: Don't insert comma before closing bracket
  # Ideally it would be nice to insert a trailing comma before newline followed by closing bracket, but in practice
  # it is difficult to keep the correct number of commas for elision elements. This is also closer to keeping source
  # verbatim.
  &( __ "]" )
  &EOS InsertComma -> $2

ElementListWithIndentedApplicationForbidden
  ForbidIndentedApplication ElementList? RestoreIndentedApplication ->
    if ($2) return $2
    return $skip

# https://262.ecma-international.org/#prod-ElementList
# NOTE: Modified and simplified from the spec
ElementList
  # NOTE: Forbid EOS to prevent eating indentation in Expression
  !EOS ArrayElementExpression:first ElementListRest*:rest ->
    if (rest.length) {
      return [{
        ...first,
        children: [...first.children, rest[0][0]],
      }].concat(rest.map(([_, e], i) => {
        const delim = rest[i+1]?.[0]
        return {
          ...e,
          children: [...e.children, delim],
        }
      }))
    }

    return [first]

ElementListRest
  # NOTE: Within ElementList, forbid newlines (EOS) before and after comma,
  # to correctly handle indentation and nested lists
  ( _? Comma !EOS ) ArrayElementExpression

# NOTE: Modified and simplified from the spec
ArrayElementExpression
  # NOTE: Prevent multiple JSX tags from combining implicitly into a fragment
  JSXTag
  ImplicitObjectLiteral &ArrayElementDelimiter -> $1
  # NOTE: Allow for postfix splat like CoffeeScript
  # NOTE: Allow empty exp spread for destructuring
  ExtendedExpression?:exp __:ws DotDotDot:dots &ArrayElementDelimiter ->
    if (!exp) {
      exp = { ...makeRef(), names: [] }
    }

    return {
      type: "SpreadElement",
      children: [...ws, dots, exp],
      names: exp.names,
    }

  # NOTE: Using PostfixedExpression, a superset of ExtendedExpression to allow If/Switch expressions
  # and also allow for postfix if/for/while
  ( ( __ DotDotDot __ )? PostfixedExpression )?:expMaybeSpread &ArrayElementDelimiter ->
    if (expMaybeSpread) {
      const [spread, exp] = expMaybeSpread

      if(!spread) {
        return {
          type: "ArrayElement",
          children: [exp],
          names: exp.names,
        }
      } else {
        return {
          type: "SpreadElement",
          children: [...spread, exp],
          names: exp.names,
        }
      }
    }

    return {
      type: "ElisionElement",
      children: [],
    }

# https://262.ecma-international.org/#prod-ObjectLiteral
# NOTE: Slightly simplified from spec
ObjectLiteral
  # NOTE: Check for object binding pattern in case of destructuring to an object lhs
  ObjectBindingPattern UpcomingAssignment -> $1
  BracedObjectLiteral
  NestedImplicitObjectLiteral
  InlineObjectLiteral

BracedObjectLiteral
  OpenBrace:open AllowAll ( BracedObjectLiteralContent __ CloseBrace )? RestoreAll ->
    if (!$3) return $skip
    const [ properties, ...close ] = $3

    return {
      type: "ObjectExpression",
      children: [open, properties, close],
      names: properties.flatMap((c) => c.names || []),
      properties,
    }

BracedObjectLiteralContent
  # Allow unnested comma-separated properties on first line, optionally
  # followed by nested comma-separated properties on further lines
  ( PropertyDefinition ObjectPropertyDelimiter )*:line NestedPropertyDefinitions?:nested ->
    line = line.flatMap(([prop, delim]) => {
      // Allow each prop to be a single Property object or an array of such
      prop = Array.isArray(prop) ? prop : [prop]
      let last = prop[prop.length-1]
      if (!last) return []
      last = {
        ...last,
        delim,
        children: [ ...last.children, delim ]
      }
      return [...prop.slice(0, prop.length-1), last]
    })
    return line.concat(nested || [])
  # As a backup, allow for arbitrary untracked indentation
  ( __ PropertyDefinition ObjectPropertyDelimiter )+ ->
    return $0.flatMap(([ws, prop, delim]) => {
      // Allow each prop to be a single Property object or an array of such
      prop = Array.isArray(prop) ? prop : [prop]
      let last = prop[prop.length-1]
      last = {
        ...last,
        delim,
        // __ will consume all whitespace that _? in PropertyDefinition could,
        // so replace _? (via slice) with __
        children: [ ws, ...last.children.slice(1), delim ]
      }
      return [...prop.slice(0, prop.length-1), last]
    })

# NOTE: Nested implicit object literal starts with an indentation.
# All properties can be spaced out and must have a colon.
NestedImplicitObjectLiteral
  InsertOpenBrace PushIndent NestedImplicitPropertyDefinitions?:properties PopIndent InsertNewline InsertIndent InsertCloseBrace ->
    if (!properties) return $skip
    return {
      type: "ObjectExpression",
      properties,
      children: $0,
    }

NestedImplicitPropertyDefinitions
  NestedImplicitPropertyDefinition+:defs ->
    return defs.flat()

NestedImplicitPropertyDefinition
  Nested:indent ( _? NamedProperty ObjectPropertyDelimiter )+:props ->
    return props.map(([ws, prop, delimiter], i) => ({
      ...prop,
      children: [
        ...(i === 0 ? [indent, ws] : [ws]),
        ...prop.children,
        delimiter
      ],
    }))

NestedPropertyDefinitions
  PushIndent NestedPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs.flat()

NestedPropertyDefinition
  # TODO: This may be a little weird/ambiguous with single identifier shorthand
  Nested:ws ( PropertyDefinition ObjectPropertyDelimiter )+:inlineProps ->
    return inlineProps.flatMap( ([prop, delim], i) => {
      // Allow each prop to be a single Property object or an array of such
      if (!Array.isArray(prop)) prop = [prop]
      if (i === 0) {
        const [first, ...rest] = prop
        prop = [ {...first, children: [...ws, ...first.children]}, ...rest ]
      }
      const last = prop[prop.length-1]
      prop = [
        ...prop.slice(0, prop.length-1),
        {
          ...last,
          delim,
          children: [ ...last.children, delim ]
        }
      ]
      return prop
    })

# NOTE: Implicit object literals are intended for beginnings of lines,
# but where the indentation has already been consumed.
# They can span multiple lines at the same indentation level.
# They must start with a snug property, and all properties must have a colon.
ImplicitObjectLiteral
  InsertInlineOpenBrace:open SnugNamedProperty:first ( ImplicitObjectPropertyDelimiter NamedProperty )*:rest ( _? Comma )?:trailing InsertCloseBrace:close ->
    return {
      type: "ObjectExpression",
      children: [open, first, ...rest, trailing, close],
    }

# This is different from ObjectPropertyDelimiter because the braces are implicit so we can't look ahead to find the closing one
# Instead we see if the next line matches a NamedProperty and if so we insert a comma
ImplicitObjectPropertyDelimiter
  _? Comma ( NotDedented / _? )
  &( Nested NamedProperty ) InsertComma Nested -> [$2, $3]

# NOTE: Inline object literals are intended for within expressions.
# They can only go onto another line if there's a trailing comma.
# They must start with a snug property, and all properties must have a colon.
InlineObjectLiteral
  InsertInlineOpenBrace:open SnugNamedProperty:first ( InlineObjectPropertyDelimiter NamedProperty )*:rest ( _? Comma &Dedented )?:trailing InsertCloseBrace:close ->
    return {
      type: "ObjectExpression",
      children: [open, first, ...rest, trailing, close],
    }

InlineObjectPropertyDelimiter
  _? Comma ( NotDedented / _? )

ObjectPropertyDelimiter
  _? Comma
  # Object closing delimits the property
  &( __ "}" )
  &EOS InsertComma -> $2

# https://262.ecma-international.org/#prod-PropertyDefinition
# NOTE: Must start on same line
PropertyDefinition
  _?:ws NamedProperty:prop ->
    return {
      ...prop,
      children: [ws, ...prop.children],
    }
  # NOTE: Added LiveScript flagging shorthand {+x, -y} -> {x: true, y: false}
  # NOTE: extended to allow {!y} -> {y: false}
  # NOTE: Must be after NamedProperty
  _?:ws $[!+-]:toggle PropertyName:id ->
    const value = toggle === "+" ? "true" : "false"
    return {
      type: "Property",
      children: [ws, id, ": ", value],
      name: id,
      names: id.names,
      value,
    }
  _?:ws MethodDefinition:def ->
    // Add commas between multiple method definitions (from globs)
    if (def.type === "MultiMethodDefinition") {
      return {
        children: def.children.flatMap((c, i) => i ? [",", c] : [c])
      }
    }
    // NOTE: Forbidding EmptyBlock in MethodDefinition to allow `foo()`
    // shorthand for `foo: foo()`
    if (!def.block || def.block.empty) return $skip
    return {
      ...def,
      children: [ws, ...def.children],
    }
  _?:ws DotDotDot:dots ExtendedExpression:exp ->
    return {
      type: "SpreadProperty",
      children: [ws, dots, exp],
      names: exp.names,
      dots,
      value: exp,
    }
  # NOTE: Added `{x.y?.z()}` shorthand for `{z: x.y?.z()}`
  # NOTE: this needs to be at the bottom to prevent shadowing NamedProperty
  _?:ws !EOS UnaryOp*:pre CallExpression:value UnaryPostfix?:post ->
    if (!pre.length && !post) {
      switch (value.type) {
        // `{identifier}` remains `{identifier}`, the one shorthand JS supports
        case "Identifier":
          return {...value, children: [ws, ...value.children]}
        // PropertyGlob like x.{a,b} turns into ObjectExpression {a: x.a, b: x.b}
        // (via `processCallMemberExpression`)
        case "ObjectExpression":
          let first = value.properties[0]
          if (first) {
            first = {
              ...first,
              children: [ws, ...first.children],
              hoistDec: value.hoistDec
            }
          }
          return [ first, ...value.properties.slice(1) ]
      }
    }
    const last = lastAccessInCallExpression(value)
    if (!last) return $skip

    let name, hoistDec, ref, refAssignment
    const { expression, type } = last
    if (type === "Index") {
      // TODO: If `last` is a suitable string literal, could use it for `name`.
      ref = maybeRef(expression)
      if (ref !== expression) {
        hoistDec = {
          type: "Declaration",
          children: ["let ", ref],
        }
        refAssignment = {
          type: "Assignment",
          children: [ref, " = ", expression],
        }

        name = {
          type: "ComputedPropertyName",
          children: [last.children[0], "(", refAssignment, ",", ref, ")", ...last.children.slice(-2)],
        }

        value = {
          ...value,
          children: value.children.map((c) => {
            if (c === last) return {
              type: "Index",
              children: ["[", ref, "]"],
            }
            return c
          })
        }
      } else {
        name = {
          type: "ComputedPropertyName",
          children: last.children,
        }
      }
    } else {
      ({name} = last)
      if (!name) return $skip
    }

    // Private name becomes public
    if (name[0] === "#") name = name.slice(1)

    return {
      type: "Property",
      children: [ws, name, ": ", processUnaryExpression(pre, value, post)],
      name,
      names: [],
      value,
      hoistDec,
    }
  # NOTE: basic identifiers are now part of the rule above
  #_?:ws IdentifierReference:id ->
  #  return {...id, children: [...ws, ...id.children]}

NamedProperty
  # NOTE: CoverInitializedName early error doesn't seem necessary with this parser
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  PropertyName:name _? Colon PostfixedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      name: name,
      names: exp.names || [],
      value: exp,
    }

# Named property but doesn't allow any space between name and colon
# used to distinguish between braceless inline objects and ternary expression conditions
# Allow postfixed expression only if this first property isn't the last
SnugNamedProperty
  PropertyName:name Colon:colon ExtendedExpression:expression ( ( _? PostfixStatement ) &( Nested NamedProperty ) )?:post ->
    if (post) {
      // post[0] drops the lookahead assertion
      expression = attachPostfixStatementAsExpression(expression, post[0])
    }
    return {
      type: "Property",
      children: [name, colon, expression],
      names: expression.names || [],
    }

PropertyName
  # https://262.ecma-international.org/#prod-LiteralPropertyName
  NumericLiteral
  ComputedPropertyName
  # NOTE: ComputedPropertyName must be before StringLiteral,
  # so that CoffeeScript interpolated strings get checked first.
  StringLiteral
  IdentifierName

ComputedPropertyName
  # https://262.ecma-international.org/#prod-ComputedPropertyName
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  OpenBracket PostfixedExpression:expression __ CloseBracket ->
    return {
      type: "ComputedPropertyName",
      children: $0,
      expression,
    }
  # NOTE: Extending to allow template literals without brackets
  InsertOpenBracket TemplateLiteral:expression InsertCloseBracket ->
    // Check for CoffeeScript interpolated double-quote string
    // without interpolation
    if ($2.type === "StringLiteral") return $2
    return {
      type: "ComputedPropertyName",
      children: $0,
      expression,
      implicit: true,
    }
  InsertOpenBracket [+-] NumericLiteral InsertCloseBracket ->
    const expression = [ $2, $3 ]
    return {
      type: "ComputedPropertyName",
      expression,
      children: [ $1, expression, $4 ],
      implicit: true,
    }

Decorator
  # Might want to disallow import, super, and return CallExpressions
  AtAt CallExpression

Decorators
  ForbidClassImplicitCall ( __ Decorator )*:decorators __ RestoreClassImplicitCall ->
    if (!decorators.length) return $skip
    return $0

# https://262.ecma-international.org/#prod-MethodDefinition
MethodDefinition
  Abstract __ MethodSignature:signature ->
    return {
      type: "MethodDefinition",
      children: $0,
      name: signature.name,
      abstract: true,
      signature,
      parameters: signature.parameters,
      ts: true
    }
  # NOTE: Not adding extra validation using PropertySetParameterList
  # NOTE: If this node layout changes, be sure to update `convertMethodTOFunction`
  MethodSignature:signature !(PropertyAccess / UnaryPostfix / NonNullAssertion) BracedBlock?:block ->
    let children = $0
    let generatorPos = 0
    let { modifier } = signature

    if (hasAwait(block)) {
      generatorPos++
      children = children.slice()
      // get or set
      if (modifier?.get || modifier?.set) {
        children.push({
          type: "Error",
          message: "Getters and setters cannot be async",
        })
      } else if(modifier?.async) {
        // Do nothing, already async
      } else {
        // Insert implicit async
        children.unshift("async ")
        modifier = { ...modifier, async: true }
        signature = { ...signature, modifier }
      }
    }

    if (hasYield(block)) {
      if (children === $0) children = children.slice()

      // get or set
      if (modifier?.get || modifier?.set) {
        children.push({
          type: "Error",
          message: "Getters and setters cannot be generators",
        })
      } else if(modifier?.generator) {
        // Do nothing, already generator
      } else {
        // Insert implicit generator
        children.splice(generatorPos, 0, "*")
        modifier = { ...modifier, generator: true }
        signature = { ...signature, modifier }
      }
    }

    return {
      type: "MethodDefinition",
      children,
      name: signature.name,
      signature,
      block,
      parameters: signature.parameters,
    }

  # shorthand get method definition
  GetOrSet:kind _?:ws ForbidIndentedApplication ( MemberBase CallExpressionRest* ReturnTypeSuffix? )?:content RestoreIndentedApplication BracedBlock?:block ->
    if (!content) return $skip
    const [ base, rest, returnType ] = content
    const value = [ base, rest ]

    if (!rest.length) {
      let name
      if (base.type === "MemberExpression") {
        const lastAccess = lastAccessInCallExpression(base)
        if (lastAccess) {
          ({ name } = lastAccess)
        }
      }

      if (!name) ({ name } = base)
      if (!name) return $skip

      // Remove leading # from private identifier since it makes no
      // sense for a private getter to point to itself
      if (name[0] === "#") name = name.slice(1)

      // Skip autoReturn for identifiers with an explicit block like `get foo { true }`
      const autoReturn = !block || base.type !== "Identifier"
      return makeGetterMethod(name, ws, base, returnType, block, kind, autoReturn)
    }

    let last = rest[rest.length-1]
    while (Array.isArray(last)) {
      last = last[last.length-1]
    }

    switch(last.type) {
      case "Call":
        return $skip
      case "PropertyAccess":
        const { name } = last
        return makeGetterMethod(name, ws, value, returnType, block, kind)
      case "PropertyGlob":
        return {
          type: "MultiMethodDefinition",
          children: last.object.properties.map((p) => {
            const { name, type } = p
            let v
            switch (type) {
              case "Identifier":
                v = insertTrimmingSpace(p, "")
                break
              case "Property":
                const { value } = p
                if (value.privateShorthand) {
                  v = value.privateId
                } else {
                  v = insertTrimmingSpace(value, "")
                }
                break
            }
            const exp = processCallMemberExpression({
              type: "CallExpression",
              children: [base, ...rest.slice(0, -1), {
                type: "PropertyAccess",
                children: [last.dot, {
                  ...v,
                  children: [ v.children.slice(0, 2) ] // Remove potential delimiter
                }],
              }],
            })

            return makeGetterMethod(name, ws, exp, returnType, block, kind)
          })
        }
    }

    const lastAccess = lastAccessInCallExpression({children: rest})
    const { name } = lastAccess

    return makeGetterMethod(name, ws, value, returnType, block, kind)

MethodModifier
  # NOTE: Merged get/set definitions
  GetOrSet:kind _? &ClassElementName ->
    return {
      type: "MethodModifier",
      async: false,
      generator: false,
      get: kind.token === "get",
      set: kind.token === "set",
      children: $0,
    }
  # NOTE: Merged async and generator into MethodModifier
  ( Async __ ) ( Star __ )? ->
    return {
      type: "MethodModifier",
      async: true,
      get: false,
      set: false,
      generator: !!$2,
      children: $0,
    }
  Star __ ->
    return {
      type: "MethodModifier",
      async: false,
      get: false,
      set: false,
      generator: true,
      children: $0,
    }

# TypeScript method signature
MethodSignature
  ConstructorShorthand NonEmptyParameters:parameters ->
    return {
      type: "MethodSignature",
      children: $0,
      name: $1.token,
      modifier: {},
      returnType: undefined,
      parameters,
    }

  # NOTE: If this node layout changes, be sure to update
  # `convertMethodToFunction` and `[3]` in code below
  MethodModifier?:modifier ClassElementName:name _? QuestionMark?:optional _? NonEmptyParameters:parameters ReturnTypeSuffix?:returnType ->
    // Normalize name so we can check if it is `constructor`
    if (name.name) {
      name = name.name
    } else if (name.token) {
      name = name.token.match(/^(?:"|')/) ? name.token.slice(1, -1) : name.token
    }

    // TypeScript supports optional methods with bodies; remove ? from JS output
    if (optional) $0[3] = optional = { ...optional, ts: true }

    modifier = modifier || {}

    return {
      type: "MethodSignature",
      children: $0,
      name,
      optional,
      modifier, // get/set/async/generator
      returnType,
      parameters,
    }

ClassElementName
  PropertyName
  LengthShorthand
  PrivateIdentifier

PrivateIdentifier
  $(Hash IdentifierName):id ->
    return {
      type: "Identifier",
      name: id,
      names: [id],
      children: [{
        $loc: $loc,
        token: id,
      }],
    }

# https://262.ecma-international.org/#prod-GeneratorDeclaration
# https://262.ecma-international.org/#prod-GeneratorExpression
# NOTE: Merged GeneratorExpression and GeneratorDeclaration into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncFunctionDeclaration
# https://262.ecma-international.org/#prod-AsyncFunctionExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorDeclaration
# https://262.ecma-international.org/#prod-AsyncGeneratorExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorMethod
# https://262.ecma-international.org/#prod-AsyncGeneratorBody
# https://262.ecma-international.org/#prod-AsyncMethod
# https://262.ecma-international.org/#prod-AsyncFunctionBody
# https://262.ecma-international.org/#prod-GeneratorMethod
# https://262.ecma-international.org/#prod-GeneratorBody
# NOTE: Merged into MethodDefinition

# NOTE: Allow arbitrary whitespace before regular assignment,
# but only allow non-newline whitespace before operator assignment.
WAssignmentOp
  __ AssignmentOp
  _? OperatorAssignmentOp

# https://262.ecma-international.org/#prod-AssignmentOperator
AssignmentOp
  AssignmentOpSymbol _? ->
    if ($2?.length) {
      if (typeof $1 !== "string") {
        return { ...$1, children: [...$1.children, $2] }
      }
      return {
        token: $1,
        children: [$1, ...$2]
      }
    }

    if (typeof $1 !== "string") return $1
    return { $loc, token: $1 }

# NOTE: x foo= y expands to x = foo(x, y)
# This is separate from AssignmentOp because it only works in certain contexts
# (in particular, not at the beginning of a line).
OperatorAssignmentOp
  Xor "=" _? ->
    return {
      special: true,
      call: module.getRef("xor"),
      children: [$2, ...$3 || []]
    }
  Xnor "=" _? ->
    return {
      special: true,
      call: module.getRef("xnor"),
      children: [$2, ...$3 || []]
    }
  Identifier "=" _? ->
    return {
      special: true,
      call: $1,
      children: [$2, ...$3 || []]
    }

AssignmentOpSymbol
  "**="
  "*="
  "/="
  "%="
  ( "++" / "⧺" ) Equals ->
    return {
      special: true,
      call: module.getRef("concatAssign"),
      omitLhs: true,
      children: [$2],
    }
  "+="
  "-="
  "<<="
  ">>>="
  ">>="
  "&&="
  "&="
  "^="
  "||="
  "|="
  "??="
  "?=" -> "??="
  # NOTE: assertion to avoid matching part of a comparison op
  "=" !"=" -> $1
  CoffeeWordAssignmentOp -> $1

CoffeeWordAssignmentOp
  "and=" -> "&&="
  "or=" -> "||="

# NOTE: Similar to `NotDedented BinaryOp`,
# but forbid Nested with custom infix operators
NotDedentedBinaryOp
  IndentedFurther? _? BinaryOp ->
    const ws = []
    if ($1) ws.push(...$1)
    if ($2) ws.push(...$2)
    return [ ws, $3 ]
  Nested _? !Identifier BinaryOp ->
    const ws = [...$1]
    if ($2) ws.push(...$2)
    return [ ws, $4 ]

IdentifierBinaryOp
  Identifier:id ->
    if (module.operators.has(id.name)) return id
    return $skip

BinaryOp
  /(?=\p{ID_Start}|[_$^«»⋙≤≥∈∋∉∌≣≡≢≠=‖⁇&|*\/!?%<>⧺+-])/ _BinaryOp:op -> op

_BinaryOp
  BinaryOpSymbol ->
    if (typeof $1 === "string") return { $loc, token: $1 }
    return $1
  Identifier:id ->
    if (!module.operators.has(id.name)) return $skip
    return {
      call: id,
      special: true,
      ...module.operators.get(id.name),
    }
  OmittedNegation __ Identifier:id ->
    if (!module.operators.has(id.name)) return $skip
    return {
      call: id,
      special: true,
      negated: true,
      ...module.operators.get(id.name),
    }

# NOTE: Condensed binary operator symbols into one rule
BinaryOpSymbol
  "**"
  "*"
  "/"
  "%%" ->
    return {
      call: module.getRef("modulo"),
      special: true,
    }
  # NOTE: %% must be above %
  "%"
  "++" / "⧺" ->
    return {
      method: "concat",
      special: true,
    }
  # NOTE: ++ must be above +
  "+"
  "-"
  "<="
  "≤" -> "<="
  ">="
  "≥" -> ">="
  # NOTE: added <? instanceof shorthand
  "<?" ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
    }
  "!<?" ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
      negated: true,
    }
  "<<"
  "«" -> "<<"
  "<"
  ">>>"
  "⋙" -> ">>>"
  ">>"
  "»" -> ">>"
  ">"
  "!=="
  "≢" -> "!=="
  # NOTE: CoffeeScript converts "!=" -> "!=="
  # Convert if CoffeeScript compat flag is set
  "!=" / "≠" ->
    if(module.config.coffeeEq) return "!=="
    return "!="
  "isnt" NonIdContinue ->
    if(module.config.coffeeIsnt) return "!=="
    return $skip
  "==="
  "≣" / "⩶" -> "==="
  # NOTE: CoffeeScript converts "==" -> "==="
  # Convert if CoffeeScript compat flag is set
  "==" / "≡" / "⩵" ->
    if(module.config.coffeeEq) return "==="
    return "=="
  "and" NonIdContinue -> "&&"
  "&&"
  "or" NonIdContinue -> "||"
  "||"
  "‖" -> "||"
  # NOTE: ^^ must be above ^
  "^^" / ( "xor" NonIdContinue ) ->
    return {
      call: module.getRef("xor"),
      special: true,
      prec: '^^',
    }
  /!\^\^?/ / ( "xnor" NonIdContinue ) ->
    return {
      call: module.getRef("xnor"),
      special: true,
      prec: '^^',
    }
  "??"
  "⁇" -> "??"
  "?" CoffeeBinaryExistentialEnabled -> "??"
  "instanceof" NonIdContinue ->
    return {
      $loc,
      token: $1,
      relational: true,
      special: true, // for typeof shorthand
    }
  CoffeeOfEnabled CoffeeOfOp:op -> op
  OmittedNegation __ NotOp:op ->
    return { ...op, $loc }
  ( Is __ In ) / "∈" ->
    return {
      method: "includes",
      relational: true,
      reversed: true,
      special: true,
    }
  "∋" ->
    return {
      method: "includes",
      relational: true,
      special: true,
    }
  "∌" ->
    return {
      method: "includes",
      relational: true,
      special: true,
      negated: true,
    }
  ( Is __ OmittedNegation __ In ) / "∉" ->
    return {
      method: "includes",
      relational: true,
      reversed: true,
      special: true,
      negated: true,
    }
  # NOTE: "is not" must come after "is not in"
  !CoffeeNotEnabled Is __ Not ->
    if (module.config.objectIs) {
      return {
        call: module.getRef("is"),
        relational: true,
        special: true,
        asConst: true,
        negated: true,
      }
    }
    return "!=="
  # NOTE: "is" must come after "is not" and "is in"
  Is ->
    if (module.config.objectIs) {
      return {
        call: module.getRef("is"),
        relational: true,
        special: true,
        asConst: true,
      }
    }
    return "==="
  In
  "&"
  "^"
  "|"

CoffeeOfOp
  Of -> "in"
  In ->
    return {
      call: [module.getRef("indexOf"), ".call"],
      relational: true,
      reversed: true,
      suffix: " >= 0",
      special: true,
    }
  OmittedNegation __ Of NonIdContinue ->
    return {
      $loc,
      token: "in",
      special: true,
      negated: true,
    }
  OmittedNegation __ In ->
    return {
      call: [module.getRef("indexOf"), ".call"],
      relational: true,
      reversed: true,
      suffix: " < 0",
      special: true,
    }

NotOp
  "instanceof" NonIdContinue ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
      negated: true,
    }
  In ->
    return {
      $loc,
      token: "in",
      special: true,
      negated: true,
    }

Xor
  "^^" / ( "xor" NonIdContinue )
Xnor
  /!\^\^?/ / "xnor"

UnaryOp
  # Lookahead to prevent unary operators from overriding update operators
  # ++/-- or block unary operator shorthand
  /(?!\+\+|--)[!~+-](?!\s)/ ->
    return { $loc, token: $0 }
  AwaitOp
  ( Delete / Void / Typeof ):op ![:.] _?:ws ->
    if (!ws) return [op, [" "]]
    return [op, ws]
  Not ![:.] " "? _? -> [$1, $4]

# https://github.com/tc39/proposal-await.ops
AwaitOp
  Await:a ( Dot IdentifierName )?:op _?:ws ->
    return {
      ...a,
      op,
      children: [a, ...(ws || [" "])],
    }

# https://262.ecma-international.org/#prod-ModuleItem
ModuleItem
  ImportDeclaration
  ExportDeclaration
  StatementListItem

# https://262.ecma-international.org/#prod-StatementListItem
StatementListItem
  Declaration
  # NOTE: Allow multi-line implicit object literals as top-level statements.
  # Leave $: for Svelte labels though.
  !"$:" ImplicitObjectLiteral ->
    return makeLeftHandSideExpression($2)
  # NOTE: Added postfix conditionals/loops
  PostfixedStatement

PostfixedStatement
  Statement:statement ( _? PostfixStatement )?:post ->
    if (post) return addPostfixStatement(statement, ...post)
    return statement

NoCommaStatementListItem
  Declaration
  # NOTE: Added postfix conditionals/loops
  PostfixedNoCommaStatement

PostfixedNoCommaStatement
  NoCommaStatement:statement ( _? PostfixStatement )?:post ->
    if (post) return addPostfixStatement(statement, ...post)
    return statement

PostfixedExpression
  ExtendedExpression:expression ( _? PostfixStatement )?:post ->
    if (post) return attachPostfixStatementAsExpression(expression, post)
    return expression

# Expression with postfixes *or* comma operators (mixing seems ambiguous)
PostfixedCommaExpression
  PostfixedExpression:expression ( ( _? PostfixStatement ) / ( CommaDelimiter AssignmentExpression )* ):post ->
    if (!post.length) return $1
    if (post.length === 2 && !Array.isArray(post[1])) {
      return attachPostfixStatementAsExpression(expression, post)
    }
    return $0

NonPipelinePostfixedExpression
  NonPipelineExtendedExpression:expression ( _? PostfixStatement )?:post ->
    if (post) return attachPostfixStatementAsExpression(expression, post)
    return expression

PostfixStatement
  /(?=for|if|loop|unless|until|while)/ _PostfixStatement -> $2

_PostfixStatement
  ForClause
  IfClause
  LoopClause
  UnlessClause
  WhileClause

# https://262.ecma-international.org/#prod-Statement
Statement
  KeywordStatement
  VariableStatement
  IfStatement
  IterationStatement
  SwitchStatement
  TryStatement

  EmptyStatement

  # NOTE: LabelledStatment is before ExpressionStatement so that `$:` is
  # treated as a label, not an implicit object literal, for Svelte compatibility
  LabelledStatement

  CommaExpressionStatement

  # NOTE: Block statement is after expression statement because valid ObjectLiterals should take priority over blocks
  BlockStatement

  # NOTE: no WithStatement

# Variant of Statement to forbid , operator (CommaExpression)
NoCommaStatement
  KeywordStatement
  VariableStatement
  IfStatement
  IterationStatement
  SwitchStatement
  TryStatement
  EmptyStatement
  LabelledStatement
  ExpressionStatement
  BlockStatement

# NOTE: EmptyStatement handled differently than spec, consuming inline whitespace and comments then asserting following semi-colon
EmptyStatement
  _? &";" ->
    return { type: "EmptyStatement", children: $1 || [] }

# https://262.ecma-international.org/#prod-BlockStatement
BlockStatement
  # NOTE: Added lookahead for `=` to allow for destructuring assignment without parens
  ExplicitBlock !( __ "=" ) -> $1

# https://262.ecma-international.org/#prod-LabelledStatement
LabelledStatement
  Label:label LabelledItem:statement ->
    return {
      type: "LabelledStatement",
      label,
      statement,
      children: $0,
    }

Label
  # NOTE: `:label` instead of `label:` to not clash with implicit object literal
  Colon:colon Identifier:id Whitespace:w ->
    return [ id, colon, w ]
  # NOTE: Make $: into label, not implicit object literal, for Svelte compat
  "$:" Whitespace

LabelledItem
  Statement
  FunctionDeclaration

# https://262.ecma-international.org/#prod-IfStatement
IfStatement
  # NOTE: Added paren-less condition
  # NOTE: Block isn't Statement so we can handle implied braces by nesting
  ( IfClause / UnlessClause ):clause Block:block ElseClause?:e ->
    return {
      type: "IfStatement",
      children: [...clause.children, block, e],
      condition: clause.condition,
      then: block,
      else: e,
    }

ElseClause
  Nested Else Block
  _? Else Block

IfClause
  If Condition:condition ->
    return {
      type: "IfStatement",
      children: $0,
      condition,
    }

UnlessClause
  Unless:kind Condition:condition ->
    // Rewrite unless to if
    kind = { ...kind, token: "if" }

    // Move leading space to after if
    kind.token += getTrimmingSpace(condition)
    condition = insertTrimmingSpace(condition, '')

    condition = negateCondition(condition)

    return {
      type: "IfStatement",
      children: [kind, condition],
      condition,
    }

# https://262.ecma-international.org/#prod-IterationStatement
IterationStatement
  /(?=loop|do|for|until|while)/ _IterationStatement -> $2

_IterationStatement
  # NOTE: Added `loop` from CoffeeScript
  LoopStatement
  !CoffeeDoEnabled DoWhileStatement -> $2
  # DoStatement must come after DoWhile statement
  !CoffeeDoEnabled DoStatement -> $2
  WhileStatement
  ForStatement

IterationExpression
  ( Async __ )?:async IterationStatement:statement ->
    return {
      type: "IterationExpression",
      subtype: statement.type,
      children: [statement],
      block: statement.block,
      statement,
      async,
    }

# NOTE: Added from CoffeeScript
LoopStatement
  LoopClause:clause Block:block ->
    return {
      type: "IterationStatement",
      children: [...clause.children, block],
      block,
    }

LoopClause
  Loop -> {
    type: "IterationStatement",
    children: [$1],
  }

# https://262.ecma-international.org/#prod-DoWhileStatement
DoWhileStatement
  # NOTE: Condition provides optional parens
  Do NoPostfixBracedBlock:block __ WhileClause -> {
    type: "IterationStatement",
    children: $0,
    block: block
  }

DoStatement
  Do NoPostfixBracedBlock:block ->
    block = insertTrimmingSpace(block, "")
    return {
      type: "DoStatement",
      children: [block],
      block,
    }

# https://262.ecma-international.org/#prod-WhileStatement
WhileStatement
  # NOTE: Condition provides optional parens
  WhileClause:clause Block:block ->
    return {
      ...clause,
      children: [...clause.children, block],
      block,
    }

WhileClause
  ( While / Until ):kind _?:ws Condition:condition ->
    if (kind.token === "until") {
      kind = { ...kind, token: "while" }
      condition = negateCondition(condition)
    }

    return {
      type: "IterationStatement",
      children: [kind, ws, condition],
      condition,
    }

# https://262.ecma-international.org/#prod-ForStatement
# https://262.ecma-international.org/#prod-ForInOfStatement
# NOTE: Merged into single rule
ForStatement
  ForClause:clause Block:block ->
    block = blockWithPrefix(clause.blockPrefix, block)

    return {
      ...clause,
      children: [...clause.children, block],
      block,
    }

ForClause
  For __ ForStatementControl:c  ->
    const {children, declaration} = c

    return {
      type: "ForStatement",
      children: [$1, ...$2, ...children],
      declaration: declaration,
      block: null,
      blockPrefix: c.blockPrefix,
      hoistDec: c.hoistDec,
    }

ForStatementControl
  !CoffeeForLoopsEnabled ForStatementParameters -> $2
  CoffeeForLoopsEnabled CoffeeForStatementParameters WhenCondition?:condition ->
    if (condition) {
      // TODO: actual block and continue ast nodes
      const block = "continue"
      $2 = {
        ...$2,
        blockPrefix: [...$2.blockPrefix,
          ["", {
            type: "IfStatement",
            then: block,
            children: ["if (!(", insertTrimmingSpace(condition, ""), ")) ", block],
          }, ";"]
        ],
      }
    }

    return $2

WhenCondition
  __ When ExpressionWithObjectApplicationForbidden:exp -> exp

CoffeeForStatementParameters
  # NOTE: Coffee for loops can't have parens
  ( Await __ )? InsertOpenParen:open CoffeeForDeclaration:declaration CoffeeForIndex?:index __ ( In / Of / From ):kind ExpressionWithObjectApplicationForbidden:exp ( _? By ExpressionWithObjectApplicationForbidden )?:step InsertCloseParen:close ->
    let blockPrefix = []
    exp = insertTrimmingSpace(exp, "")
    declaration = insertTrimmingSpace(declaration, "")

    if (kind.token === "from") {
      if (step) {
        throw new Error("Can't use 'by' with 'from' in CoffeeScript for loops")
      }
      kind = { ...kind, token: "of" }
    } else if (kind.token === "of") {
      if (step) {
        throw new Error("Can't use 'by' with 'of' in CoffeeScript for loops")
      }

      // TODO: Exp ref if exp is not a literal or identifier

      if (declaration.own) {
        const hasPropRef = module.getRef("hasProp")

        blockPrefix./**/push(["", ["if (!", hasPropRef, "(", exp, ", ", declaration, ")) continue"], ";"])
      }

      // index is actually value in Coffee "for of", y = z[x]
      if (index) {
        blockPrefix./**/push(["", {
          type: "AssignmentExpression",
          children: [index, " = ", exp, "[", declaration, "]"],
          names: index.names,
        }, ";"])
      }

      kind.token = "in"
    } else if (kind.token === "in") { // CoffeeScript loop comprehensions
      const counterRef = makeRef("i")
      const lenRef = makeRef("len")

      if (exp.type === "RangeExpression") {
        return forRange(open, declaration, exp, step?.[2], close)
      }

      // If exp isn't a simple identifier use a ref
      const expRef = maybeRef(exp)

      const varRef = declaration
      let increment = "++",
        indexAssignment,
        assignmentNames = [...varRef.names]

      if (index) {
        index = insertTrimmingSpace(index, "")
        indexAssignment = [index, "="]
        assignmentNames./**/push(...index.names)
      }

      const expRefDec = (expRef !== exp)
        // Trim a single leading space if present
        ? [expRef, " = ", insertTrimmingSpace(exp, ""), ", "]
        : []

      blockPrefix./**/push(["", {
        type: "AssignmentExpression",
        children: [varRef, " = ", expRef, "[", indexAssignment, counterRef, "]"],
        names: assignmentNames,
      }, ";"])

      declaration = {
        type: "Declaration",
        children: ["let ", ...expRefDec, counterRef, " = 0, ", lenRef, " = ", expRef, ".length"],
        names: []
      }

      let condition = [counterRef, " < ", lenRef, "; "]

      if (step) {
        let [stepWs, , stepExp] = step
        stepWs = insertTrimmingSpace(stepWs, "")
        if (stepExp.type === "Literal") {
          increment = [" +=", ...stepWs, stepExp]
          // Negative step loops are reversed
          if ( stepExp.raw[0] === "-") {
            declaration = {
              type: "Declaration",
              children: ["let ", ...expRefDec, counterRef, " = ", expRef, ".length - 1"],
              names: []
            }
            condition = [counterRef, " >= 0; "]
          }
        } else {
          throw new Error("TODO: Support non-literal step in CoffeeScript for loops")
        }

        return {
          declaration,
          children: [$1, open, declaration, "; ", ...condition, counterRef, increment, close],
          blockPrefix,
        }
      }

      return {
        declaration,
        children: [$1, open, declaration, "; ", ...condition, counterRef, increment, close],
        blockPrefix,
      }
    }

    return {
      declaration,
      children: [$1, open, declaration, $5, kind, " ", exp, close],
      blockPrefix,
    }
  ForRangeParameters

CoffeeForIndex
  _?:ws1 Comma _?:ws2 BindingIdentifier:id ->
    ws2 = insertTrimmingSpace(ws1, "")

    return {
      ...id,
      children: [...(ws1 || []), ...(ws2 || []), ...id.children]
    }

CoffeeForDeclaration
  # NOTE: Coffee doesn't allow expression bindings like `for a.x in b`
  ( __ Own )?:own ForBinding:binding ->
    return {
      type: "AssignmentExpression",
      own: Boolean(own),
      children: [$2],
      names: $2.names,
    }

ForStatementParameters
  # https://262.ecma-international.org/#prod-ForStatement
  OpenParen __ ( LexicalDeclaration / VariableStatement / CommaExpression? ):declaration __ Semicolon CommaExpression? Semicolon CommaExpression? __ CloseParen ->
    return {
      declaration,
      children: $0,
    }
  # NOTE: Added optional parens
  InsertOpenParen __ ( LexicalDeclaration / VariableStatement / CommaExpression? ):declaration __ Semicolon CommaExpression? Semicolon (!EOS ExpressionWithIndentedApplicationForbidden)? InsertCloseParen ->
    return {
      declaration,
      children: $0,
    }

  # https://262.ecma-international.org/#prod-ForInOfStatement
  # NOTE: Consolidated declarations
  # NOTE: Consolidated optional 'await'
  ( Await __ )? ( (Each / Own) __ )? ( OpenParen __ ) ForInOfDeclaration ( __ Comma __ ForInOfDeclaration )? __ ( In / Of ) ExpressionWithObjectApplicationForbidden ( __ By ExpressionWithObjectApplicationForbidden )? ( __ CloseParen ) ->
    return processForInOf($0, module.getRef)
  # NOTE: Added optional parens
  ( Await __ )? ( (Each / Own) __ )? InsertOpenParen ForInOfDeclaration ( __ Comma __ ForInOfDeclaration )? __ ( In / Of ) ExpressionWithObjectApplicationForbidden ( __ By ExpressionWithObjectApplicationForbidden )? InsertCloseParen ->
    return processForInOf($0, module.getRef)
  ForRangeParameters

ForRangeParameters
  # NOTE: CoffeeScript-style `for [start..end] by step` without declaration
  ( Await __ )? OpenParen:open OpenBracket RangeExpression:exp CloseBracket ( __ By ExpressionWithObjectApplicationForbidden )?:step CloseParen:close ->
    return forRange(open, null, exp, step, close)
  ( Await __ )? InsertOpenParen:open OpenBracket RangeExpression:exp CloseBracket ( __ By ExpressionWithObjectApplicationForbidden )?:step InsertCloseParen:close ->
    return forRange(open, null, exp, step, close)

# NOTE: Consolidated declarations
ForInOfDeclaration
  Var ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: $0,
      declare: $1,
      binding,
      names: binding.names,
    }
  ForDeclaration
  LeftHandSideExpression

# https://262.ecma-international.org/#prod-ForDeclaration
ForDeclaration
  LetOrConst:c ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      declare: c,
      binding,
      names: binding.names,
    }
  # NOTE: Added default implicit const to for bindings
  # NOTE: the assertion is a bit of a hack to prevent valid LHS expressions from only parsing the identifier and matching this rule
  # i.e. a.x would match as identifier `a` without this lookahead
  InsertConst:c ForBinding:binding /(?=[\s\),])/ ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      declare: c,
      binding,
      names: binding.names,
    }

# https://262.ecma-international.org/#prod-ForBinding
ForBinding
  BindingIdentifier
  BindingPattern

# https://262.ecma-international.org/#prod-SwitchStatement
SwitchStatement
  Switch ( EmptyCondition / Condition ):condition CaseBlock:caseBlock ->
    if (condition.type === "EmptyCondition") {
      // Negate all case condition expressions. This converts them to booleans
      // and is slightly smaller than switch(true) {case: !!exp ... }
      caseBlock.clauses.forEach(({cases}) => {
        if (cases) {
          cases.forEach((c) => {
            const exp = c[1]
            switch(exp.type) {
              case "Identifier":
              case "Literal":
                c.splice(1, 0, "!")
                break;
              default:
               c.splice(1, 1, "!(", exp, ")")
            }
          })
        }
      })
    }

    return {
      type: "SwitchStatement",
      children: $0,
      condition,
      caseBlock,
    }

EmptyCondition
  &EOS ->
    return {
      type: "EmptyCondition",
      children: [{
        $loc,
        token: " (false)",
      }]
    }

# https://262.ecma-international.org/#prod-CaseBlock
CaseBlock
  ( Nested / _ )? OpenBrace NestedCaseClauses:clauses __ CloseBrace ->
    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

  # NOTE: Added optional braces with nesting
  InsertOpenBrace NestedCaseClauses:clauses InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

NestedCaseClauses
  PushIndent NestedCaseClause*:clauses PopIndent ->
    if (clauses.length) return clauses
    return $skip

NestedCaseClause
  Nested:indent CaseClause:clause ->
    return {
      ...clause,
      // Bring the indent into the clause
      children: [indent, ...clause.children],
    }

# https://262.ecma-international.org/#prod-CaseClause
CaseClause
  PatternExpressionList:patterns ( ThenClause / BareBlock ):block ->
    return {
      type: "PatternClause",
      children: $0,
      block,
      patterns,
    }
  Case CaseExpressionList IgnoreColon ( ThenClause / BareBlock ) -> {
    type: "CaseClause",
    children: $0
  }
  # NOTE: Added "when" from CoffeeScript. `when` always inserts `break;`.
  When CaseExpressionList:cases IgnoreColon InsertOpenBrace ( ThenClause / BareBlock ):block InsertBreak:b InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "WhenClause",
      cases,
      block,
      break: b,
      children: $0,
    }
  # NOTE: Merged in default clause
  Default ImpliedColon ( ThenClause / BareBlock):block ->
    return {
      type: "DefaultClause",
      block,
      children: $0
    }
  # NOTE: Added else from CoffeeScript
  Else ImpliedColon ( ThenClause / BracedBlock / EmptyBlock ):block ->
    $1.token = "default"
    return {
      type: "DefaultClause",
      block,
      children: $0
    }

PatternExpressionList
  ConditionFragment:first ( _? Comma ( Nested / _ )? ConditionFragment )*:rest ->
    return [first, ...rest.map(([, , , p]) => p)]

ConditionFragment
  BindingPattern
  ForbidIndentedApplication ( SingleLineBinaryOpRHS+ )?:pattern RestoreIndentedApplication ->
    if (!pattern) return $skip

    return {
      type: "ConditionFragment",
      children: pattern,
    }

CaseExpressionList
  ( _? CaseExpression InsertColon ):first ( __ Comma CaseExpression InsertColon )*:rest ->
    // Convert comma separated expression list to `case <exp>:`
    const result = rest.map(([ws, _comma, exp, col]) => {
      exp = insertTrimmingSpace(exp, "")

      if (ws.length) return [insertTrimmingSpace("case ", ws), exp, col]
      return ["case ", exp, col]
    })
    result./**/unshift(first)

    return result

CaseExpression
  # NOTE: Explicitly matching `case foo:` to prevent this from looking like
  # an object literal, but treat `case [foo]:` like an array literal
  PropertyName:value &( _? Colon ) ->
    if (value.type === "ComputedPropertyName") {
      if (value.implicit) return value.expression
      return {...value, type: "ArrayExpression"}
    }
    return value
  ExpressionWithObjectApplicationForbidden

ImpliedColon
  _? Colon
  InsertColon

# Optionally match Colon and throw it away
IgnoreColon
  ( _? Colon )? ->
    if ($1) return $1[0]

# https://262.ecma-international.org/#prod-TryStatement
TryStatement
  Try:t !":" NoPostfixBracedOrEmptyBlock:b CatchClause?:c FinallyClause?:f ->
    if (!c && !f) {
      const emptyCatchBlock = makeEmptyBlock()

      c = {
        type: "CatchClause",
        children: [" catch(e) ", emptyCatchBlock],
        block: emptyCatchBlock,
      }

      return {
        type: "TryStatement",
        blocks: [ b, emptyCatchBlock ],
        children: [t, b, c],
      }
    }

    const blocks = [b]
    if (c) blocks.push(c.block)

    return {
      type: "TryStatement",
      blocks,
      children: [t, b, c, f],
    }

# https://262.ecma-international.org/#prod-Catch
CatchClause
  ( Nested / _ ) Catch CatchBind? ( BracedThenClause / BracedOrEmptyBlock ):block ->
    return {
      type: "CatchClause",
      children: $0,
      block,
    }

# NOTE: Added optional parentheses to catch binding
CatchBind
  _? OpenParen __ CatchParameter __ CloseParen
  _ InsertOpenParen !EOS CatchParameter InsertCloseParen

# https://262.ecma-international.org/#prod-Finally
FinallyClause
  ( Nested / _ ) Finally ( BracedThenClause / BracedOrEmptyBlock )

# https://262.ecma-international.org/#prod-CatchParameter
CatchParameter
  BindingIdentifier TypeSuffix?
  BindingPattern TypeSuffix?

# An expression with explicit or implied parentheses, for use in if/while/switch
Condition
  # NOTE: DeclarationCondition must come before the ExpressionCondition because we need to look ahead to potentially match `:=` or `.=`
  OpenParen:open _?:ws DeclarationCondition:expression CloseParen:close ->
    return {
      type: "ParenthesizedExpression",
      children: [open, ws, expression, close],
      expression,
    }
  ParenthesizedExpression !( _? ( BinaryOp / AssignmentOp / Dot / QuestionMark ) ) !( _ OperatorAssignmentOp ) -> $1
  # NOTE: DeclarationCondition must come before the ExpressionCondition because we need to look ahead to potentially match `:=` or `.=`
  InsertOpenParen:open DeclarationCondition:expression InsertCloseParen:close ->
    return {
      type: "ParenthesizedExpression",
      children: [open, expression, close],
      expression,
    }

  InsertOpenParen:open ExpressionWithObjectApplicationForbidden:expression InsertCloseParen:close ->
    // Don't double wrap parethesized expressions
    if (expression.type === "ParenthesizedExpression") return expression
    expression = insertTrimmingSpace(expression, "")
    return {
      type: "ParenthesizedExpression",
      children: [open, expression, close],
      expression,
    }

DeclarationCondition
  ForbidBracedApplication ForbidIndentedApplication ForbidNewlineBinaryOp LexicalDeclaration?:declaration RestoreNewlineBinaryOp RestoreBracedApplication RestoreIndentedApplication ->
    if (!declaration) return $skip

    return {
      type: "DeclarationCondition",
      declaration,
    }

ExpressionWithIndentedApplicationForbidden
  ForbidIndentedApplication ForbidNewlineBinaryOp ExtendedExpression?:exp RestoreNewlineBinaryOp RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

SingleLineExpressionWithIndentedApplicationForbidden
  ForbidIndentedApplication ForbidNewlineBinaryOp SingleLineAssignmentExpression?:exp RestoreNewlineBinaryOp RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

# NOTE: Forbid both explicit (braced) and implicit indented object literals
# as arguments to implicit function calls.  This is useful in the context of
# an `if` or `class` line where we don't want to treat the body as an object.
ExpressionWithObjectApplicationForbidden
  ForbidBracedApplication ForbidIndentedApplication ForbidNewlineBinaryOp ExtendedExpression?:exp RestoreNewlineBinaryOp RestoreBracedApplication RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

LeftHandSideExpressionWithObjectApplicationForbidden
  ForbidBracedApplication ForbidIndentedApplication ForbidNewlineBinaryOp LeftHandSideExpression?:exp RestoreNewlineBinaryOp RestoreBracedApplication RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

ForbidClassImplicitCall
  "" ->
    module.forbidClassImplicitCall.push(true)

AllowClassImplicitCall
  "" ->
    module.forbidClassImplicitCall.push(false)

RestoreClassImplicitCall
  "" ->
    module.forbidClassImplicitCall.pop()

ClassImplicitCallForbidden
  "" ->
    if (!module.classImplicitCallForbidden) return $skip
    return

ForbidBracedApplication
  "" ->
    module.forbidBracedApplication.push(true)

AllowBracedApplication
  "" ->
    module.forbidBracedApplication.push(false)

RestoreBracedApplication
  "" ->
    module.forbidBracedApplication.pop()

BracedApplicationAllowed
  "" ->
    if (module.config.verbose) {
      console.log("forbidBracedApplication:", module.forbidBracedApplication)
    }
    if (module.bracedApplicationForbidden) return $skip
    return

ForbidIndentedApplication
  "" ->
    module.forbidIndentedApplication.push(true)

AllowIndentedApplication
  "" ->
    module.forbidIndentedApplication.push(false)

RestoreIndentedApplication
  "" ->
    module.forbidIndentedApplication.pop()

IndentedApplicationAllowed
  "" ->
    if (module.config.verbose) {
      console.log("forbidIndentedApplication:", module.forbidIndentedApplication)
    }
    if (module.indentedApplicationForbidden) return $skip
    return

ForbidTrailingMemberProperty
  "" ->
    module.forbidTrailingMemberProperty.push(true)

AllowTrailingMemberProperty
  "" ->
    module.forbidTrailingMemberProperty.push(false)

RestoreTrailingMemberProperty
  "" ->
    module.forbidTrailingMemberProperty.pop()

TrailingMemberPropertyAllowed
  "" ->
    if (module.config.verbose) {
      console.log("forbidTrailingMemberProperty:", module.forbidTrailingMemberProperty)
    }
    if (module.trailingMemberPropertyForbidden) return $skip

AllowNewlineBinaryOp
  "" ->
    module.forbidNewlineBinaryOp.push(false)

ForbidNewlineBinaryOp
  "" ->
    module.forbidNewlineBinaryOp.push(true)

RestoreNewlineBinaryOp
  "" ->
    module.forbidNewlineBinaryOp.pop()

NewlineBinaryOpAllowed
  "" ->
    if (module.config.verbose) {
      console.log("forbidNewlineBinaryOp:", module.forbidNewlineBinaryOp)
    }
    if (module.newlineBinaryOpForbidden) return $skip

AllowAll
  AllowTrailingMemberProperty AllowBracedApplication AllowIndentedApplication AllowClassImplicitCall AllowNewlineBinaryOp

RestoreAll
  RestoreTrailingMemberProperty RestoreBracedApplication RestoreIndentedApplication RestoreClassImplicitCall RestoreNewlineBinaryOp

# https://262.ecma-international.org/#prod-ExpressionStatement
CommaExpressionStatement
  # NOTE: semi-colons are being handled elsewhere
  # NOTE: Shouldn't need negative lookahead if shadowed in the proper order
  # NOTE: Allow for e.g. await forms of IterationExpression that weren't
  # already parsed as IterationStatement. Must be before AssignmentExpression
  # to avoid treated `async do ...` like a function call `async(do ...)`.
  IterationExpression
  # NOTE: CommaExpression allows , operator
  CommaExpression ->
    // Wrap object literal with parens to disambiguate from block statements.
    // Also wrap nameless functions from `->` expressions with parens
    // as needed in JS.
    return makeExpressionStatement($1)

# CommaExpressionStatement, but forbidding comma operator
ExpressionStatement
  IterationExpression
  # NOTE: AssignmentExpression forbids , operator
  AssignmentExpression ->
    return makeExpressionStatement($1)

KeywordStatement
  # https://262.ecma-international.org/#prod-BreakStatement
  # NOTE: Also allow `break :label` for symmetry
  Break ( _ Colon? Identifier:id )? ->
    return {
      type: "BreakStatement",
      children: $2 ? [ $1, $2[0], $2[2] ] : [ $1 ],
                           // omit colon
    }

  # https://262.ecma-international.org/#prod-ContinueStatement
  # NOTE: Also allow `continue :label` for symmetry
  Continue ( _ Colon? Identifier:id )? ->
    return {
      type: "ContinueStatement",
      children: $2 ? [ $1, $2[0], $2[2] ] : [ $1 ],
                           // omit colon
    }

  DebuggerStatement

  # https://262.ecma-international.org/#prod-ReturnStatement
  # NOTE: Modified to leave room for `return.value` and `return =`
  Return !(":" / "." / AfterReturnShorthand) MaybeNestedExpression?:expression -> {
    type: "ReturnStatement",
    expression,
    children: $0,
  }

  ThrowStatement

# https://262.ecma-international.org/#sec-debugger-statement
DebuggerStatement
  Debugger -> {
    type: "DebuggerStatement",
    children: $0,
  }

# https://262.ecma-international.org/#prod-ThrowStatement
ThrowStatement
  Throw ExtendedExpression -> {
    type: "ThrowStatement",
    children: $0,
  }

Break
  "break" NonIdContinue ->
    return { $loc, token: $1 }

Continue
  "continue" NonIdContinue ->
    return { $loc, token: $1 }

Debugger
  "debugger" NonIdContinue ->
    return { $loc, token: $1 }

MaybeNestedExpression
  # Not nested case
  !EOS ExtendedExpression ->
    return $2
  # Avoid wrapping object return value in parentheses.
  &EOS ObjectLiteral ->
    return $2
  # Value after `return` needs to be wrapped in parentheses
  # if it starts on another line.
  &EOS InsertSpace InsertOpenParen PushIndent Nested ExtendedExpression PopIndent InsertNewline InsertIndent InsertCloseParen

# https://262.ecma-international.org/#prod-ImportDeclaration
ImportDeclaration
  # NOTE: TypeScript's CommonJS import syntax
  # https://www.typescriptlang.org/docs/handbook/modules/reference.html#export--and-import--require
  Import _ Identifier _? Equals __ "require" NonIdContinue Arguments ->
    // Replace `import` with `const` in JS output
    const imp = [
      { ...$1, ts: true },
      { ...$1, token: "const", js: true },
    ]
    return {
      type: "ImportDeclaration",
      children: [imp, $0.slice(1)],
    }
  Import __ TypeKeyword __ ImportClause __ FromClause -> { type: "ImportDeclaration", ts: true, children: $0 }
  Import __ ImportClause __ FromClause -> { type: "ImportDeclaration", children: $0 }
  Import __ ModuleSpecifier -> { type: "ImportDeclaration", children: $0 }
  # NOTE: Added import shorthand
  # NOTE: Not adding $loc to source map here yet because it will point to the start of the identifier
  # the proper place may be to use the From location
  ImpliedImport:i ( TypeKeyword __ )?:t ImportClause:c __:w FromClause:f ->
    // Map implied import location to `from`
    // The pos and length adjustment better match how tsc outputs to include the space before `from` with the `from` token
    i.$loc = {
      pos: f[0].$loc.pos-1,
      length: f[0].$loc.length+1,
    }
    const children = [i, t, c, w, f]
    if (!t) return children
    return { type: "ImportDeclaration", ts: true, children }

ImpliedImport
  "" ->
    return { $loc, token: "import " }

# https://262.ecma-international.org/#prod-ImportClause
ImportClause
  ImportedBinding:binding ( __ Comma __ ( NameSpaceImport / NamedImports ) )?:rest ->
    if (rest) {
      return {
        type: "Declaration",
        children: $0,
        names: [...binding.names, ...rest[3].names],
      }
    }

    return {
      type: "Declaration",
      children: $0,
      names: binding.names,
    }
  NameSpaceImport
  NamedImports

# https://262.ecma-international.org/#prod-NameSpaceImport
NameSpaceImport
  Star ImportAsToken __ ImportedBinding:binding  ->
    return {
      type: "Declaration",
      children: $0,
      names: binding.names
    }

# https://262.ecma-international.org/#prod-NamedImports
NamedImports
  OpenBrace TypeAndImportSpecifier*:specifiers ( __ Comma )? __ CloseBrace ->
    const names = specifiers.flatMap(({binding}) => binding.names)

    return {
      type: "Declaration",
      children: $0,
      names
    }

# https://262.ecma-international.org/#prod-FromClause
FromClause
  From __ ModuleSpecifier

# https://github.com/tc39/proposal-import-assertions
# https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#import-assertions
# https://github.com/tc39/proposal-import-attributes
# https://devblogs.microsoft.com/typescript/announcing-typescript-5-3/#import-attributes
# NOTE: Forbid newline before `with` which could mean a function call
ImportAssertion
  _? ( "with" / "assert" ) NonIdContinue _? ObjectLiteral

# https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports
TypeAndImportSpecifier
  ( __ TypeKeyword )? ImportSpecifier ->
    if (!$1) return $2
    return { ts: true, children: $0, binding: $2.binding }
  # `operator id` blesses `id` as operator; doesn't make sense with `type`
  __:ws Operator OperatorImportSpecifier:spec ->
    if (spec.binding.type !== "Identifier") {
      throw new Error("Expected identifier after `operator`")
    }
    module.operators.set(spec.binding.name, spec.behavior)
    return {
      ...spec,
      children: [
        ws, insertTrimmingSpace(spec[0], ""),
        spec.children.slice(1),
      ],
    }

# https://262.ecma-international.org/#prod-ImportSpecifier
ImportSpecifier
  __ ModuleExportName ImportAsToken __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding,
      children: $0,
    }
  __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding,
      children: $0,
    }

OperatorImportSpecifier
  __ ModuleExportName OperatorBehavior?:behavior ImportAsToken __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding,
      behavior,
      children: [$1, $2, $4, $5, $6, $7],
    }
  __ ImportedBinding:binding OperatorBehavior?:behavior ObjectPropertyDelimiter ->
    return {
      binding,
      behavior,
      children: [$1, $2, $4],
    }

ImportAsToken
  __ As
  # NOTE: Allowing ':' in place of 'as', a preliminary step towards unifying
  # imports and destructuring.
  Loc:l __:ws Colon:c " "? ->
    const children = [
      ...ws,
      { ...c, token: "as " },
    ]

    if (!ws.length) {
      children.unshift({ $loc: l.$loc, token: " " })
    }

    return {
      children,
    }

# https://262.ecma-international.org/#prod-ModuleExportName
ModuleExportName
  StringLiteral
  IdentifierName

# https://262.ecma-international.org/#prod-ModuleSpecifier
ModuleSpecifier
  UnprocessedModuleSpecifier ImportAssertion?:a ->
    let { token } = $1
    if (module.config.rewriteTsImports) {
      // Workaround to fix:
      // https://github.com/microsoft/TypeScript/issues/42151
      // import t.ts
      // "An import path cannot end with a '.ts' extension. Consider importing './t.js' instead."
      // convert .[mc]?ts to .[mc]?js
      token = token.replace(/\.([mc])?ts(['"])$/, ".$1js$2")
    }
    if (module.config.rewriteCivetImports) {
      token = token.replace(/\.civet(['"])$/,
        `${module.config.rewriteCivetImports.replace(/\$/g, '$$')}$1`)
    }

    if (a)
      return [{ ...$1, token }, a]

    return { ...$1, token }

UnprocessedModuleSpecifier
  StringLiteral
  UnquotedSpecifier

UnquotedSpecifier
  # Currently allowing all characters except for whitespace, double quotes, and semi-colon
  # It may make sense to restrict this to only allow characters that are valid in a module specifier
  # Also consider URLs
  /[^;"\s]+/:spec ->
    return { $loc, token: `"${spec}"` }

# https://262.ecma-international.org/#prod-ImportedBinding
ImportedBinding
  BindingIdentifier

# https://262.ecma-international.org/#prod-ExportDeclaration
ExportDeclaration
  # NOTE: TypeScript's CommonJS export syntax
  # https://www.typescriptlang.org/docs/handbook/modules/reference.html#export--and-import--require
  Export _? Equals ExtendedExpression ->
    // Replace `export` with `module.exports` in JS output
    const exp = [
      { ...$1, ts: true },
      { ...$1, token: "module.exports", js: true },
    ]
    return {
      type: "ExportDeclaration",
      children: [exp, $0.slice(1)],
    }
  # NOTE: export default for all Declarations not supported by TS export default
  # NOTE: Avoid matching `f := ->`, leaving that for the next rule.
  Decorators? Export __ Default __ !FunctionDeclaration ( LexicalDeclaration / VariableStatement / TypeAliasDeclaration / NamespaceDeclaration / EnumDeclaration / OperatorDeclaration ):declaration ->
    let id, error
    if (declaration.id) {
      id = declaration.id
    } else if (declaration.names) {
      if (declaration.names.length !== 1) {
        error = {
          type: "Error",
          message: `export default with ${declaration.names.length} variable declaration (should be 1)`
        }
      }
      id = declaration.names[0]
    } else {
      throw new Error("Could not find name of declaration in export default")
    }
    return [
      declaration,
      { children: [";"], ts: declaration.ts },
      error ??
      { type: "ExportDeclaration", declaration: id, ts: declaration.ts,
        children: [ ...$0.slice(0, -2), id ] }
    ]
  # NOTE: This covers all forms that can be directly export defaulted in TS.
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  Decorators? Export __ Default __ ( HoistableDeclaration / ClassDeclaration / InterfaceDeclaration / ExtendedExpression ):declaration ->
    return { type: "ExportDeclaration", declaration, ts: declaration.ts, children: $0 }
  Export __ ExportFromClause __ FromClause ->
    return { type: "ExportDeclaration", ts: $3.ts, children: $0 }
  # NOTE: Declaration and VariableStatement should come before NamedExports
  # so that NamedExports doesn't grab function, async, type, var, etc.
  # NOTE: TS decorators come before `export` keyword but TC39 stage 3 decorators proposal come after
  Decorators? Export __ ( Declaration / VariableStatement / TypeAndNamedExports / ExportVarDec ):declaration ->
    return { type: "ExportDeclaration", declaration, ts: declaration.ts, children: $0 }

# CoffeeScript style `export x = 3` -> `export var x = 3`
ExportVarDec
  InsertVar VariableDeclarationList ->
    return {
      ...$2,
      children: [$1, ...$2.children]
    }

# https://262.ecma-international.org/#prod-ExportFromClause
ExportFromClause
  Star ( __ As __ ModuleExportName )?
  TypeAndNamedExports

# https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports
TypeAndNamedExports
  ( TypeKeyword __ )? NamedExports ->
    if (!$1) return $2
    return { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-NamedExports
NamedExports
  OpenBrace ExportSpecifier* (__ Comma )? __ CloseBrace
  # Unbraced version: export x, y
  InsertInlineOpenBrace:open ImplicitExportSpecifier:first ( ImplicitObjectPropertyDelimiter ImplicitExportSpecifier )*:rest InsertCloseBrace:close &( StatementDelimiter / ( __ From )) ->
    return [open, first, ...rest, close]

# https://262.ecma-international.org/#prod-ExportSpecifier
ExportSpecifier
  __ ( TypeKeyword __ )? ModuleExportName ( __ As __ ModuleExportName )? ObjectPropertyDelimiter ->
    if (!$2) return $0
    return { ts: true, children: $0 }

ImplicitExportSpecifier
  !Default ModuleExportName ( __ As __ ModuleExportName )?

# https://262.ecma-international.org/#prod-Declaration
Declaration
  HoistableDeclaration
  ClassDeclaration
  LexicalDeclaration:d ->
    if (d.thisAssignments?.length)
      return {
        ...d,
        children: [...d.children, ...d.splices, ";", ...d.thisAssignments]
      }
    if (d.splices?.length)
      return {
        ...d,
        children: [...d.children, ...d.splices]
      }
    return d
  TypeDeclaration
  EnumDeclaration
  OperatorDeclaration
  UsingDeclaration

# https://262.ecma-international.org/#prod-HoistableDeclaration
HoistableDeclaration
  FunctionDeclaration

# https://262.ecma-international.org/#prod-LexicalDeclaration
LexicalDeclaration
  # NOTE: Eliminated left recursion
  LetOrConst:decl LexicalBinding:binding ( __ Comma __ LexicalBinding )*:tail ->
    const bindings = [binding].concat(tail.map(([,,,b]) => b))

    return {
      type: "Declaration",
      children: $0,
      names: bindings.flatMap(b => b.names),
      bindings,
      decl,
      splices: bindings.flatMap(b => b.splices),
      thisAssignments: bindings.flatMap(b => b.thisAssignments),
    }
  # NOTE: Added const shorthand
  # NOTE: Using ExtendedExpression to allow for If/SwitchExpressions
  InsertConst ( BindingPattern / BindingIdentifier ) TypeSuffix? __ ConstAssignment PostfixedExpression ->
    return processAssignmentDeclaration(...$0)

  # NOTE: Added let shorthand
  InsertLet ( BindingPattern / BindingIdentifier ) TypeSuffix? __ LetAssignment PostfixedExpression ->
    return processAssignmentDeclaration(...$0)

ConstAssignment
  ":=" / "≔" ->
    return { $loc, token: "=" }

LetAssignment
  ".=" ->
    return { $loc, token: "=" }


TypeAssignment
  "::=" ->
    return { $loc, token: "=" }

# https://262.ecma-international.org/#prod-LexicalBinding
# merged with https://262.ecma-international.org/#prod-VariableDeclaration
LexicalBinding
  BindingPattern:pattern TypeSuffix?:suffix Initializer:initializer ->
    const [splices, thisAssignments] = gatherBindingCode(pattern)

    return {
      type: "Binding",
      children: $0,
      names: pattern.names,
      pattern,
      suffix,
      initializer,
      splices: splices.map(s => [",", s]),
      thisAssignments: thisAssignments.map(s => ["", s, ";"]),
    }

  BindingIdentifier:pattern TypeSuffix?:suffix Initializer?:initializer ->
    return {
      type: "Binding",
      children: $0,
      names: pattern.names,
      pattern,
      suffix,
      initializer,
      splices: [],
      thisAssignments: [],
    }

# https://262.ecma-international.org/#prod-Initializer
Initializer
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  __ Equals ExtendedExpression

# https://262.ecma-international.org/#prod-VariableStatement
VariableStatement
  Var __ VariableDeclarationList ->
    return {
      ...$3,
      names: $3.names,
      children: [$1, ...$2, ...$3.children],
    }

# https://262.ecma-international.org/#prod-VariableDeclarationList
VariableDeclarationList
  LexicalBinding:binding ( __ Comma __ LexicalBinding )*:tail ->
    const bindings = [binding].concat(tail.map(([,,,b]) => b))

    return {
      type: "Declaration",
      children: [binding, ...tail],
      bindings,
      names: bindings.flatMap(b => b.names),
    }

# https://262.ecma-international.org/#prod-NumericLiteral
# NOTE: No leading minus sign
NumericLiteral
  # perf: short circuit if no possibility of being a number
  /(?=[0-9.])/ NumericLiteralKind:token ->
    return { type: "NumericLiteral", $loc, token }

NumericLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral
  DecimalLiteral

# https://262.ecma-international.org/#prod-DecimalBigIntegerLiteral
DecimalBigIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)n/
  # /[_0-9]*n/

# https://262.ecma-international.org/#prod-DecimalLiteral
DecimalLiteral
  # NOTE: Not matching the dot as part of a number if it is followed by a valid JS identifier so that it will match as a property access
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?=\.(?:\p{ID_Start}|[_$]))/ ) ->
    // Insert an extra dot to make property access work
    return $1 + "."
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?:\.(?:[0-9](?:_[0-9]|[0-9])*))?/ ExponentPart? )
  $( /(?:\.[0-9](?:_[0-9]|[0-9])*)/ ExponentPart? )

ExponentPart
  /(?:[eE][+-]?[0-9]+(?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-BinaryIntegerLiteral
BinaryIntegerLiteral
  /0[bB][01](?:[01]|_[01])*n?/

# https://262.ecma-international.org/#prod-OctalIntegerLiteral
OctalIntegerLiteral
  /0[oO][0-7](?:[0-7]|_[0-7])*n?/

# https://262.ecma-international.org/#prod-HexIntegerLiteral
HexIntegerLiteral
  /0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_[0-9a-fA-F])*n?/

# NOTE: Integer variation of NumericLiteral
IntegerLiteral
  # perf: short circuit if no possibility of being an integer
  /(?=[0-9])/ IntegerLiteralKind:token ->
    return { $loc, token }

IntegerLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral
  DecimalIntegerLiteral

DecimalIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-StringLiteral
# NOTE: This includes unprocessed double-quoted strings.  If you might want to
# accept a template literal in the form of a CoffeeScript double-quoted string
# interpolation, be sure to check TemplateLiteral before StringLiteral.
StringLiteral
  DoubleQuote DoubleStringCharacters:str DoubleQuote ->
    return {
      type: "StringLiteral",
      token: `"${modifyString(str.token)}"`,
      $loc,
    }

  SingleQuote SingleStringCharacters:str SingleQuote ->
    return {
      type: "StringLiteral",
      token: `'${modifyString(str.token)}'`,
      $loc,
    }

DoubleStringCharacters
  /(?:\\.|[^"])*/ ->
    return { $loc, token: $0 }

SingleStringCharacters
  /(?:\\.|[^'])*/ ->
    return { $loc, token: $0 }

TripleDoubleStringCharacters
  /(?:"(?!"")|#(?!\{)|\\.|[^#"])+/ ->
    return { $loc, token: $0 }

TripleSingleStringCharacters
  /(?:'(?!'')|\\.|[^'])*/ ->
    return { $loc, token: $0 }

CoffeeStringSubstitution
  CoffeeSubstitutionStart AllowAll ( PostfixedExpression __ CloseBrace )? RestoreAll ->
    if (!$3) return $skip
    return [$1, ...$3]

CoffeeInterpolatedDoubleQuotedString
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringSubstitution )*:parts DoubleQuote:e ->
    return processCoffeeInterpolation(s, parts, e, $loc)

CoffeeDoubleQuotedStringCharacters
  /(?:\\.|#(?!\{)|[^"#])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#prod-RegularExpressionLiteral
RegularExpressionLiteral
  HeregexLiteral
  $("/" RegularExpressionBody "/" RegularExpressionFlags) ->
    return { type: "RegularExpressionLiteral", $loc, token: $1 }

RegularExpressionClass
  $(OpenBracket RegularExpressionClassCharacters CloseBracket) ->
    return { $loc, token: $1 }

RegularExpressionClassCharacters
  /(?:\\.|[^\]])*/ ->
    return { $loc, token: $0 }

HeregexLiteral
  TripleSlash:open HeregexBody:body TripleSlash:close RegularExpressionFlags:flags ->
    let hasSubstitutions = body.some((part) => part.type === "Substitution")

    if (hasSubstitutions) {
      const children = [
        {...open, token: "RegExp(`"},
        // Escape backticks, backslashes, and '$' in the body text
        body.map(e => e.type === "Substitution"
          ? e
          : {
            ...e,
            token: e.token.replace(/`|\\|\$/g, "\\$&"),
          }
        ),
        "`"
      ]

      if (flags.length) {
        children.push(
          ", ",
          JSON.stringify(flags)
        )
      }
      children.push( {...close, token: ")" })
      return {
        type: "RegularExpressionLiteral",
        children,
      }
    }

    return {
      type: "RegularExpressionLiteral",
      children: $0,
    }

HeregexBody
  !TripleSlash HeregexPart* -> $2

HeregexPart
  RegularExpressionClass

  CoffeeStringSubstitution -> { type: "Substitution", children: $1 }
  TemplateSubstitution -> { type: "Substitution", children: $1 }

  /(?:\\.)/ ->
    let token = $0
    switch ($0[1]) {
      case "\n": token = "\\n"; break
      case "\r": token = "\\r"; break
      case " ": token =   " "; break
    }
    return { $loc, token }

  HeregexComment ->
    return { $loc, token: "" }
  # NOTE: CoffeeScript strips out all unescaped whitespace chars
  # but Python doesn't strip out whitespace inside character classes
  # or inside '(?' groups and assertions
  # TODO: this behavior should be toggled by a coffeeCompat directive
  /[\s]+/ ->
    return { $loc, token: "" }
  # Escape forward slashes (that aren't part of a triple slash)
  /\/(?!\/\/)/ ->
    return { $loc, token: "\\/" }
  /[^[\/\s#\\]+/ ->
    return { $loc, token: $0 }

HeregexComment
  # NOTE: CoffeeScript doesn't treat JS comments as regex comments
  # TODO: this behavior should be toggled by a coffeeCompat directive
  JSSingleLineComment
  CoffeeSingleLineComment

# https://262.ecma-international.org/#prod-RegularExpressionBody
# NOTE: Simplified a little from the spec, ignoring <PS>, <LS>
RegularExpressionBody
  ![*\/\r\n] RegExpPart*

RegExpPart
  RegularExpressionClass
  RegExpCharacter

RegExpCharacter
  /(?:\\.|[^[\/\r\n])+/

# https://262.ecma-international.org/#prod-RegularExpressionFlags
RegularExpressionFlags
  /(?:\p{ID_Continue}|[\u200C\u200D$])*/

# https://262.ecma-international.org/#prod-TemplateLiteral
# NOTE: Simplified template grammar
TemplateLiteral
  # perf: assertion to exit early
  /(?=[`'"])/ _TemplateLiteral -> $2

_TemplateLiteral
  TripleTick ( TemplateBlockCharacters / TemplateSubstitution )* TripleTick ->
    return dedentBlockSubstitutions($0, module.config.tab)

  Backtick ( TemplateCharacters / TemplateSubstitution )* Backtick ->
    return {
      type: "TemplateLiteral",
      children: $0,
    }

  # NOTE: actual CoffeeScript """ string behaviors are pretty weird, this is simplified
  TripleDoubleQuote ( TripleDoubleStringCharacters / CoffeeStringSubstitution )* TripleDoubleQuote ->
    return dedentBlockSubstitutions($0, module.config.tab)

  # NOTE: ''' don't have interpolation so could be converted into a regular
  # String, but currently we use `template`s so the output looks similar to
  # the input.  Also, this enables tagged template literals such as tag'''x''',
  # which CoffeeScript also allows.
  TripleSingleQuote:s TripleSingleStringCharacters:str TripleSingleQuote:e ->
    return {
      type: "TemplateLiteral",
      children: [s, dedentBlockString(str, module.config.tab), e]
    }

  # CoffeeScript Interpolation is enabled when "civet coffee-compat" or "civet coffee-interpolation" directive is present
  CoffeeInterpolatedDoubleQuotedString

# NOTE: Simplified grammar
TemplateSubstitution
  SubstitutionStart AllowAll ( PostfixedExpression __ CloseBrace )? RestoreAll ->
    if (!$3) return $skip
    return [$1, ...$3]

# https://262.ecma-international.org/#prod-TemplateCharacter
TemplateCharacters
  /(?:\$(?!\{)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

TemplateBlockCharacters
  /(?:\$(?!\{)|`(?!``)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#sec-comments
ReservedWord
  /(?:on|off|yes|no)(?!\p{ID_Continue})/ CoffeeBooleansEnabled
  /(?:isnt)(?!\p{ID_Continue})/ CoffeeIsntEnabled
  /(?:by)(?!\p{ID_Continue})/ CoffeeForLoopsEnabled
  /(?:of)(?!\p{ID_Continue})/ CoffeeOfEnabled
  # NOTE: Added `let`, Civet assumes strict mode
  /(?:and|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|import|in|instanceof|interface|is|let|loop|new|not|null|or|private|protected|public|return|static|super|switch|this|throw|true|try|typeof|unless|until|var|void|while|with|yield)(?!\p{ID_Continue})/

# https://262.ecma-international.org/#sec-comments
Comment
  # perf: assertion to exit early
  /(?=\/|#)/ _Comment -> $2

_Comment
  MultiLineComment
  SingleLineComment

# https://262.ecma-international.org/#prod-SingleLineComment
# This is more accurately called "RestOfLineComment"
SingleLineComment
  JSSingleLineComment
  CoffeeCommentEnabled CoffeeSingleLineComment

JSSingleLineComment
  # JS Comments are two slashes not followed by a third (because that is a heregex)
  /\/\/(?!\/)[^\r\n]*/ ->
    return { type: "Comment", $loc, token: $0 }

# https://262.ecma-international.org/#prod-MultiLineComment
MultiLineComment
  JSMultiLineComment
  # NOTE: Added CoffeeScript style ### multiline comments
  CoffeeMultiLineComment

JSMultiLineComment
  $( "/*" (!"*/" . )* "*/" ) ->
    return { type: "Comment", $loc, token: $1 }

CoffeeSingleLineComment
  # NOTE: CoffeeScript style single line comments
  /#(?!##(?!#))([^\r\n]*)/ ->
    return { type: "Comment", $loc, token: `//${$1}` }

CoffeeMultiLineComment
  CoffeeHereCommentStart $/[^]*?###/ ->
    $2 = $2.slice(0, $2.length-3).replace(/\*\//g, "* /")
    return { type: "Comment", $loc, token: `/*${$2}*/` }

CoffeeHereCommentStart
  /###(?!#)/

# InlineComment is a multi-line comment with no line separators
InlineComment
  /\/\*(?:(?!\*\/)[^\r\n])*\*\// ->
    return { $loc, token: $0 }

RestOfLine
  ( NonNewlineWhitespace / Comment )* EOL

# Matches any whitespace optionally followed by a rest of line comment
# This will always succeed since each part is optional that's why it
# doesn't have `?` when used in other rules.
TrailingComment
  _? SingleLineComment?

# Non-newline "white space" (includes inline comments)
# TODO: Allow for inline Coffee comments when enabled
_
  # perf: assertion to exit early
  /(?=[ \t\/\\])/ ( NonNewlineWhitespace / InlineComment )+ -> $2

NonNewlineWhitespace
  [ \t]+ ->
    return { $loc, token: $0 }
  "\\" CoffeeLineContinuationEnabled EOL -> " "

# Whitespace / comments with a single leading space trimmed off if possible
Trimmed_
  _?:ws ->
    return insertTrimmingSpace(ws, "")

# Optional whitespace including newlines and comments
__
  # perf: assertion to skip checking
  /(?=\s|\/|#)/ ( Whitespace / Comment )* -> $2
  ""

Whitespace
  [\s]+ ->
    return { $loc, token: $0 }

# Fake a blocklike form for single expressions
ExpressionDelimiter
  _? Semicolon InsertComma TrailingComment ->
    // Replace semicolon with comma
    return [$1, $3, $4]
  &EOS InsertComma -> $2

SimpleStatementDelimiter
  &EOS
  SemicolonDelimiter

StatementDelimiter
  &EOS
  SemicolonDelimiter
  # Allow for closing a block within the same line as a nested statement
  &( _? ( "}" / ")" / "]" ) )

SemicolonDelimiter
  _? Semicolon TrailingComment ->
    return {
      type: "SemicolonDelimiter",
      children: $0
    }

NonIdContinue
  /(?!\p{ID_Continue})/

Loc
  "" ->
    return { $loc, token: "" }

## Tokens

Abstract
  $("abstract" NonIdContinue " "?) ->
    return { $loc, token: $1, ts: true }

Ampersand
  "&" ->
    return { $loc, token: $1 }

As
  "as" NonIdContinue ->
    return { $loc, token: $1 }

At
  "@" ->
    return { $loc, token: $1 }

# hack for experimentalDecorators
# Since `@` is premium real estate we use `@@` for decorators with all the shame that entails.
AtAt
  "@@" ->
    return { $loc, token: "@" }

Async
  "async" NonIdContinue ->
    return { $loc, token: $1, type: 'Async' }

Await
  "await" NonIdContinue ->
    return { $loc, token: $1, type: 'Await' }

Backtick
  "`" ->
    return { $loc, token: $1 }

By
  "by" NonIdContinue ->
    return { $loc, token: $1 }

Caret
  "^" ->
    return { $loc, token: $1 }

Case
  "case" NonIdContinue ->
    return { $loc, token: $1 }

Catch
  "catch" NonIdContinue ->
    return { $loc, token: $1 }

Class
  "class" NonIdContinue ->
    return { $loc, token: $1 }

CloseAngleBracket
  ">" ->
    return { $loc, token: $1 }

CloseBrace
  "}" ->
    return { $loc, token: $1 }

CloseBracket
  "]" ->
    return { $loc, token: $1 }

CloseParen
  ")" ->
    return { $loc, token: $1 }

CoffeeSubstitutionStart
  "#{" ->
    return { $loc, token: "${" }

Colon
  ":" !"=" ->
    return { $loc, token: $1 }

Comma
  "," ->
    return { $loc, token: $1 }

ConstructorShorthand
  "@" ->
    return { $loc, token: "constructor" }

Declare
  "declare" NonIdContinue ->
    return { $loc, token: $1 }

Default
  "default" NonIdContinue ->
    return { $loc, token: $1 }

Delete
  "delete" NonIdContinue ->
    return { $loc, token: $1 }

Do
  "do" NonIdContinue ->
    return { $loc, token: $1 }

Dot
  "." ->
    return { $loc, token: $1 }
  # English possessive
  /['’]s/ _:ws ->
    return [
      { $loc, token: "." },
      insertTrimmingSpace(ws, ""),
    ]

DotDot
  ".." !"." ->
    return { $loc, token: $1 }
  "‥" ->
    return { $loc, token: ".." }

DotDotDot
  "..." ->
    return { $loc, token: $1 }
  "…" ->
    return { $loc, token: "..." }

DoubleColon
  "::" ->
    return { $loc, token: $1 }

DoubleQuote
  "\"" ->
    return { $loc, token: $1 }

Each
  "each" NonIdContinue ->
    return { $loc, token: $1 }

Else
  "else" NonIdContinue ->
    return { $loc, token: $1 }

Equals
  "=" ->
    return { $loc, token: $1 }

ExclamationPoint
  "!" ->
    return { $loc, token: $1 }

Export
  "export" NonIdContinue ->
    return { $loc, token: $1 }

Extends
  "extends" NonIdContinue ->
    return { $loc, token: $1 }

Finally
  "finally" NonIdContinue ->
    return { $loc, token: $1 }

For
  "for" NonIdContinue ->
    return { $loc, token: $1 }

From
  "from" NonIdContinue ->
    return { $loc, token: $1 }

Function
  "function" NonIdContinue ->
    return { $loc, token: $1 }

GetOrSet
  ( "get" / "set" ) NonIdContinue ->
    return { $loc, token: $1, type: 'GetOrSet' }

Hash
  "#" ->
    return { $loc, token: $1 }

If
  # NOTE: Pull a single space into the 'if ' token so if it is replaced
  # with a ternary in expressions it doesn't add an extra space
  $("if" NonIdContinue " "?) ->
    return { $loc, token: $1 }

Import
  # NOTE: this is a hack so import.meta will parse correctly
  "import" &/\s/ ->
    return { $loc, token: $1 }

In
  "in" NonIdContinue ->
    return { $loc, token: $1 }

Infer
  "infer" NonIdContinue ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-LetOrConst
LetOrConst
  ( "let" / "const" ) NonIdContinue ->
    return { $loc, token: $1 }

Const
  "const" NonIdContinue ->
    return { $loc, token: $1 }

In
  "in" NonIdContinue ->
    return { $loc, token: $1 }

Is
  "is" NonIdContinue ->
    return { $loc, token: $1 }

LetOrConstOrVar
  LetOrConst
  Var

Loop
  # NOTE: loop becomes while
  "loop" NonIdContinue ->
    return { $loc, token: "while(true)" }

New
  "new" NonIdContinue ->
    return { $loc, token: $1 }

Not
  "not" NonIdContinue !( _? ":" ) ->
    return { $loc, token: "!" }

Of
  "of" NonIdContinue ->
    return { $loc, token: $1 }

OpenAngleBracket
  "<" ->
    return { $loc, token: $1 }

OpenBrace
  "{" ->
    return { $loc, token: $1 }

OpenBracket
  "[" ->
    return { $loc, token: $1 }

OpenParen
  "(" ->
    return { $loc, token: $1 }

Operator
  "operator" NonIdContinue ->
    return { $loc, token: $1 }

Own
  "own" NonIdContinue ->
    return { $loc, token: $1 }

Public
  "public" NonIdContinue ->
    return { $loc, token: $1 }

Private
  "private" NonIdContinue ->
    return { $loc, token: $1 }

Protected
  "protected" NonIdContinue ->
    return { $loc, token: $1 }

Pipe
  "||>" / "|▷" ->
    return { $loc, token: "||>" }

  "|>=" / "▷=" ->
    return { $loc, token: "|>=" }

  "|>" / "▷" ->
    return { $loc, token: "|>" }

QuestionMark
  "?" ->
    return { $loc, token: $1 }

Readonly
  "readonly" NonIdContinue ->
    return { $loc, token: $1, ts: true }

Return
  "return" NonIdContinue ->
    return { $loc, token: $1 }

Satisfies
  "satisfies" NonIdContinue ->
    return { $loc, token: $1 }

Semicolon
  ";" ->
    return { $loc, token: $1 }

SingleQuote
  "'" ->
    return { $loc, token: $1 }

Star
  "*" ->
    return { $loc, token: $1 }

Static
  "static" NonIdContinue ->
    return { $loc, token: $1 }
  # NOTE: In ClassElements @ is a shorthand for 'static'
  # NOTE: added negative assertion to prevent overlapping constructor shorthand and `@@` decorator syntax
  "@" !( "(" / "@" ) ->
    return { $loc, token: "static " }

SubstitutionStart
  "${" ->
    return { $loc, token: $1 }

Super
  "super" NonIdContinue ->
    return { $loc, token: $1 }

Switch
  "switch" NonIdContinue ->
    return { $loc, token: $1 }

Target
  "target" NonIdContinue ->
    return { $loc, token: $1 }

Then
  # TODO: comments/whitespace get lost here
  __ "then" NonIdContinue ->
    return { $loc, token: "" }

This
  "this" NonIdContinue ->
    return { $loc, token: $1 }

Throw
  "throw" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: These become a single backtick, to properly escape "s and newlines
# and in case there are interpolations
TripleDoubleQuote
  "\"\"\"" ->
    return { $loc, token: "`" }

# NOTE: These become a single backtick, to properly escape 's and newlines
TripleSingleQuote
  "'''" ->
    return { $loc, token: "`" }

# Used in Heregex
TripleSlash
  "///" ->
    return { $loc, token: '/' }

TripleTick
  "```" ->
    return { $loc, token: "`" }

Try
  "try" NonIdContinue ->
    return { $loc, token: $1 }

Typeof
  "typeof" NonIdContinue ->
    return { $loc, token: $1 }

Unless
  "unless" NonIdContinue ->
    return { $loc, token: $1, negated: true }

Until
  "until" NonIdContinue ->
    return { $loc, token: $1 }

Using
  "using" NonIdContinue ->
    return { $loc, token: $1 }

Var
  "var" NonIdContinue ->
    return { $loc, token: $1 }

Void
  "void" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: When maps to 'case'
When
  "when" NonIdContinue ->
    return { $loc, token: "case" }

While
  "while" NonIdContinue ->
    return { $loc, token: $1 }

Yield
  "yield" NonIdContinue ->
    return { $loc, token: $1, type: "Yield" }

## JSX

JSXImplicitFragment
  JSXTag ( Nested JSXTag )* ->
    const jsx = $2.length === 0 ? $1 : {
      type: "JSXFragment",
      children: [
        "<>\n",
        module.currentIndent.token,
        ...$0,
        "\n",
        module.currentIndent.token,
        "</>",
      ],
      jsxChildren: [$1].concat($2.map(([, tag]) => tag)),
    }
    const type = typeOfJSX(jsx, module.config, module.getRef)
    return type ? [
      { ts: true, children: ["("] },
      jsx,
      { ts: true, children: [" as any as ", type, ")"] }
    ] : jsx

JSXTag
  # perf: assertion to exit early
  /(?=[<])/ _JSXTag -> $2

_JSXTag
  JSXElement
  JSXFragment
  JSXComment

# https://facebook.github.io/jsx/#prod-JSXElement
JSXElement
  JSXSelfClosingElement
  # NOTE: In default JSX mode, JSX children must be properly indented,
  # and closing tags are optional (but still allowed).
  !CoffeeJSXEnabled PushJSXOpeningElement:open JSXMixedChildren?:children JSXOptionalClosingElement:close PopJSXStack ->
    if (!children) return $skip
    let parts
    $0 = $0.slice(1)
    if (close) {
      parts = $0
    } else if (children.jsxChildren.length) {
      parts = [
        ...$0,
        "\n", // InsertNewline
        module.currentIndent.token, // InsertIndent
        ["</", open[1], ">"],
      ]
    } else {
      parts = [open.slice(0, -1), " />"]
    }
    return { type: "JSXElement", children: parts, tag: open[1] }
  # NOTE: In CoffeeScript JSX mode, JSX children do not need to be properly
  # indented, but tags must be explicitly closed.
  CoffeeJSXEnabled JSXOpeningElement:open JSXChildren? Whitespace? JSXClosingElement:close ->
    $0 = $0.slice(1)
    // Check that tags match
    if (open[1] !== close[2]) return $skip
    return { type: "JSXElement", children: $0, tag: open[1] }

# https://facebook.github.io/jsx/#prod-JSXSelfClosingElement
JSXSelfClosingElement
  "<" JSXElementName TypeArguments? JSXAttributes? Whitespace? "/>" ->
    return { type: "JSXElement", children: $0, tag: $2 }

PushJSXOpeningElement
  JSXOpeningElement ->
    module.JSXTagStack.push($1[1])
    return $1

PopJSXStack
  "" ->
    module.JSXTagStack.pop()

# https://facebook.github.io/jsx/#prod-JSXOpeningElement
JSXOpeningElement
  "<" JSXElementName TypeArguments? JSXAttributes? Whitespace? ">"

JSXOptionalClosingElement
  Whitespace? JSXClosingElement:close ->
    if (module.currentJSXTag !== close[2]) return $skip
    return $0
  ""

# https://facebook.github.io/jsx/#prod-JSXClosingElement
JSXClosingElement
  "</" Whitespace? JSXElementName Whitespace? ">"

# https://facebook.github.io/jsx/#prod-JSXFragment
JSXFragment
  # NOTE: In default JSX mode, JSX children must be properly indented,
  # and closing tags are optional (but still allowed).
  !CoffeeJSXEnabled PushJSXOpeningFragment:open JSXMixedChildren?:children JSXOptionalClosingFragment:close PopJSXStack ->
    if (!children) return $skip
    $0 = $0.slice(1)
    const parts = close ? $0 :
      [
        ...$0,
        "\n", // InsertNewline
        module.currentIndent.token, // InsertIndent
        "</>",
      ]
    return { type: "JSXFragment", children: parts, jsxChildren: children.jsxChildren }
  # NOTE: In CoffeeScript JSX mode, JSX children do not need to be properly
  # indented, but tags must be explicitly closed.
  CoffeeJSXEnabled "<>" JSXChildren?:children Whitespace? JSXClosingFragment ->
    $0 = $0.slice(1)
    return {
      type: "JSXFragment",
      children: $0,
      jsxChildren: children ? children.jsxChildren : []
    }

PushJSXOpeningFragment
  "<>" ->
    module.JSXTagStack.push("")
    return $1

JSXOptionalClosingFragment
  Whitespace? JSXClosingFragment ->
    if (module.currentJSXTag !== "") return $skip
    return $0
  ""

JSXClosingFragment
  "</>"

# https://facebook.github.io/jsx/#prod-JSXElementName
JSXElementName
  # Implicit element name
  &( ( "#" / Dot ) JSXShorthandString ) ->
    return module.config.defaultElement
  # Merged in https://facebook.github.io/jsx/#prod-JSXNamespacedName
  # Merged in https://facebook.github.io/jsx/#prod-JSXMemberExpression
  $( JSXIdentifierName ( (Colon JSXIdentifierName) / ( Dot JSXIdentifierName )* ) )

# NOTE: Like IdentifierName but includes hyphens after start
# NOTE: Combined from recursive https://facebook.github.io/jsx/#prod-JSXIdentifier definition
JSXIdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$-])*/

# https://facebook.github.io/jsx/#prod-JSXAttributes
JSXAttributes
  ( Whitespace? JSXAttribute )* ->
    // Extract all .class shorthands into `classes` array
    const classes = []
    let attrs = $0.filter((pair) => {
      const [, attr] = pair
      if (attr.type === "JSXClass") {
        classes.push(attr.class)
        return false
      }
      return true
    })
    if (classes.length) {
      // Check for non-shorthand class or className attribute
      let className = module.config.react ? "className" : "class"
      attrs = attrs.filter((pair) => {
        const [, attr] = pair
        if ((attr[0][0] === "class" || attr[0][0] === "className") &&
            !attr[0][1]) {
          className = attr[0][0]
          classes.push(attr[1][attr[1].length-1])
          return false
        }
        return true
      })
      function isBraced(c) {
        return c[0] === "{" || c[0]?.token === "{"
      }
      function unbrace(c) {
        // Remove leading "{" and trailing "}" tokens
        return c.slice(1, -1)
      }
      function parseClass(c) {
        c = c.token || c
        if (c.startsWith("'")) {
          c = '"' +
            c.slice(1, -1)
            .replace(/\\*"/g, (m) => m.length % 2 == 0 ? m : "\\"+m) +
            '"'
        }
        return JSON.parse(c)
      }
      const strings = [], exprs = []
      classes.forEach((c) => {
        if (isBraced(c)) {
          exprs.push(unbrace(c))
          exprs.push(", ")
        } else {
          strings.push(parseClass(c))
        }
      })
      const stringPart = strings.filter(Boolean).join(" ")
      let classValue
      if (exprs.length) { // some expressions
        exprs.pop()  // remove trailing comma
        if (stringPart) { // some strings too
          exprs.unshift(JSON.stringify(stringPart), ", ")
        }
        if (exprs.length === 1) {
          // Single expression doesn't need array, filter, or join.
          let root = exprs[0]
          // Remove trailing whitespace, e.g. in JSXShorthandString rule
          while (root.length &&
                 isWhitespaceOrEmpty(root[root.length-1])) {
            root = root.slice(0, -1)
          }
          // Unwrap possibly resulting singleton arrays
          while (root?.length === 1) root = root[0]
          // processUnaryExpression wraps in {children: [...]}
          if (root?.children) root = root.children
          if (root?.[0]?.token === "`") {
            // Template literals work just as-is.
            classValue = ["{", ...exprs, "}"]
          } else {
            // Other expressions get `|| ""` to avoid e.g. `undefined` class.
            classValue = ["{(", ...exprs, ") || \"\"}"]
          }
        } else {
          // In general, wrap expressions in array and filter out falsy values,
          // to avoid accidental e.g. `undefined` classes.
          classValue = ["{[", ...exprs, "].filter(Boolean).join(\" \")}"]
        }
      } else { // strings only
        if (!stringPart.includes('&') && !stringPart.includes('"')) {
          classValue = `"${stringPart}"`
        } else if (!stringPart.includes('&') && !stringPart.includes("'")) {
          classValue = `'${stringPart}'`
        } else {
          classValue = `{${JSON.stringify(stringPart)}}`
        }
      }
      attrs.splice(0, 0, [" ", [className, ["=", classValue]]])
    }
    return attrs.map((pair) => {
      const [space, attr] = pair
      // Sometimes JSXAttribute adds a leading space to separate from previous.
      // Remove that space if there's already whitespace here.
      if (space && attr[0] === " ") {
        pair = [space, attr.slice(1)]
      }
      return pair
    })

# NOTE: Merged SpreadAttribute and Attribute
JSXAttribute
  # https://facebook.github.io/jsx/#prod-JSXSpreadAttribute
  # allows something like
  #   OpenBrace __ DotDotDot ExtendedExpression __ CloseBrace
  # (where ExtendedExpression additionally allows If/Switch expressions).
  # More generally, we allow any braced object literal:
  # {foo} is equivalent to foo={foo}, and
  # {foo, bar: baz} is equivalent to foo={foo} and bar={baz}.
  # {...foo} is a special case.
  BracedObjectLiteral ->
    return convertObjectToJSXAttributes($1)

  # https://facebook.github.io/jsx/#prod-JSXAttribute
  JSXAttributeName:name ( JSXAttributeInitializer / &JSXAttributeSpace ):value ->
    if (name.type === "ComputedPropertyName") {
      if (value) {
        // Strip off equals sign and whitespace from JSXAttributeInitializer
        value = value[value.length-1]
        // Strip off braces if present
        if (value[0]?.token === "{" &&
            value[value.length-1]?.token === "}") {
          value = value.slice(1, -1)
        }
      } else {
        // React and SolidJS define a bare attribute to mean setting it to true.
        // We need to specify a value here, so this seems a reasonable choice.
        value = "true"
      }
      return ["{...{", name, ": ", value, "}}"]
    } else {
      return $0
    }

  # NOTE: Adding ...foo shorthand for {...foo}
  InsertInlineOpenBrace DotDotDot InlineJSXAttributeValue InsertCloseBrace &JSXAttributeSpace

  # NOTE: @foo and @@foo shorthands
  # for foo={this.foo} and foo={this.foo.bind(this)}
  AtThis:at Identifier?:id InlineJSXCallExpressionRest*:rest &JSXAttributeSpace ->
    const access = id && {
      type: "PropertyAccess",
      children: [".", id],
      name: id,
    }
    const expr = processCallMemberExpression({
      type: "CallExpression",
      children: [ at, access, ...rest.flat() ],
    })
    const last = lastAccessInCallExpression(expr)
    if (!last) return $skip
    let name
    if (last.type === "Index") {
      return [
        "{...{",
        {...last, type: "ComputedPropertyName"},
        ": ", expr, "}}"
      ]
    } else if (last.name) {
      return [last.name, "={", expr, "}"]
    }
    return $skip

  # NOTE: foo(), foo.bar, foo?.bar, foo!, foo[bar], foo@bar don't need braces
  Identifier:id InlineJSXCallExpressionRest+:rest &JSXAttributeSpace ->
    const expr = processCallMemberExpression({
      type: "CallExpression",
      children: [ id, ...rest.flat() ],
    })
    if (expr.type === "ObjectExpression") {  // glob
      return convertObjectToJSXAttributes(expr)
    }
    const last = lastAccessInCallExpression(expr)
    if (!last) return $skip
    let name
    if (last.type === "Index") {
      return [
        "{...{",
        {...last, type: "ComputedPropertyName"},
        ": ", expr, "}}"
      ]
    } else if (last.name) {
      return [last.name, "={", expr, "}"]
    }
    return $skip

  # NOTE: #id shorthand
  "#" JSXShorthandString ->
    return [ " ", "id=", $2 ]
  Dot JSXShorthandString ->
    return {
      type: "JSXClass",
      class: $2,
    }

  # NOTE: Matching LiveScript flagging shorthand in addition +x -y !z -> x={true} y={false} z={false}
  $[!+-]:toggle JSXAttributeName:id &JSXAttributeSpace ->
    const value = toggle === "+" ? "true" : "false"
    return [ " ", id, "={", value, "}" ]

JSXAttributeSpace
  /[\s>]|\/>/

JSXShorthandString
  /(?:[\w\-:]+|\([^()]*\)|\[[^\[\]]*\])+/ ->
    return quoteString($0)
  TemplateLiteral ->
    return [ "{", $1, "}" ]
  # NOTE: TemplateLiteral must be before StringLiteral,
  # so that CoffeeScript interpolated strings get checked first.
  StringLiteral
  OpenBrace PostfixedExpression Whitespace? CloseBrace

# https://facebook.github.io/jsx/#prod-JSXAttributeName
JSXAttributeName
  # NOTE: Merged JSXIdentifier and JSXNamespacedName
  JSXIdentifierName ( Colon JSXIdentifierName )?
  ComputedPropertyName

# https://facebook.github.io/jsx/#prod-JSXAttributeInitializer
JSXAttributeInitializer
  Whitespace? Equals Whitespace? JSXAttributeValue

# https://facebook.github.io/jsx/#prod-JSXAttributeValue
JSXAttributeValue
  # https://facebook.github.io/jsx/#prod-JSXDoubleStringCharacters
  # https://facebook.github.io/jsx/#prod-JSXSingleStringCharacters
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  OpenBrace PostfixedExpression Whitespace? CloseBrace
  JSXElement
  JSXFragment
  InsertInlineOpenBrace:open InlineJSXAttributeValue:value InsertCloseBrace:close &JSXAttributeSpace ->
    // Check for string literal resulting from CoffeeScript interpolated
    // double-quoted string that didn't end up actually interpolating.
    if (value.type === "StringLiteral") {
      // Instead parse using the following string literal rule,
      // which avoids e.g. converting newlines into \n.
      return $skip
    }
    return [open, value, close]  // omit &JSXAttributeSpace
  # NOTE: InlineJSXAttributeValue which contains TemplateLiteral must be before
  # StringLiteral, so that CoffeeScript interpolated strings get checked first.
  # NOTE: JSX strings allow newlines, and they get passed through as-is.
  /"[^"]*"|'[^']*'/

# JSX shorthand to avoid explicit braces when unnecessary (no whitespace)
InlineJSXAttributeValue
  InlineJSXUnaryExpression InlineJSXBinaryOpRHS* ->
    if ($2.length) return processBinaryOpExpression($0)
    return $1

# BinaryOpRHS without whitespace and without ExpressionizedStatement,
# forbidding operators starting with < or > (possible JSX tags),
# and forbidding implicitly parenthesized assignments.
InlineJSXBinaryOpRHS
  ![<>] BinaryOp:op InlineJSXUnaryExpression:rhs ->
    // NOTE: Inserting empty whitespace arrays to be compatible with BinaryOpRHS and `processBinaryOpExpression`
    return [[], op, [], rhs]

# JSXUnaryExpression, with InlineJSX prefixes and no Do (which has whitespace)
InlineJSXUnaryExpression
  InlineJSXUnaryOp*:pre InlineJSXUpdateExpression:exp InlineJSXUnaryPostfix?:post ->
    return processUnaryExpression(pre, exp, post)

# UnaryOp, restricted to whitespace-free symbol operators
InlineJSXUnaryOp
  /[!~+-](?!\s|[!~+-]*&)/ ->
    return { $loc, token: $0 }

# UnaryPostfix, restricted to whitespace-free symbol operators
InlineJSXUnaryPostfix
  QuestionMark

# UpdateExpression, with LeftHandSideExpression -> InlineJSXCallExpression
InlineJSXUpdateExpression
  UpdateExpressionSymbol UnaryExpression
  InlineJSXCallExpression UpdateExpressionSymbol? ->
    if ($2) return $0
    return $1

# CallExpression, with only explicit function calls.
# This also acts as a replacement for LeftHandSideExpression
# (we don't allow New because that has whitespace).
InlineJSXCallExpression
  Super ExplicitArguments:args InlineJSXCallExpressionRest*:rest ->
    return processCallMemberExpression({
      type: "CallExpression",
      children: [
        $1,
        args,
        ...rest.flat()
      ],
    })
  "import" ExplicitArguments:args InlineJSXCallExpressionRest*:rest ->
    return processCallMemberExpression({
      type: "CallExpression",
      children: [
        $1,
        args,
        ...rest.flat()
      ],
    })
  InlineJSXMemberExpression:member InlineJSXCallExpressionRest*:rest ->
    if (rest.length) {
      rest = rest.flat()
      return processCallMemberExpression({
        type: "CallExpression",
        children: [member, ...rest]
      })
    }
    return member

# CallExpressionRest, with only explicit function calls.
InlineJSXCallExpressionRest
  InlineJSXMemberExpressionRest
  TemplateLiteral / StringLiteral ->
    if ($1.type === "StringLiteral") {
      return "`" + $1.token.slice(1, -1).replace(/(`|\$\{)/g, "\\$1") + "`"
    }
    return $1
  OptionalShorthand? ExplicitArguments:args ->
    if (!$1) return args
    return [ $1, args ]

# MemberExpression, with PrimaryExpression -> InlineJSXPrimaryExpression
InlineJSXMemberExpression
  ( InlineJSXPrimaryExpression / SuperProperty / MetaProperty ) InlineJSXMemberExpressionRest*:rest ->
    if (rest.length || Array.isArray($1)) {
      return processCallMemberExpression({
        type: "MemberExpression",
        children: [$1, ...rest].flat(),
      })
    }
    return $1

# MemberExpressionRest without optional IndentFurther before PropertyAccess
InlineJSXMemberExpressionRest
  OptionalShorthand?:dot InlineComment*:comments MemberBracketContent:content ->
    if (!dot && !comments.length) return content
    if (dot) {
      // Optional followed by a slice expression
      if (dot.type === "Optional" && content.type === "SliceExpression") {
        // Remove '.' from optional since it is present in '.slice'
        return [...dot.children.slice(0, -1), ...comments, content]
      }
      return [dot, ...comments, content]
    }
    return [...comments, content]
  PropertyAccess
  PropertyGlob
  PropertyBind
  NonNullAssertion

# Subset of PrimaryExpression; omissions documented below.
InlineJSXPrimaryExpression
  NullLiteral
  BooleanLiteral
  NumericLiteral
  TemplateLiteral
  # Omitting StringLiteral already matched in JSXAttributeValue
  ThisLiteral
  ArrayLiteral
  # Requiring braces on ObjectLiteral; this allows {a, b} even though `a, b` doesn't work as an inline object
  BracedObjectLiteral
  IdentifierReference
  # Omitting FunctionExpression and ClassExpression which have whitespace
  RegularExpressionLiteral
  ParenthesizedExpression
  # Omitting JSXElement and JSXFragment which don't need braces

JSXMixedChildren
  # NOTE: c1 matches "same-line" children, while c2 matches indented children
  # Used in indentation-based JSX
  JSXChild*:c1 JSXNestedChildren:c2 ->
    return {
      children: c1.concat(c2),
      jsxChildren: c1.concat(c2.jsxChildren),
    }

# https://facebook.github.io/jsx/#prod-JSXChildren
# JSX eats whitespace around newlines
JSXChildren
  ( ( NonNewlineWhitespace? EOL NonNewlineWhitespace? )* JSXChild )* ->
    return {
      children: $1,
      jsxChildren: $1.map(children => children[1]),
    }

JSXNestedChildren
  PushIndent ( JSXNested JSXChild+ )* PopIndent ->
    if ($2.length) {
      return {
        children: $2,
        jsxChildren: [].concat(...$2.map(nestedChildren => nestedChildren[1])),
      }
    }
    return $skip
  # NOTE: Empty JSXNestedChildren can be from newline or unmatched close brace
  # (e.g. when used in an attribute) or a following closing tag.
  &( JSXEOS / "}" / JSXClosingElement / JSXClosingFragment ) ->
    return { children: [], jsxChildren: [] }

# NOTE: Special variations of EOS and Nested that forbid end-of-line JS
# comments, as JS comments are not allowed in JSX (they get treated as text).
JSXEOS
  ( NonNewlineWhitespace? EOL )+

JSXNested
  JSXEOS:eos Indent:indent ->
    const { level } = indent
    const currentIndent = module.currentIndent
    if (level !== currentIndent.level) return $skip
    return $0

# https://facebook.github.io/jsx/#prod-JSXChild
JSXChild
  JSXElement
  JSXFragment
  # NOTE: Adding support for XML comments
  JSXComment
  OpenBrace IndentedJSXChildExpression:expression __ CloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  OpenBrace JSXChildExpression?:expression __ CloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  # NOTE: Adding support for arrow functions without wrapping braces
  InsertInlineOpenBrace ArrowFunction:expression InsertCloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  # NOTE: JSXText must come after attempt to match ArrowFunction
  JSXText

# XML comments: https://www.w3.org/TR/xml/#sec-comments
JSXComment
  "<!--" JSXCommentContent "-->" ->
    return [ "{/*", $2, "*/}" ]

JSXCommentContent
  /(?:-[^-]|[^-]*)*/ ->
    return { $loc, token: $0.replace(/\*\//g, "* /") }

# https://facebook.github.io/jsx/#prod-JSXText
JSXText
  # NOTE: not currently excluding https://facebook.github.io/jsx/#prod-HTMLCharacterReference
  # NOTE: additionally excluding newlines to leave the next indentation;
  # leading whitespace will actually be consumed by JSXChildren or
  # JSXNestedChildren (where it's used for indentation).
  [^{}<>\r\n]+ ->
    return {
      type: "JSXText",
      token: $0,
      $loc,
    }

# https://facebook.github.io/jsx/#prod-JSXChildExpression
JSXChildExpression
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  Whitespace? ( DotDotDot Whitespace? )? PostfixedExpression

IndentedJSXChildExpression
  PushIndent NestedJSXChildExpression? PopIndent ->
    if (!$2) return $skip
    return $2

NestedJSXChildExpression
  JSXNested JSXChildExpression

## Using Declaration

UsingDeclaration
  Using:decl _? UsingBinding:binding ( __ Comma __ UsingBinding )*:tail UsingJSModeError ->
    const bindings = [binding].concat(tail.map(([,,,b]) => b))

    return {
      type: "Declaration",
      children: $0,
      names: bindings.flatMap(b => b.names),
      bindings,
      decl,
      splices: bindings.flatMap(b => b.splices),
      thisAssignments: bindings.flatMap(b => b.thisAssignments),
    }

UsingBinding
  BindingIdentifier:pattern TypeSuffix?:suffix Initializer:initializer ->
    return {
      type: "Binding",
      children: $0,
      names: pattern.names,
      pattern,
      suffix,
      initializer,
      splices: [],
      thisAssignments: [],
    }

UsingJSModeError
  "" ->
    return {
      type: "Error",
      js: true,
      message: "`using` is not currently transpiled in JS mode."
    }

## Type Stuff

TypeDeclaration
  # NOTE: First check for forms with a `declare` keyword present
  ( Export _? )? ( Declare _? )  TypeLexicalDeclaration -> { ts: true, children: $0 }
  ( Export _? )?:export_ ( Declare _? )?:declare TypeDeclarationRest:t ->
    return {
      ...t,
      ts: true,
      export: export_,
      declare,
      children: [ export_, declare, ...t.children ]
    }

# NOTE: These are declarations even without a `declare` prefix
TypeDeclarationRest
  TypeAliasDeclaration
  InterfaceDeclaration
  NamespaceDeclaration
  FunctionSignature

TypeAliasDeclaration
  # TODO: ( __ Type ) can be refined further to check for consistently nested binary ops, etc.
  TypeKeyword _? IdentifierName:id TypeParameters? OptionalEquals ( MaybeIndentedType / ( __ Type ) ) ->
    return {
      type: "TypeDeclaration",
      id,
      children: $0,
      ts: true,
    }

  InsertType IdentifierName:id TypeParameters? __ TypeAssignment ( MaybeIndentedType / ( __ Type ) ) ->
    return {
      type: "TypeDeclaration",
      id,
      children: $0,
      ts: true,
    }

InterfaceDeclaration
  Interface _? IdentifierName:id TypeParameters? InterfaceExtendsClause? InterfaceBlock ->
    return {
      type: "InterfaceDeclaration",
      id,
      children: $0,
      ts: true,
    }

NamespaceDeclaration
  Namespace _? IdentifierName:id ModuleBlock ->
    return {
      type: "NamespaceDeclaration",
      id,
      children: $0,
      ts: true,
    }

OptionalEquals
  __ Equals
  &IndentedFurther InsertSpaceEquals -> $2

# NOTE: These are all guaranteed to be preceded by a `declare` keyword
TypeLexicalDeclaration
  __ LetOrConstOrVar TypeDeclarationBinding ( CommaDelimiter __ TypeDeclarationBinding )*
  __ EnumDeclaration
  ClassSignature
  Namespace _? IdentifierName DeclareBlock
  Module _ StringLiteral DeclareBlock?
  Global DeclareBlock?

TypeDeclarationBinding
  # NOTE: This is almost the same as LexicalBinding except it cannot have an initializer
  ( BindingPattern / BindingIdentifier ) TypeSuffix?

InterfaceExtendsClause
  ExtendsToken InterfaceExtendsTarget ( Comma InterfaceExtendsTarget )*

InterfaceExtendsTarget
  ImplementsTarget

TypeKeyword
  "type" NonIdContinue ->
    return { $loc, token: $1 }

Enum
  "enum" NonIdContinue ->
    return { $loc, token: $1 }

Interface
  "interface" NonIdContinue ->
    return { $loc, token: $1 }

Global
  "global" NonIdContinue ->
    return { $loc, token: $1 }

Module
  "module" NonIdContinue ->
    return { $loc, token: $1 }

Namespace
  "namespace" NonIdContinue ->
    return { $loc, token: $1 }


InterfaceBlock
  __ OpenBrace NestedInterfaceProperties __ CloseBrace
  __ OpenBrace ( __ InterfaceProperty )* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedInterfaceProperties InsertNewline InsertIndent InsertCloseBrace

NestedInterfaceProperties
  PushIndent NestedInterfaceProperty*:props PopIndent ->
    if (props.length) return props
    return $skip

NestedInterfaceProperty
  Nested InterfaceProperty

InterfaceProperty
  BasicInterfaceProperty
  NonEmptyParameters TypeSuffix InterfacePropertyDelimiter
  MethodSignature InterfacePropertyDelimiter

BasicInterfaceProperty
  ( TypeIndexSignature / TypeProperty ) _? TypeSuffix InterfacePropertyDelimiter

InterfacePropertyDelimiter
  _? ( Semicolon / Comma )
  &( __ CloseBrace )
  &EOS

# Namespace blocks are like self-contained modules
ModuleBlock
  __ OpenBrace NestedModuleItems __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedModuleItems InsertNewline InsertIndent InsertCloseBrace

NestedModuleItems
  PushIndent NestedModuleItem*:items PopIndent ->
    if (items.length) return items
    return $skip

# Based on TopLevelStatement
NestedModuleItem
  Nested ModuleItem StatementDelimiter

DeclareBlock
  __ OpenBrace NestedDeclareElements __ CloseBrace
  __ OpenBrace ( __ DeclareElement InterfacePropertyDelimiter)* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedDeclareElements InsertNewline InsertIndent InsertCloseBrace

NestedDeclareElements
  PushIndent NestedDeclareElement*:decs PopIndent ->
    if (decs.length) return decs
    return $skip

NestedDeclareElement
  Nested DeclareElement InterfacePropertyDelimiter

# NOTE: Variation on TypeDeclaration where Declare already applied.
DeclareElement
  Decorators? ( Export _? )? TypeLexicalDeclaration -> { ts: true, children: $0 }
  ( Export _? )? TypeDeclarationRest    -> { ts: true, children: $0 }

EnumDeclaration
  ( Const _ )?:isConst Enum _? IdentifierName:id EnumBlock:block ->
    const ts = {
      ts: true,
      children: $0,
    }
    // In TypeScript const enums do not generate any JavaScript code
    // but we don't yet do the same post-processing to completely
    // erase the enum from the output. So we just use a simpler
    // but less optimized output for raw js.
    // if (isConst) return ts
    // Generate JS output for enum similar to how TypeScript does
    const names = new Set(block.properties.map(p => p.name.name))
    return {
      type: "EnumDeclaration",
      id,
      children: [ts, {
        js: true,
        children: [
          ["let ", id, " = {};\n"],
          ...block.properties.map((property, i) => {
            let init, isString
            if (property.initializer) {
              // Replace references to other enum members.
              // TS further restricts this to past enum members,
              // but we don't need to enforce that here.
              init = replaceNodes(deepCopy(property.initializer),
                n => n.type === "Identifier" && names.has(n.name),
                n => [id, '["', n.name, '"]'])
              const value = init[init.length - 1]
              isString = value.type === "TemplateLiteral" ||
                (value.type === "Literal" && value.subtype === "StringLiteral")
            } else {
              // Default initializer is previous property + 1, or 0 if first.
              // TS further restricts this to when previous property is
              // constant, but we don't need to enforce that here.
              init = i === 0 ? " = 0" :
                [" = ", id, '["', block.properties[i-1].name, '"] + 1']
            }
            // String enums do not get back references
            if (isString) {
              return [
                id, '["', property.name, '"]', init, ";\n",
              ]
            } else {
              return [
                id, "[", id, '["', property.name, '"]', init,
                '] = "', property.name, '";\n',
              ]
            }
          }),
        ],
      }]
    }

EnumBlock
  __ OpenBrace NestedEnumProperties:props __ CloseBrace ->
    return {
      properties: props.properties,
      children: $0,
    }
  __ OpenBrace ( __ EnumProperty )*:props __ CloseBrace ->
    return {
      properties: props.map(p => p[1]),
      children: $0,
    }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedEnumProperties:props InsertNewline InsertIndent InsertCloseBrace ->
    return {
      properties: props.properties,
      children: $0,
    }

NestedEnumProperties
  PushIndent NestedEnumPropertyLine*:props PopIndent ->
    if (!props.length) return $skip
    return {
      properties: props.flat().map((p) => p.property),
      children: $0,
    }

NestedEnumPropertyLine
  ( Nested EnumProperty ) ( _? EnumProperty )* ->
    return [$1, ...$2].map(pair => ({
      property: pair[1],
      children: pair,
    }))

EnumProperty
  Identifier:name ( __ Equals ExtendedExpression )?:initializer ObjectPropertyDelimiter ->
    return {
      type: "EnumProperty",
      name,
      initializer,
      children: $0,
    }

TypeProperty
  ( Readonly NotDedented )? PropertyName

TypeIndexSignature
  # NOTE: QuestionMark will be parsed by following TypeSuffix
  ( [+-]? Readonly NotDedented )? OpenBracket TypeIndex CloseBracket ( __ [+-] &( _? QuestionMark ) )?

TypeIndex
  __ Identifier TypeSuffix
  __ PropertyName __ In Type ( __ As Type )?

# NOTE: TypeScript allows ? only in some circumstances (function parameters
# and class properties, but not let/const) and ! only in some circumstances
# (let/const and class properties, but not function parameters), and can't
# parse both (?!).  For simplicity, we allow either in all cases.
# In some cases (e.g. let/const), we transpile them away later.
TypeSuffix
  _? QuestionMark?:optional _? Colon MaybeIndentedType:t -> {
    type: "TypeSuffix",
    ts: true,
    optional,
    t,
    children: $0,
  }
  _? QuestionMark:optional _? -> {
    type: "TypeSuffix",
    ts: true,
    optional,
    children: $0,
  }
  # TypeScript has a special error for ! without : ("Declarations with definite
  # assignment assertions must also have type annotations.") but we parse it
  # so that the user can get this more useful error message.
  NonNullAssertion _? (Colon MaybeIndentedType)?:ct ->
    const [colon, t] = ct ?? []
    return {
      type: "TypeSuffix",
      ts: true,
      t,
      children: [ $1, $2, colon, t ],
    }

MaybeIndentedType
  # NOTE: Let InterfaceBlock take first crack at an indented block
  # But don't prevent parsing a braced type with unary suffix like {}[]
  !(__ OpenBrace) InterfaceBlock -> $2
  PushIndent ( Nested Type )? PopIndent ->
    if (!$2) return $skip
    return $2
  Type

ReturnTypeSuffix
  _? QuestionMark?:optional _? Colon ReturnType:t ->
    return {
      ...t,
      optional,
      children: [ $1, optional, $3, $4, ...t.children ]
    }

ReturnType
  ( __ "asserts" NonIdContinue )?:asserts TypePredicate:t ->
    if (asserts) {
      t = {
        type: "AssertsType",
        t,
        children: [asserts[0], asserts[1], t],
        ts: true,
      }
    }

    return {
      type: "ReturnTypeAnnotation",
      children: [t],
      t,
      ts: true,
    }

TypePredicate
  Type:lhs ( __ "is" NonIdContinue Type )?:rhs ->
    if (!rhs) return lhs
    return {
      type: "TypePredicate",
      lhs,
      rhs: rhs[3],
      children: [lhs, ...rhs],
    }

Type
  TypeConditional

TypeBinary
  ( __ TypeBinaryOp __ )?:optionalPrefix TypeUnary:t ( __ TypeBinaryOp __ TypeUnary )*:ops ->
    if (!ops.length && !optionalPrefix) return t
    if (!ops.length) return [optionalPrefix, t]
    if (!optionalPrefix) return [t, ...ops]
    return [optionalPrefix, t, ops]

TypeUnary
  ( __ TypeUnaryOp )*:prefix TypePrimary:t TypeUnarySuffix*:suffix ->
    if (!prefix.length && !suffix.length) return t
    return {
      type: "UnaryType",
      prefix,
      suffix,
      t,
      // omit empty prefix for trimming space
      children: prefix.length ? $0 : [t, suffix],
    }

TypeUnarySuffix
  TypeIndexedAccess
  QuestionMark

TypeUnaryOp
  "keyof" NonIdContinue
  "readonly" NonIdContinue

TypeIndexedAccess
  OpenBracket Type? __ CloseBracket
  # NOTE: Added shorthand T."string" -> T["string"] and T.0 -> T[0]
  Dot:dot ( TemplateLiteral / StringLiteral / IntegerLiteral ):literal ->
    const open = { ...dot, token: "[" }
    return [
      open,
      literal,
      "]"
    ]
  # NOTE: Extension of coffeePrototype syntax: T::x -> T["x"]
  CoffeePrototypeEnabled DoubleColon:p IdentifierName?:id ->
    const open = { ...p, token: '["' }
    return [
      open,
      id,
      '"]'
    ]

UnknownAlias
  "???" ->
    return { $loc, token: "unknown" }

TypePrimary
  # NOTE: https://github.com/microsoft/TypeScript/blob/ae27e55b027c66bf5b80f596da866f8485ac491d/src/compiler/parser.ts#L4724-L4745
  _? Infer _? IdentifierName ( NotDedented ExtendsToken Type )?
  # NOTE: typeof also parses as an identifier, so check for it early
  # NOTE: typeof takes a unary expression, as in
  # https://github.com/microsoft/TypeScript/blob/ae27e55b027c66bf5b80f596da866f8485ac491d/src/compiler/parser.ts#L5666-L5669
  # (binary expression can accidentally grab closing ">" of type arguments)
  _? Typeof _? UnaryExpression ->
    return {
      type: "TypeofType",
      children: $0,
    }
  _? TypeTuple ->
    return { ...$2, children: [ $1, ...$2.children ] }
  InterfaceBlock
  _? TypeFunction
  _? InlineInterfaceLiteral
  _? ImportType:t ->
    return {
      type: "ImportType",
      t,
      children: $0,
    }
  _? TypeLiteral:t ->
    return {
      type: "LiteralType",
      t,
      children: $0,
    }
  _? UnknownAlias ->
    return {
      type: "IdentifierType",
      children: $0,
      raw: $2.token,
      args: undefined
    }
  _? IdentifierName (Dot IdentifierName)* TypeArguments?:args ->
    return {
      type: "IdentifierType",
      children: $0,
      raw: [$2.name, ...$3.map(([dot, id]) => dot.token + id.name), ].join(''),
      args,
    }
  # NOTE: Check TypeFunction before parenthesized in order to distinguish between (a: T) => U and
  # A parenthesized inline interface (a: T) ---> ({a: T})
  # NOTE: Check Type before ( EOS Type ) to find implicit nested interfaces first. EOS would swallow the
  # newline so Nested wouldn't match otherwise.
  _? OpenParen ( Type / ( EOS Type ) ) __ CloseParen ->
    return {
      type: "ParenthesizedType",
      children: $0,
    }

ImportType
  "import" OpenParen __ StringLiteral __ CloseParen ( Dot IdentifierName )? TypeArguments?
  # NOTE: Added implicit import without parens
  "import" InsertOpenParen Trimmed_ StringLiteral InsertCloseParen

TypeTuple
  OpenBracket ( NestedTypeList / TypeList? ) __ CloseBracket ->
    return {
      type: "TypeTuple",
      children: $0,
    }

TypeList
  TypeElement (__ Comma TypeElement)*

TypeElement
  # NOTE: Allow for postfix splat like CoffeeScript
  # NOTE: Match named form first, to avoid matching `foo: bar,` as Type
  # and then DotDotDot from next entry.
  __:ws ( DotDotDot __ )?:dots1 IdentifierName:name ( _? DotDotDot )?:dots2 (__ (QuestionMark _?)? Colon __):colon Type:type ->
    let dots = dots1 || (dots2 && [dots2[1], dots2[0]] /* space at end */)
    if (dots1 && dots2) {
      dots = [dots, {
        type: "Error",
        message: "... both before and after identifier",
      }]
    }
    return [ ws, dots, name, colon, type ]
  __ DotDotDot __ Type:type
  Type:type ( _? DotDotDot )?:spaceDots ->
    if (!spaceDots) return type
    const [ space, dots ] = spaceDots
    const ws = getTrimmingSpace(type)
    if (!ws) return [ dots, space, type ]
    return [ ws, dots, space, insertTrimmingSpace(type, '') ]

NestedTypeList
  PushIndent NestedType*:types PopIndent ->
    if (types.length)
      return types
    return $skip

NestedType
  Nested TypeElement ArrayElementDelimiter

TypeConditional
  _? /(?=if|unless)/ TypeIfThenElse ->
    return [$1, expressionizeTypeIf($3)]
  TypeCondition NotDedented QuestionMark Type __ Colon Type ->
    if ($1.negated) return [ $1, $2, $3, $7, $5, $6, $4 ]
    return $0
  TypeBinary

TypeCondition
  TypeBinary IndentedFurther? ( ExtendsToken / NotExtendsToken ) Type ->
    return {
      type: "TypeCondition",
      negated: $3.negated,
      children: $0,
    }

TypeIfThenElse
  _? ( If / Unless ) ( OpenParen TypeCondition CloseParen ) TypeBlock TypeElse? ->
    return [ $1, $2, $3[1], $4, $5 ]  // unwrap parentheses
  _? ( If / Unless ) TypeCondition TypeBlock TypeElse?

TypeElse
  NotDedented Else TypeBlock

TypeBlock
  Then Type -> $2
  !EOS Type -> $2
  PushIndent (Nested Type)? PopIndent ->
    if (!$2) return $skip
    return $2

TypeTemplateSubstitution
  SubstitutionStart Type __ CloseBrace

TypeTemplateLiteral
  Backtick ( TemplateCharacters / TypeTemplateSubstitution )* Backtick ->
    return {
      type: "TemplateLiteral",
      children: $0,
    }
  CoffeeInterpolatedDoubleQuotedTypeLiteral

CoffeeStringTypeSubstitution
  CoffeeSubstitutionStart Type __ CloseBrace

CoffeeInterpolatedDoubleQuotedTypeLiteral
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringTypeSubstitution )*:parts DoubleQuote:e ->
    return processCoffeeInterpolation(s, parts, e, $loc)

TypeLiteral
  TypeTemplateLiteral
  # NOTE: TemplateLiteral must be before Literal, so that CoffeeScript
  # interpolated strings get checked first before StringLiteral.
  Literal
  "void" NonIdContinue ->
    return { type: "VoidType", $loc, token: $1 }
  "[]" ->
    return { $loc, token: "[]" }

InlineInterfaceLiteral
  InsertInlineOpenBrace InlineBasicInterfaceProperty ( ( IndentedFurther / _? ) InlineBasicInterfaceProperty )* InsertCloseBrace

InlineBasicInterfaceProperty
  # NOTE: Not using TypeSuffix here to require a Colon, and to forbid spaces
  # before the colon (to enable conditional types like prop ? T1 : T2).
  ( TypeIndexSignature / TypeProperty ) QuestionMark? Colon Type InlineInterfacePropertyDelimiter

InlineInterfacePropertyDelimiter
  ( _? Semicolon ) / CommaDelimiter
  &( ( IndentedFurther / _? ) InlineBasicInterfaceProperty ) InsertComma -> $2
  &( __  ( ":" / ")" / "]" / "}" ) )
  &EOS

TypeBinaryOp
  "|" ->
    return { $loc, token: "|" }
  "&" ->
    return { $loc, token: "&" }

TypeFunction
  ( ( Abstract _? )? New _? )? Parameters __ TypeArrowFunction ReturnType?:type ->
    if (type) {
      return $0
    }

    return [...$0, "void"]

TypeArrowFunction
  "=>" / "⇒" / "->" / "→" ->
    return { $loc, token: "=>" }

TypeArguments
  OpenAngleBracket TypeArgument+:args __ CloseAngleBracket ->
    return {
      type: 'TypeArguments',
      ts: true,
      types: args.map(([, t, ]) => t),
      children: $0
    }

TypeArgument
  __ Type TypeArgumentDelimiter

TypeArgumentDelimiter
  TypeParameterDelimiter

TypeParameters
  OpenAngleBracket TypeParameter+:parameters __ CloseAngleBracket ->
    return {
      type: "TypeParameters",
      parameters,
      ts: true,
      children: $0
    }

TypeParameter
  __ ( "const" _? )? Identifier TypeConstraint? TypeInitializer? TypeParameterDelimiter

TypeConstraint
  __ ExtendsToken Type

TypeInitializer
  __ "=" Type

TypeParameterDelimiter
  _? Comma
  &( __ ">" )
  &EOS InsertComma -> $2

# TypeScript's this: T syntax in function parameters
ThisType
  _? ( This / AtThis ) Colon Type ParameterElementDelimiter -> {
    type: "ThisType",
    ts: true,
    children: $0
  }

## Utility

Shebang
  /#![^\r\n]*/ EOL

CivetPrologue
  [\t ]* DoubleQuote CivetPrologueContent:content DoubleQuote SimpleStatementDelimiter [ \t]* ( EOL / &RestOfLine ) -> content
  [\t ]* SingleQuote CivetPrologueContent:content SingleQuote SimpleStatementDelimiter [ \t]* ( EOL / &RestOfLine ) -> content

CivetPrologueContent
  "civet" NonIdContinue CivetOption*:options [\s]* ->
    return {
      type: "CivetPrologue",
      children: [],
      config: Object.fromEntries(options),
    }

CivetOption
  /\s+([+-]?)([a-zA-Z0-9-]+)(\s*=\s*([a-zA-Z0-9.+-]*))?/ ->
    // Normalize option names to camelCase
    const optionName = $2.replace(/-+([a-z]?)/g, (_, l) => {
      if (l) return l.toUpperCase()
      return ""
    })
    // - is disabled, + is enabled, no prefix is enabled
    // =value sets the value to any value (used for `tab`)
    let value =
      $3 ? $4 : ($1 === "-") ? false : true
    // Some options are automatically converted to numbers
    if (optionName === "tab") {
      value = parseFloat(value)
      if (isNaN(value)) value = 0
    }

    return [optionName, value]

UnknownPrologue
  # NOTE: $ is to keep source verbatim and not insert a semicolon if one was omitted
  # Can't use $EOS because it will prevent re-writing of coffee style comments
  [\t ]* StringLiteral:s $SimpleStatementDelimiter EOS

TripleSlashDirective
  # https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html
  /\/\/\/[^\r\n]*/ EOS?

DirectivePrologue
  PrologueString !( __ ( AccessStart / Pipe ) ) -> $1

PrologueString
  CivetPrologue
  UnknownPrologue

EOS
  # perf: assertion to exit early
  /(?=[ \t\r\n\/#]|$)/ RestOfLine+ -> $2

# End of line, including EOF
EOL
  /\r\n|\n|\r|$/ ->
    return { $loc, token: $0 }

DebugHere
  "" ->
    debugger

# Insertions

InsertColon
  "" ->
    return { $loc, token: ":" }

InsertSemicolon
  "" ->
    return { $loc, token: ";" }

InsertOpenParen
  "" ->
    return { $loc, token: "(" }

InsertCloseParen
  "" ->
    return { $loc, token: ")" }

InsertOpenBrace
  # NOTE: Includes a preceding space
  "" ->
    return [{ $loc, token: " " }, { $loc, token: "{" } ]

InsertInlineOpenBrace
  "" ->
    return { $loc, token: "{" }

InsertCloseBrace
  "" ->
    return { $loc, token: "}" }

InsertOpenBracket
  "" ->
    return { $loc, token: "[" }

InsertCloseBracket
  "" ->
    return { $loc, token: "]" }

InsertComma
  "" ->
    return { $loc, token: "," }

InsertSpaceEquals
  "" ->
    return { $loc, token: " =" }

InsertConst
  # NOTE: Includes a trailing space
  "" ->
    return { $loc, token: "const " }

InsertLet
  "" ->
    return { $loc, token: "let " }

InsertReadonly
  # NOTE: Includes a trailing space
  "" ->
    return { ts: true, children: [ { $loc, token: "readonly " } ] }

InsertNewline
  "" ->
    return "\n"

InsertIndent
  "" ->
    return module.currentIndent.token

InsertSpace
  "" ->
    return { $loc, token: " " }

InsertDot
  "" ->
    return { $loc, token: "." }

InsertBreak
  "" ->
    return { $loc, token: ";break;" }

InsertVar
  "" ->
    return { $loc, token: "var " }

InsertType
  "" ->
    return { $loc, token: "type " }

CoffeeBinaryExistentialEnabled
  "" ->
    if(module.config.coffeeBinaryExistential) return
    return $skip

CoffeeBooleansEnabled
  "" ->
    if(module.config.coffeeBooleans) return
    return $skip

CoffeeClassesEnabled
  "" ->
    if(module.config.coffeeClasses) return
    return $skip

CoffeeCommentEnabled
  "" ->
    if(module.config.coffeeComment) return
    return $skip

CoffeeDoEnabled
  "" ->
    if(module.config.coffeeDo) return
    return $skip

CoffeeForLoopsEnabled
  "" ->
    if(module.config.coffeeForLoops) return
    return $skip

CoffeeInterpolationEnabled
  "" ->
    if(module.config.coffeeInterpolation) return
    return $skip

CoffeeIsntEnabled
  "" ->
    if(module.config.coffeeIsnt) return
    return $skip

CoffeeJSXEnabled
  "" ->
    if(module.config.coffeeJSX) return
    return $skip

CoffeeLineContinuationEnabled
  "" ->
    if(module.config.coffeeLineContinuation) return
    return $skip

CoffeeNotEnabled
  "" ->
    if(module.config.coffeeNot) return
    return $skip

CoffeeOfEnabled
  "" ->
    if(module.config.coffeeOf) return
    return $skip

CoffeePrototypeEnabled
  "" ->
    if(module.config.coffeePrototype) return
    return $skip

ObjectIsEnabled
  "" ->
    if(module.config.objectIs) return
    return $skip

# Reset module level data
Reset
  "" ->
    // Storage for PushIndent/PopIndent
    module.indentLevels = [{
      level: 0,
      token: "",
    }]

    module.forbidClassImplicitCall = [false]
    module.forbidIndentedApplication = [false]
    module.forbidBracedApplication = [false]
    module.forbidTrailingMemberProperty = [false]
    module.forbidNewlineBinaryOp = [false]
    module.JSXTagStack = [undefined]

    module.operators = new Map

    if (!module._init) {
      module._init = true
      Object.defineProperties(module, {
        currentIndent: {
          get() {
            const {indentLevels: l} = module
            return l[l.length-1]
          },
        },
        classImplicitCallForbidden: {
          get() {
            const {forbidClassImplicitCall: s} = module
            return s[s.length-1]
          },
        },
        indentedApplicationForbidden: {
          get() {
            const {forbidIndentedApplication: s} = module
            return s[s.length-1]
          },
        },
        bracedApplicationForbidden: {
          get() {
            const {forbidBracedApplication: s} = module
            return s[s.length-1]
          },
        },
        trailingMemberPropertyForbidden: {
          get() {
            const {forbidTrailingMemberProperty: s} = module
            return s[s.length-1]
          },
        },
        newlineBinaryOpForbidden: {
          get() {
            const {forbidNewlineBinaryOp: s} = module
            return s[s.length-1]
          },
        },
        currentJSXTag: {
          get() {
            const {JSXTagStack: s} = module
            return s[s.length-1]
          },
        },
      })
    }

    module.config = {
      autoConst: false,
      autoVar: false,
      autoLet: false,
      coffeeBinaryExistential: false,
      coffeeBooleans: false,
      coffeeClasses: false,
      coffeeComment: false,
      coffeeDo: false,
      coffeeEq: false,
      coffeeForLoops: false,
      coffeeInterpolation: false,
      coffeeIsnt: false,
      coffeeJSX: false,
      coffeeLineContinuation: false,
      coffeeNot: false,
      coffeeOf: false,
      coffeePrototype: false,
      defaultElement: "div",
      implicitReturns: true,
      objectIs: false,
      react: false,
      solid: false,
      client: false, // default behavior: client only
      rewriteTsImports: true,
      server: false,
      tab: undefined, // default behavior = same as space
      verbose: false,
    }

    const asAny = {
      ts: true,
      children: [" as any"]
    }
    module.prelude = []

    const preludeVar = "var "
    const declareRef = {
      indexOf(indexOfRef) {
        const typeSuffix = {
          ts: true,
          children: [": <T>(this: T[], searchElement: T) => number"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, indexOfRef, typeSuffix, " = [].indexOf", asAny, ";\n"]])
      },
      hasProp(hasPropRef) {
        const typeSuffix = {
          ts: true,
          children: [": <T>(object: T, prop: PropertyKey) => boolean"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, hasPropRef, typeSuffix, " = ({}.constructor", asAny, ").hasOwn;\n"]])
      },
      is(isRef) {
        // Thanks to @thetarnav for help with this TypeScript magic.
        // If the second argument is more general, narrow it.
        // Otherwise (including when the first argument is more general,
        // or partial overlap), always narrow the first argument,
        // as that's usually the one that matters.
        // Waiting on https://github.com/Microsoft/TypeScript/issues/26916
        // for proper narrowing of both arguments.
        const typeSuffix = {
          ts: true,
          children: [": { <B, A extends B> (a: A, b: B): b is A, <A, B> (a: A, b: B): a is A & B }"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, isRef, typeSuffix, " = Object.is", asAny, ";\n"]])
      },
      /**
       * Array length check with type guard.
       * From tlgreg https://discord.com/channels/933472021310996512/1012166187196629113/1157386582546976873
       */
      len(lenRef) {
        module.prelude.push(["", [{
          ts: true,
          children: [ "function ", lenRef, "<T extends readonly unknown[], N extends number>(arr: T, length: N): arr is T & { length: N } { return arr.length === length }" ]
        }, {
          js: true,
          children: [ "function ", lenRef, "(arr, length) { return arr.length === length }" ]
        }], "\n"])
      },
      modulo(moduloRef) {
        const typeSuffix = {
          ts: true,
          children: [": (a: number, b: number) => number"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, moduloRef, typeSuffix, " = (a, b) => (a % b + b) % b;", "\n"]])
      },
      Falsy(FalsyRef) {
        module.prelude.push(["", [{
          ts: true,
          children: ["type ", FalsyRef, " = false | 0 | '' | 0n | null | undefined;", "\n"]
        }]])
      },
      xor(xorRef) {
        const Falsy = module.getRef("Falsy")
        const typeSuffix = {
          ts: true,
          children: [
            ": <A, B>(a: A, b: B) => A extends ",
            Falsy,
            " ? B : B extends ",
            Falsy,
            " ? A : (false | (A & ",
            Falsy,
            " extends never ? never : B) | (B & ",
            Falsy,
            " extends never ? never : A))"
          ]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, xorRef, typeSuffix, " = (a, b) => (a ? !b && a : b)", asAny, ";", "\n"]])
      },
      xnor(xnorRef) {
        const Falsy = module.getRef("Falsy")
        const typeSuffix = {
          ts: true,
          children: [
            ": <A, B>(a: A, b: B) => A & ",
            Falsy,
            " extends never ? B : (true | (B extends ",
            Falsy,
            " ? never : A) | (A extends ",
            Falsy,
            " ? never : B))"
          ]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, xnorRef, typeSuffix, " = (a, b) => (a ? b : !b || a)", asAny, ";", "\n"]])
      },
      returnSymbol(ref) {
        module.prelude.push({
          children: [
            preludeVar, ref, " = Symbol(\"return\")';\n",
          ],
        })
      },
      concatAssign(ref) {
        const typeSuffix = {
          ts: true,
          children: [
            ": <B, A extends {push: (this: A, b: B) => void} | (B extends unknown[] ? {push: (this: A, ...b: B) => void} : never)>(lhs: A, rhs: B) => A",
          ]
        }
        module.prelude.push({
          children: [
            preludeVar, ref, typeSuffix,
            " = (lhs, rhs) => (((rhs", asAny, ")?.[Symbol.isConcatSpreadable] ?? Array.isArray(rhs)) ? (lhs", asAny, ").push.apply(lhs, rhs", asAny, ") : (lhs", asAny, ").push(rhs), lhs);\n"
          ]
        })
      },
      JSX(jsxRef) {
        module.prelude.push({
          ts: true,
          children: [
            "import type { JSX as ", jsxRef, " } from 'solid-js';\n",
          ],
        })
      },
      IntrinsicElements(intrinsicElementsRef) {
        // JSX.IntrinsicElements[TagName] gives HTMLAttributes<ElementType> or
        // SVGCoreAttributes<ElementType> or various subinterfaces of those.
        // All of them extend DOMAttributes<ElementType>, though.  See
        // https://raw.githubusercontent.com/ryansolid/dom-expressions/main/packages/dom-expressions/src/jsx.d.ts
        // Thanks to @thetarnav for the TypeScript magic to extract ElementType.
        // (TypeScript's HTMLElementTagNameMap and SVGElementTagNameMap are an
        // alternative, but don't necessary match Solid's IntrinsicElements.)
        const JSX = module.getRef("JSX")
        module.prelude.push({
          ts: true,
          children: [
            "type ", intrinsicElementsRef, "<K extends keyof ", JSX, ".IntrinsicElements> =\n",
            "  ", JSX, ".IntrinsicElements[K] extends ", JSX, ".DOMAttributes<infer T> ? T : unknown;\n",
          ],
        })
      },
    }
    const refs = {}

    module.getRef = function (base) {
      if (refs.hasOwnProperty(base)) return refs[base]
      const ref = makeRef(base)
      if (declareRef.hasOwnProperty(base)) declareRef[base](ref)
      return refs[base] = ref
    }

    Object.defineProperty(module.config, "deno", {
      set(b) {
        module.config.rewriteTsImports = !b
      }
    })
    // default to deno compatibility if running in deno
    module.config.deno = typeof Deno !== "undefined"

    // Expand setting coffeeCompat to the individual options
    Object.defineProperty(module.config, "coffeeCompat", {
      set(b) {
        for (const option of [
          "autoVar",
          "coffeeBinaryExistential",
          "coffeeBooleans",
          "coffeeClasses",
          "coffeeComment",
          "coffeeDo",
          "coffeeEq",
          "coffeeForLoops",
          "coffeeInterpolation",
          "coffeeIsnt",
          "coffeeJSX",
          "coffeeLineContinuation",
          "coffeeNot",
          "coffeeOf",
          "coffeePrototype",
        ]) {
          module.config[option] = b
        }
        if (b) {
          module.config.objectIs = false
        }
      }
    })

    // Hack to pass in parser config from main
    if (typeof parse !== "undefined") {
      Object.assign(module.config, parse.config)
      parse.config = module.config
    } else {
      Object.assign(module.config, exports.parse.config)
      exports.parse.config = module.config
    }

    // Hack to pass parser state to cache key
    return {
      type: "ParserMeta",
      children: [],
      getStateKey() {
        const stateInt =
          ((module.currentIndent.level % 256) << 8) |
          (module.classImplicitCallForbidden << 7) |
          (module.indentedApplicationForbidden << 6) |
          (module.bracedApplicationForbidden << 5) |
          (module.trailingMemberPropertyForbidden << 4) |
          (module.newlineBinaryOpForbidden << 3) |
          // This is slightly different than the rest of the state,
          // since it is affected by the directive prologue and may be hit
          // by the EOL rule early in the parse. Later if we wanted to
          // allow block scoping of the compat directives we would need to
          // add them all here.
          (module.config.coffeeComment << 2)

        return [stateInt, module.currentJSXTag]
      },
    }

Init
  Shebang? Prologue:directives ->
    directives.forEach((directive) => {
      if (directive.type === "CivetPrologue") {
        Object.assign(module.config, directive.config)
      }
    })

    return $0

Prologue
  ( TripleSlashDirective / ( ( JSSingleLineComment / JSMultiLineComment ) EOS ) / DirectivePrologue )*

# NOTE: Used by Playground to separate Prologue from rest of program
ProloguePrefix
  Prologue /[^]*/

# Indentation

# Holds the last indent level in `module.lastIndent`
# Can get weird with backtracking but should work out as long as
# EOS/Nested rules are used carefully and if we only compare to the
# pushed value.
Indent
  /[ \t]*/ ->
    const level = getIndentLevel($0, module.config.tab)

    return {
      $loc,
      token: $0,
      level
    }

# Used in PushIndent to keep track of the last indent level for nesting
TrackIndented
  Indent:indent ->
    const {level} = indent

    if (level <= module.currentIndent.level) {
      return $skip
    }
    if (module.config.verbose) {
      console.log("pushing indent", indent)
    }

    module.indentLevels.push(indent)
    return $1

# Indents one level deeper,
# without consuming the indentation so it can be by Nested
# Must be matched with PopIndent
PushIndent
  # TrackIndented pushes the indent level if it is deeper than the current level
  # it will skip if it is not deeper
  &( EOS TrackIndented )

PopIndent
  "" ->
    if (module.config.verbose) {
      console.log("popping indent", module.indentLevels[module.indentLevels.length-1], "->", module.indentLevels[module.indentLevels.length-2])
    }
    module.indentLevels./**/pop()

# "Nested" actually means "new line at current indentation level",
# where the current indentation level is set by TrackIndented / PushIndent
# (which require strictly more indentation than previous levels)
# Consumes and returns the newline and indentation
Nested
  EOS Indent:indent ->
    if (indent.level === module.currentIndent.level) return $0
    if (module.config.verbose) {
      console.log(`failing Nested: ${indent.level} does not match current indent level ${module.currentIndent.level}`)
    }
    return $skip

IndentedFurther
  EOS Indent:indent ->
    if (indent.level > module.currentIndent.level) return $0
    return $skip

IndentedAtLeast
  EOS Indent:indent ->
    if (indent.level >= module.currentIndent.level) return $0
    return $skip

NotDedented
  IndentedAtLeast? _? ->
    const ws = []
    if ($1) ws.push(...$1)
    if ($2) ws.push(...$2)
    return ws.flat(Infinity).filter(Boolean)

Dedented
  !IndentedAtLeast EOS -> $2
