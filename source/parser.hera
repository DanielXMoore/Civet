# Civet: A successor to CoffeeScript and alternative to TypeScript
# much more 1-to-1 with es6

# ECMA Reference
# https://262.ecma-international.org/13.0/

Program
  Reset Init __ TopLevelStatement*:statements __ ->
    module.processProgram(statements)

    return $0

TopLevelStatement
  EOS? ModuleItem StatementDelimiter

# Expressions with If and Switch
ExtendedExpression
  # Check for nested expressionized statements first
  &EOS PushIndent ( Nested ExpressionizedStatement )?:expression PopIndent ->
    if (expression) return expression
    return $skip
  __ ExpressionizedStatement ->
    return {...$2,
      children: [...$1, ...$2.children]
    }
  AssignmentExpression

ExpressionizedStatement
  DebuggerExpression
  IfExpression
  UnlessExpression
  IterationExpression
  SwitchExpression
  ThrowExpression

# https://262.ecma-international.org/#prod-Expression
Expression
  # CommaOperator
  # https://262.ecma-international.org/#sec-comma-operator
  # NOTE: Eliminated left recursion
  AssignmentExpression (__ Comma AssignmentExpression)* ->
    if($2.length == 0) return $1
    return $0

# https://262.ecma-international.org/#prod-Arguments
Arguments
  OpenParen ArgumentList? ( __ Comma )? __ CloseParen
  # NOTE: Added spacing based implicit function application
  # Trailing (__ MemberExpressionRest)* is to capture trailing .someMethod and bind them at the right place

  # Space / indentation based function application
  # Function application:
  # a b => a(b)
  # a b, c, d => a(b, c, d)
  # x y z => x(y(z))
  ApplicationStart InsertOpenParen:open _*:ws ArgumentList:args InsertCloseParen:close ->
    return [open, module.insertTrimmingSpace(ws, ""), args, close]

# Start of function application, inserts an open parenthesis, maintains spacing and comments when possible
ApplicationStart
  IndentedApplicationAllowed &NestedImplicitObjectLiteral
  !EOS &( _+ !AdditionalReservedWords )

IndentedApplicationAllowed
  "" ->
    if (module.suppressIndentedApplication) return $skip
    return

ArgumentsWithTrailingCallExpressions
  # Since this is recursive Arguments must consume input to avoid infinite recursion
  # NOTE: Do not allow trailing template literals to match
  Arguments ( Samedent !Backtick CallExpressionRest )*

# https://262.ecma-international.org/#prod-ArgumentList
ArgumentList
  ArgumentPart ( __ Comma ( NestedImplicitObjectLiteral / NestedArgumentList ) )+
  # NOTE: Added nested arguments on separate new lines
  NestedArgumentList
  InlineArgumentExpressions

NestedArgumentList
  PushIndent NestedArgument*:args PopIndent ->
    if (args.length) return args
    return $skip

NestedArgument
  Nested SingleLineArgumentExpressions ParameterElementDelimiter

InlineArgumentExpressions
  # NOTE: Eliminated left recursion
  TrailingComment* ArgumentPart ( __ Comma TrailingComment* ArgumentPart )* ->
    return [...$1, $2, ...$3]

SingleLineArgumentExpressions
  TrailingComment* ArgumentPart ( TrailingComment* Comma TrailingComment* ArgumentPart )*

ArgumentPart
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  # NOTE: Allow leading or trailing dots for argument splats like CoffeeScript
  DotDotDot ExtendedExpression
  ExtendedExpression DotDotDot? ->
    if ($2) {
      return [$2, $1]
    }
    return $1

BinaryOpExpression
  UnaryExpression BinaryOpRHS* ->
    if ($2.length) {
      return module.processBinaryOpExpression($0)
    }

    return $1

BinaryOpRHS
  __ BinaryOp __ ( ParenthesizedAssignment / UnaryExpression / ExpressionizedStatement )

ParenthesizedAssignment
  InsertOpenParen ActualAssignment InsertCloseParen

# https://262.ecma-international.org/#prod-UnaryExpression
UnaryExpression
  # NOTE: Merged AwaitExpression with UnaryOp
  # https://262.ecma-international.org/#prod-AwaitExpression
  # NOTE: Eliminated left recursion
  UnaryOp*:pre UpdateExpression:exp UnaryPostfix?:post ->
    // Handle "?" postfix
    if (post?.token === "?") {
      post = {
        $loc: post.$loc,
        token: " != null",
      }

      switch (exp.type) {
        case "Identifier":
        case "Literal":
          return {...exp,
            children: [...pre, ...exp.children, post]
          }
        default:
          return {
            type: "ParenthesizedExpression",
            children: ["(", ...pre, "(", exp, ")", post, ")"]
          }
      }
    }

    // Combine unary - to create negative numeric literals
    if (exp.type === "Literal") {
      if (pre.length === 1 && pre[0].token === "-") {
        const children = [pre[0], ...exp.children]
        if (post) exp.children./**/push(post)

        return {
          type: "Literal",
          children,
          raw: `-${exp.raw}`
        }
      }
    }

    if (exp.children) {
      const children = [...pre, ...exp.children]
      if (post) children./**/push(post)
      return Object.assign({}, exp, { children })
    } else if (Array.isArray(exp)) {
      const children = [...pre, ...exp]
      if (post) children./**/push(post)
      return { children }
    } else {
      const children = [...pre, exp]
      if (post) children./**/push(post)
      return { children }
    }

  # NOTE: This is a little hacky to match CoffeeScript's behavior
  # https://coffeescript.org/#try:do%20x%20%2B%20y%0Ado%20x%20%3D%20y%0Ado%20-%3E%20x%20%3D%201
  CoffeeDoEnabled Do __:ws ( ( LeftHandSideExpression !( __ AssignmentOpSymbol ) ) / ArrowFunction / ExtendedExpression ):exp ->
    ws = module.insertTrimmingSpace(ws, "")
    return ["(", ...ws, exp, ")()"]

UnaryPostfix
  QuestionMark
  ( __ As Type )+ -> { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-UpdateExpression
UpdateExpression
  # NOTE: Not allowing whitespace betwen prefix and postfix increment operators and operand
  UpdateExpressionSymbol UnaryExpression
  LeftHandSideExpression UpdateExpressionSymbol? ->
    if ($2) return $0
    return $1

UpdateExpressionSymbol
  ("++" / "--") ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-AssignmentExpression
AssignmentExpression
  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  TrailingComment*:ws AssignmentExpressionTail:tail ->
    if (ws.length) {
      // Glom whitespace into identifiers and literals to ease checking of "simple" refs
      // NOTE: This can get weird if we depend on the specific location of children
      if (tail.children && tail.type !== "IterationExpression") {
        return {
          ...tail,
          children: [...ws, ...tail.children]
        }
      }
      return $0
    }
    return tail

  __ AssignmentExpressionTail

AssignmentExpressionTail
  YieldExpression
  ArrowFunction
  ActualAssignment
  ConditionalExpression

# An assignment that actually includes an assignment operator, not just passing down to a ConditionalExpression
ActualAssignment
  # NOTE: Eliminated left recursion
  # NOTE: Consolidated assignment ops
  ( __ LeftHandSideExpression __ AssignmentOp )+ ExtendedExpression ->
    return {
      type: "AssignmentExpression",
      children: $0,
      // NOTE: This null marks the assignment for later processing to distinguish it
      // from fake assignments that only add a name to a scope
      names: null,
      lhs: $1,
      exp: $2,
    }

# https://262.ecma-international.org/#prod-YieldExpression
YieldExpression
  Yield YieldTail

YieldTail
  &EOS
  # NOTE: Merged optional star
  ( TrailingComment* Star )? AssignmentExpression

# https://262.ecma-international.org/#prod-ArrowFunction
ArrowFunction
  ( Async __ )? ArrowFunctionTail:tail ->
    return {
      ...tail,
      children: [...($1 || []), ...tail.children]
    }

ArrowFunctionTail
  ThinArrowFunction
  Parameters:parameters ReturnTypeSuffix?:suffix FatArrow FatArrowBody:expOrBlock ->
    return {
      type: "ArrowFunction",
      parameters,
      returnType: suffix?.children?.[1]?.[0]?.[1]?.token,
      ts: false,
      block: expOrBlock,
      children: $0,
    }

FatArrow
  # Ensures at least one space before arrow
  __:ws "=>" ->
    if (!ws.length)
      return " =>"
    return $0

# NOTE Different from
# https://262.ecma-international.org/#prod-ConciseBody
FatArrowBody
  ExplicitBlock
  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock
  AssignmentExpression
  EmptyBlock

# https://262.ecma-international.org/#prod-ConditionalExpression
ConditionalExpression
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  ShortCircuitExpression TernaryRest? ->
    if ($2) {
      return [$1, ...$2]
    }
    return $1

TernaryRest
  NestedTernaryRest
  # NOTE: Ternary `a ? b : c` is disabled if CoffeeScript binary existential `a ? b` is enabled
  !CoffeeBinaryExistentialEnabled &" " TrailingComment* QuestionMark ExtendedExpression __ Colon ExtendedExpression ->
    return $0.slice(2)

NestedTernaryRest
  PushIndent (Nested QuestionMark ExtendedExpression Nested Colon ExtendedExpression)? PopIndent ->
    if ($2) return $2
    return $skip

# https://262.ecma-international.org/#prod-ShortCircuitExpression
ShortCircuitExpression
  # NOTE: We don't need to track the precedence of all the binary operators so they all collapse into this
  BinaryOpExpression

# https://262.ecma-international.org/#prod-PrimaryExpression
PrimaryExpression
  ThisLiteral
  Literal
  ArrayLiteral
  ObjectLiteral
  IdentifierReference # NOTE: Must be below ObjectLiteral for inline objects `a: 1, b: 2` to not be shadowed by matching the first identifier
  FunctionExpression
  ClassExpression
  RegularExpressionLiteral
  TemplateLiteral
  ParenthesizedExpression
  # https://facebook.github.io/jsx/#sec-jsx-PrimaryExpression
  JSXElement
  JSXFragment

# https://262.ecma-international.org/#prod-ParenthesizedExpression
ParenthesizedExpression
  # NOTE: Currently ignoring early error checking in https://262.ecma-international.org/#prod-CoverParenthesizedExpressionAndArrowParameterList
  OpenParen ExtendedExpression:exp ( TrailingComment* PostfixStatement )?:post __ CloseParen ->
    if (post) {
      return module.attachPostfixStatementAsExpression(exp, post)
    }

    return {
      type: "ParenthesizedExpression",
      expression: exp,
      children: $0,
    }

# https://262.ecma-international.org/#prod-ClassDeclaration
ClassDeclaration
  # NOTE: skipping syntax directed operation for now
  ClassExpression

# https://262.ecma-international.org/#prod-ClassExpression
ClassExpression
  Decorators? Class ( BindingIdentifier )? ( __ ClassHeritage )? ClassBody

# https://262.ecma-international.org/#prod-ClassHeritage
ClassHeritage
  # ExtendsToken __ LeftHandSideExpression
  # NOTE: This is a subset of member expression that doesn't have spaced function application
  # TODO: there are some other LeftHandSideExpressions that are valid here but aren't yet supported (new, super, import expression)
  ExtendsToken __ MemberExpression

ExtendsToken
  # NOTE: Added "<" extends shorthand
  "<" ->
    return { $loc, token: "extends" }
  "extends" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-ClassBody
# NOTE: Nesting and indentation sensitive
ClassBody
  __ OpenBrace NestedClassElements? __ CloseBrace
  InsertOpenBrace NestedClassElements? InsertNewline InsertIndent InsertCloseBrace

NestedClassElements
  PushIndent NestedClassElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassElement
  Nested ClassElement StatementDelimiter

# https://262.ecma-international.org/#prod-ClassElement
ClassElement
  MethodDefinition
  # NOTE: Combined optional static and Method/Field definition
  ( Static TrailingComment* )? ( MethodDefinition / FieldDefinition )
  # ClassStaticBlock
  Static BracedBlock

# https://262.ecma-international.org/#prod-FieldDefinition
FieldDefinition
  # TODO: CoffeeCompat class method fields
  # name: (param1, param2) ->
  CoffeeClassesEnabled ClassElementName:id __ Colon __ AssignmentExpression:exp ->
    switch (exp.type) {
      // TODO: => functions
      case "FunctionExpression":
        return {
          ...exp,
          // Remove "function" token
          children: [id, ...exp.children.slice(1)]
        }
      default:
        return [id, " = ", exp]
    }

  # NOTE: Added readonly semantic equivalent of const field assignment
  # NOTE: Using ExtendedExpression to allow for If/SwitchExpressions
  InsertReadonly:r ClassElementName TypeSuffix? __ ConstAssignment:ca ExtendedExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    r.children[0].$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return $0

  ClassElementName TypeSuffix? Initializer?

ThisLiteral
  This
  # NOTE: Added @identifier shorthand, also works for private identifiers
  At:t $( "#"? IdentifierName ):id ->
    // Extract children from 'Identifier' node because this won't interfere with refs
    return [{...t, token: "this."}, id]
  # NOTE: Added '@' as a 'this' shorthand from CoffeeScript
  At ->
    $1.token = "this"
    return $1

# https://262.ecma-international.org/#prod-LeftHandSideExpression
LeftHandSideExpression
  # https://262.ecma-international.org/#prod-NewExpression
  # NOTE: Merged in NewExpression
  # NOTE: Changed to CallExpression to handle arguments
  # NOTE: Eliminated left recursion
  ( New !"." __ )* CallExpression ->
    if ($1.length) return $0
    return $2
  # NOTE: OptionalExpression is merged into CallExpression

# https://262.ecma-international.org/#prod-CallExpression
CallExpression
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  "super" ArgumentsWithTrailingCallExpressions
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  "import" __ OpenParen ExtendedExpression __ CloseParen
  MemberExpression CallExpressionRest* ->
    if ($2.length) return $0
    return $1

CallExpressionRest
  MemberExpressionRest
  TemplateLiteral
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  ( OptionalShorthand / NonNullAssertion )? ArgumentsWithTrailingCallExpressions

# NOTE: Added shorthand x?(3) -> x?.(3)
OptionalShorthand
  ( QuestionMark ( Dot / InsertDot ) )

NonNullAssertion
  "!" -> { ts: true, children: $1 }

# Reserved words that will prevent spaced function application
# ie: the 'of' in 'for x of ...'
AdditionalReservedWords
  /(for|of|then|when)(?!\p{ID_Continue}|[\u200C\u200D$])/
  AtAt # experimentalDecorators

# https://262.ecma-international.org/#prod-MemberExpression
MemberExpression
  # NOTE: "new" MemberExpression Arguments seems to be handled fine by other rules already
  # NOTE: Eliminated left recursion
  PrimaryExpression MemberExpressionRest* ->
    if ($2.length) return $0
    return $1
  SuperProperty
  MetaProperty

MemberExpressionRest
  # NOTE: Added shorthand x?[3] -> x?.[3]
  ( OptionalShorthand / NonNullAssertion )? MemberBracketContent ->
    if ($1) {
      // Optional followed by a slice expression
      if ($1.length === 2 && $2.type === "SliceExpression") {
        // Remove '.' from optional since it is present in '.slice'
        return [$1[0], $2]
      }
      return $0
    }
    return $2
  # NOTE: Combined Optional and Property access
  # TODO: this doesn't yet work for arbitrarily deep nesting, only the first level
  IndentedFurther? PropertyAccess ->
    if ($1) return Object.assign({}, $2, {
      children: [$1, ...$2.children]
    })
    return $2
  # NOTE: Added TypeScript '!' non-null assertion
  NonNullAssertion

# Handles indexing and slicing
MemberBracketContent
  OpenBracket:open ( SliceParameters / ExtendedExpression ):exp __:ws CloseBracket:close ->
    // Some kind of slice
    if (exp.type === "SliceParameters") {
      const {start, end, children} = exp

      return {
        type: "SliceExpression",
        start,
        end,
        children: [
          {...open, token: ".slice("},
          ...children,
          [...ws, {...close, token: ")"}],
        ]
      }
    }

    // Regular index `[exp]`
    return $0

SliceParameters
  ExtendedExpression:start __:ws ( DotDotDot / DotDot ):sep ExtendedExpression?:end ->
    const inclusive = sep.token === ".."

    let children
    if (end) {
      const inc = []
      if (inclusive) {
        end = ["1 + ", end]
        inc./**/push(" || 1/0")
      }
      children = [start, [...ws, {...sep, token: ", "}], [end, ...inc]]
    } else {
      children = [start, ws]
    }

    return {
      type: "SliceParameters",
      start,
      end,
      children,
    }

  Loc:l __:ws ( DotDotDot / DotDot ):sep ExtendedExpression:end ->
    const inclusive = sep.token === ".."

    const inc = []
    if (inclusive) {
      end = ["1 + ", end]
      inc./**/push(" || 1/0")
    }

    const start = {
      $loc: l.$loc,
      token: "0",
    }

    return {
      type: "SliceParameters",
      start,
      end,
      children: [start, [...ws, {...sep, token: ", "}], [end, ...inc]]
    }

PropertyAccess
  ( QuestionMark / NonNullAssertion )? Dot ( IdentifierName / PrivateIdentifier ):id ->
    const children = [$2, ...id.children]
    if ($1) children./**/unshift($1)

    return {
      type: "PropertyAccess",
      children,
    }

  # NOTE: Added CoffeeScript :: prototype shorthand
  DoubleColon:p IdentifierName?:id ->
    if (id) {
      p.token = ".prototype."
      return [p, id]
    }
    p.token = ".prototype"
    return p

SuperProperty
  "super[" ExtendedExpression __ CloseBracket

MetaProperty
  New Dot Target
  "import.meta" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-FormalParameters
# The parameters in a function definition
Parameters
  NonEmptyParameters
  "" ->
    return {
      type: "Parameters",
      children:[{$loc, token: "()"}],
      names: [],
    }

NonEmptyParameters
  # NOTE: BindingElement -> ParameterElement
  TypeParameters?:tp OpenParen:open ParameterElement*:pes FunctionRestParameter?:rest ParameterElement*:after ( __ CloseParen ):close ->
    const names = pes.flatMap(p => p.names)
    if (rest) {
      let restIdentifier
      if (rest.binding.ref) {
        restIdentifier = rest.binding.ref
      } else {
        names.push(...rest.names)
        restIdentifier = rest.names[0]
      }

      let blockPrefix
      if (after.length) {
        const spliceRef = module.getSpliceRef()

        blockPrefix = {
          children: ["[", module.insertTrimmingSpace(after, ""), "] = ", spliceRef, ".call(", restIdentifier, ", -", after.length.toString(), ")"],
          names: after.flatMap(p => p.names),
        }
      }

      return {
        type: "Parameters",
        children: [
          tp,
          open,
          ...pes,
          // Remove delimiter
          {...rest, children: rest.children.slice(0, -1)},
          close,
        ],
        names,
        blockPrefix,
      }
    }

    return {
      type: "Parameters",
      children: [tp, open, ...pes, close],
      names: pes.flatMap((p) => p.names),
    }

# https://262.ecma-international.org/#prod-FunctionRestParameter
FunctionRestParameter
  BindingRestElement:id TypeSuffix? ParameterElementDelimiter ->
    return {
      type: "FunctionRestParameter",
      children: $0,
      names: id.names,
      binding: id,
    }

# NOTE: Similar to BindingElement but appears in formal parameters list
ParameterElement
  # NOTE: Merged in SingleNameBinding
  ( BindingIdentifier / BindingPattern ) TypeSuffix? Initializer? ParameterElementDelimiter ->
    return {
      type: "Parameter",
      children: $0,
      names: $1.names,
    }

ParameterElementDelimiter
  _* Comma
  &( __ ")" )
  &EOS ->
    return { $loc, token: "," }

# https://262.ecma-international.org/#prod-BindingIdentifier
BindingIdentifier
  # NOTE: Added @param for binding identifiers
  # The parser will allow them in const/let/var declarations but JS/TS doesn't allow them there
  __:ws At AtIdentifierRef:ref ->
    return {
      type: "AtBinding",
      children: [...ws, ref],
      ref,
    }

  __:ws Identifier:id ->
    return {
      ...id,
      children: [...ws, ...id.children],
    }

AtIdentifierRef
  ReservedWord:r ->
    return {
      type: "Ref",
      base: `_${r}`,
      id: r,
    }
  IdentifierName:id ->
    return {
      type: "Ref",
      base: id.name,
      id: id.name,
    }

# https://262.ecma-international.org/#prod-BindingPattern
BindingPattern
  __ ObjectBindingPattern:p ->
    return {
      children: [...$1, p],
      names: p.names,
    }
  __ ArrayBindingPattern:p ->
    return {
      children: [...$1, p.children],
      names: p.names,
    }

# https://262.ecma-international.org/#prod-ObjectBindingPattern
# NOTE: Simplified from spec
ObjectBindingPattern
  OpenBrace ObjectBindingPatternContent:c __ CloseBrace ->
    return {
      type: "ObjectBindingPattern",
      children: [$1, ...c.children, ...$3, $4],
      names: c.names,
    }

ObjectBindingPatternContent
  # NOTE: Added indentation based binding properties
  NestedBindingProperties
  BindingProperty*:props BindingRestProperty?:rest BindingProperty*:after ->
    const names = props.flatMap(p => p.names)
    const children = [...props]

    if (rest) {
      [rest, after] = module.reorderBindingRestProperty(rest, after)
      children./**/push(...after, rest)
      names./**/push(...after.flatMap(p => p.names), ...rest.names)
    }

    return {
      names,
      children,
    }

# https://262.ecma-international.org/#prod-ArrayBindingPattern
# NOTE: Simplified from spec
ArrayBindingPattern
  OpenBracket ArrayBindingPatternContent:c __ CloseBracket ->
    return {
      type: "ArrayBindingPattern",
      names: c.names,
      children: $0
    }

ArrayBindingPatternContent
  # NOTE: Added indentation based binding elements
  NestedBindingElements
  ( BindingElement / Elision )*:props ( BindingRestElement ArrayElementDelimiter )?:rest ( BindingElement / Elision )*:after ->
    const names = props.flatMap((p) => p.names || [])
    const children = [...props]

    let blockPrefix

    if (rest) {
      const [ restBinding ] = rest
      // Drop delimiter
      children./**/push(restBinding)

      let restIdentifier
      if (restBinding.ref) {
        restIdentifier = restBinding.ref
      } else {
        restIdentifier = restBinding.names[0]
        names./**/push(...restBinding.names)
      }

      if (after.length) {
        const spliceRef = module.getSpliceRef()

        blockPrefix = {
          children: ["[", module.insertTrimmingSpace(after, ""), "] = ", spliceRef, ".call(", restIdentifier, ", -", after.length.toString(), ")"],
          names: after.flatMap(p => p.names),
        }
      }
    }

    return {
      names,
      children,
      blockPrefix,
    }

# https://262.ecma-international.org/#prod-Elision
Elision
  # NOTE: The repetition is handled from outside rather than using left recursion here
  __ Comma

NestedBindingProperties
  # NOTE: Add NestedBindingProperties after rest from CoffeeScript
  PushIndent NestedBindingProperty*:props NestedBindingRestProperty?:rest NestedBindingProperty*:after PopIndent ->
    if (!(props.length || rest)) return $skip
    const names = props.flatMap(p => p.names)
    const children = [...props]
    if (rest) {
      [rest, after] = module.reorderBindingRestProperty(rest, after)
      children./**/push(...after, rest)
      names./**/push(...after.flatMap(p => p.names), ...rest.names)
    }
    return {
      children,
      names,
    }

NestedBindingProperty
  Nested:indent BindingProperty:prop ->
    return {
      ...prop,
      children: [...indent, ...prop.children],
    }

# https://262.ecma-international.org/#prod-BindingProperty
BindingProperty
  __ PropertyName __ Colon ( BindingIdentifier / BindingPattern ):b Initializer? ObjectPropertyDelimiter ->
    return {
      names: b.names,
      children: $0
    }
  BindingIdentifier:b Initializer? ObjectPropertyDelimiter ->
    if (b.type === "AtBinding") {
      return {
        type: "AtBindingProperty",
        ref: b.ref,
        names: [],
        children: $0
      }
    }

    return {
      names: b.names,
      children: $0
    }

NestedBindingRestProperty
  Nested:indent BindingRestProperty:prop ->
    return {
      ...prop,
      children: [indent, ...prop.children],
    }

# https://262.ecma-international.org/#prod-BindingRestProperty
BindingRestProperty
  __:ws DotDotDot:dots BindingIdentifier:id ObjectPropertyDelimiter:delimiter ->
    return {
      ...id,
      children: [...ws, dots, ...id.children, delimiter],
    }
  __:ws BindingIdentifier:id DotDotDot:dots ObjectPropertyDelimiter:delimiter ->
    return {
      ...id,
      children: [...ws, dots, ...id.children, delimiter],
    }

NestedBindingElements
  PushIndent NestedBindingElement*:props ( Nested BindingRestElement ArrayElementDelimiter )?:rest NestedBindingElement*:after PopIndent ->
    if (!(props.length || rest)) return $skip
    const names = props.flatMap(p => p.names),
      children = [...props]

    let blockPrefix

    if (rest) {
      const [ , restBinding ] = rest
      let restIdentifier
      if (restBinding.ref) {
        restIdentifier = restBinding.binding.ref
      } else {
        restIdentifier = restBinding.names[0]
      }

      if (after.length) {
        const spliceRef = module.getSpliceRef()

        blockPrefix = {
          children: ["[", module.insertTrimmingSpace(after, ""), "] = ", spliceRef, ".call(", restIdentifier, ", -", after.length.toString(), ")"],
          names: after.flatMap(p => p.names),
        }
      }

      children./**/push(...rest)
      names./**/push(...restBinding.names)
    }

    return {
      children,
      names,
      blockPrefix,
    }

NestedBindingElement
  Nested:indent BindingElement:element ->
    return {
      ...element,
      children: [indent, ...element.children],
    }

# https://262.ecma-international.org/#prod-BindingElement
BindingElement
  # NOTE: Merged in SingleNameBinding
  ( BindingIdentifier / BindingPattern ):binding Initializer? ArrayElementDelimiter ->
    return {
      names: binding.names,
      children: $0
    }

# https://262.ecma-international.org/#prod-BindingRestElement
BindingRestElement
  __:ws DotDotDot:dots ( BindingIdentifier / BindingPattern / EmptyBindingPattern ):binding ->
    return {
      ...binding,
      children: [...ws, dots, ...binding.children],
    }
  __:ws ( BindingIdentifier / BindingPattern ):binding DotDotDot:dots ->
    return {
      ...binding,
      children: [...ws, dots, ...binding.children],
    }

# NOTE: Allows for empty binding rest pattern like in CoffeeScript
EmptyBindingPattern
  "" ->
    const ref = {
      type: "Ref",
      base: "ref",
      id: "ref"
    }
    return {
      type: "EmptyBinding",
      children: [ref],
      names: [],
      ref,
    }

# https://262.ecma-international.org/#prod-FunctionDeclaration
FunctionDeclaration
  FunctionExpression

FunctionSignature
  # NOTE: Merged in async and generator with optionals
  ( Async __ )? Function Star? BindingIdentifier?:id __ NonEmptyParameters:parameters ReturnTypeSuffix?:suffix ->
    return {
      type: "FunctionSignature",
      id,
      parameters,
      returnType: suffix?.children?.[1]?.[0]?.[1]?.token,
      ts: false,
      block: null,
      children: $0,
    }

# https://262.ecma-international.org/#prod-FunctionExpression
FunctionExpression
  # NOTE: block isn't actually optional in FunctionExpression only in declarations/TS overloads
  FunctionSignature:signature BracedBlock?:block ->
    // TS Function overloads
    if (!block) {
      signature.ts = true
      return signature
    }

    // Attach the block
    return {
      ...signature,
      type: "FunctionExpression",
      children: [...signature.children, block],
      block,
    }

  # Ruby/Crystal style block shorthand
  Ampersand !_ CallExpressionRest+ ->
    $1.token = "$ => $"
    return {
      type: "ArrowFunction",
      children: [$1, $3],
    }

  # Binary ops
  Ampersand ![&] BinaryOpRHS+ ->
    $1.token = "$ => $"
    const exp = module.processBinaryOpExpression([$1, $3])

    return {
      type: "ArrowFunction",
      children: exp,
    }

  # Unary ops
  [!~+-]+ Ampersand ->
    return {
      type: "ArrowFunction",
      children: ["$ => ", $1, "$"],
    }

ThinArrowFunction
  Parameters:parameters ReturnTypeSuffix?:suffix _* Arrow:arrow BracedOrEmptyBlock:block ->
    return {
      type: "FunctionExpression",
      id: undefined,
      parameters,
      returnType: suffix?.children?.[1]?.[0]?.[1]?.token,
      ts: false,
      block: block,
      children: [
        { $loc: arrow.$loc, token: "function" },
        parameters,
        suffix,
        block
      ],
    }

Arrow
  "->" ->
    return { $loc, token: $1}

ExplicitBlock
  __ OpenBrace NestedBlockStatements:block __ CloseBrace ->
    return Object.assign({}, block, {
      children: [$1, $2, ...block.children, $4, $5],
      bare: false,
    })

ImplicitNestedBlock
  InsertOpenBrace NestedBlockStatements:block InsertNewline InsertIndent InsertCloseBrace ->
    return Object.assign({}, block, {
      children: [$1, ...block.children, $3, $4, $5],
      bare: false,
    })

# NOTE: This is the body of if/else/for/case etc.
Block
  ExplicitBlock
  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock

  ThenClause
  TrailingComment*:ws Statement:s ->
    const expressions = [$0]
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }

ThenClause
  Then TrailingComment*:ws Statement:s  ->
    const expressions = [[ws, s]]
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }

BracedOrEmptyBlock
  BracedBlock
  EmptyBlock

EmptyBlock
  # Implied empty block
  InsertOpenBrace InsertCloseBrace ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [$1, expressions, $2],
      bare: false,
    }

# This is a block that must include braces (function body, try/catch/finally)
BracedBlock
  TrailingComment* OpenBrace BracedContent:block __ CloseBrace ->
    return {
      type: "BlockStatement",
      expressions: block.expressions,
      children: [$1, $2, ...block.children, $4, $5],
      bare: false,
    }
    return block

  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock

  # Immediate nested object literal
  InsertOpenBrace &EOS ObjectLiteral:s InsertCloseBrace ->
    return {
      type: "BlockStatement",
      expressions: [s],
      // Remove &EOS assertion
      children: [$1, s, $3],
    }

  # One liner
  InsertOpenBrace:o !EOS SingleLineStatements:s InsertSpace:ws InsertCloseBrace:c ->
    return {
      type: "BlockStatement",
      expressions: s,
      // Remove !EOS assertion
      children: [o, s, ws, c],
    }

SingleLineStatements
  ( TrailingComment* Statement ):first ( ( TrailingComment* Semicolon TrailingComment* ) Statement )*:rest ->
    if (rest.length) {
      return [first, ...rest]
    }
    return [first]

BracedContent
  NestedBlockStatements
  TrailingComment* Statement ->
    const expressions = [["", $2]]
    return {
      type: "BlockStatement",
      expressions,
      children: [$1, expressions],
      bare: true,
    }

NestedBlockStatements
  PushIndent NestedBlockStatement*:statements PopIndent ->
    if (!statements.length) return $skip

    const first = statements[0]
    // separate EOS from indent
    const ws = first[0]
    const [indent] = ws.slice(-1)
    first[0] = indent

    return {
      type: "BlockStatement",
      expressions: statements,
      children: [ws.slice(0, -1), statements],
      bare: true,
    }

NestedBlockStatement
  Nested StatementListItem StatementDelimiter

# https://262.ecma-international.org/#prod-Literal
Literal
  LiteralContent ->
    return {
      type: "Literal",
      children: $0,
      raw: $1.token,
    }

LiteralContent
  NullLiteral
  BooleanLiteral
  NumericLiteral
  StringLiteral

# https://262.ecma-international.org/#prod-NullLiteral
NullLiteral
  "null" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-BooleanLiteral
BooleanLiteral
  CoffeeBooleansEnabled CoffeeScriptBooleanLiteral -> $2
  ( "true" / "false" ) NonIdContinue ->
    return { $loc, token: $1 }

CoffeeScriptBooleanLiteral
  ( "yes" / "on" ) NonIdContinue ->
    return { $loc, token: "true" }
  ( "no" / "off" ) NonIdContinue ->
    return { $loc, token: "false" }

Comma
  _* Comma _*

# https://262.ecma-international.org/#prod-Identifier
Identifier
  !ReservedWord IdentifierName -> $2

# https://262.ecma-international.org/#prod-IdentifierName
IdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$])*/ ->
    return {
      type: "Identifier",
      name: $0,
      names: [$0],
      children: [{
        $loc: $loc,
        token: $0,
      }],
    }

# https://262.ecma-international.org/#prod-IdentifierReference
IdentifierReference
  Identifier

UpcomingAssignment
  &( __ "=" !( "=" / ">" ) )

# https://262.ecma-international.org/#prod-ArrayLiteral
ArrayLiteral
  # NOTE: Check ArrayBindingPattern case of lhs destructuring
  ArrayBindingPattern UpcomingAssignment -> $1
  OpenBracket ArrayLiteralContent:content __:ws CloseBracket ->
    if (content.type === "RangeExpression") {
      return {...content,
        children: [...content.children, ...ws],
      }
    }

    let children
    if (Array.isArray(content)) {
      children = [$1, ...content, ...ws, $4]
    } else {
      children = [$1, content, ...ws, $4]
    }

    // Gather names when ArrayLiteral is used as a destructuring pattern
    const names = children.flatMap((c) => {
      return c.names || []
    })

    return {
      type: "ArrayExpression",
      children,
      names,
    }

RangeExpression
  ExtendedExpression:s __:ws ( DotDotDot / DotDot ):range ExtendedExpression:e ->
    const inclusive = range.token === ".."
    range.token = ","

    if (s.type === "Literal" && e.type === "Literal") {
      let start, end
      if (s.raw[0] === "'") {
        start = s.raw.match(/^'(.*)'$/)[1]
      } else {
        start = JSON.parse(s.raw)
      }
      if (e.raw[0] === "'") {
        end = e.raw.match(/^'(.*)'$/)[1]
      } else {
        end = JSON.parse(e.raw)
      }

      if (typeof start !== typeof end) {
        throw new Error("Range start and end must be of the same type")
      }

      if (typeof start === "string") {
        if (start.length !== 1 || end.length !== 1) {
          throw new Error("String range start and end must be a single character")
        }

        const startCode = start.charCodeAt(0)
        const endCode = end.charCodeAt(0)
        const step = startCode < endCode ? 1 : -1

        const length = Math.abs(endCode - startCode) + (inclusive ? 1 : 0)
        if (length <= 26) {
          return {
            type: "RangeExpression",
            children: ["[", Array.from({ length }, (_, i) => JSON.stringify(String.fromCharCode(startCode + i * step))).join(", "), "]"],
            inclusive,
            start: s,
            end: e
          }
        } else {
          const inclusiveAdjust = inclusive ? " + 1" : ""
          const children = ["((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)", inclusiveAdjust, "}, (_, i) => String.fromCharCode(s + i * step))})(", startCode.toString(), ws, range, endCode.toString(), ")"]
          return {
            type: "RangeExpression",
            children,
            inclusive,
            start: s,
            end: e,
          }
        }
      } else if (typeof start === "number") {
        const step = end > start ? 1 : -1

        const length = Math.abs(end - start) + (inclusive ? 1 : 0)
        if (length <= 20) {
          // Use array of literal values
          return {
            type: "RangeExpression",
            children: ["[", Array.from({ length }, (_, i) => start + i * step).join(", "), "]"],
            inclusive,
            start: s,
            end: e,
          }
        }
      }
    }

    const inclusiveAdjust = inclusive ? " + 1" : ""
    const children = ["((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)", inclusiveAdjust, "}, (_, i) => s + i * step)})(", s, ws, range, e, ")"]

    return {
      type: "RangeExpression",
      children,
      inclusive,
      start: s,
      end: e,
    }

ArrayLiteralContent
  RangeExpression
  NestedElementList
  ElementList

NestedElementList
  PushIndent NestedElement*:elements PopIndent ->
    if (elements.length)
      return elements.flat()
    return $skip

NestedElement
  Nested:indent ElementList:list ArrayElementDelimiter:delimiter ->
    const {length} = list
    if (length) {
      // Prepend indent to first element and append delimiter to last element
      return list.map((e, i) => {
        if (i === 0 && i === length - 1) {
          return {...e, children: [indent, ...e.children, delimiter]}
        }
        if (i === 0) {
          return {...e, children: [indent, ...e.children]}
        }
        if (i === length - 1) {
          return {...e, children: [...e.children, delimiter]}
        }
        return e
      })
    }

ArrayElementDelimiter
  __ Comma
  # NOTE: Don't insert comma before closing bracket
  # Ideally it would be nice to insert a trailing comma before newline followed by closing bracket, but in practice
  # it is difficult to keep the correct number of commas for elision elements. This is also closer to keeping source
  # verbatim.
  &( __ "]" )
  &EOS ->
    return { $loc, token: "," }

# https://262.ecma-international.org/#prod-ElementList
# NOTE: Modified and simplified from the spec
ElementList
  ArrayElementExpression:first ElementListRest*:rest ->
    if (rest.length) {
      return [{
        ...first,
        children: [...first.children, rest[0][0]],
      }].concat(rest.map(([_, e], i) => {
        const delim = rest[i+1]?.[0]
        return {
          ...e,
          children: [...e.children, delim],
        }
      }))
    }

    return [first]

ElementListRest
  # NOTE: This is an explicit comma because we could be in a nested list and we don't want to match
  # the &EOS delimiter
  ( __ Comma ) ArrayElementExpression

# NOTE: Modified and simplified from the spec
ArrayElementExpression
  # NOTE: Allow for postfix splat like CoffeeScript
  # NOTE: Allow empty exp spread for destructuring
  ExtendedExpression?:exp __:ws DotDotDot:dots &ArrayElementDelimiter ->
    if (!exp) {
      exp = {
        type: "Ref",
        base: "ref",
        id: "ref",
        names: [],
      }
    }

    return {
      type: "SpreadElement",
      children: [...ws, dots, exp],
      names: exp.names,
    }

  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  ( ( __ DotDotDot __ )? ExtendedExpression )?:expMaybeSpread &ArrayElementDelimiter ->
    if (expMaybeSpread) {
      const [spread, exp] = expMaybeSpread

      if(!spread) {
        return {
          type: "ArrayElement",
          children: [exp],
          names: exp.names,
        }
      } else {
        return {
          type: "SpreadElement",
          children: [...spread, exp],
          names: exp.names,
        }
      }
    }

    return {
      type: "ElisionElement",
      children: [],
    }

# https://262.ecma-international.org/#prod-ObjectLiteral
# NOTE: Slightly simplified from spec
ObjectLiteral
  # NOTE: Check for object binding pattern in case of destructuring to an object lhs
  ObjectBindingPattern UpcomingAssignment -> $1
  BracedObjectLiteral
  NestedImplicitObjectLiteral
  InlineObjectLiteral

BracedObjectLiteral
  OpenBrace:open BracedObjectLiteralContent?:content ( __ CloseBrace ):close ->
    if(content) {
      const children = [open, ...content, close]

      return {
        type: "ObjectExpression",
        children,
        names: children.flatMap((c) => {
          return c.names || []
        }),
      }
    }

    return {
      type: "ObjectExpression",
      children: [open, close],
      names: [],
    }

BracedObjectLiteralContent
  NestedPropertyDefinitions
  PropertyDefinitionList

NestedImplicitObjectLiteral
  InsertOpenBrace NestedImplicitPropertyDefinitions InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "ObjectExpression",
      children: [$1, ...$2, $3, $4, $5],
    }

NestedImplicitPropertyDefinitions
  PushIndent NestedImplicitPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs.flat()

NestedImplicitPropertyDefinition
  Nested:ws NamedProperty:prop ObjectPropertyDelimiter:delimiter ->
    return {
      ...prop,
      children: [...ws, ...prop.children, delimiter],
    }

NestedPropertyDefinitions
  PushIndent NestedPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs.flat()

NestedPropertyDefinition
  # TODO: This may be a little weird/ambiguous with single identifier shorthand
  Nested:ws ( PropertyDefinition ObjectPropertyDelimiter )+:inlineProps ->
    return inlineProps.map( ([prop, delimiter], i) => ({
      ...prop,
      children: [ ...(i === 0 ? ws : []), ...prop.children, delimiter],
    }))

InlineObjectLiteral
  InsertInlineOpenBrace:open SnugNamedProperty ImplicitInlineObjectPropertyDelimiter ( NamedProperty ImplicitInlineObjectPropertyDelimiter )* InsertCloseBrace:close ->
    return [open, $2, $3, ...$4, close]

# This is different from ObjectPropertyDelimiter because the braces are implicit so we can't look ahead to find the closing one
# Instead we see if the next line matches a NamedProperty and if so we insert a comma
ImplicitInlineObjectPropertyDelimiter
  TrailingComment* ","
  &( EOS NamedProperty ) -> ","
  # NOTE: This is hacky but used when an inline object is inside a ternary conditional
  # Also if inline object is in an argument list or subexpression
  &( __  ( ":" / ")" / "]" / "}" / ReservedWord ) ) -> ""
  &EOS -> ""

ObjectPropertyDelimiter
  _* Comma
  # Object closing delimits the property
  &( __ "}" )
  &EOS ->
    return { $loc, token: "," }

PropertyDefinitionList
  ( PropertyDefinition ObjectPropertyDelimiter )+ ->
    return $0.map(([prop, delim]) => {
      return {
        ...prop,
        children: [...prop.children, delim],
      }
    })

# https://262.ecma-international.org/#prod-PropertyDefinition
PropertyDefinition
  # NOTE: Added CoffeeScript {@id} -> {id: this.id} shorthand
  __:ws At:at IdentifierReference:id ->
    return {
      type: "Property",
      children: [...ws, id, ": ", {...at, token: "this."}, id],
      names: id.names,
    }
  NamedProperty
  __:ws MethodDefinition:def ->
    return {
      ...def,
      children: [...ws, ...def.children],
    }
  __:ws DotDotDot:dots ExtendedExpression:exp ->
    return {
      type: "SpreadProperty",
      children: [...ws, dots, exp],
      names: exp.names,
    }
  # NOTE: this needs to be at the bottom to prevent shadowing PropertyName
  __:ws IdentifierReference:id  ->
    return {...id, children: [...ws, ...id.children]}

NamedProperty
  # NOTE: CoverInitializedName early error doesn't seem necessary with this parser
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  __ PropertyName __ Colon ExtendedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      names: exp.names || [],
    }

# Named property but doesn't allow any space between name and colon
# used to distinguish between braceless inline objects and ternary expression conditions
SnugNamedProperty
  PropertyName Colon ExtendedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      names: exp.names || [],
    }

PropertyName
  # https://262.ecma-international.org/#prod-LiteralPropertyName
  NumericLiteral
  StringLiteral
  IdentifierName
  # https://262.ecma-international.org/#prod-ComputedPropertyName
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  OpenBracket ExtendedExpression __ CloseBracket

Decorator
  AtAt IdentifierReference Arguments?

Decorators
  ( __ Decorator )+ __

# https://262.ecma-international.org/#prod-MethodDefinition
MethodDefinition
  # NOTE: Not adding extra validation using PropertySetParameterList
  Decorators? MethodSignature:signature BracedBlock:block ->
    return {
      type: "MethodDefinition",
      children: $0,
      signature,
      block,
      parameters: signature.parameters,
    }

MethodModifier
  # NOTE: Merged get/set definitions
  GetOrSet TrailingComment*
  # NOTE: Merged async and generator into MethodModifier
  ( Async __ ) ( Star __ )?
  Star __
  Async __

# TypeScript method signature
MethodSignature
  ConstructorShorthand NonEmptyParameters:parameters ->
    return {
      type: "MethodSignature",
      children: $0,
      name: $1.token,
      returnType: undefined,
      parameters,
    }

  MethodModifier? ClassElementName:name _* NonEmptyParameters:parameters ReturnTypeSuffix?:suffix ->
    // Normalize name so we can check if it is `constructor`
    if (name.name) {
      name = name.name
    } else if (name.token) {
      name = name.token.match(/^(?:"|')/) ? name.token.slice(1, -1) : name.token
    }

    return {
      type: "MethodSignature",
      children: $0,
      name: name,
      modifier: $1?.[0]?.token, // get/set
      // TODO: get return type from type annotation
      returnType: undefined,
      parameters,
    }

ClassElementName
  PropertyName
  PrivateIdentifier

PrivateIdentifier
  $("#" IdentifierName) ->
    return {
      type: "Identifier",
      name: $0,
      names: [$0],
      children: [{
        $loc: $loc,
        token: $0,
      }],
    }

# https://262.ecma-international.org/#prod-GeneratorDeclaration
# https://262.ecma-international.org/#prod-GeneratorExpression
# NOTE: Merged GeneratorExpression and GeneratorDeclaration into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncFunctionDeclaration
# https://262.ecma-international.org/#prod-AsyncFunctionExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorDeclaration
# https://262.ecma-international.org/#prod-AsyncGeneratorExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorMethod
# https://262.ecma-international.org/#prod-AsyncGeneratorBody
# https://262.ecma-international.org/#prod-AsyncMethod
# https://262.ecma-international.org/#prod-AsyncFunctionBody
# https://262.ecma-international.org/#prod-GeneratorMethod
# https://262.ecma-international.org/#prod-GeneratorBody
# NOTE: Merged into MethodDefinition

# https://262.ecma-international.org/#prod-AssignmentOperator
AssignmentOp
  AssignmentOpSymbol TrailingComment* ->
    if ($2.length) {
      return {
        token: $1,
        children: [$1, ...$2]
      }
    }

    return { $loc, token: $1 }

AssignmentOpSymbol
  "**="
  "*="
  "/="
  "%="
  "+="
  "-="
  "<<="
  ">>>="
  ">>="
  "&&="
  "&="
  "^="
  "||="
  "|="
  "??="
  "?=" -> "??="
  "="
  CoffeeWordAssignmentOp -> $1

CoffeeWordAssignmentOp
  "and=" -> "&&="
  "or=" -> "||="

BinaryOp
  BinaryOpSymbol ->
    if (typeof $1 === "string") return { $loc, token: $1 }
    return $1

# NOTE: Condensed binary operator symbols into one rule
BinaryOpSymbol
  "**"
  "*"
  "/"
  "%"
  "+"
  "-"
  "<="
  ">="
  "<<"
  # NOTE: Avoid matching JSX opening tag by requiring non-identifier character
  # (e.g. whitespace) after "<".  This does forbid 1<2 or x<y.
  /<(?!\p{ID_Start}|[_$])/ ->
    return "<"
  ">>>"
  ">>"
  ">"
  "!=="
  # NOTE: CoffeeScript converts "!=" -> "!=="
  # Convert if CoffeeScript compat flag is set
  "!=" ->
    if(module.config.coffeeEq) return "!=="
    return $1
  "isnt" NonIdContinue ->
    if(module.config.coffeeIsnt) return "!=="
    return $skip
  "is" NonIdContinue -> "==="
  "==="
  # NOTE: CoffeeScript converts "==" -> "==="
  # Convert if CoffeeScript compat flag is set
  "==" ->
    if(module.config.coffeeEq) return "==="
    return $1
  "and" NonIdContinue -> "&&"
  "&&"
  CoffeeOfEnabled "of" NonIdContinue -> "in"
  "or" NonIdContinue -> "||"
  "||"
  "??"
  CoffeeBinaryExistentialEnabled "?" -> "??"
  "instanceof" NonIdContinue ->
    return $1
  CoffeeNotEnabled "not" NonIdContinue __ "instanceof" NonIdContinue ->
    return {
      $loc: $loc,
      token: "instanceof",
      special: true,
    }
  CoffeeNotEnabled "not" NonIdContinue __ "of" NonIdContinue ->
    return {
      $loc: $loc,
      token: "in",
      special: true,
    }
  CoffeeOfEnabled "in" NonIdContinue ->
    return {
      ref: module.getIndexOfRef(),
      suffix: " >= 0",
      special: true,
    }
  CoffeeOfEnabled "not" NonIdContinue __ "in" NonIdContinue ->
    return {
      ref: module.getIndexOfRef(),
      suffix: " < 0",
      special: true,
    }
  "in" NonIdContinue ->
    return $1
  "&"
  "^"
  "|"

UnaryOp
  # Lookahead to prevent unary operators from overriding block unary operator shorthand
  /[!~+-](?!\s|[!~+-]*&)/ ->
    return { $loc, token: $0 }
  ( Await / Delete / Void / Typeof ) __
  Not # only when CoffeeNotEnabled (see definition of `Not`)

# https://262.ecma-international.org/#prod-ModuleItem
ModuleItem
  ImportDeclaration
  ExportDeclaration
  StatementListItem

# https://262.ecma-international.org/#prod-StatementListItem
StatementListItem
  Declaration
  # NOTE: Added postfix conditionals/loops
  Statement:statement ( TrailingComment* PostfixStatement )?:post ->
    if (post) return module.addPostfixStatement(statement, ...post)
    return statement

PostfixStatement
  ForClause
  IfClause
  LoopClause
  UnlessClause
  WhileClause

# https://262.ecma-international.org/#prod-Statement
Statement
  KeywordStatement
  BlockStatement
  VariableStatement
  IfStatement
  IterationStatement
  SwitchStatement
  TryStatement

  EmptyStatement
  ExpressionStatement

  # NOTE: no WithStatement
  # NOTE: no LabelledStatement

# NOTE: EmptyStatement handled differently than spec, consuming inline whitespace and comments then asserting following semi-colon
EmptyStatement
  TrailingComment* &";" -> { type: "EmptyStatement", children: $1 }

# https://262.ecma-international.org/#prod-BlockStatement
BlockStatement
  # NOTE: Added lookahead for `=` to allow for destructuring assignment without parens
  ExplicitBlock !( __ "=" ) -> $1

# https://262.ecma-international.org/#prod-IfStatement
IfStatement
  # NOTE: Added paren-less condition
  # NOTE: Block isn't Statement so we can handle implied braces by nesting
  (IfClause / UnlessClause):clause Block:block ElseClause?:e ->
    const children = [...clause.children, block]
    if (e) children./**/push(e)
    return {
      type: "IfStatement",
      children,
    }

ElseClause
  &EOS Samedent Else Block -> [$2, $3, $4]
  TrailingComment* Else Block

IfClause
  If Condition -> { type: "IfStatement", children: $0 }

UnlessClause
  Unless:kind Condition:condition ->
    // Rewrite unless to if
    kind.token = "if"

    return {
      type: "IfStatement",
      // TODO: Don't add unnecessary parens
      children: [kind, ["(!", condition, ")"]],
    }

# NOTE: Added IfExpression from CoffeeScript
IfExpression
  IfClause:clause ExpressionBlock:b ElseExpressionClause?:e ->
    return module.expressionizeIfClause(clause, b, e)

UnlessExpression
  UnlessClause:clause ExpressionBlock:b ElseExpressionClause?:e ->
    return module.expressionizeIfClause(clause, b, e)

ElseExpressionClause
  ( ( Samedent Else ) / ( TrailingComment* Else ) ) ElseExpressionBlock ->
    return [...$1, $2]

# Block of expressions that can't include pure statements
ExpressionBlock
  InsertOpenParen NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseParen ->
    // If there is only one expression and it doesn't require parens, then return it as is, preserving whitespace
    if (exps.length === 1) {
      let [ws, exp] = exps[0]
      switch (exp.type) {
        case "Identifier":
        case "Literal":
          return [ws, exp]
      }
    }

    // Remove final trailing expression delimiter
    exps = exps.map((e, i) => {
      if (i === exps.length - 1) {
        return e.slice(0, -1)
      }
      return e
    })

    return {
      type: "BlockExpressions",
      expressions: exps,
      children: [$1, exps, $3, $4, $5],
    }
  Then ExtendedExpression

ElseExpressionBlock
  InsertOpenParen NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseParen ->
    // If there is only one expression and it doesn't require parens, then return it as is, preserving whitespace
    if (exps.length === 1) {
      let [ws, exp] = exps[0]
      switch (exp.type) {
        case "Identifier":
        case "Literal":
          return [ws, exp]
      }
    }

    // Remove final trailing expression delimiter
    exps = exps.map((e, i) => {
      if (i === exps.length - 1) {
        return e.slice(0, -1)
      }
      return e
    })

    return {
      type: "BlockExpressions",
      expressions: exps,
      children: [$1, exps, $3, $4, $5],
    }
  !EOS ExtendedExpression -> $2

NestedBlockExpressions
  PushIndent NestedBlockExpression*:exps PopIndent ->
    if (!exps.length) return $skip
    return exps

NestedBlockExpression
  Nested:ws ExtendedExpression:exp ( TrailingComment* PostfixStatement )?:post ExpressionDelimiter:d ->
    if (post) {
      return [ws, module.attachPostfixStatementAsExpression(exp, post), d]
    }

    return [ws, exp, d]

# https://262.ecma-international.org/#prod-IterationStatement
IterationStatement
  # NOTE: Added `loop` from CoffeeScript
  LoopStatement
  !CoffeeDoEnabled DoWhileStatement -> $2
  WhileStatement
  ForStatement

IterationExpression
  IterationStatement ->
    return {
      type: "IterationExpression",
      children: [$1],
      block: $1.block,
    }

# NOTE: Added from CoffeeScript
LoopStatement
  LoopClause:clause Block:block ->
    return {
      type: "IterationStatement",
      children: [...clause.children, block],
      block,
    }

LoopClause
  Loop -> {
    type: "IterationStatement",
    children: [$1],
  }

# https://262.ecma-international.org/#prod-DoWhileStatement
DoWhileStatement
  # NOTE: Condition provides optional parens
  Do BracedBlock:block __ WhileClause -> {
    type: "IterationStatement",
    children: $0,
    block: block
  }

# https://262.ecma-international.org/#prod-WhileStatement
WhileStatement
  # NOTE: Condition provides optional parens
  WhileClause:clause Block:block ->
    return {
      type: "IterationStatement",
      children: [...clause.children, block],
      block: block
    }

WhileClause
  ( While / Until ):kind TrailingComment*:ws Condition:cond ->
    if (kind.token === "until") {
      kind.token = "while"

      // TODO: Don't add unnecessary parens
      return {
        type: "IterationStatement",
        children: [kind, ...ws, ["(!", ...cond.children, ")"]]
      }
    }

    return {
      type: "IterationStatement",
      children: [kind, ...ws, ...cond.children]
    }

# https://262.ecma-international.org/#prod-ForStatement
# https://262.ecma-international.org/#prod-ForInOfStatement
# NOTE: Merged into single rule
ForStatement
  ForClause:clause Block:block ->
    // TODO: remove mutation
    if (clause.blockPrefix) {
      block.expressions.splice(0, 0, ...clause.blockPrefix)
    }
    return {
      ...clause,
      children: [...clause.children, block],
      block,
    }

ForClause
  For __ ForStatementControl:c  ->
    const {children, declaration} = c

    return {
      type: "ForStatement",
      children: [$1, ...$2, ...children],
      declaration: declaration,
      block: null,
      blockPrefix: c.blockPrefix,
    }

ForStatementControl
  !CoffeeForLoopsEnabled ForStatementParameters -> $2
  CoffeeForLoopsEnabled CoffeeForStatementParameters WhenCondition? ->
    if ($3) {
      const indent = module.currentIndent.token + "  "
      $2.blockPrefix.push([indent, {
        type: "IfStatement",
        children: ["if (!(", module.insertTrimmingSpace($3, ""), ")) continue\n"],
      }])
    }

    return $2

WhenCondition
  __ When ExtendedExpression:exp -> exp

CoffeeForStatementParameters
  # NOTE: Coffee for loops can't have parens
  ( Await __ )? InsertOpenParen:open CoffeeForDeclaration:declaration CoffeeForIndex?:index __ ( In / Of / From ):kind ExtendedExpression:exp ( __ By ExtendedExpression )?:step InsertCloseParen:close ->
    let blockPrefix = []
    const indent = module.currentIndent.token + "  "
    exp = module.insertTrimmingSpace(exp, "")
    declaration = module.insertTrimmingSpace(declaration, "")

    if (kind.token === "from") {
      if (step) {
        throw new Error("Can't use 'by' with 'from' in CoffeeScript for loops")
      }
      kind.token = "of"
    } else if (kind.token === "of") {
      if (step) {
        throw new Error("Can't use 'by' with 'of' in CoffeeScript for loops")
      }

      if (declaration.own) {
        const indent = module.currentIndent.token + "  "
        const hasPropRef = module.getHasPropRef()

        blockPrefix./**/push([indent, "if (!", hasPropRef, ".call(", exp, ", ", declaration, ")) continue\n"])
      }
      kind.token = "in"
    } else if (kind.token === "in") { // CoffeeScript loop comprehensions
      const counterRef = {
        type: "Ref",
        base: "i",
        id: "i",
      }

      const lenRef = {
        type: "Ref",
        base: "len",
        id: "len",
      }

      // If exp isn't a simple identifier use a ref
      let expRef
      switch(exp.type) {
        case "Identifier":
          expRef = exp
          break
        case "RangeExpression": {
          const {start, end, inclusive} = exp

          let stepExp = step?.[2]
          let stepRef
          if (stepExp) {
            stepExp = module.insertTrimmingSpace(stepExp, "")
            if (stepExp.type === "Literal") {
              stepRef = stepExp
            } else {
              stepRef = {
                type: "Ref",
                base: "step",
                id: "step",
              }
            }
          }

          let startRef, endRef
          if (start.type === "Literal") {
            startRef = start
          } else if (start.type === "Identifier") {
            startRef = start
          } else {
            startRef = {
              type: "Ref",
              base: "ref",
              id: "ref",
            }
          }

          if (end.type === "Literal") {
            endRef = end
          } else if (end.type === "Identifier") {
            endRef = end
          } else {
            endRef = {
              type: "Ref",
              base: "ref",
              id: "ref",
            }
          }

          const startRefDec = (startRef !== start) ? [startRef, " = ", start, ", "] : []
          const endRefDec = (endRef !== end) ? [endRef, " = ", end, ", "] : []
          const varRef = declaration
          const ascDec = stepRef
          ? stepRef !== stepExp
            ? [", step = ", stepExp]
            : []
          : [", asc = ", startRef, " <= ", endRef]
          declaration = {
            type: "Declaration",
            children: ["let ", ...startRefDec, ...endRefDec, counterRef, " = ", varRef, " = ", startRef, ...ascDec],
            names: []
          }

          blockPrefix./**/push(["", {
            type: "AssignmentExpression",
            children: [], // Empty assignment to trigger auto-var
            names: varRef.names,
          }])

          const counterPart = inclusive
            ? [counterRef, " <= ", endRef, " : ", counterRef, " >= ", endRef]
            : [counterRef, " < " , endRef, " : ", counterRef, " > " , endRef]

          const condition = stepRef
            ? [stepRef, " !== 0 && (", stepRef, " > 0 ? ", ...counterPart, ")"]
            : ["asc ? ", ...counterPart]

          const increment = stepRef
          ? [varRef, " = ", counterRef, " += ", stepRef]
          : [varRef, " = asc ? ++", counterRef, " : --", counterRef]

          return {
            declaration,
            children: [$1, open, declaration, "; ", ...condition, "; ", ...increment, close],
            blockPrefix,
          }
        }
        default:
          expRef = {
            type: "Ref",
            base: "ref",
            id: "ref",
          }
      }

      const varRef = declaration
      let increment = "++",
        indexAssignment,
        assignmentNames = [...varRef.names]

      if (index) {
        index = module.insertTrimmingSpace(index, "")
        indexAssignment = [index, "="]
        assignmentNames./**/push(...index.names)
      }

      const expRefDec = (expRef !== exp)
        // Trim a single leading space if present
        ? [expRef, " = ", module.insertTrimmingSpace(exp, ""), ", "]
        : []

      blockPrefix./**/push([indent, {
        type: "AssignmentExpression",
        children: [varRef, " = ", expRef, "[", indexAssignment, counterRef, "]\n"],
        names: assignmentNames,
      }])

      declaration = {
        type: "Declaration",
        children: ["let ", ...expRefDec, counterRef, " = 0, ", lenRef, " = ", expRef, ".length"],
        names: []
      }

      let condition = [counterRef, " < ", lenRef, "; "]

      if (step) {
        let [stepWs, , stepExp] = step
        stepWs = module.insertTrimmingSpace(stepWs, "")
        if (stepExp.type === "Literal") {
          increment = [" +=", ...stepWs, stepExp]
          // Negative step loops are reversed
          if ( stepExp.raw[0] === "-") {
            declaration = {
              type: "Declaration",
              children: ["let ", ...expRefDec, counterRef, " = ", expRef, ".length - 1"],
              names: []
            }
            condition = [counterRef, " >= 0; "]
          }
        } else {
          throw new Error("TODO: Support non-literal step in CoffeeScript for loops")
        }

        return {
          declaration,
          children: [$1, open, declaration, "; ", ...condition, counterRef, increment, close],
          blockPrefix,
        }
      }

      return {
        declaration,
        children: [$1, open, declaration, "; ", ...condition, counterRef, increment, close],
        blockPrefix,
      }
    }

    return {
      declaration,
      children: [$1, open, declaration, $5, kind, " ", exp, close],
      blockPrefix,
    }

CoffeeForIndex
  TrailingComment*:ws1 Comma TrailingComment*:ws2 BindingIdentifier:id ->
    return Object.assign({}, id, {
      children: [...ws1, ...ws2, ...id.children]
    })

CoffeeForDeclaration
  # NOTE: Coffee doesn't allow expression bindings like `for a.x in b`
  ( __ "own" )?:own ForBinding:binding ->
    if (own) {
      binding.own = true
    }

    // Flag as assignment for auto-var
    binding.type = "AssignmentExpression"

    return binding

ForStatementParameters
  # https://262.ecma-international.org/#prod-ForStatement
  OpenParen __       ( LexicalDeclaration / VariableStatement / Expression? ):declaration __ Semicolon Expression? Semicolon Expression? __ CloseParen ->
    return {
      declaration,
      children: $0,
    }
  # NOTE: Added optional parens
  InsertOpenParen __ ( LexicalDeclaration / VariableStatement / Expression? ):declaration __ Semicolon Expression? Semicolon (!EOS Expression)? InsertCloseParen ->
    return {
      declaration,
      children: $0,
    }

  # https://262.ecma-international.org/#prod-ForInOfStatement
  # NOTE: Consolidated declarations
  # NOTE: Consolidated optional 'await'
  ( Await __ )? OpenParen __    ForInOfDeclaration:declaration __ ( In / Of ) ExpressionWithIndentedApplicationSuppressed __ CloseParen ->
    return {
      declaration,
      children: $0,
    }
  # NOTE: Added optional parens
  ( Await __ )? InsertOpenParen ForInOfDeclaration:declaration __ ( In / Of ) ExpressionWithIndentedApplicationSuppressed InsertCloseParen ->
    return {
      declaration: declaration,
      children: $0,
    }

# NOTE: Consolidated declarations
ForInOfDeclaration
  Var ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: $0,
      names: binding.names,
    }
  ForDeclaration
  LeftHandSideExpression

# https://262.ecma-international.org/#prod-ForDeclaration
ForDeclaration
  LetOrConst:c NonIdContinue ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      names: binding.names,
    }
  # NOTE: Added default implicit const to for bindings
  # NOTE: the assertion is a bit of a hack to prevent valid LHS expressions from only parsing the identifier and matching this rule
  # i.e. a.x would match as identifier `a` without this lookahead
  InsertConst:c ForBinding:binding /(?=[\s\)])/ ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      names: binding.names,
    }

# https://262.ecma-international.org/#prod-ForBinding
ForBinding
  BindingIdentifier
  BindingPattern

# https://262.ecma-international.org/#prod-SwitchStatement
SwitchStatement
  Switch ( EmptyCondition / Condition ):condition CaseBlock:caseBlock ->
    if (condition.type === "EmptyCondition") {
      // Negate all case condition expressions. This converts them to booleans
      // and is slightly smaller than switch(true) {case: !!exp ... }
      caseBlock.clauses.forEach(({cases}) => {
        if (cases) {
          cases.forEach((c) => {
            const exp = c[1]
            switch(exp.type) {
              case "Identifier":
              case "Literal":
                c.splice(1, 0, "!")
                break;
              default:
               c.splice(1, 1, "!(", exp, ")")
            }
          })
        }
      })
    }

    return {
      type: "SwitchStatement",
      children: $0
    }

EmptyCondition
  &EOS ->
    return {
      type: "EmptyCondition",
      children: [{
        $loc,
        token: " (false)",
      }]
    }

# NOTE: Added from CoffeeScript
SwitchExpression
  SwitchStatement:e ->
    return {
      type: "SwitchExpression",
      block: e.children[2],
      // wrap with IIFE
      children: ["(()=>{", e.children, "})()"]
    }

# https://262.ecma-international.org/#prod-CaseBlock
CaseBlock
  __ OpenBrace NestedCaseClauses:clauses __ CloseBrace ->
    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

  # NOTE: Added optional braces with nesting
  InsertOpenBrace NestedCaseClauses:clauses InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

NestedCaseClauses
  PushIndent NestedCaseClause*:clauses PopIndent ->
    if (clauses.length) return clauses
    return $skip

NestedCaseClause
  Nested:indent CaseClause:clause ->
    return Object.assign({}, clause, {
      // Bring the indent into the clause
      children: [indent, ...clause.children],
    })

# https://262.ecma-international.org/#prod-CaseClause
CaseClause
  # NOTE: This differs from ESTree significantly to be easier to work with for implicit returns
  Case CaseExpressionList:cases ( NestedBlockStatements / NoExpressions ):expressions -> {
    type: "CaseClause",
    cases,
    expressions,
    children: $0
  }
  # NOTE: Added "when" from CoffeeScript. `when` always inserts `break;`.
  When CaseExpressionList:cases InsertOpenBrace ( ThenClause / NestedBlockStatements )?:expressions InsertBreak:b InsertNewline InsertIndent InsertCloseBrace ->
    let children = $0
    if (!expressions) {
      expressions = []
      children = children.map((c, i) => i === 3 ? expressions : c)
    }
    // ThenClause is a BlockExpression so let's point to its expressions
    if (expressions.expressions) {
      expressions = expressions.expressions
    }
    return {
      type: "WhenClause",
      cases,
      expressions,
      break: b,
      children,
    }
  # NOTE: Merged in default clause
  Default ImpliedColon ( NestedBlockStatements / NoExpressions ):expressions ->
    if (expressions.expressions) expressions = expressions.expressions
    return {
      type: "DefaultClause",
      expressions,
      children: $0
    }
  # NOTE: Added else from CoffeesScript
  Else ImpliedColon InsertOpenBrace ( NestedBlockStatements / ( TrailingComment* Statement ) ):expressions InsertNewline InsertIndent InsertCloseBrace ->
    $1.token = "default"
    if (expressions.expressions) expressions = expressions.expressions
    return {
      type: "DefaultClause",
      expressions,
      children: $0
    }

CaseExpressionList
  ( _* ExpressionWithIndentedApplicationSuppressed ImpliedColon ) ( __ Comma ExpressionWithIndentedApplicationSuppressed ImpliedColon )* ->
    // Convert comma separated expression list to `case <exp>:`
    const result = $2.map(([ws, _comma, exp, col]) => {
      exp = module.insertTrimmingSpace(exp, "")

      if (ws.length) return [module.insertTrimmingSpace("case ", ws), exp, col]
      return ["case ", exp, col]
    })
    result./**/unshift($1)

    return result

NoExpressions
  "" -> []

ImpliedColon
  __ Colon
  "" ->
    return { $loc, token: ":" }

# https://262.ecma-international.org/#prod-TryStatement
TryStatement
  Try:t BracedBlock:b CatchClause?:c Finally?:f ->
    if (!c && !f) {
      return {
        type: "TryStatement",
        children: [t, b, " catch(e) {}"]
      }
    }

    return {
      type: "TryStatement",
      children: [t, b, c, f]
    }

# https://262.ecma-international.org/#prod-Catch
CatchClause
  __ Catch CatchBind? BracedBlock

# NOTE: Added optional parentheses to catch binding
CatchBind
  __ OpenParen __ CatchParameter __ CloseParen
  !EOS TrailingComment* InsertOpenParen CatchParameter InsertCloseParen

# https://262.ecma-international.org/#prod-Finally
Finally
  __ "finally" BracedBlock

# https://262.ecma-international.org/#prod-CatchParameter
CatchParameter
  BindingIdentifier
  BindingPattern

# An expression with explicit or implied parentheses, for use in if/while/switch
Condition
  ParenthesizedExpression !( TrailingComment* ( BinaryOp / AssignmentOp / Dot / QuestionMark ) ) -> $1
  InsertOpenParen:open ExpressionWithIndentedApplicationSuppressed:exp InsertCloseParen:close ->
    // Don't double wrap parethesized expressions
    if (exp.type === "ParenthesizedExpression") return exp
    return {
      type: "ParenthesizedExpression",
      children: [open, module.insertTrimmingSpace(exp, ""), close],
    }

ExpressionWithIndentedApplicationSuppressed
  SuppressIndentedApplication ExtendedExpression?:exp ->
    module.suppressIndentedApplication = false

    if (exp) return exp
    return $skip

SuppressIndentedApplication
  "" ->
    module.suppressIndentedApplication = true


# https://262.ecma-international.org/#prod-ExpressionStatement
ExpressionStatement
  # NOTE: semi-colons are being handled elsewhere
  # NOTE: Shouldn't need negative lookahead if shadowed in the proper order
  Expression

KeywordStatement
  # https://262.ecma-international.org/#prod-BreakStatement
  # NOTE: no label
  "break" NonIdContinue -> {
    type: "BreakStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ContinueStatement
  # NOTE: no label
  "continue" NonIdContinue -> {
    type: "ContinueStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#sec-debugger-statement
  "debugger" NonIdContinue -> {
    type: "DebuggerStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ReturnStatement
  Return MaybeNestedExpression? -> {
    type: "ReturnStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ThrowStatement
  Throw ExtendedExpression -> {
    type: "ThrowStatement",
    children: $0,
  }

DebuggerExpression
  "debugger" NonIdContinue ->
    return {
      type: "DebuggerExpression",
      children: ["(()=>{", $1, "})()"],
    }

ThrowExpression
  Throw ExtendedExpression ->
    return {
      type: "ThrowExpression",
      children: ["(()=>{", $0, "})()"],
    }

MaybeNestedExpression
  # Not nested case
  !EOS ExtendedExpression ->
    return $2
  # Avoid wrapping object return value in parentheses.
  &EOS ObjectLiteral ->
    return $2
  # Value after `return` needs to be wrapped in parentheses
  # if it starts on another line.
  &EOS InsertSpace InsertOpenParen PushIndent Nested ExtendedExpression PopIndent InsertNewline InsertIndent InsertCloseParen

# https://262.ecma-international.org/#prod-ImportDeclaration
ImportDeclaration
  "import type" NonIdContinue __ ImportClause __ FromClause -> { ts: true, children: $0 }
  Import __ ImportClause __ FromClause
  Import __ ModuleSpecifier
  # NOTE: Added import shorthand
  # NOTE: Not adding $loc to source map here yet because it will point to the start of the identifier
  # the proper place may be to use the From location
  ImpliedImport:i ImportClause:c __:w FromClause:f ->
    // Map implied import location to `from`
    // The pos and length adjustment better match how tsc outputs to include the space before `from` with the `from` token
    i.$loc = {
      pos: f[0].$loc.pos-1,
      length: f[0].$loc.length+1,
    }
    return [i, c, w, f]

ImpliedImport
  "" ->
    return { $loc, token: "import " }

# https://262.ecma-international.org/#prod-ImportClause
ImportClause
  ImportedBinding:binding ( __ Comma __ ( NameSpaceImport / NamedImports ) )?:rest ->
    if (rest) {
      return {
        type: "Declaration",
        children: $0,
        names: [...binding.names, ...rest[3].names],
      }
    }

    return {
      type: "Declaration",
      children: $0,
      names: binding.names,
    }
  NameSpaceImport
  NamedImports

# https://262.ecma-international.org/#prod-NameSpaceImport
NameSpaceImport
  Star __ As __ ImportedBinding:binding  ->
    return {
      type: "Declaration",
      children: $0,
      names: binding.names
    }

# https://262.ecma-international.org/#prod-NamedImports
NamedImports
  OpenBrace ImportSpecifier*:specifiers ( __ Comma )? __ CloseBrace ->
    const names = specifiers.flatMap(({binding}) => {
      return binding.names
    })

    return {
      type: "Declaration",
      children: $0,
      names
    }

# https://262.ecma-international.org/#prod-FromClause
FromClause
  From __ ModuleSpecifier

# https://262.ecma-international.org/#prod-ImportSpecifier
ImportSpecifier
  __ ModuleExportName __ As __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding: binding,
      children: $0,
    }
  __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding: binding,
      children: $0,
    }

# https://262.ecma-international.org/#prod-ModuleExportName
ModuleExportName
  StringLiteral
  IdentifierName

# https://262.ecma-international.org/#prod-ModuleSpecifier
ModuleSpecifier
  UnprocessedModuleSpecifier ->
    // Workaround to fix:
    // https://github.com/microsoft/TypeScript/issues/42151
    // import t.ts
    // "An import path cannot end with a '.ts' extension. Consider importing './t.js' instead."
    const {token} = $1
    // convert .[mc]?ts to .[mc]?js
    return { $loc, token: token.replace(/\.([mc])?ts(['"])$/, ".$1js$2") }

UnprocessedModuleSpecifier
  BasicStringLiteral
  UnquotedSpecifier

UnquotedSpecifier
  # Currently allowing all characters except for whitespace, double quotes, and semi-colon
  # It may make sense to restrict this to only allow characters that are valid in a module specifier
  # Also consider URLs
  /[^;"\s]+/:spec ->
    return { $loc, token: `"${spec}"` }

# https://262.ecma-international.org/#prod-ImportedBinding
ImportedBinding
  BindingIdentifier

# https://262.ecma-international.org/#prod-ExportDeclaration
ExportDeclaration
  # NOTE: Using ExtendedExportDeclaration to allow If/Switch expressions
  Export __ "default" NonIdContinue __ ( HoistableDeclaration / ClassDeclaration / ExtendedExpression )
  Export __ ExportFromClause __ FromClause
  # NOTE: Declaration should come before NamedExports
  # so that NamedExports doesn't grab function, async, type, etc.
  Export __ ( Declaration / NamedExports / VariableStatement / ExportVarDec )

# CoffeeScript style `export x = 3` -> `export var x = 3`
ExportVarDec
  InsertVar VariableDeclarationList

# https://262.ecma-international.org/#prod-ExportFromClause
ExportFromClause
  Star ( __ As __ ModuleExportName )?
  NamedExports

# https://262.ecma-international.org/#prod-NamedExports
NamedExports
  OpenBrace ExportSpecifier* (__ Comma )? __ CloseBrace
  # Unbraced version: export x, y
  InsertInlineOpenBrace:open ImplicitExportSpecifier ( _ ImplicitExportSpecifier )* InsertCloseBrace:close ->
    return [open, $2, ...$3, close]

# https://262.ecma-international.org/#prod-ExportSpecifier
ExportSpecifier
  __ ModuleExportName ( __ As __ ModuleExportName )? ObjectPropertyDelimiter

ImplicitExportSpecifier
  !"default" ModuleExportName ( __ As __ ModuleExportName )? ( &( __ From ) / ImplicitInlineObjectPropertyDelimiter )

# https://262.ecma-international.org/#prod-Declaration
Declaration
  HoistableDeclaration
  ClassDeclaration
  LexicalDeclaration
  TypeDeclaration

# https://262.ecma-international.org/#prod-HoistableDeclaration
HoistableDeclaration
  FunctionDeclaration

# https://262.ecma-international.org/#prod-LexicalDeclaration
LexicalDeclaration
  # NOTE: Eliminated left recursion
  LetOrConst LexicalBinding:binding ( __ Comma LexicalBinding )*:tail ->
    return {
      type: "Declaration",
      children: $0,
      names: [...binding.names].concat(tail.flatMap(([,,b]) => b.names)),
    }
  # NOTE: Added const shorthand
  # NOTE: Using ExtendedExpression to allow for If/SwitchExpressions
  InsertConst:c ( BindingPattern / BindingIdentifier ):id TypeSuffix?:suffix __:ws ConstAssignment:ca ExtendedExpression:e ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    c = {
      ...c,
      $loc: {
        pos: ca.$loc.pos - 1,
        length: ca.$loc.length + 1,
      }
    }

    let exp
    if (e.type === "FunctionExpression") {
      exp = e
    } else {
      exp = e[1]
    }

    // TODO: Better AST nodes so we don't have to adjust for whitespace nodes here
    if (exp?.children?.[0]?.token?.match(/^\s+$/)) exp.children.shift()

    if (id.type === "Identifier" && exp?.type === "FunctionExpression" && !exp.id) {
      const i = exp.children.findIndex(c => c?.token === "function") + 1
      exp = {
        ...exp,
        // Insert id, type suffix, spacing
        children: [...exp.children.slice(0, i), " ", id, $3, $4, ...exp.children.slice(i)]
      }
      return {
        type: "Declaration",
        children: [exp],
        names: id.names,
      }
    }

    let [splices, thisAssignments] = module.gatherBindingCode(id)

    splices = splices.map(s => [", ", s])
    thisAssignments = thisAssignments.map(a => [";", a])

    const children = [c, id, suffix, ...ws, ca, e, ...splices, ...thisAssignments]

    return {
      type: "Declaration",
      names: id.names,
      children,
    }

ConstAssignment
  ":=" ->
    return { $loc, token: "=" }

# https://262.ecma-international.org/#prod-LexicalBinding
LexicalBinding
  BindingPattern TypeSuffix? Initializer ->
    const children = [...$1.children]
    if ($2) children./**/push($2)
    children./**/push($3)
    return {
      children,
      names: $1.names,
    }

  BindingIdentifier TypeSuffix? Initializer? ->
    const children = [...$1.children]
    if ($2) children./**/push($2)
    if ($3) children./**/push($3)
    return {
      children,
      names: $1.names,
    }

# https://262.ecma-international.org/#prod-Initializer
Initializer
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  __ Equals ExtendedExpression

# https://262.ecma-international.org/#prod-VariableStatement
VariableStatement
  Var __ VariableDeclarationList ->
    return Object.assign({}, $3, {
      children: [$1, ...$2, ...$3.children],
    })

# https://262.ecma-international.org/#prod-VariableDeclarationList
VariableDeclarationList
  VariableDeclaration ( __ Comma __ VariableDeclaration )* ->
    let children
    if ($2.length) {
      children = [$1, ...$2]
    }else {
      children = [$1]
    }

    const names = children.flatMap((c) => c.names || [])

    return {
      type: "Declaration",
      children,
      names,
    }

# https://262.ecma-international.org/#prod-VariableDeclaration
VariableDeclaration
  BindingPattern TypeSuffix? Initializer ->
    const children = [...$1.children]
    if ($2) children./**/push($2)
    children./**/push($3)
    return {
      children,
      names: $1.names,
    }

  BindingIdentifier TypeSuffix? Initializer? ->
    const children = [...$1.children]
    if ($2) children./**/push($2)
    if ($3) children./**/push($3)
    return {
      children,
      names: $1.names,
    }

# https://262.ecma-international.org/#prod-NumericLiteral
NumericLiteral
  NumericLiteralKind ->
    return { $loc, token: $1 }

NumericLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexLiteral
  DecimalLiteral

# https://262.ecma-international.org/#prod-DecimalBigIntegerLiteral
DecimalBigIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)n/
  # /[_0-9]*n/

# https://262.ecma-international.org/#prod-DecimalLiteral
DecimalLiteral
  # NOTE: Not matching the dot as part of a number if it is followed by a valid JS identifier so that it will match as a property access
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?=\.(?:\p{ID_Start}|[_$]))/ ) ->
    // Insert an extra dot to make property access work
    return $1 + "."
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?:\.(?:[0-9](?:_[0-9]|[0-9])*))?/ ExponentPart? )
  $( /(?:\.[0-9](?:_[0-9]|[0-9])*)/ ExponentPart? )

ExponentPart
  /(?:[eE][+-]?[0-9]+(?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-BinaryIntegerLiteral
BinaryIntegerLiteral
  /0[bB][01](?:[01]|_[01])*n?/

# https://262.ecma-international.org/#prod-OctalIntegerLiteral
OctalIntegerLiteral
  /0[oO][0-7](?:[0-7]|_[0-7])*n?/

# https://262.ecma-international.org/#prod-HexIntegerLiteral
HexLiteral
  /0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_[0-9a-fA-F])*n?/

# https://262.ecma-international.org/#prod-StringLiteral
StringLiteral
  # NOTE: actual CoffeeScript """ string behaviors are pretty weird, this is simplifed
  TripleDoubleQuote ( TripleDoubleStringCharacters / CoffeeStringSubstitution )* TripleDoubleQuote ->
    return module.dedentBlockSubstitutions($0)

  TripleSingleQuote:s TripleSingleStringCharacters:str TripleSingleQuote:e ->
    return [s, module.dedentBlockString(str), e]

  # CoffeeScript Interpolation is enabled when "civet coffee-compat" or "civet coffee-interpolation" directive is present
  CoffeeInterpolatedDoubleQuotedString
  BasicStringLiteral

BasicStringLiteral
  DoubleQuote DoubleStringCharacters:str DoubleQuote ->
    return {
      token: `"${module.modifyString(str.token)}"`,
      $loc,
    }

  SingleQuote SingleStringCharacters:str SingleQuote ->
    return {
      token: `'${module.modifyString(str.token)}'`,
      $loc,
    }

DoubleStringCharacters
  /(?:\\.|[^"])*/ ->
    return { $loc, token: $0 }

SingleStringCharacters
  /(?:\\.|[^'])*/ ->
    return { $loc, token: $0 }

TripleDoubleStringCharacters
  /(?:"(?!"")|#(?!\{)|\\.|[^#"])+/ ->
    return { $loc, token: $0 }

TripleSingleStringCharacters
  /(?:'(?!'')|\\.|[^'])*/ ->
    return { $loc, token: $0 }

CoffeeStringSubstitution
  CoffeeSubstitutionStart ExtendedExpression __ CloseBrace

CoffeeInterpolatedDoubleQuotedString
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringSubstitution )*:parts DoubleQuote:e ->
    const noInterpolations = parts.length === 1 && parts[0].token != null
    if (noInterpolations) {
      return {
        token: `"${module.modifyString(parts[0].token)}"`,
        $loc,
      }
    }

    parts.forEach((part) => {
      // Is a string
      if(part.token) {
        // Escape '${' and '`'
        const str = part.token.replace(/(`|\$\{)/g, "\\$1")
        // Escape non-continuation newlines
        part.token = module.modifyString(str)
      }
    })

    // Convert to backtick enclosed string
    s.token = e.token = "`"

    return [s, parts, e]

CoffeeDoubleQuotedStringCharacters
  /(?:\\.|#(?!\{)|[^"#])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#prod-RegularExpressionLiteral
RegularExpressionLiteral
  HeregexLiteral
  $("/" RegularExpressionBody "/" RegularExpressionFlags) ->
    return { $loc, token: $1 }

RegularExpressionClass
  $(OpenBracket RegularExpressionClassCharacters CloseBracket) ->
    return { $loc, token: $1 }

RegularExpressionClassCharacters
  /(?:\\.|[^\]])*/ ->
    return { $loc, token: $0 }

HeregexLiteral
  TripleSlash:open HeregexBody:body TripleSlash:close RegularExpressionFlags:flags ->
    let hasSubstitutions = body.some((part) => part.type === "Substitution")

    if (hasSubstitutions) {
      const result = [
        {...open, token: "RegExp(`"},
        // Escape backticks, backslashes, and '$' in the body text
        body.map(e => e.type === "Substitution"
          ? e
          : {
            ...e,
            token: e.token.replace(/`|\\|\$/g, "\\$&"),
          }
        ),
        "`"
      ]

      if (flags.length) {
        result.push(
          ", ",
          JSON.stringify(flags)
        )
      }
      result.push( {...close, token: ")" })
      return result
    }

    return $0

HeregexBody
  !TripleSlash HeregexPart* -> $2

HeregexPart
  RegularExpressionClass

  CoffeeStringSubstitution -> { type: "Substitution", children: $1 }
  TemplateSubstitution -> { type: "Substitution", children: $1 }

  /(?:\\.)/ ->
    let token = $0
    switch ($0[1]) {
      case "\n": token = "\\n"; break
      case "\r": token = "\\r"; break
      case " ": token =   " "; break
    }
    return { $loc, token }

  HeregexComment ->
    return { $loc, token: "" }
  # NOTE: CoffeeScript strips out all unescaped whitespace chars
  # but Python doesn't strip out whitespace inside character classes
  # or inside '(?' groups and assertions
  # TODO: this behavior should be toggled by a coffeeCompat directive
  /[\s]+/ ->
    return { $loc, token: "" }
  # Escape forward slashes (that aren't part of a triple slash)
  /\/(?!\/\/)/ ->
    return { $loc, token: "\\/" }
  /[^\/\s#\\]+/ ->
    return { $loc, token: $0 }

HeregexComment
  # NOTE: CoffeeScript doesn't treat JS comments as regex comments
  # TODO: this behavior should be toggled by a coffeeCompat directive
  JSSingleLineComment
  CoffeeSingleLineComment

# https://262.ecma-international.org/#prod-RegularExpressionBody
# NOTE: Simplified a little from the spec, ignoring <PS>, <LS>
RegularExpressionBody
  ![*\/\r\n] RegExpCharacter*

RegExpCharacter
  /(?:\\.|[^\/\r\n])+/

# https://262.ecma-international.org/#prod-RegularExpressionFlags
RegularExpressionFlags
  /(?:\p{ID_Continue}|[\u200C\u200D$])*/

# https://262.ecma-international.org/#prod-TemplateLiteral
# NOTE: Simplified template grammar
TemplateLiteral
  TripleTick ( TemplateBlockCharacters / TemplateSubstitution )* TripleTick ->
    return module.dedentBlockSubstitutions($0)

  Backtick ( TemplateCharacters / TemplateSubstitution )* Backtick

# NOTE: Simplified grammar
TemplateSubstitution
  SubstitutionStart ExtendedExpression __ CloseBrace

# https://262.ecma-international.org/#prod-TemplateCharacter
TemplateCharacters
  /(?:\$(?!\{)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

TemplateBlockCharacters
  /(?:\$(?!\{)|`(?!``)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#sec-comments
ReservedWord
  CoffeeBooleansEnabled /(?:on|off|yes|no)(?!\p{ID_Continue})/
  CoffeeIsntEnabled /(?:isnt)(?!\p{ID_Continue})/
  CoffeeForLoopsEnabled /(?:by)(?!\p{ID_Continue})/
  CoffeeOfEnabled /(?:of)(?!\p{ID_Continue})/
  # NOTE: Added `let`, Civet assumes strict mode
  /(?:and|as|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|import|in|instanceof|interface|is|let|loop|new|null|or|return|static|super|switch|this|throw|true|try|typeof|unless|until|var|void|while|with|yield)(?!\p{ID_Continue})/

# https://262.ecma-international.org/#sec-comments
Comment
  MultiLineComment
  SingleLineComment

SingleLineComment
  JSSingleLineComment
  CoffeeCommentEnabled CoffeeSingleLineComment

JSSingleLineComment
  # JS Comments are two slashes not followed by a third (because that is a heregex)
  /\/\/(?!\/)[^\r\n]*/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#prod-MultiLineComment
MultiLineComment
  JSMultiLineComment
  # NOTE: Added CoffeeScript style ### multiline comments
  CoffeeMultiLineComment

JSMultiLineComment
  $( "/*" (!"*/" . )* "*/" ) ->
    return { $loc, token: $1 }

CoffeeSingleLineComment
  # NOTE: CoffeeScript style single line comments
  /#(?!##(?!#))([^\r\n]*)/ ->
    return { $loc, token: `//${$1}` }

CoffeeMultiLineComment
  CoffeeHereCommentStart $( !(CoffeeHereCommentStart / "*/") . )* CoffeeHereCommentStart ->
    return { $loc, token: `/*${$2}*/` }

CoffeeHereCommentStart
  /###(?!#)/

# InlineComment is a multi-line comment with no line separators
InlineComment
  $( "/*" $(!"*/" [^\r\n] )* "*/" ) ->
    return { $loc, token: $1 }

RestOfLine
  (NonNewlineWhitespace / SingleLineComment / MultiLineComment)* EOL

TrailingComment
  (NonNewlineWhitespace / InlineComment / SingleLineComment)

# Non-newline "white space" (includes comments)
# TODO: JS counts line terminators that appear in multi-line comments. For example "return /*\n*/5" is different than "return /**/ 5" because of the newline within the comment
# NOTE: Maybe Comment should only be single line comments here?
_
  (NonNewlineWhitespace / Comment)+

NonNewlineWhitespace
  [ \t]+ ->
    return { $loc, token: $0 }
  CoffeeLineContinuationEnabled "\\" EOL -> ""

# Optional whitespace including newlines and comments
__
  # Fast path for whitespace without comments
  # /(?!(?=\s|#|\/\/|\/\*))|[\s]+(?!(?:#|\/\/|\/\*))/ ->
  #   return [{ $loc, token: $0 }]
  ( Whitespace / Comment )*

Whitespace
  [\s]+ ->
    return { $loc, token: $0 }

# Fake a blocklike form for single expressions
ExpressionDelimiter
  TrailingComment* Semicolon TrailingComment* ->
    $2.token = ","
    return $0
  &EOS ->
    return { $loc, token: "," }

StatementDelimiter
  TrailingComment* Semicolon TrailingComment*
  &EOS

NonIdContinue
  /(?!\p{ID_Continue})/

Loc
  "" ->
    return { $loc, token: "" }

## Tokens

Ampersand
  "&" ->
    return { $loc, token: $1 }

As
  "as" NonIdContinue ->
    return { $loc, token: $1 }

At
  "@" ->
    return { $loc, token: $1 }

# hack for experimentalDecorators
# Since `@` is premium real estate we use `@@` for decorators with all the shame that entails.
AtAt
  "@@" ->
    return { $loc, token: "@" }

Async
  "async" ->
    return { $loc, token: $1 }

Await
  "await" NonIdContinue ->
    return { $loc, token: $1 }

Backtick
  "`" ->
    return { $loc, token: $1 }

By
  "by" NonIdContinue ->
    return { $loc, token: $1 }

Case
  "case" NonIdContinue ->
    return { $loc, token: $1 }

Catch
  "catch" ->
    return { $loc, token: $1 }

Class
  "class" ->
    return { $loc, token: $1 }

CloseBrace
  "}" ->
    return { $loc, token: $1 }

CloseBracket
  "]" ->
    return { $loc, token: $1 }

CloseParen
  ")" ->
    return { $loc, token: $1 }

CoffeeSubstitutionStart
  "#{" ->
    return { $loc, token: "${" }

Colon
  ":" ->
    return { $loc, token: $1 }

Comma
  "," ->
    return { $loc, token: $1 }

ConstructorShorthand
  "@" ->
    return { $loc, token: "constructor" }

Default
  "default" NonIdContinue ->
    return { $loc, token: $1 }

Delete
  "delete" NonIdContinue ->
    return { $loc, token: $1 }

Do
  "do" NonIdContinue ->
    return { $loc, token: $1 }

Dot
  "." ->
    return { $loc, token: $1 }

DotDot
  ".." ->
    return { $loc, token: $1 }

DotDotDot
  "..." ->
    return { $loc, token: $1 }

DoubleColon
  "::" ->
    return { $loc, token: $1 }

DoubleQuote
  "\"" ->
    return { $loc, token: $1 }

Else
  "else" ->
    return { $loc, token: $1 }

Equals
  "=" ->
    return { $loc, token: $1 }

Export
  "export" NonIdContinue ->
    return { $loc, token: $1 }

For
  "for" NonIdContinue ->
    return { $loc, token: $1 }

From
  "from" NonIdContinue ->
    return { $loc, token: $1 }

Function
  "function" ->
    return { $loc, token: $1 }

GetOrSet
  ( "get" / "set" ) NonIdContinue ->
    return { $loc, token: $1 }

If
  # NOTE: Pull a single space into the 'if ' token so if it is replaced
  # with a ternary in expressions it doesn't add an extra space
  $("if" " "?) ->
    return { $loc, token: $1 }

Import
  # NOTE: this is a hack so import.meta will parse correctly
  "import" &/\s/ ->
    return { $loc, token: $1 }

In
  "in" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-LetOrConst
LetOrConst
  ( "let" / "const" ) NonIdContinue ->
    return { $loc, token: $1 }

Loop
  # NOTE: loop becomes while
  "loop" NonIdContinue ->
    return { $loc, token: "while(true)" }

New
  "new" NonIdContinue ->
    return { $loc, token: $1 }

Not
  # Not keyword only active in compat mode
  CoffeeNotEnabled "not" NonIdContinue " "? ->
    return { $loc, token: "!" }

Of
  "of" ->
    return { $loc, token: $1 }

OpenBrace
  "{" ->
    return { $loc, token: $1 }

OpenBracket
  "[" ->
    return { $loc, token: $1 }

OpenParen
  "(" ->
    return { $loc, token: $1 }

QuestionMark
  "?" ->
    return { $loc, token: $1 }

Return
  "return" NonIdContinue ->
    return { $loc, token: $1 }

Semicolon
  ";" ->
    return { $loc, token: $1 }

SingleQuote
  "'" ->
    return { $loc, token: $1 }

Star
  "*" ->
    return { $loc, token: $1 }

Static
  "static" ->
    return { $loc, token: $1 }
  # NOTE: In ClassElements @ is a shorthand for 'static'
  # NOTE: added negative assertion to prevent overlapping constructor shorthand and `@@` decorator syntax
  "@" !( "(" / "@" ) ->
    return { $loc, token: "static " }

SubstitutionStart
  "${" ->
    return { $loc, token: $1 }

Switch
  "switch" NonIdContinue ->
    return { $loc, token: $1 }

Target
  "target" NonIdContinue ->
    return { $loc, token: $1 }

Then
  # TODO: comments/whitespace get lost here
  __ "then" NonIdContinue ->
    return { $loc, token: "" }

This
  "this" NonIdContinue ->
    return { $loc, token: $1 }

Throw
  "throw" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: These become a single backtick
TripleDoubleQuote
  "\"\"\"" ->
    return { $loc, token: "`" }

# NOTE: These become a single backtick
TripleSingleQuote
  "'''" ->
    return { $loc, token: "`" }

# Used in Heregex
TripleSlash
  "///" ->
    return { $loc, token: '/' }

TripleTick
  "```" ->
    return { $loc, token: "`" }

Try
  "try" NonIdContinue ->
    return { $loc, token: $1 }

Typeof
  "typeof" NonIdContinue ->
    return { $loc, token: $1 }

Unless
  "unless" NonIdContinue ->
    return { $loc, token: $1 }

Until
  "until" NonIdContinue ->
    return { $loc, token: $1 }

Var
  "var" NonIdContinue ->
    return { $loc, token: $1 }

Void
  "void" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: When maps to 'case'
When
  "when" NonIdContinue ->
    return { $loc, token: "case" }

While
  "while" NonIdContinue ->
    return { $loc, token: $1 }

Yield
  "yield" NonIdContinue ->
    return { $loc, token: $1 }

## JSX

# https://facebook.github.io/jsx/#prod-JSXElement
JSXElement
  JSXSelfClosingElement
  JSXOpeningElement JSXChildren? __ JSXClosingElement ->
    // Check that tags match
    if ($1[1] !== $4[2]) return $skip
    return $0
  # NOTE: c1 matches "same-line" children, while c2 matches indented children
  JSXOpeningElement:open (_ / JSXChild)*:c1 JSXNestedChildren:c2 InsertNewline InsertIndent ->
    if (c1.length || c2.length) {
      return [...$0, ["</", open[1], ">"]]
    } else {
      return [open.slice(0, -1), " />"]
    }
  JSXOpeningElement ->
    throw new Error(`could not parse JSX element "${require('./generate')($0)}" at pos ${$loc.pos}`)

# https://facebook.github.io/jsx/#prod-JSXSelfClosingElement
JSXSelfClosingElement
  "<" $JSXElementName JSXAttributes? __ "/>"

# https://facebook.github.io/jsx/#prod-JSXOpeningElement
JSXOpeningElement
  "<" $JSXElementName JSXAttributes? __ ">"

# https://facebook.github.io/jsx/#prod-JSXClosingElement
JSXClosingElement
  "</" __ $JSXElementName __ ">"

# https://facebook.github.io/jsx/#prod-JSXFragment
JSXFragment
  "<>" JSXChildren? "</>"
  "<>" JSXNestedChildren InsertNewline InsertIndent ->
    return [...$0, "</>"]

# https://facebook.github.io/jsx/#prod-JSXElementName
JSXElementName
  # Merged in https://facebook.github.io/jsx/#prod-JSXNamespacedName
  # Merged in https://facebook.github.io/jsx/#prod-JSXMemberExpression
  JSXIdentifierName ( (Colon JSXIdentifierName) / ( Dot JSXIdentifierName )* )

# NOTE: Like IdentifierName but includes hyphens after start
# NOTE: Combined from recursive https://facebook.github.io/jsx/#prod-JSXIdentifier definition
JSXIdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$-])*/

# https://facebook.github.io/jsx/#prod-JSXAttributes
JSXAttributes
  ( __ JSXAttribute )*

# NOTE: Merged SpreadAttribute and Attribute
JSXAttribute
  # https://facebook.github.io/jsx/#prod-JSXSpreadAttribute
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  OpenBrace __ DotDotDot ExtendedExpression __ CloseBrace

  # https://facebook.github.io/jsx/#prod-JSXAttribute
  JSXAttributeName JSXAttributeInitializer?

# https://facebook.github.io/jsx/#prod-JSXAttributeName
JSXAttributeName
  # NOTE: Merged JSXIdentifier and JSXNamespacedName
  JSXIdentifierName ( Colon JSXIdentifierName )?

# https://facebook.github.io/jsx/#prod-JSXAttributeInitializer
JSXAttributeInitializer
  __ Equals __ JSXAttributeValue

# https://facebook.github.io/jsx/#prod-JSXAttributeValue
JSXAttributeValue
  # https://facebook.github.io/jsx/#prod-JSXDoubleStringCharacters
  /"[^"]*"/
  # https://facebook.github.io/jsx/#prod-JSXSingleStringCharacters
  /'[^']*'/
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  OpenBrace ExtendedExpression __ CloseBrace
  JSXElement
  JSXFragment

# https://facebook.github.io/jsx/#prod-JSXChildren
JSXChildren
  ( __ JSXChild )*

JSXNestedChildren
  PushIndent ( Nested JSXChild+ )* PopIndent ->
    if ($2.length) return $2
    return $skip
  &EOS ->
    return []

# https://facebook.github.io/jsx/#prod-JSXChild
JSXChild
  JSXText
  JSXElement
  JSXFragment
  OpenBrace JSXChildExpression? __ CloseBrace

# https://facebook.github.io/jsx/#prod-JSXText
JSXText
  # NOTE: not currently excluding https://facebook.github.io/jsx/#prod-HTMLCharacterReference
  # NOTE: Additionally forbidding leading whitespace, so it can be used for
  # indentation (by JSXNestedChildren) or ignored by JSXChildren,
  # and newlines which we leave for the next indentation.
  [^{}<>\r\n]+

# https://facebook.github.io/jsx/#prod-JSXChildExpression
JSXChildExpression
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  __ ( DotDotDot __ )? ExtendedExpression

## Type Stuff

TypeDeclaration
  (TypeDeclarationModifier TrailingComment*)* TypeDeclarationRest -> { ts: true, children: $0 }

TypeDeclarationModifier
  "declare" NonIdContinue
  Export

TypeDeclarationRest
  TypeKeyword TrailingComment* IdentifierName TypeParameters? __ Equals __ Type
  Interface   TrailingComment* IdentifierName TypeParameters? InterfaceBlock
  Namespace   TrailingComment* IdentifierName NamespaceBlock
  FunctionSignature

TypeKeyword
  "type" NonIdContinue

Interface
  "interface" NonIdContinue

Namespace
  "namespace" NonIdContinue

InterfaceBlock
  __ OpenBrace NestedInterfaceProperties __ CloseBrace
  __ OpenBrace ( __ InterfaceProperty )* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedInterfaceProperties InsertNewline InsertIndent InsertCloseBrace

NestedInterfaceProperties
  PushIndent NestedInterfaceProperty*:props PopIndent ->
    if (props.length) return props
    return $skip

NestedInterfaceProperty
  Nested InterfaceProperty

InterfaceProperty
  ( TypeIndexSignature / PropertyName ) TypeSuffix InterfacePropertyDelimiter
  NonEmptyParameters TypeSuffix InterfacePropertyDelimiter
  MethodSignature InterfacePropertyDelimiter

InterfacePropertyDelimiter
  _* ( Semicolon / Comma )
  &( __ CloseBrace )
  &EOS

NamespaceBlock
  __ OpenBrace NestedTypeDeclarations __ CloseBrace
  __ OpenBrace ( __ TypeDeclaration InterfacePropertyDelimiter)* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedTypeDeclarations InsertNewline InsertIndent InsertCloseBrace

NestedTypeDeclarations
  PushIndent NestedTypeDeclaration*:decs PopIndent ->
    if (decs.length) return decs
    return $skip

NestedTypeDeclaration
  Nested TypeDeclaration InterfacePropertyDelimiter

TypeIndexSignature
  ( [+-]? "readonly" __ )? OpenBracket TypeIndex CloseBracket ( __ [+-] QuestionMark )?

TypeIndex
  __ Identifier TypeSuffix
  __ PropertyName __ In Type ( __ As Type )?

TypeSuffix
  QuestionMark? __ Colon Type -> {
    type: "TypeSuffix",
    ts: true,
    children: $0
  }

ReturnTypeSuffix
  __ Colon ( __ "asserts" NonIdContinue )? TypePredicate ->
    const children = [...$1, $2]
    if ($3) children./**/push($3)
    children./**/push($4)

    return {
      type: "ReturnTypeAnnotation",
      children,
      ts: true,
    }

TypePredicate
  Type ( __ "is" NonIdContinue Type )? ->
    if (!$2) return $1
    return $0

Type
  TypeConditional

TypeBinary
  TypeUnary (__ TypeBinaryOp __ TypeUnary)* ->
    if ($2.length) return $0
    return $1

TypeUnary
  ( __ TypeUnaryOp NonIdContinue )* TypePrimary TypeUnarySuffix* ->
    return [...$1, $2, ...$3]

TypeUnarySuffix
  TypeIndexedAccess
  QuestionMark

TypeUnaryOp
  "keyof"
  "typeof"
  "infer"
  "readonly"

TypeIndexedAccess
  __ OpenBracket Type? __ CloseBracket

TypePrimary
  InterfaceBlock
  __ OpenParen Type __ CloseParen
  __ TypeTuple
  _* FunctionType
  _* TypeLiteral
  _* IdentifierName (Dot IdentifierName)* TypeArguments?

TypeTuple
  OpenBracket NestedTypeList __ CloseBracket
  OpenBracket TypeList? __ CloseBracket

TypeList
  Type (__ Comma Type)*

NestedTypeList
  PushIndent NestedType*:types PopIndent ->
    if (types.length)
      return types
    return $skip

NestedType
  Nested Type ArrayElementDelimiter

TypeConditional
  TypeBinary ( __ "extends" Type ( __ QuestionMark Type __ Colon Type )? )? ->
    if ($2) return $0
    return $1

TypeLiteral
  Literal
  TemplateLiteral
  "void" ->
    return { $loc, token: "void" }
  "[]" ->
    return { $loc, token: "[]" }

TypeBinaryOp
  "|" ->
    return { $loc, token: "|" }
  "&" ->
    return { $loc, token: "&" }

FunctionType
  Parameters __ "=>" Type

TypeArguments
  __ "<" __ Type (__ Comma __ Type)* (__ Comma)? __ ">"

TypeParameters
  __ "<" __ Type (__ Comma __ Type)* (__ Comma)? __ ">" ->
    return { ts: true, children: $0 }

TypeParameter
  __ Identifier TypeConstraint? TypeParameterDelimiter

TypeConstraint
  __ "extends" Type

TypeParameterDelimiter
  _* Comma
   # NOTE: Don't insert comma before inline closing angle bracket
  &( _* ">" )
  # NOTE: Do insert comma before closing angle bracket on following line
  &( __ ">" ) ->
    return { $loc, token: "," }
  &EOS ->
    return { $loc, token: "," }

## Utility

Shebang
  /#![^\r\n]*/ EOL

CivetPrologue
  [\t ]* DoubleQuote CivetPrologueContent:content DoubleQuote $StatementDelimiter EOS -> content
  [\t ]* SingleQuote CivetPrologueContent:content SingleQuote $StatementDelimiter EOS -> content

CivetPrologueContent
  "civet" CivetOption*:options [\s]* ->
    return {
      type: "CivetPrologue",
      children: [],
      config: Object.fromEntries(options),
    }

CivetOption
  /\s+([+-]?)([a-zA-Z0-9-]+)(\s*=\s*([a-zA-Z0-9.+-]*))?/ ->
    // Normalize option names to camelCase
    const optionName = $2.replace(/-+([a-z]?)/g, (_, l) => {
      if (l) return l.toUpperCase()
      return ""
    })
    // - is disabled, + is enabled, no prefix is enabled
    // =value sets the value to any value (used for `tab`)
    let value =
      $3 ? $4 : ($1 === "-") ? false : true
    // Some options are automatically converted to numbers
    if (optionName === "tab") {
      value = parseFloat(value)
      if (isNaN(value)) value = 0
    }

    return [optionName, value]

UnknownPrologue
  # NOTE: $ is to keep source verbatim and not insert a semicolon if one was omitted
  # Can't use $EOS because it will prevent re-writing of coffee style comments
  [\t ]* BasicStringLiteral:s $StatementDelimiter EOS

DirectivePrologue
  CivetPrologue
  UnknownPrologue

EOS
  RestOfLine+

# End of line, including EOF
EOL
  /\r\n|\n|\r|$/ ->
    return { $loc, token: $0 }

Debugger
  "" ->
    debugger

# Insertions

InsertOpenParen
  "" ->
    return { $loc, token: "(" }

InsertCloseParen
  "" ->
    return { $loc, token: ")" }

InsertOpenBrace
  # NOTE: Includes a preceding space
  "" ->
    return [{ $loc, token: " " }, { $loc, token: "{" } ]

InsertInlineOpenBrace
  "" ->
    return [{ $loc, token: "{" } ]

InsertCloseBrace
  "" ->
    return { $loc, token: "}" }

InsertConst
  # NOTE: Includes a trailing space
  "" ->
    return { $loc, token: "const " }

InsertReadonly
  # NOTE: Includes a trailing space
  "" ->
    return { ts: true, children: [ { $loc, token: "readonly " } ] }

InsertNewline
  "" ->
    return "\n"

InsertIndent
  "" ->
    return module.currentIndent.token

InsertSpace
  "" ->
    return { $loc, token: " " }

InsertDot
  "" ->
    return { $loc, token: "." }

InsertBreak
  "" ->
    return { $loc, token: ";break;" }

InsertVar
  "" ->
    return { $loc, token: "var " }

CoffeeBinaryExistentialEnabled
  "" ->
    if(module.config.coffeeBinaryExistential) return
    return $skip

CoffeeBooleansEnabled
  "" ->
    if(module.config.coffeeBooleans) return
    return $skip

CoffeeClassesEnabled
  "" ->
    if(module.config.coffeeClasses) return
    return $skip

CoffeeCommentEnabled
  "" ->
    if(module.config.coffeeComment) return
    return $skip

CoffeeDoEnabled
  "" ->
    if(module.config.coffeeDo) return
    return $skip

CoffeeForLoopsEnabled
  "" ->
    if(module.config.coffeeForLoops) return
    return $skip

CoffeeInterpolationEnabled
  "" ->
    if(module.config.coffeeInterpolation) return
    return $skip

CoffeeIsntEnabled
  "" ->
    if(module.config.coffeeIsnt) return
    return $skip

CoffeeLineContinuationEnabled
  "" ->
    if(module.config.coffeeLineContinuation) return
    return $skip

CoffeeNotEnabled
  "" ->
    if(module.config.coffeeNot) return
    return $skip

CoffeeOfEnabled
  "" ->
    if(module.config.coffeeOf) return
    return $skip

# Reset module level data
Reset
  "" ->
    // Storage for PushIndent/PopIndent
    module.indentLevels = [{
      level: 0,
      token: "",
    }]

    if (!module._init) {
      module._init = true
      Object.defineProperties(module, {
        currentIndent: {
          get() {
            return module.indentLevels[module.indentLevels.length-1]
          },
        }
      })
    }

    module.config = parse.config = {
      autoVar: false,
      coffeeBinaryExistential: false,
      coffeeBooleans: false,
      coffeeClasses: false,
      coffeeComment: false,
      coffeeDo: false,
      coffeeEq: false,
      coffeeForLoops: false,
      coffeeInterpolation: false,
      coffeeIsnt: false,
      coffeeLineContinuation: false,
      coffeeNot: false,
      coffeeOf: false,
      implicitReturns: true,
      tab: undefined, // default behavior = same as space
      verbose: false,
    }

    let indexOfRef, hasPropRef, spliceRef
    const asAny = {
      ts: true,
      children: [" as any"]
    }
    module.prelude = []

    module.getSpliceRef = function () {
      if (spliceRef) return spliceRef

      spliceRef = {
        type: "Ref",
        base: "splice",
        id: "splice",
      }

      return spliceRef
    }

    module.getIndexOfRef = function() {
      if (indexOfRef) return indexOfRef

      indexOfRef = {
        type: "Ref",
        base: "indexOf",
        id: "indexOf",
      }

      const typeSuffix = {
        ts: true,
        children: [": <T>(this: T[], searchElement: T) => boolean"]
      }
      // [indent, statement]
      module.prelude.push(["", ["const ", indexOfRef, typeSuffix, " = [].indexOf", asAny, "\n"]])

      return indexOfRef
    }

    module.getHasPropRef = function() {
      if (hasPropRef) return hasPropRef

      hasPropRef = {
        type: "Ref",
        base: "hasProp",
        id: "hasProp",
      }

      const typeSuffix = {
        ts: true,
        children: [": <T>(this: T, prop: keyof T) => boolean"]
      }
      // [indent, statement]
      module.prelude.push(["", ["const ", hasPropRef, typeSuffix, " = {}.hasOwnProperty", asAny, "\n"]])

      return hasPropRef
    }

    // Expand setting coffeeCompat to the individual options
    Object.defineProperty(module.config, "coffeeCompat", {
      set(b) {
        if (b) {
          this.autoVar = true
          this.coffeeBinaryExistential = true
          this.coffeeBooleans = true
          this.coffeeClasses = true
          this.coffeeComment = true
          this.coffeeDo = true
          this.coffeeEq = true
          this.coffeeForLoops = true
          this.coffeeInterpolation = true
          this.coffeeIsnt = true
          this.coffeeLineContinuation = true
          this.coffeeNot = true
          this.coffeeOf = true
        } else {
          this.autoVar = false
          this.coffeeBinaryExistential = false
          this.coffeeBooleans = false
          this.coffeeClasses = false
          this.coffeeComment = false
          this.coffeeDo = false
          this.coffeeEq = false
          this.coffeeForLoops = false
          this.coffeeInterpolation = false
          this.coffeeIsnt = false
          this.coffeeLineContinuation = false
          this.coffeeNot = false
          this.coffeeOf = false
        }
      }
    })

    // TODO: this is only here because directive prologues depend on it
    // eventually all these `module.*` variables should be handled better in Hera
    // Adjust a parsed string by escaping newlines
    module.modifyString = function(str) {
      // Replace non-escaped newlines with escaped newlines
      // taking into account the possibility of a preceding escaped backslash
      return str.replace(/(^.?|[^\\]{2})(\\\\)*\n/g, '$1$2\\n')
    }

Init
  Shebang? DirectivePrologue*:directives "" ->
    directives.forEach((directive) => {
      if (directive.type === "CivetPrologue") {
        Object.assign(module.config, directive.config)
      }
    })

    module.expressionizeIfClause = function(clause, b, e) {
      const children = clause.children.slice(1) // Remove 'if'
      children./**/push("?", b) // Add ternary
      if (e) {
        // Remove 'else'
        children./**/push(e[0], ":", ...e.slice(2))
      }
      else {
        children.push(":void 0")
      }

      return {
        type: "IfExpression",
        children,
      }
    }

    module.addPostfixStatement = function(statement, ws, post) {
      let children, expressions
      if (post.blockPrefix?.length) {
        let indent = post.blockPrefix[0][0]
        expressions = [...post.blockPrefix, [indent, statement]]
        children = [" {\n", ...expressions, "\n", indent?.slice?.(0, -2), "}"]
      } else {
        expressions = [["", statement]]
        children = [" { ", ...expressions, " }"]
      }

      const block = {
        type: "BlockStatement",
        children,
        expressions,
      }

      children = [...post.children]
      children./**/push(block)

      // This removes trailing whitespace for easier testing
      if (!module.isWhitespaceOrEmpty(ws)) children./**/push(ws)

      return Object.assign({}, post, {
        children,
        block
      })
    }

    function expressionizeIteration(exp) {
      const resultsRef = {
        type: "Ref",
        base: "results",
        id: "results",
      }

      // insert `results.push` to gather results array
      insertPush(exp.block, resultsRef)
      // Wrap with IIFE
      exp.children = ["(", resultsRef, "=>{", ...exp.children, "; return ", resultsRef, "})([])"]
    }

    function wrapIterationReturningResults(statement, outerRef) {
      const resultsRef = {
        type: "Ref",
        base: "results",
        id: "results",
      }

      const declaration = {
        type: "Declaration",
        children: ["const ", resultsRef, "=[];"],
      }

      insertPush(statement.block, resultsRef)

      statement.children.unshift(declaration)
      if (outerRef) {
        statement.children.push(";", outerRef, ".push(", resultsRef, ");")
      } else {
        statement.children.push(";return ", resultsRef, ";")
      }
    }

    // NOTE: this is almost the same as insertReturn but doesn't remove `breaks` in `when` and
    // does construct an else clause pushing undefined in if statements that lack them
    // and adds to the beginning and the end of the expression's children.
    // Maybe these insertion modifications can be refactored to be more DRY eventually.
    function insertPush(node, ref) {
      if (!node) return
      // TODO: unify this with the `exp` switch
      switch (node.type) {
        case "AssignmentExpression":
          node.children.unshift(ref, ".push(")
          node.children.push(")")
          return
        case "Identifier":
          node.children.unshift(ref, ".push(")
          node.children.push(")")
          return
        case "BlockStatement":
          insertPush(node.expressions[node.expressions.length - 1], ref)
          return
        case "ObjectBindingPattern":
        case "ObjectExpression":
          module.insertTrimmingSpace(node.children[0], "")
          node.children.unshift(ref, ".push(")
          node.children.push(")")
          return
        case "CaseBlock":
          node.clauses.forEach((clause) => {
            insertPush(clause, ref)
          })
          return
        case "CaseClause":
          // Don't adjust case clauses
          return
        case "WhenClause":
          insertPush(node.expressions[node.expressions.length - 1], ref)
          return
        case "DefaultClause":
          insertPush(node.expressions[node.expressions.length - 1], ref)
          return
      }
      if (!Array.isArray(node)) return

      const [, exp] = node
      if (!exp) return

      let indent = node[0]
      // Hacky way to get the indent of the last expression
      if (Array.isArray(indent)) indent = indent[indent.length - 1]

      switch (exp.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "EmptyStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "Declaration":
          return
        case "ForStatement":
        case "IterationStatement":
          wrapIterationReturningResults(exp, ref)
          return
        case "BlockStatement":
          insertPush(exp.expressions[exp.expressions.length - 1], ref)
          return
        case "IfStatement":
          // if block
          insertPush(exp.children[2], ref)
          // else block
          if (exp.children[3]) insertPush(exp.children[3][2], ref)
          // Add else block pushing undefined if no else block
          else exp.children.push([" else {\n", indent, ref, ".push(undefined)\n", indent, "}"])
          return
        case "SwitchStatement":
          // insert a results.push in each case block
          insertPush(exp.children[2], ref)
          return
        case "TryStatement":
          // try block
          insertPush(exp.children[1], ref)
          // catch block
          if (exp.children[2]) insertPush(exp.children[2][2], ref)
          // NOTE: CoffeeScript doesn't add a push to an empty catch block but does add if there is any statement in the catch block
          // NOTE: do not insert a push in the finally block
          return
      }

      // Insert push wrapping expression
      node.splice(1, 0, ref, ".push(")
      node.push(")")
    }

    // [indent, statement, semicolon]
    function insertReturn(node) {
      if (!node) return
      // TODO: unify this with the `exp` switch
      switch (node.type) {
        case "AssignmentExpression":
          node.children.unshift("return ")
          return
        case "Identifier":
          // TODO: It may be better to wrap/insert a node
          node.children.unshift("return ")
          return
        case "BlockStatement":
          insertReturn(node.expressions[node.expressions.length - 1])
          return
        case "ObjectBindingPattern":
        case "ObjectExpression":
          module.insertTrimmingSpace(node.children[0], "")
          node.children.unshift("return ")
          return
        case "CaseBlock":
          node.clauses.forEach((clause) => {
            insertReturn(clause)
          })
          return
        case "CaseClause":
          // Don't adjust case clauses
          return
        case "WhenClause":
          // Remove inserted `break;`
          node.children.splice(node.children.indexOf(node.break), 1)
          if (node.expressions.length === 0) {
            node.expressions.push("return")
            return
          }
          insertReturn(node.expressions[node.expressions.length - 1])
          return
        case "DefaultClause":
          insertReturn(node.expressions[node.expressions.length - 1])
          return
      }
      if (!Array.isArray(node)) return

      const [, exp] = node
      let indent = node[0]
      // Hacky way to get the indent of the last expression
      if (Array.isArray(indent)) indent = indent[indent.length - 1]
      if (!exp) return

      switch (exp.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "EmptyStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "Declaration":
          return
        case "ForStatement":
        case "IterationStatement":
          wrapIterationReturningResults(exp)
          return
        case "BlockStatement":
          insertReturn(exp.expressions[exp.expressions.length - 1])
          return
        case "IfStatement":
          // if block
          insertReturn(exp.children[2])
          // else block
          if (exp.children[3]) insertReturn(exp.children[3][2])
          // Add explicit return after if block if no else block
          else exp.children.push(["\n", indent, "return"])
          return
        case "SwitchStatement":
          // insert a return in each case block
          insertReturn(exp.children[2])
          return
        case "TryStatement":
          // try block
          insertReturn(exp.children[1])
          // catch block
          if (exp.children[2]) insertReturn(exp.children[2][3])
          // NOTE: do not insert a return in the finally block
          return
      }

      // Insert return before expression
      node.splice(1, 0, "return ")
    }

    module.isWhitespaceOrEmpty = function(node) {
      if (!node) return true
      if (!node.length) return true
      if (typeof node === "string") return node.match(/^\s*$/)
      if (Array.isArray(node)) return node.every(module.isWhitespaceOrEmpty)
    }

    module.processBinaryOpExpression = function($0) {
      const expandedOps = module.expandChainedComparisons($0)

      // Expanded ops is [a, __, op1, __, b, __, op2, __, c, __, op3, __, d], etc.
      // NOTE: all operators of higher precedence than relational have been merged into the operand expressions
      let i = 2
      while (i < expandedOps.length) {
        const op = expandedOps[i]
        // a in b -> indexOf.call(b, a) >= 0
        // a not in b -> indexOf.call(b, a) < 0
        // a not instanceof b -> !(a instanceof b)
        if (op.special) {
          let [a, wsOp, op, wsB, b] = expandedOps.slice(i - 2, i + 3)

          let children
          if (op.ref) {
            wsOp = module.insertTrimmingSpace(wsOp, "")
            wsB = module.insertTrimmingSpace(wsB, "")

            children = [wsOp, op.ref, ".call(", wsB, b, ", ", a, ")", op.suffix]
          } else if (op.token === "instanceof" || op.token === "in") { // `not instanceof` / `not of`
            children = ["!(", a, wsOp, op, wsB, b, ")"]
          } else {
            throw new Error("Unknown operator: " + JSON.stringify(op))
          }

          expandedOps.splice(i - 2, 5, {
            children
          })
        } else {
          i += 4
        }
      }

      return expandedOps
    }

    /**
    * binops is an array of [__, op, __, exp] tuples
    * first is an expression
    */
    module.expandChainedComparisons = function([first, binops]) {
      // TODO: add refs to ensure middle expressions are evaluated only once

      // all relational operators could be chained in theory, including in and instanceof
      const relationalOps = ["==", "===", "!=", "!==", "<", "<=", ">", ">=", "in", "instanceof"]

      // short circuit/bitwise ops have lower precedence than comparison ops
      // so we only need to look for chains in the sections between them
      const lowerPrecedenceOps = ["??", "&&", "||", "&", "|", "^"]

      // shift/arithmetic ops have higher precedence, they will bind to expressions inside the chains
      // const higherPrecedenceOps = ["<<", ">>", ">>>", "+", "-", "*", "**", "/", "%"]

      let results = []

      let i = 0
      let l = binops.length

      let start = 0
      // indexes of chainable ops
      let chains = []
      while (i < l) {
        const [, op] = binops[i]

        // NOTE: coffee `in` and `not in` are ops that use a ref to indexOf. They are our only ref ops so far and they are both relational.
        if (relationalOps.includes(op.token) || op.ref) {
          chains.push(i)
        } else if (lowerPrecedenceOps.includes(op.token)) {
          // end of the chain
          processChains()
          first = []
        }

        i++
      }

      processChains()

      return results

      function processChains() {
        if (chains.length > 1) {
          chains.forEach((index, k) => {
            if (k > 0) {
              // NOTE: Inserting ws tokens to keep even operator spacing in the resulting array
              results.push(" ", "&&", " ")
            }
            const [pre, op, post, exp] = binops[index]

            let endIndex
            if (k < chains.length - 1) {
              endIndex = chains[k + 1]
            } else {
              endIndex = i + 1
            }

            results = results.concat(first, ...binops.slice(start, endIndex))
            first = [exp].concat(binops.slice(index + 1, endIndex))
            start = endIndex
          })
        } else {
          // Advance start if there was no chain
          results = results.concat(first, ...binops.slice(start, i + 1))
          start = i + 1
        }

        chains.length = 0
      }
    }

    // Return an array of Rule names that correspond to the current call stack
    module.parsePosition = function() {
      let s = Error().stack.split(/\n    at /)
      s./**/shift()
      s = s.filter((e) => !e.match(/^eval/)).map((e) => e.split(' ')[0])
      s = s.slice(1, s.indexOf('Program') + 1)

      return s
    }

    module.prune = function(node) {
      if(node === null || node === undefined) return
      if(node.length === 0) return

      if (Array.isArray(node)) {
        const a = node
        .map((n) => module.prune(n))
        .filter((n) => !!n)

        if(a.length > 1)  return a
        if(a.length === 1) return a[0]
        return
      }

      if(node.children != null) {
        node.children = module.prune(node.children)
        return node
      }

      return node
    }

    // Trims the first single space from the spacing array or node's children if present
    // maintains $loc for source maps
    module.insertTrimmingSpace = function(target, c) {
      if (!target) return target

      if (Array.isArray(target)) return target.map((e, i) => {
        if (i === 0) return module.insertTrimmingSpace(e, c)
        return e
      })
      if (target.children) return Object.assign({}, target, {
        children: target.children.map((e, i) => {
          if (i === 0) return module.insertTrimmingSpace(e, c)
          return e
        })
      })

      if (target.token) return Object.assign({}, target, {
        token: target.token.replace(/^ ?/, c)
      })

      return target
    }

    // Split out leading newlines from the first indented line
    const initialSpacingRe = /^(?:\r?\n|\n)*((?:\r?\n|\n)\s+)/

    module.dedentBlockSubstitutions = function($0) {
      const [s, strWithSubstitutions, e] = $0

      if (strWithSubstitutions.length === 0) {
        return $0
      }

      let initialSpacing, i=0, l=strWithSubstitutions.length, results=[s]
      // Get initial spacing from the first string token if it is not a substitution
      const {token} = strWithSubstitutions[0]

      if (token) {
        initialSpacing = token.match(initialSpacingRe)
      } else {
        initialSpacing = false
      }

      while (i < l) {
        let segment = strWithSubstitutions[i]

        if (segment.token) {
          segment = module.dedentBlockString(segment, initialSpacing, false)
          if (i === 0) {
            // Trim leading newline
            segment.token = segment.token.replace(/^(\r?\n|\n)/, "")
          }
          if (i === l - 1) {
            // Trim trailing newline
            segment.token = segment.token.replace(/(\r?\n|\n)[ \t]*$/, "")
          }
          results.push(segment)
        } else {
          results.push(segment)
        }

        i++
      }

      results.push(e)
      return results
    }

    module.dedentBlockString = function({$loc, token: str}, spacing, trim=true) {
      // If string begins with a newline then indentation assume that it should be removed for all lines
      if (spacing == null) spacing = str.match(initialSpacingRe)

      if (spacing) {
        str = str.replaceAll(spacing[1], "\n")
        const l = spacing.length
        $loc.pos += l
        $loc.length -= l
      }

      if (trim) {
        // Remove leading newline
        str = str.replace(/^(\r?\n|\n)/, "")
        // Remove trailing newline
        .replace(/(\r?\n|\n)[ \t]*$/, "")
      }

      // escape backtick, $
      str = str.replace(/(`|\$\{)/g, "\\$1")

      return {
        $loc,
        token: str,
      }
    }

    module.reorderBindingRestProperty = function(rest, after) {
      // Swap delimiters of last property and rest so that an omitted trailing comma doesn't end up in the middle
      if (after.length) {
        const
          [restDelim]       = rest.children.slice(-1),
          lastAfterProp     = after[after.length - 1],
          lastAfterChildren = lastAfterProp.children,
          [lastDelim]       = lastAfterChildren.slice(-1)

        rest = {...rest, children: [...rest.children.slice(0, -1), lastDelim]}
        after = [...after.slice(0, -1), {...lastAfterProp, children: [...lastAfterChildren.slice(0, -1), restDelim]}]
      }

      return [rest, after]
    }

    // Gather child nodes that match a predicate
    // while recursing into nested expressions
    // without recursing into nested blocks/for loops
    function gatherNodes(node, predicate) {
      if (node == null) return []

      if (Array.isArray(node)) {
        return node.flatMap((n) => gatherNodes(n, predicate))
      }

      if (predicate(node)) {
        return [node]
      }

      switch(node.type) {
        case "BlockStatement":
          return []
        case "ForStatement":
          // Descend into expressions but not into declarations or the body of the for loop
          const isDec = node.declaration?.type === "Declaration"
          return node.children.flatMap((n) => {
            if (isDec && n === node.declaration) return []
            return gatherNodes(n, predicate)
          })
        default:
          return gatherNodes(node.children, predicate)
      }

      return []
    }

    // Gather nodes that match a predicate recursing into all unmatched children
    // i.e. if the predicate matches a node it is not recursed into further
    function gatherRecursive(node, predicate) {
      if (node == null) return []

      if (Array.isArray(node)) {
        // TODO: should this be `gatherRecursive`?
        return node.flatMap((n) => gatherNodes(n, predicate))
      }

      if (predicate(node)) {
        return [node]
      }

      // TODO: should this be `gatherRecursive`?
      return gatherNodes(node.children, predicate)
    }

    function gatherRecursiveAll(node, predicate) {
      if (node == null) return []

      if (Array.isArray(node)) {
        return node.flatMap((n) => gatherRecursiveAll(n, predicate))
      }

      const nodes = gatherRecursiveAll(node.children, predicate)
      if (predicate(node)) {
        nodes.push(node)
      }

      return nodes
    }

    function processParams(f) {
      const { parameters, block } = f
      if (!block) return
      const { expressions } = block
      if (!expressions) return
      const { blockPrefix } = parameters

      let indent
      if (!expressions.length) {
        indent = ""
      } else {
        indent = expressions[0][0]
      }

      const [splices, thisAssignments] = gatherBindingCode(parameters)

      const prefix = splices.map(s => ["let ", s]).concat(thisAssignments)
      .map((s) => [indent, s, ";\n"])

      expressions.unshift(...prefix)
    }

    // Adjusts @binding inside object properties that need to be aliased
    // see test/function.civet binding pattern
    function adjustAtBindings(statements, asThis=false) {
      gatherRecursiveAll(statements, n => n.type === "AtBindingProperty")
      .forEach(binding => {
        const { ref } = binding

        if (asThis) {
          // Convert from @x to x: this.x keeping any whitespace or initializer to the right
          const atBinding = binding.children[0]
          atBinding.children.pop()
          atBinding.type = undefined

          binding.children.unshift(ref.id, ": this.", ref.base)
          binding.type = "Property"
          binding.ref = undefined
          return
        }

        if (ref.names[0] !== ref.base) {
          binding.children.unshift(ref.base, ": ")
        }
      })
    }

    function processFunctions(statements) {
      gatherRecursiveAll(statements, n => {
        return (
          n.type === "FunctionExpression" ||
          n.type === "ArrowFunction"
        )
      })
      .forEach((f) => {
        processParams(f)
        const { block, returnType } = f
        if (module.config.implicitReturns) {
          const isVoid  = returnType  === "void"
          const isBlock = block?.type === "BlockStatement"
          if (!isVoid && isBlock) {
            insertReturn(block)
          }
        }
      })

      gatherRecursiveAll(statements, n => n.type === "MethodDefinition")
      .forEach((f) => {
        processParams(f)
        const {signature, block} = f
        if (module.config.implicitReturns) {
          const isConstructor = signature.name       === "constructor"
          const isVoid        = signature.returnType === "void"
          const isSet         = signature.modifier   === "set"

          if (!isConstructor && !isSet && !isVoid) {
            insertReturn(block)
          }
        }
      })
    }

    function processSwitchExpressions(statements) {
      if (module.config.implicitReturns) {
        // Add returns to SwitchExpressions
        gatherRecursiveAll(statements, n => n.type === "SwitchExpression")
        .forEach(({ block }) => {
          insertReturn(block)
        })
      }
    }

    function processBindingPatternLHS(lhs, tail) {
      // Expand AtBindings first before gathering splices
      adjustAtBindings(lhs, true)
      const [splices, thisAssignments] = module.gatherBindingCode(lhs)
      // TODO: This isn't quite right for compound assignments, may need to wrap with parens and use comma to return the complete value
      tail.push(...splices.map(s => [", ", s]), ...thisAssignments.map(a => [", ", a]))
    }

    function processAssignments(statements) {
      gatherRecursiveAll(statements, n => n.type === "AssignmentExpression" && n.names === null)
      .forEach(exp => {
        let {lhs: $1, exp: $2} = exp, tail = [], i = 0, len = $1.length

        // Force parens around destructuring object assignments
        // Walk from left to right the minimal number of parens are added and enclose all destructured assignments
        // TODO: Could validate some lhs ecmascript rules here if we wanted to
        let wrapped = false
        while (i < len) {
          const lastAssignment = $1[i++]
          const [,lhs,,op] = lastAssignment
          if (op.token !== "=") continue

          if (lhs.type === "ObjectExpression" || lhs.type === "ObjectBindingPattern") {
            // Wrap with parens to distinguish from braced blocks
            if (!wrapped) {
              wrapped = true
              lhs.children./**/splice(0, 0, "(")
              tail./**/push(")")
            }
          }
        }

        // TODO: Handle optional assignment refs

        // Walk from right to left to handle splices
        i = len - 1
        while (i >= 0) {
          const lastAssignment = $1[i]

          if (lastAssignment[3].token === "=") {
            const lhs = lastAssignment[1]

            // Splice assignment
            if (Array.isArray(lhs) && lhs.length > 1) {
              const props = lhs[lhs.length-1]

              if (Array.isArray(props)) {
                const lastProp = props[props.length-1]

                // TODO: this is kind of bonkers
                if(lastProp.type === "SliceExpression") {
                  const {start, end, children: c} = lastProp
                  // TODO: don't lose as many source mappings
                  c[0].token = ".splice("
                  c[1] = start
                  c[2] = ", "
                  if (end)
                    c[3] = [end, " - ", start]
                  else
                    c[3] = ["1/0"]
                  c[4] = [", ...", $2]
                  c[5] = ")"

                  // Remove assignment token
                  lastAssignment./**/pop()
                  if (module.isWhitespaceOrEmpty(lastAssignment[2])) lastAssignment./**/pop()
                  // TODO: this only works for the last assignment, not multiple splice assignments, or splice assignments earlier in the chain
                  if ($1.length > 1) {
                    throw new Error("Not implemented yet! TODO: Handle multiple splice assignments")
                  }

                  exp.children = [$1]
                  exp.names = []
                  return
                }
              }
            } else if (lhs.type === "ObjectBindingPattern" || lhs.type === "ArrayBindingPattern") {
              processBindingPatternLHS(lhs, tail)
            }
            // NOTE: currently not processing any non-binding pattern ObjectExpression or ArrayExpressions
            // This might not be correct in all situations, esp BindingPatterns nested inside ObjectExpressions
          }
          i--
        }

        // Gather all identifier names from the lhs array
        const names = $1.flatMap(([,l]) => l.names || [])
        exp.children = [$1, $2, ...tail]
        exp.names = names
      })
    }

    // Don't push to prelude unless ref actually ends up in final parse tree,
    // the parse could backtrack and not actually use the ref!
    function checkSpliceRef(statements) {
      const spliceRef = module.getSpliceRef()
      if (gatherRecursiveAll(statements, n => n === spliceRef).length) {
        const typeSuffix = {
          ts: true,
          children: [": <T>(this: T[], start: number, deleteCount?: number) => T[]"]
        }

        const asAny = {
          ts: true,
          children: [" as any"]
        }
        // [indent, statement]
        module.prelude.push(["", ["const ", spliceRef, typeSuffix, " = [].splice", asAny, "\n"]])
      }
    }

    module.attachPostfixStatementAsExpression = function (exp, post) {
      let clause
      switch (post[1].type) {
        case "IterationStatement":
        case "ForStatement":
          clause = module.addPostfixStatement(exp, ...post)
          return {
            type: "IterationExpression",
            children: [clause],
            block: clause.block,
          }
        case "IfStatement":
          clause = module.expressionizeIfClause(post[1], exp)
          return clause
        default:
          throw new Error("Unknown postfix statement")
      }
    }

    module.processProgram = function(statements) {
      processAssignments(statements)
      processFunctions(statements)
      processSwitchExpressions(statements)

      // Modify iteration expressions
      gatherRecursiveAll(statements, n => n.type === "IterationExpression")
      .forEach((e) => expressionizeIteration(e))

      // NOTE: This must be done after function processing because that inserts the ref into the block body
      checkSpliceRef(statements)

      // Insert prelude
      statements.unshift(...module.prelude)

      if (module.config.autoVar) {
        createVarDecs(statements, [])
      }

      populateRefs(statements)
      adjustAtBindings(statements)
    }

    function findDecs(statements) {
      const declarationNames = gatherNodes(statements, (node) => {
        if(node.type === "Declaration") {
          return true
        }
      }).flatMap(d => d.names)

      return new Set(declarationNames)
    }

    function populateRefs(statements) {
      const refNodes = gatherNodes(statements, ({type}) => type === "Ref")
      const blockNodes = new Set(gatherNodes(statements, ({type}) => type === "BlockStatement"))
      const forNodes = gatherNodes(statements, ({type}) => type === "ForStatement")

      // Populate refs from inside out
      forNodes.forEach(({declaration, block}) => {
        // Need to include declarations with block because they share scope
        if (block.type === "BlockStatement") {
          populateRefs([declaration, ...block.children])
        } else { // single non-block statement
          populateRefs([declaration, ...block])
        }
        blockNodes.delete(block)
      })

      blockNodes.forEach(({expressions}) => populateRefs(expressions))

      if (refNodes.length) {
        // Find all ids within nested scopes
        const ids = gatherRecursive(statements, (s) => s.type === "Identifier")
        const names = new Set(ids.flatMap(({names}) => names || []))

        // Populate each ref
        refNodes.forEach((ref) => {
          const {type, base} = ref
          if (type !== "Ref") return

          ref.type = "Identifier"

          let n = 0
          let name = base

          // check for name collisions and increment name suffix
          while (names.has(name)) {
            n++
            name = `${base}${n}`
          }

          names.add(name)
          ref.children = ref.names = [name]
        })
      }
    }

    // CoffeeScript compatible automatic var insertion
    function createVarDecs(statements, scopes, pushVar) {
      // NOTE: var and let/const have different scoping rules
      // need to keep var scopes when entering functions and within a var scope keep
      // track of lexical scopes within blocks
      function hasDec(name) {
        return scopes.some((s) => s.has(name))
      }

      function findAssignments(statements, decs) {
        let assignmentStatements = gatherNodes(statements, (node) => {
          return node.type === "AssignmentExpression"
        })

        if (assignmentStatements.length) {
          // Get nested assignments that could be in expressions
          assignmentStatements = assignmentStatements
          .concat(findAssignments(assignmentStatements.map(s => s.children), decs))
        }

        return assignmentStatements
      }

      // Let descendent blocks add the var at the outer enclosing function scope
      if (!pushVar) {
        pushVar = function(name) {
          varIds./**/push(name)
          decs.add(name)
        }
      }

      const decs = findDecs(statements)
      scopes./**/push(decs)
      const varIds = []
      const assignmentStatements = findAssignments(statements, scopes)
      const undeclaredIdentifiers = assignmentStatements.flatMap((a) => {
        return a.names
      })

      // Unique, undeclared identifiers in this scope
      undeclaredIdentifiers.filter((x, i, a) => {
        if (!hasDec(x)) return a.indexOf(x) === i
      }).forEach(pushVar)

      const fnNodes  = gatherNodes(statements, (s) => s.type === "FunctionExpression")
      const forNodes = gatherNodes(statements, (s) => s.type === "ForStatement")

      const blockNodes = new Set(gatherNodes(statements, (s) => s.type === "BlockStatement"))
      // Remove function blocks and for statements, they get handled separately because they have additional parameter scopes and lexical scopes to add
      fnNodes .forEach(({block}) => blockNodes.delete(block))
      forNodes.forEach(({block}) => blockNodes.delete(block))

      // recurse into nested blocks
      blockNodes.forEach((block) => {
        createVarDecs(block.expressions, scopes, pushVar)
      })

      // recurse into for loops
      forNodes.forEach(({block, declaration}) => {
        scopes./**/push(new Set(declaration.names))
        createVarDecs(block.expressions, scopes, pushVar)
        scopes./**/pop()
      })

      // recurse into nested functions
      fnNodes.forEach(({block, parameters}) => {
        scopes./**/push(new Set(parameters.names))
        createVarDecs(block.expressions, scopes)
        scopes./**/pop()
      })

      if (varIds.length) {
        // get indent from first statement
        let indent = statements[0][0]
        if (Array.isArray(indent)) indent = indent[indent.length - 1]
        statements.unshift([indent, "var ", varIds.join(", "), "\n"])
      }
    }

    function gatherBindingCode(statements) {
      const thisAssignments = []
      const splices = []

      function insertRestSplices(s, p, thisAssignments) {
        gatherRecursiveAll(s, n => n.blockPrefix || n.type === "AtBinding")
        .forEach((n) => {
          // Insert `this` assignments
          if (n.type === "AtBinding") {
            const { ref } = n, { id } = ref
            thisAssignments.push([`this.${id} = `, ref])
            return
          }
          const { blockPrefix } = n
          p.push(blockPrefix)

          // Search for any further nested splices, and at bindings
          insertRestSplices(blockPrefix, p, thisAssignments)
        })
      }

      insertRestSplices(statements, splices, thisAssignments)

      return [splices, thisAssignments]
    }

    module.gatherBindingCode = gatherBindingCode

    return $0

# Indentation

# Holds the last indent level in `module.lastIndent`
# Can get weird with backtracking but should work out as long as
# EOS/Nested rules are used carefully and if we only compare to the
# pushed value.
Indent
  /[ \t]*/ ->
    let level
    if (module.config.tab) {
      const tabs = $0.match(/\t/g)
      const numTabs = tabs ? tabs.length : 0
      level = numTabs * module.config.tab + /*spaces*/ ($0.length - numTabs)
    } else {
      level = $0.length
    }

    return {
      $loc,
      token: $0,
      level
    }

# Used in PushIndent to keep track of the last indent level for nesting
TrackIndented
  Indent:indent ->
    const {level} = indent

    if (level <= module.currentIndent.level) {
      return $skip
    }
    if (module.config.verbose) {
      console.log("pushing indent", indent)
    }

    module.indentLevels.push(indent)

Samedent
  EOS Indent:indent ->
    const { level } = indent
    const currentIndentLevel = module.currentIndent.level
    if (level === currentIndentLevel) {
      return $0
    }
    return $skip

IndentedFurther
  EOS Indent:indent ->
    const { level } = indent
    const currentIndentLevel = module.currentIndent.level
    if (level > currentIndentLevel) {
      return $0
    }
    return $skip

# Indents one level deeper
# Must be matched with PopIndent
PushIndent
  # TrackIndented pushes the indent level if it is deeper than the current level
  # it will skip if it is not deeper
  &( EOS TrackIndented )

PopIndent
  "" ->
    if (module.config.verbose) {
      console.log("popping indent", module.indentLevels[module.indentLevels.length-1], "->", module.indentLevels[module.indentLevels.length-2])
    }
    module.indentLevels./**/pop()

Nested
  EOS:eos Indent:indent ->
    const { level } = indent
    const currentIndent = module.currentIndent
    if (module.config.verbose) {
      console.log("Indented", level, currentIndent)
    }
    if (level !== currentIndent.level) {
      if (module.config.verbose) {
        console.log("skipped nested")
      }
      return $skip
    }
    return $0
