# Civet: A successor to CoffeeScript and alternative to TypeScript
# much more 1-to-1 with es6

# ECMA Reference
# https://262.ecma-international.org/13.0/

```
const {
  blockWithPrefix,
  clone,
  deepCopy,
  findAncestor,
  forRange,
  gatherBindingCode,
  gatherNodes,
  gatherRecursive,
  gatherRecursiveAll,
  gatherRecursiveWithinFunction,
  getIndent,
  getTrimmingSpace,
  hasAwait,
  hasYield,
  hoistRefDecs,
  insertTrimmingSpace,
  isFunction,
  literalValue,
  modifyString,
  processCoffeeInterpolation,
  processConstAssignmentDeclaration,
  processLetAssignmentDeclaration,
  quoteString,
  removeParentPointers,
} = require("./lib.js")

const assert = {
  equal(a, b, msg) {
    if (a !== b) {
      throw new Error(`Assertion failed [${msg}]: ${a} !== ${b}`)
    }
  }
}

```

Program
  # EOS allows for initial comment blocks and newlines,
  # when Init didn't already consume them.
  Reset Init EOS? TopLevelStatements:statements __ ->
    // NOTE: Wrap top level statements in a bare block so they have a parent
    module.processProgram({
      type: "BlockStatement",
      expressions: statements,
      children: [statements],
      bare: true,
      root: true,
    })
    return $0

TopLevelStatements
  # If first line is strictly indented, require all lines to be equally so
  # Use TrackIndented instead of PushIndent to avoid requiring leading EOS
  TrackIndented:indent TopLevelSingleLineStatements:first NestedTopLevelStatements*:rest PopIndent ->
    return [
      [indent, ...first[0]],
      ...first.slice(1).map(s => ["", ...s]),
      ...rest.flat(),
    ]
  # Unindented case: rely on initial indentLevel of 0
  TopLevelSingleLineStatements:first NestedTopLevelStatements*:rest ->
    return [
      ...first.map(s => ["", ...s]),
      ...rest.flat(),
    ]
  # Empty case
  "" -> []

NestedTopLevelStatements
  Nested:nested TopLevelSingleLineStatements:statements ->
    return [
      [nested, ...statements[0]],
      ...statements.slice(1).map(s => ["", ...s]),
    ]

# Multiple top-level semicolon-separated statements
TopLevelSingleLineStatements
  TopLevelStatement+

TopLevelStatement
  # NOTE: !EOS forces semicolon after all but last statement, forbids leading __
  # NOTE: _? allows for leading inline comments
  !EOS _?:ws ModuleItem:statement StatementDelimiter:delimiter ->
    if (ws) {
      statement = {
        ...statement,
        children: [ws, ...statement.children],
      }
    }
    return [statement, delimiter]

# Expressions with If and Switch, but no comma operator
ExtendedExpression
  NonAssignmentExtendedExpression
  AssignmentExpression

SingleLineExtendedExpression
  NonAssignmentExtendedExpression
  SingleLineAssignmentExpression

NonPipelineExtendedExpression
  NonAssignmentExtendedExpression
  NonPipelineAssignmentExpression

NonAssignmentExtendedExpression
  # Check for nested expressionized statements first
  &EOS PushIndent ( Nested ExpressionizedStatement )?:expression PopIndent ->
    if (expression) return expression
    return $skip
  __ ExpressionizedStatement ->
    return {...$2,
      children: [...$1, ...$2.children]
    }

ExpressionizedStatement
  DebuggerExpression
  IfExpression
  UnlessExpression
  IterationExpression
  SwitchExpression
  ThrowExpression
  TryExpression

# https://262.ecma-international.org/#prod-Expression
Expression
  # CommaOperator
  # https://262.ecma-international.org/#sec-comma-operator
  # NOTE: Eliminated left recursion
  AssignmentExpression ( CommaDelimiter AssignmentExpression )* ->
    if($2.length == 0) return $1
    return $0

# https://262.ecma-international.org/#prod-Arguments
Arguments
  ExplicitArguments

  # Space / indentation based function application
  # Function application:
  # a b => a(b)
  # a b, c, d => a(b, c, d)
  # x y z => x(y(z))
  ForbidTrailingMemberProperty ImplicitArguments?:args RestoreTrailingMemberProperty ->
    if (args) return args
    return $skip

ImplicitArguments
  ( TypeArguments !ImplementsToken )?:ta ApplicationStart InsertOpenParen:open _*:ws NonPipelineArgumentList:args InsertCloseParen:close ->
    // Don't treat as call if this is a postfix for/while/until/if/unless
    if (args.length === 1 && args[0].type === "IterationExpression" &&
        args[0].subtype !== "DoStatement" && !args[0].async &&
        module.isEmptyBareBlock(args[0].block)) {
      return $skip
    }
    return [ta?.[0], open, insertTrimmingSpace(ws, ""), args, close]

ExplicitArguments
  TypeArguments? OpenParen ArgumentList? ( __ Comma )? __ CloseParen

# Start of function application, inserts an open parenthesis, maintains spacing and comments when possible
ApplicationStart
  IndentedApplicationAllowed &NestedImplicitObjectLiteral
  !EOS &( _ !ForbiddenImplicitCalls )

ForbiddenImplicitCalls
  # Reserved words that prevent spaced implicit function application
  # ie: the 'of' in 'for x of ...'
  /(as|of|satisfies|then|when|implements|xor|xnor)(?!\p{ID_Continue}|[\u200C\u200D$])/
  # NOTE: Don't allow non-heregex regexes that begin with a space as first argument without parens
  "/ "
  # Don't treat @@decorator class ... as an implicit call
  ClassImplicitCallForbidden Class
  AtAt # experimentalDecorators
  Identifier "=" Whitespace
  Identifier !"(" ->
    if (module.operators.has($1.name)) return $1
    return $skip

ArgumentsWithTrailingMemberExpressions
  Arguments:args AllowedTrailingMemberExpressions:trailing ->
    const call = {
      type: "Call",
      children: args,
    }
    return [ call, ...trailing ]

TrailingMemberExpressions
  # NOTE: Assert "." to not match "?" or "!" as a member expression on the following line
  MemberExpressionRest* ( ( Samedent / IndentedFurther ) &( "?"? "." ![0-9] ) MemberExpressionRest )* ->
    return $1.concat($2)

AllowedTrailingMemberExpressions
  TrailingMemberPropertyAllowed TrailingMemberExpressions -> $2
  MemberExpressionRest*

CommaDelimiter
  ( Samedent / IndentedFurther )? _* Comma

# https://262.ecma-international.org/#prod-ArgumentList
ArgumentList
  ArgumentPart ( CommaDelimiter ( NestedImplicitObjectLiteral / NestedArgumentList ) )+
  # NOTE: Added nested arguments on separate new lines
  NestedImplicitObjectLiteral ->
    return insertTrimmingSpace($1, '')
  NestedArgumentList
  # NOTE: Eliminated left recursion
  _? ArgumentPart ( CommaDelimiter _? ArgumentPart )* ->
    return [...($1 || []), $2, ...$3]

# NOTE: ArgumentList variant that forbids top-level pipeline operators
NonPipelineArgumentList
  NonPipelineArgumentPart ( CommaDelimiter ( NestedImplicitObjectLiteral / NestedArgumentList ) )+
  # NOTE: Added nested arguments on separate new lines
  NestedImplicitObjectLiteral ->
    return insertTrimmingSpace($1, '')
  NestedArgumentList
  # NOTE: Eliminated left recursion
  _? NonPipelineArgumentPart ( CommaDelimiter _? NonPipelineArgumentPart )* ->
    return [...($1 || []), $2, ...$3]

NestedArgumentList
  PushIndent NestedArgument*:args PopIndent ->
    if (args.length) return args
    return $skip

NestedArgument
  Nested SingleLineArgumentExpressions ParameterElementDelimiter

SingleLineArgumentExpressions
  _? ArgumentPart ( _? Comma _? ArgumentPart )*

ArgumentPart
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  # NOTE: Allow leading or trailing dots for argument splats like CoffeeScript
  DotDotDot ExtendedExpression
  ExtendedExpression DotDotDot? ->
    if ($2) {
      return [$2, $1]
    }
    return $1

# NOTE: ArgumentPart variant that forbids top-level pipeline operators
NonPipelineArgumentPart
  DotDotDot NonPipelineExtendedExpression
  NonPipelineExtendedExpression DotDotDot? ->
    if ($2) {
      return [$2, $1]
    }
    return $1

BinaryOpExpression
  UnaryExpression BinaryOpRHS* ->
    if ($2.length) return module.processBinaryOpExpression($0)
    return $1

BinaryOpRHS
  # Snug binary ops a+b
  BinaryOp:op RHS:rhs ->
    // Insert empty whitespace placeholder to maintan structure
    return [[], op, [], rhs]
  # Spaced binary ops a + b
  # a
  # + b
  # Does not match
  # a
  # +b
  NotDedented BinaryOp ( _ / ( EOS __ ) ) RHS

RHS
  ParenthesizedAssignment
  UnaryExpression
  ExpressionizedStatement

ParenthesizedAssignment
  InsertOpenParen ActualAssignment InsertCloseParen

# https://262.ecma-international.org/#prod-UnaryExpression
UnaryExpression
  # NOTE: Merged AwaitExpression with UnaryOp
  # https://262.ecma-international.org/#prod-AwaitExpression
  # NOTE: Eliminated left recursion
  UnaryOp*:pre UpdateExpression:exp UnaryPostfix?:post ->
    return module.processUnaryExpression(pre, exp, post)

  # NOTE: This is a little hacky to match CoffeeScript's behavior
  # https://coffeescript.org/#try:do%20x%20%2B%20y%0Ado%20x%20%3D%20y%0Ado%20-%3E%20x%20%3D%201
  CoffeeDoEnabled Do __:ws ( ( LeftHandSideExpression !( __ AssignmentOpSymbol ) ) / ArrowFunction / ExtendedExpression ):exp ->
    ws = insertTrimmingSpace(ws, "")
    return ["(", ...ws, exp, ")()"]

UnaryPostfix
  QuestionMark
  ( __ As Type )+ -> { ts: true, children: $0 }
  ( __ Satisfies Type )+ -> { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-UpdateExpression
UpdateExpression
  # NOTE: Not allowing whitespace betwen prefix and postfix increment operators and operand
  UpdateExpressionSymbol UnaryExpression ->
    return {
      type: "UpdateExpression",
      assigned: $2,
      children: $0,
    }
  LeftHandSideExpression UpdateExpressionSymbol? ->
    if (!$2) return $1
    return {
      type: "UpdateExpression",
      assigned: $1,
      children: $0,
    }

UpdateExpressionSymbol
  ("++" / "--") ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-AssignmentExpression
AssignmentExpression
  # It is important for pipeline to have higher precedence than
  # usual binary operators, so that x |> & + 2 |> & * 3
  # is equivalent to x |> (& + 2) |> (& * 3)
  PipelineExpression
  # TODO If NonPipelineAssignmentExpression or SingleLineAssignmentExpression is used here then behavior changes

  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  SingleLineAssignmentExpression
  # TODO: Ideally this wouldn't be needed.
  __ AssignmentExpressionTail
  # NonPipelineAssignmentExpression

NonPipelineAssignmentExpression
  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  SingleLineAssignmentExpression
  __ AssignmentExpressionTail

SingleLineAssignmentExpression
  _?:ws AssignmentExpressionTail:tail ->
    if (ws?.length) {
      // Glom whitespace into identifiers and literals to ease checking of "simple" refs
      // NOTE: This can get weird if we depend on the specific location of children
      if (tail.children && tail.type !== "IterationExpression") {
        return {
          ...tail,
          children: [...ws, ...tail.children]
        }
      }
      return $0
    }
    return tail

AssignmentExpressionTail
  YieldExpression
  ArrowFunction
  ActualAssignment
  ConditionalExpression

# An assignment that actually includes an assignment operator, not just passing down to a ConditionalExpression
ActualAssignment
  # NOTE: Eliminated left recursion
  # NOTE: Consolidated assignment ops
  # NOTE: UpdateExpression instead of LeftHandSideExpression to allow
  # e.g. ++x *= 2 which we later convert to ++x, x *= 2
  ( __ UpdateExpression WAssignmentOp )+ ExtendedExpression ->
    $1 = $1.map((x) => [x[0], x[1], ...x[2]])
    $0 = [$1, $2]
    return {
      type: "AssignmentExpression",
      children: $0,
      // NOTE: This null marks the assignment for later processing to distinguish it
      // from fake assignments that only add a name to a scope
      names: null,
      lhs: $1,
      assigned: $1[0][1],
      exp: $2,
    }

# https://262.ecma-international.org/#prod-YieldExpression
YieldExpression
  Yield YieldTail

YieldTail
  &EOS
  # NOTE: Merged optional star
  ( _? Star )? AssignmentExpression

# https://262.ecma-international.org/#prod-ArrowFunction
ArrowFunction
  ThinArrowFunction
  ( Async _ )?:async Parameters:parameters ReturnTypeSuffix?:suffix FatArrow FatArrowBody:expOrBlock ->
    if (hasAwait(expOrBlock) && !async) {
      async = "async "
    }

    let error
    if (hasYield(expOrBlock)) {
      error = {
        type: "Error",
        message: "Can't use yield inside of => arrow function",
      }
    }

    return {
      type: "ArrowFunction",
      parameters,
      returnType: suffix,
      ts: false,
      async,
      block: expOrBlock,
      children: [async, $0.slice(1), error],
    }

FatArrow
  # Ensures at least one space before arrow
  __:ws "=>" ->
    if (!ws.length)
      return " =>"
    return $0

# NOTE Different from
# https://262.ecma-international.org/#prod-ConciseBody
FatArrowBody
  # If same-line single expression, avoid wrapping in braces
  !EOS NonPipelinePostfixedExpression:exp !SemicolonDelimiter -> exp
  # Otherwise, wrap block body in braces and insert returns
  BracedOrEmptyBlock

# https://262.ecma-international.org/#prod-ConditionalExpression
ConditionalExpression
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  ShortCircuitExpression TernaryRest? ->
    if ($2) {
      return [$1, ...$2]
    }
    return $1

TernaryRest
  NestedTernaryRest
  # NOTE: Ternary `a ? b : c` is disabled if CoffeeScript binary existential `a ? b` is enabled
  !CoffeeBinaryExistentialEnabled &" " _? QuestionMark ExtendedExpression __ Colon ExtendedExpression ->
    return $0.slice(2)

NestedTernaryRest
  PushIndent (Nested QuestionMark ExtendedExpression Nested Colon ExtendedExpression)? PopIndent ->
    if ($2) return $2
    return $skip

# https://262.ecma-international.org/#prod-ShortCircuitExpression
ShortCircuitExpression
  # NOTE: We don't need to track the precedence of all the binary operators so they all collapse into this
  BinaryOpExpression

PipelineExpression
  _?:ws PipelineHeadItem:head ( NotDedented Pipe __ PipelineTailItem )+:body ->
    if (head.token === "&") {
      const ref = {
        type: "Ref",
        base: "$",
      }

      const arrowBody = {
        type: "PipelineExpression",
        children: [ws, ref, body]
      }

      return {
        type: "ArrowFunction",
        children: [ref, " => ", arrowBody],
        ref,
        body: [arrowBody],
        ampersandBlock: true,
      }
    }

    return {
      type: "PipelineExpression",
      children: [ws, head, body]
    }

PipelineHeadItem
  # Needed to avoid left recursion
  NonPipelineExtendedExpression
  # Allow a pipeline to be part of first step if within parenthesis
  ParenthesizedExpression
  Ampersand

PipelineTailItem
  Await
  Yield
  Return
  AmpersandFunctionExpression
  !Ampersand PipelineHeadItem -> $2

# https://262.ecma-international.org/#prod-PrimaryExpression
PrimaryExpression
  ObjectLiteral
  ThisLiteral
  TemplateLiteral
  # NOTE: TemplateLiteral must be before Literal, so that CoffeeScript
  # interpolated strings get checked first before StringLiteral.
  Literal
  ArrayLiteral
  IdentifierReference # NOTE: Must be below ObjectLiteral for inline objects `a: 1, b: 2` to not be shadowed by matching the first identifier
  FunctionExpression
  ClassExpression
  RegularExpressionLiteral
  ParenthesizedExpression
  # https://facebook.github.io/jsx/#sec-jsx-PrimaryExpression
  # NOTE: Modified to parse multiple JSXElement/JSXFragments as one fragment
  JSXImplicitFragment

# https://262.ecma-international.org/#prod-ParenthesizedExpression
ParenthesizedExpression
  # NOTE: Currently ignoring early error checking in https://262.ecma-international.org/#prod-CoverParenthesizedExpressionAndArrowParameterList
  OpenParen:open AllowAll ( PostfixedExpression __ CloseParen )? RestoreAll ->
    if (!$3) return $skip
    const [exp, ws, close] = $3
    // Avoid extra parenthetical wrapping in `(for x in y ...)`
    switch (exp.type) {
      case "IterationExpression":
        return exp
    }
    return {
      type: "ParenthesizedExpression",
      children: [ open, exp, ws, close ],
      expression: exp,
    }

# https://262.ecma-international.org/#prod-ClassDeclaration
ClassDeclaration
  # NOTE: skipping syntax directed operation for now
  ClassExpression

# https://262.ecma-international.org/#prod-ClassExpression
ClassExpression
  Decorators? ( Abstract __ )? Class ClassBinding? ClassHeritage? ClassBody

ClassBinding
  !EOS BindingIdentifier TypeParameters? -> [$2, $3]

# https://262.ecma-international.org/#prod-ClassHeritage
ClassHeritage
  ExtendsClause ImplementsClause?
  ImplementsClause

ExtendsClause
  ExtendsToken __ ExtendsTarget

ExtendsToken
  # NOTE: Added "<" extends shorthand
  Loc:l __:ws OpenAngleBracket:lt " "? ->
    const children = [
      ...ws,
      { ...lt, token: "extends " },
    ]

    if (!ws.length) {
      children.unshift({ $loc: l.$loc, token: " " })
    }

    return { children }

  __ Extends

ExtendsTarget
  # NOTE: ECMA uses LeftHandSideExpression, but we allow ExtendedExpression
  # for e.g. if expressions, and then wrap in parentheses if needed.
  ExpressionWithIndentedApplicationForbidden:exp TypeArguments?:ta ->
    exp = module.makeLeftHandSideExpression(exp)
    if (ta) return [exp, ta]
    return exp

ImplementsClause
  ImplementsToken ImplementsTarget ( Comma ImplementsTarget )* ->
    return {
      ts: true,
      children: $0,
    }

ImplementsToken
  # NOTE: Added "<:" implements shorthand
  Loc:l __:ws ImplementsShorthand:token " "? ->
    const children = [ ...ws, token ]

    if (!ws.length) {
      children.unshift({ $loc: l.$loc, token: " " })
    }

    return { children }

  __ "implements" NonIdContinue ->
    $2 = { $loc, token: $2 }
    return [$1, $2]

ImplementsShorthand
  "<:" ->
    return { $loc, token: "implements " }

ImplementsTarget
  __ IdentifierName (Dot IdentifierName)* TypeArguments?

# https://262.ecma-international.org/#prod-ClassBody
# NOTE: Nesting and indentation sensitive
ClassBody
  __ OpenBrace NestedClassElements? __ CloseBrace
  InsertOpenBrace NestedClassElements? InsertNewline InsertIndent InsertCloseBrace

NestedClassElements
  PushIndent NestedClassElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassElement
  Nested ClassElement StatementDelimiter

# https://262.ecma-international.org/#prod-ClassElement
ClassElement
  # NOTE: Combined optional static and Method/Field definition
  Decorators? AccessModifier? ( Static _? )? ClassElementDefinition
  # ClassStaticBlock
  Static BracedBlock

ClassElementDefinition
  ( MethodDefinition / FieldDefinition )

# `declare class` form of ClassDeclaration, where all methods are signatures
ClassSignature
  Decorators? ( Abstract __ )? Class ClassBinding? ClassHeritage? ClassSignatureBody

ClassSignatureBody
  __ OpenBrace NestedClassSignatureElements? __ CloseBrace
  InsertOpenBrace NestedClassSignatureElements? InsertNewline InsertIndent InsertCloseBrace

NestedClassSignatureElements
  PushIndent NestedClassSignatureElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassSignatureElement
  Nested ClassSignatureElement StatementDelimiter

ClassSignatureElement
  # NOTE: MethodSignature instead of MethodDefinition
  Decorators? AccessModifier? ( Static _? )? ( MethodSignature / FieldDefinition )
  Static ClassSignatureBody

AccessModifier
  ( ( Public / Private / Protected ) __ )? ( Readonly __ )? ->
    if (!($1 || $2)) return $skip

    return {
      ts: true,
      children: $0
    }

# https://262.ecma-international.org/#prod-FieldDefinition
FieldDefinition
  # TODO: CoffeeCompat class method fields
  # name: (param1, param2) ->
  CoffeeClassesEnabled ClassElementName:id _? Colon __ AssignmentExpression:exp ->
    switch (exp.type) {
      // TODO: => functions
      case "FunctionExpression":
        const fnTokenIndex = exp.children.findIndex(c => c?.token?.startsWith("function"))
        // copy
        const children = exp.children.slice()
        if (exp.generator) {
          // replace "function" and move generator ahead of id
          children.splice(fnTokenIndex, 2, children[fnTokenIndex+1], id)
        } else {
          // replace "function" token with id
          children.splice(fnTokenIndex, 1, id)
        }
        return {
          ...exp,
          children,
        }
      default:
        return [id, " = ", exp]
    }

  # NOTE: Added readonly semantic equivalent of const field assignment
  # NOTE: Using ExtendedExpression to allow for If/SwitchExpressions
  InsertReadonly:r ClassElementName TypeSuffix? __ ConstAssignment:ca ExtendedExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    r.children[0].$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return $0

  ( Abstract _? )? ( Readonly _? )? ClassElementName TypeSuffix? Initializer? ->
    if ($1) return { children: $0, ts: true }
    return $0

ThisLiteral
  This
  # NOTE: Added @identifier shorthand, also works for private identifiers
  # Converts 'IdentifierName' node to string so this won't interfere with refs
  AtThis:at $( "#"? IdentifierName ):id ->
    return [at, ".", id]
  AtThis

# NOTE: Added '@' as a 'this' shorthand from CoffeeScript
AtThis
  At:at ->
    return { ...at, token: "this" }

# https://262.ecma-international.org/#prod-LeftHandSideExpression
LeftHandSideExpression
  # https://262.ecma-international.org/#prod-NewExpression
  # NOTE: Merged in NewExpression
  # NOTE: Changed to CallExpression to handle arguments
  # NOTE: Eliminated left recursion
  ( New !"." __ )* CallExpression ->
    if ($1.length) return $0
    return $2
  # NOTE: OptionalExpression is merged into CallExpression

# https://262.ecma-international.org/#prod-CallExpression
CallExpression
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  "super" ArgumentsWithTrailingMemberExpressions CallExpressionRest*:rest ->
    return module.processGlob({
      type: "CallExpression",
      children: [$1, ...$2, ...rest.flat()],
    })
  # Dynamic import(), with optional parentheses when not used at top level.
  # (At top level, ImportDeclaration will match first.)
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  "import" ArgumentsWithTrailingMemberExpressions CallExpressionRest*:rest ->
    return module.processGlob({
      type: "CallExpression",
      children: [$1, ...$2, ...rest.flat()],
    })
  ReturnValue

  MemberExpression:member AllowedTrailingMemberExpressions:trailing CallExpressionRest*:rest ->
    if (rest.length || trailing.length) {
      rest = rest.flat()
      return module.processGlob({
        type: "CallExpression",
        children: [member, ...trailing, ...rest]
      })
    }

    return member

# NOTE: Special `return.value` (and `return =` shorthand)
# for changing the automatic return value of function
ReturnValue
  ( "return.value" NonIdContinue ) / ( Return &AfterReturnShorthand ) ->
    return { type: "ReturnValue", children: [$1[0]] }

AfterReturnShorthand
  WAssignmentOp
  UpdateExpressionSymbol
  # Allow e.g. `let return: T`
  TypeSuffix
  __ LetAssignment
  __ ConstAssignment

CallExpressionRest
  MemberExpressionRest
  TemplateLiteral / StringLiteral ->
    if ($1.type === "StringLiteral") {
      return "`" + $1.token.slice(1, -1).replace(/(`|\$\{)/g, "\\$1") + "`"
    }
    return $1
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  ( OptionalShorthand / NonNullAssertion )? ArgumentsWithTrailingMemberExpressions ->
    if (!$1) return $2
    return [ $1, ...$2 ]

# NOTE: Added shorthand x?(3) -> x?.(3)
OptionalShorthand
  QuestionMark OptionalDot ->
    return {
      type: "Optional",
      children: $0,
    }

OptionalDot
  ( Dot / InsertDot )

NonNullAssertion
  # NOTE: Prevent shadowing !^ xnor operator
  "!" !"^" -> { type: "NonNullAssertion", ts: true, children: $1 }

# https://262.ecma-international.org/#prod-MemberExpression
MemberExpression
  # NOTE: "new" MemberExpression Arguments seems to be handled fine by other rules already
  # NOTE: Eliminated left recursion
  ( PrimaryExpression / SuperProperty / MetaProperty ) MemberExpressionRest*:rest ->
    if (rest.length || Array.isArray($1)) {
      return module.processGlob({
        type: "MemberExpression",
        children: [$1, ...rest].flat(),
      })
    }
    return $1

MemberExpressionRest
  # NOTE: Added shorthand x?[3] -> x?.[3]
  ( OptionalShorthand / NonNullAssertion )? MemberBracketContent ->
    if ($1) {
      // Optional followed by a slice expression
      if ($1.type === "Optional" && $2.type === "SliceExpression") {
        // Remove '.' from optional since it is present in '.slice'
        return [$1.children[0], $2]
      }
      return $0.flat()
    }
    return $2
  # NOTE: Combined Optional and Property access
  PropertyAccess
  PropertyGlob
  # NOTE: Added TypeScript '!' non-null assertion
  NonNullAssertion

# Handles indexing and slicing
MemberBracketContent
  OpenBracket:open ( SliceParameters / PostfixedExpression ):exp __:ws CloseBracket:close ->
    // Some kind of slice
    if (exp.type === "SliceParameters") {
      const {start, end, children} = exp

      return {
        type: "SliceExpression",
        start,
        end,
        children: [
          {...open, token: ".slice("},
          ...children,
          [...ws, {...close, token: ")"}],
        ]
      }
    }

    // Regular index `[exp]`
    return {
      type: "Index",
      children: $0
    }

  # NOTE: Added shorthand x."string" -> x["string"]
  Dot:dot ( TemplateLiteral / StringLiteral ):str ->
    return {
      type: "Index",
      children: [
        { token: "[", $loc: dot.$loc },
        str,
        "]",
      ]
    }

  # NOTE: Added shorthand x.3 -> x[3]
  Dot:dot IntegerLiteral:num ->
    return {
      type: "Index",
      children: [
        { token: "[", $loc: dot.$loc },
        num,
        "]",
      ]
    }

  # NOTE: Added shorthand x.-1 -> x.at(-1)
  Dot:dot "-":neg IntegerLiteral:num ->
    return [
      { type: "PropertyAccess", children: [dot, "at"] },
        // not including `name` so that `{x.-1}` doesn't use it
      { type: "Call", children: [ "(", neg, num, ")" ] },
    ]

SliceParameters
  ExtendedExpression:start __:ws ( DotDotDot / DotDot ):sep ExtendedExpression?:end ->
    const inclusive = sep.token === ".."

    let children
    if (end) {
      const inc = []
      if (inclusive) {
        end = ["1 + ", end]
        inc./**/push(" || 1/0")
      }
      children = [start, [...ws, {...sep, token: ", "}], [end, ...inc]]
    } else {
      children = [start, ws]
    }

    return {
      type: "SliceParameters",
      start,
      end,
      children,
    }

  Loc:l __:ws ( DotDotDot / DotDot ):sep ExtendedExpression:end ->
    const inclusive = sep.token === ".."

    const inc = []
    if (inclusive) {
      end = ["1 + ", end]
      inc./**/push(" || 1/0")
    }

    const start = {
      $loc: l.$loc,
      token: "0",
    }

    return {
      type: "SliceParameters",
      start,
      end,
      children: [start, [...ws, {...sep, token: ", "}], [end, ...inc]]
    }

  Loc:l __:ws ( DotDot / DotDotDot ) &( __ CloseBracket ) ->
    const start = {
      $loc: l.$loc,
      token: "0",
    }

    return {
      type: "SliceParameters",
      start,
      end: undefined,
      children: [start, ws],
    }

PropertyAccess
  ( QuestionMark / NonNullAssertion )? Dot ( IdentifierName / PrivateIdentifier ):id ->
    const children = [$2, ...id.children]
    if ($1) children./**/unshift($1)

    return {
      type: "PropertyAccess",
      name: id.name,
      children,
    }

  # NOTE: Added CoffeeScript :: prototype shorthand only when enabled
  CoffeePrototypeEnabled DoubleColon:p IdentifierName?:id ->
    if (id) {
      p.token = ".prototype."
      return [p, id]
    }
    p.token = ".prototype"
    return p

PropertyGlob
  # NOTE: Added shorthand obj.{a,b:c} -> {a: obj.a, c: obj.b}
  OptionalDot BracedObjectLiteral:object ->
    return {
      type: "PropertyGlob",
      object,
      children: $0
    }

SuperProperty
  "super" MemberBracketContent
  "super" !( QuestionMark / NonNullAssertion ) PropertyAccess

MetaProperty
  New Dot Target
  "import.meta" NonIdContinue ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-FormalParameters
# The parameters in a function definition
Parameters
  NonEmptyParameters
  "" ->
    return {
      type: "Parameters",
      children: [{$loc, token: "()"}],
      names: [],
      implicit: true,
    }

NonEmptyParameters
  # NOTE: BindingElement -> ParameterElement
  TypeParameters?:tp OpenParen:open ThisType?:tt ParameterElement*:pes FunctionRestParameter?:rest ParameterElement*:after ( __ CloseParen ):close ->
    const names = pes.flatMap(p => p.names)
    if (rest) {
      let restIdentifier
      if (rest.binding.ref) {
        restIdentifier = rest.binding.ref
      } else {
        names.push(...rest.names)
        restIdentifier = rest.names[0]
      }

      let blockPrefix
      if (after.length) {
        const spliceRef = module.getRef("splice")

        blockPrefix = {
          children: ["[", insertTrimmingSpace(after, ""), "] = ", spliceRef, ".call(", restIdentifier, ", -", after.length.toString(), ")"],
          names: after.flatMap(p => p.names)
        }
      }

      return {
        type: "Parameters",
        children: [
          tp,
          open,
          tt,
          ...pes,
          // Remove delimiter
          {...rest, children: rest.children.slice(0, -1)},
          close,
        ],
        tp,
        names,
        blockPrefix,
      }
    }

    return {
      type: "Parameters",
      children: [tp, open, tt, ...pes, close],
      names: pes.flatMap((p) => p.names),
      tp,
    }

# https://262.ecma-international.org/#prod-FunctionRestParameter
FunctionRestParameter
  BindingRestElement:id TypeSuffix? ParameterElementDelimiter ->
    return {
      type: "FunctionRestParameter",
      children: $0,
      names: id.names,
      binding: id,
    }

# NOTE: Similar to BindingElement but appears in formal parameters list
ParameterElement
  __ AccessModifier? ( BindingIdentifier / BindingPattern ) TypeSuffix? Initializer? ParameterElementDelimiter ->
    return {
      type: "Parameter",
      children: $0,
      names: $3.names,
      accessModifier: $2,
    }

ParameterElementDelimiter
  _* Comma
  &( __ [)}] )
  &EOS InsertComma -> $2

# https://262.ecma-international.org/#prod-BindingIdentifier
BindingIdentifier
  # NOTE: Added @param for binding identifiers
  # The parser will allow them in const/let/var declarations but JS/TS doesn't allow them there
  __:ws NWBindingIdentifier:identifier ->
    return { ...identifier, children: [...ws, ...identifier.children] }

# Non-whitespace version of BindingIdentifier
NWBindingIdentifier
  # NOTE: Added @param for binding identifiers
  # The parser will allow them in const/let/var declarations but JS/TS doesn't allow them there
  At AtIdentifierRef:ref ->
    return {
      type: "AtBinding",
      children: [ref],
      ref,
    }
  Identifier:id
  # NOTE: Support for return := 1 and let return: number
  ReturnValue ->
    return { children: [$1], names: [] }

AtIdentifierRef
  ReservedWord:r ->
    return {
      type: "Ref",
      base: `_${r}`,
      id: r,
    }
  IdentifierName:id ->
    return {
      type: "Ref",
      base: id.name,
      id: id.name,
    }

# https://262.ecma-international.org/#prod-BindingPattern
BindingPattern
  __ ObjectBindingPattern:p ->
    return {
      children: [...$1, p],
      names: p.names,
    }
  __ ArrayBindingPattern:p ->
    return {
      children: [...$1, p.children],
      names: p.names,
    }

# https://262.ecma-international.org/#prod-ObjectBindingPattern
# NOTE: Simplified from spec
ObjectBindingPattern
  OpenBrace ObjectBindingPatternContent:c __ CloseBrace ->
    return {
      type: "ObjectBindingPattern",
      children: [$1, ...c.children, $3, $4],
      content: c.children,
      names: c.names,
    }

ObjectBindingPatternContent
  # NOTE: Added indentation based binding properties
  NestedBindingProperties
  BindingPropertyList?:props ->
    if (!props) return { children: [], names: [] }

    return module.reorderBindingRestProperty(props)

BindingPropertyList
  ( BindingProperty ObjectPropertyDelimiter )+:props ->
    return props.map(([prop, delim]) => {
      return {
        ...prop,
        children: [...prop.children, delim],
      }
    })

# https://262.ecma-international.org/#prod-ArrayBindingPattern
# NOTE: Simplified from spec
ArrayBindingPattern
  OpenBracket ArrayBindingPatternContent:c __ CloseBracket ->
    return {
      type: "ArrayBindingPattern",
      names: c.names,
      children: $0
    }

ArrayBindingPatternContent
  # NOTE: Added indentation based binding elements
  NestedBindingElements
  BindingElementList?:elements ->
    if (!elements) return { children: [], names: [] }

    return module.adjustBindingElements(elements)

BindingElementList
  ( BindingElement ArrayElementDelimiter )+:elements ->
    return elements.map(([element, delim]) => {
      return {
        ...element,
        children: [...element.children, delim],
      }
    })

NestedBindingElementList
  Nested:ws BindingElementList:elements ->
    // Attach whitespace to first element
    return elements.map( (element, i) => {
      if (i > 0) return element
      return {
        ...element,
        children: [ws, ...element.children],
      }
    })

# https://262.ecma-international.org/#prod-Elision
Elision
  # NOTE: The repetition is handled from outside rather than using left recursion here
  __ Comma

NestedBindingProperties
  PushIndent NestedBindingPropertyList*:props PopIndent ->
    if (!props.length) return $skip

    return module.reorderBindingRestProperty(props.flat())

NestedBindingPropertyList
  Nested:ws BindingPropertyList:props ->
    // Attach whitespace to first property
    return props.map( (prop, i) => {
      if (i > 0) return prop
      return {
        ...prop,
        children: [ws, ...prop.children],
      }
    })

# https://262.ecma-international.org/#prod-BindingProperty
BindingProperty
  # NOTE: Merged in BindingRestProperty
  # TS will mark errors about invalid multiple rest properties
  # NOTE: Must be checked first to pick up trailing "..." form
  BindingRestProperty

  _? PropertyName:name _? Colon ( BindingIdentifier / BindingPattern ):b Initializer?:init ->
    return {
      name,
      value: b,
      init,
      names: b.names,
      children: $0
    }

  BindingIdentifier:b Initializer?:init ->
    if (b.type === "AtBinding") {
      return {
        type: "AtBindingProperty",
        ref: b.ref,
        init,
        names: [],
        children: $0
      }
    }

    return {
      name: b,
      init,
      names: b.names,
      children: $0
    }

# https://262.ecma-international.org/#prod-BindingRestProperty
BindingRestProperty
  _?:ws DotDotDot:dots BindingIdentifier:id ->
    return {
      ...id,
      type: "BindingRestProperty",
      children: [...(ws || []), dots, ...id.children],
    }

  _?:ws BindingIdentifier:id DotDotDot:dots ->
    return {
      ...id,
      type: "BindingRestProperty",
      children: [...(ws || []), dots, ...id.children],
    }

NestedBindingElements
  PushIndent NestedBindingElementList*:elements PopIndent ->
    if (!elements.length) return $skip

    return module.adjustBindingElements(elements.flat())

NestedBindingElement
  Nested:indent BindingElement:element ->
    return {
      ...element,
      children: [indent, ...element.children],
    }

# https://262.ecma-international.org/#prod-BindingElement
BindingElement
  BindingRestElement
  # NOTE: Merged in SingleNameBinding
  ( BindingIdentifier / BindingPattern ):binding Initializer? ->
    return {
      names: binding.names,
      children: $0
    }
  # NOTE: Merged in ElisionElement
  &( _? "," ) ->
    return {
      children: [{
        type: "ElisionElement",
        children: [""],
      }],
      names: [],
    }

# https://262.ecma-international.org/#prod-BindingRestElement
BindingRestElement
  _?:ws DotDotDot:dots ( BindingIdentifier / BindingPattern / EmptyBindingPattern ):binding ->
    return {
      ...binding,
      children: [...(ws || []), dots, ...binding.children],
      rest: true,
    }
  _?:ws ( BindingIdentifier / BindingPattern ):binding DotDotDot:dots ->
    return {
      ...binding,
      children: [...(ws || []), dots, ...binding.children],
      rest: true,
    }

# NOTE: Allows for empty binding rest pattern like in CoffeeScript
EmptyBindingPattern
  "" ->
    const ref = {
      type: "Ref",
      base: "ref",
      id: "ref"
    }
    return {
      type: "EmptyBinding",
      children: [ref],
      names: [],
      ref,
    }

# Pattern matching
MatchingPattern
  ObjectMatchingPattern
  ArrayMatchingPattern
  Literal
  RegularExpressionLiteral
  # TODO: Relational RHS

ObjectMatchingPattern
  _?:ws OpenBrace:open ObjectMatchingPatternContent:properties __:ws CloseBrace:close ->
    return {
      type: "ObjectMatchingPattern",
      children: [ws, open, ...properties.children, ...ws, close],
      properties: properties.children
    }

ObjectMatchingPatternContent
  # NOTE: Added indentation based binding properties
  NestedMatchingProperties
  MatchingPropertyList?:properties ->
    if (!properties) return { children: [], names: [], }

    return module.reorderBindingRestProperty(properties)

NestedMatchingProperties
  # NOTE: Add NestedBindingProperties after rest from CoffeeScript
  PushIndent NestedMatchingPropertyList*:properties PopIndent ->
    if (!props.length) return $skip

    return module.reorderBindingRestProperty(props.flat())

MatchingPropertyList
  ( MatchingProperty ObjectPropertyDelimiter )+:props ->
    return props.map(([prop, delim]) => {
      return {
        ...prop,
        children: [...prop.children, delim],
      }
    })

NestedMatchingPropertyList
  Nested:ws MatchingPropertyList:props ->
    // Attach whitespace to first property
    return props.map( (prop, i) => {
      if (i > 0) return prop
      return {
        ...prop,
        children: [ws, ...prop.children],
      }
    })

MatchingProperty
  MatchingRestProperty

  _? PropertyName:name _? Colon _? ( BindingIdentifier / MatchingPattern ):match ->
    return {
      type: "BindingMatchProperty",
      name,
      match,
      children: $0,
    }

  _?:ws BindingIdentifier:b ->
    if (b.type === "AtBinding") {
      return {
        type: "AtBindingProperty",
        ref: b.ref,
        names: [],
        children: [ws, b]
      }
    }

    return {
      type: "BindingProperty",
      names: b.names,
      children: [ws, b],
      identifier: b,
    }

MatchingRestProperty
  BindingRestProperty

ArrayMatchingPattern
  _?:ws OpenBracket ArrayMatchingPatternContent:elements __ CloseBracket ->
    return {
      type: "ArrayMatchingPattern",
      children: $0,
      elements: elements.children,
      length: elements.length,
    }

ArrayMatchingPatternContent
  # NOTE: Added indentation based binding elements
  NestedMatchingElements
  MatchingElementList?:elements ->
    if (!elements) return { children: [], names: [], length: 0 }

    return module.adjustBindingElements(elements)

NestedMatchingElements
  PushIndent NestedMatchingElementList*:elements PopIndent ->
    return module.adjustBindingElements(elements.flat())

MatchingElementList
  ( MatchingElement ArrayElementDelimiter )+:elements ->

    return elements.map(([element, delim]) => {
      return {
        ...element,
        children: [...element.children, delim],
      }
    })

NestedMatchingElementList
  Nested:ws MatchingElementList:elements ->

    // Attach whitespace to first element
    return elements.map( (element, i) => {
      if (i > 0) return element
      return {
        ...element,
        children: [ws, ...element.children],
      }
    })

MatchingElement
  MatchingRestElement

  _?:ws BindingIdentifier:name _? Colon _? ( BindingIdentifier / MatchingPattern ):match ->
    // Attach blockPrefix to bind sub-patterns
    let blockPrefix
    switch (match.type) {
      case "ArrayMatchingPattern":
      case "ObjectMatchingPattern":
        blockPrefix = [ match, " = ", name ]
        break;
      default:
        break;
    }

    return {
      names: name.names,
      children: [ ws, {
        type: "BindingMatchElement",
        name,
        match,
        children: [ name ],
        blockPrefix,
      } ],
    }

  # NOTE: Merged in SingleNameBinding
  _?:ws ( BindingIdentifier / MatchingPattern ):binding ->
    return {
      names: binding.names,
      children: [ ws, binding ]
    }

  &( _? "," ) ->
    return {
      children: [{
        type: "ElisionElement",
        children: [""],
      }],
      names: [],
    }

MatchingRestElement
  BindingRestElement

# https://262.ecma-international.org/#prod-FunctionDeclaration
FunctionDeclaration
  # Wrap nameless function declarations with parens, as needed in JS.
  FunctionExpression ->
    if ($1.id) return $1
    return module.makeLeftHandSideExpression($1)

FunctionSignature
  # NOTE: Merged in async and generator with optionals
  ( Async _ )?:async Function:func ( _? Star )?:generator ( _? NWBindingIdentifier )?:wid _?:w Parameters:parameters ReturnTypeSuffix?:suffix ->
    if (!async) async = []
    if (!generator) generator = []

    return {
      type: "FunctionSignature",
      id: wid?.[1],
      parameters,
      returnType: suffix,
      ts: false,
      async,
      generator,
      block: null,
      children: !parameters.implicit ? $0 :
        [ async, func, generator, wid, parameters, w, suffix ],
        // move whitespace w to after implicit () in parameters
    }

# https://262.ecma-international.org/#prod-FunctionExpression
FunctionExpression
  # NOTE: block isn't actually optional in FunctionExpression only in declarations/TS overloads
  FunctionSignature:signature BracedBlock?:block ->
    // TS Function overloads
    if (!block) {
      signature.ts = true
      return signature
    }

    if (hasAwait(block) && !signature.async.length) {
      signature.async.push("async ")
    }

    if (hasYield(block) && !signature.generator.length) {
      signature.generator.push("*")
    }

    // Attach the block
    return {
      ...signature,
      type: "FunctionExpression",
      children: [...signature.children, block],
      block,
    }
  AmpersandFunctionExpression

AmpersandFunctionExpression
  # Ruby/Crystal style block shorthand
  # NOTE: !NumericLiteral is so we don't match on `.1` etc.
  AmpersandUnaryPrefix?:prefix ( Ampersand / ( !NumericLiteral &( QuestionMark? Dot ) ) ) AmpersandBlockRHS?:rhs ->
    if (!prefix && !rhs) return $skip

    let body, ref

    // Only unary ops
    if (!rhs) {
      ref = {
        type: "Ref",
        base: "$",
        id: "$"
      }
      body = [ prefix, ref ]
    } else {
      ({ ref } = rhs)
      body = [ prefix, rhs ]
    }

    const children = [ ref, " => ", ...body ]
    if (hasAwait(body)) {
      children.unshift("async ")
    }

    return {
      type: "ArrowFunction",
      children,
      ref,
      body,
      ampersandBlock: true,
    }

# NOTE: Dynamic infix operators
OperatorDeclaration
  # `operator {x, y} := ...` declaration while blessing
  Operator:op _:w LexicalDeclaration:decl ->
    decl.names.forEach((name) => module.operators.add(name))
    return [insertTrimmingSpace(w, ""), decl]
  # `operator id(a, b) {...}` defines a function
  OperatorSignature:signature BracedBlock:block ->
    module.operators.add(signature.id.name)
    return {
      ...signature,
      type: "FunctionExpression",
      children: [...signature.children, block],
      block,
      operator: true,
    }
  # `operator id` alone blesses `id` as an operator
  Operator:op _:w1 Identifier:id ( CommaDelimiter _? Identifier )*:ids ->
    module.operators.add(id.name)
    ids.forEach(([, , id2]) => module.operators.add(id2.name))
    return []

# NOTE: Like FunctionSignature, but no async or star or @,
# and parameters are required (to be useful).
OperatorSignature
  Operator:op ( _ Function )?:func _:w1 Identifier:id _?:w2 NonEmptyParameters:parameters ReturnTypeSuffix?:suffix ->
    // Add "function" (if not already one) to replace "operator"
    if (!func) {
      func = { $loc: op.$loc, token: "function" }
    } else {
      func = [ insertTrimmingSpace(func[0], ""), func[1] ]
    }
    return {
      type: "FunctionSignature",
      id,
      parameters,
      returnType: suffix,
      ts: false,
      block: null,
      children: [ func, w1, id, w2, parameters, suffix ],
    }

AmpersandBlockRHS
  ForbidTrailingMemberProperty AmpersandBlockRHSBody? RestoreTrailingMemberProperty ->
    if (!$2) return $skip
    return $2

AmpersandBlockRHSBody
  (!_ CallExpressionRest+ )?:callExpRest ( ![&] BinaryOpRHS+ )?:binopRHS ->
    if (!callExpRest && !binopRHS) return $skip
    const ref = {
      type: "Ref",
      base: "$",
      id: "$"
    }

    const exp = {
      type: "AmpersandRef",
      children: [ref],
      names: [],
      ref,
    }

    if (callExpRest) {
      exp.children.push(...callExpRest[1])
    }

    if (binopRHS) {
      return {
        children: module.processBinaryOpExpression([exp, binopRHS[1]]),
        ref,
      }
    }

    return exp

AmpersandUnaryPrefix
  [!~+-]+

ThinArrowFunction
  ( Async _ )?:async Parameters:parameters ReturnTypeSuffix?:suffix _* Arrow:arrow BracedOrEmptyBlock:block ->
    if (hasAwait(block) && !async) {
      async = "async "
    }

    let generator
    if (hasYield(block)) {
      generator = "*"
    }

    return {
      type: "FunctionExpression",
      id: undefined,
      parameters,
      returnType: suffix,
      ts: false,
      async,
      generator,
      block: block,
      children: [
        async,
        { $loc: arrow.$loc, token: "function" },
        generator,
        parameters,
        suffix,
        block
      ],
    }

Arrow
  "->" ->
    return { $loc, token: $1}

ExplicitBlock
  __ OpenBrace __ CloseBrace ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [$1, expressions, $2],
      bare: false,
      empty: true,
    }
  __ OpenBrace NestedBlockStatements:block __ CloseBrace ->
    return {
      ...block,
      children: [$1, $2, ...block.children, $4, $5],
      bare: false,
    }

ImplicitNestedBlock
  # NOTE: Check &EOS needed by eventual PushIndent to skip work if not needed
  &EOS InsertOpenBrace:open AllowAll ( NestedBlockStatements InsertNewline InsertIndent InsertCloseBrace )? RestoreAll ->
    if (!$4) return $skip
    const [block, ...tail] = $4
    return {
      ...block,
      children: [open, ...block.children, ...tail],
      bare: false,
    }

# NOTE: This is the body of if/else/for/case etc.
Block
  ExplicitBlock
  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock

  ThenClause
  # NOTE: !EOS prevents capturing a following unindented Statement
  _?:ws !EOS Statement:s ->
    const expressions = [[ws, s]]
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }

ThenClause
  Then SingleLineStatements -> $2

# A block that must include braces (function body, try/catch/finally)
BracedOrEmptyBlock
  BracedBlock
  EmptyBlock

NoPostfixBracedOrEmptyBlock
  NoPostfixBracedBlock
  EmptyBlock

EmptyBlock
  # Implied empty block
  InsertOpenBrace InsertCloseBrace ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [$1, expressions, $2],
      bare: false,
      empty: true,
    }

EmptyBareBlock
  # Implied empty block with no braces. Used in case statements.
  "" ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
      bare: true,
    }

# A nonempty block that must include braces
# This version allows same-line postfixes like `while cond`.
BracedBlock
  NonSingleBracedBlock
  # Nonempty one liner
  InsertOpenBrace:o !EOS PostfixedSingleLineStatements:s InsertSpace:ws InsertCloseBrace:c ->
    if (!s.children.length) return $skip
    return {
      type: "BlockStatement",
      expressions: s.expressions,
      // Remove !EOS assertion
      children: [o, s.children, ws, c],
    }

# This version forbids same-line postfixes like `while cond`, e.g., in do/try.
NoPostfixBracedBlock
  NonSingleBracedBlock
  # Nonempty one liner
  InsertOpenBrace:o !EOS SingleLineStatements:s InsertSpace:ws InsertCloseBrace:c ->
    if (!s.children.length) return $skip
    return {
      type: "BlockStatement",
      expressions: s.expressions,
      // Remove !EOS assertion
      children: [o, s.children, ws, c],
    }

NonSingleBracedBlock
  _?:ws1 OpenBrace:open AllowAll ( BracedContent __ CloseBrace )? RestoreAll ->
    if (!$4) return $skip
    const [block, ws2, close] = $4
    return {
      type: "BlockStatement",
      expressions: block.expressions,
      children: [ws1, open, ...block.children, ws2, close],
      bare: false,
    }
    return block

  # NOTE: Added indentation based implied braces
  ImplicitNestedBlock

  # Immediate nested object literal
  InsertOpenBrace &EOS ObjectLiteral:s InsertCloseBrace ->
    return {
      type: "BlockStatement",
      expressions: [s],
      // Remove &EOS assertion
      children: [$1, s, $3],
    }

# NOTE: SingleLineStatements includes the empty case
SingleLineStatements
  # NOTE: Statement can start with __ via AssignmentExpression.
  # Force staying on the same line via !/\n/ assertion.
  ( ( _? !EOS ) Statement SemicolonDelimiter )*:stmts ( ( _? !EOS ) Statement SemicolonDelimiter? )?:last ->
    const children = [...stmts]
    if (last) children.push(last)

    return {
      type: "BlockStatement",
      expressions: children,
      children,
      bare: true,
    }

PostfixedSingleLineStatements
  ( ( _? !EOS ) PostfixedStatement SemicolonDelimiter )*:stmts ( ( _? !EOS ) PostfixedStatement SemicolonDelimiter? )?:last ->
    const children = [...stmts]
    if (last) children.push(last)

    return {
      type: "BlockStatement",
      expressions: children,
      children,
      bare: true,
    }

BracedContent
  NestedBlockStatements
  _? Statement ->
    const expressions = [["", $2]]
    return {
      type: "BlockStatement",
      expressions,
      children: [$1, expressions],
    }
  # Empty content
  &( __ "}" ) ->
    const expressions = []
    return {
      type: "BlockStatement",
      expressions,
      children: [expressions],
    }

NestedBlockStatements
  PushIndent NestedBlockStatement*:statements PopIndent ->
    if (!statements.length) return $skip

    // Each element of statements is a list of same-line statements. Flatten.
    statements = statements.flat()

    return {
      type: "BlockStatement",
      expressions: statements,
      children: [statements],
      bare: true,
    }

NestedBlockStatement
  Nested:nested BlockStatementPart+:statements ->
    return [
      [nested, ...statements[0]],
      ...statements.slice(1).map(s => ["", ...s]),
    ]

BlockStatementPart
  # NOTE: !EOS forces semicolon after all but last statement, forbids leading __
  # NOTE: _? allows for leading inline comments
  !EOS _?:ws StatementListItem:statement StatementDelimiter:delimiter ->
    if (ws) {
      statement = {...statement, children: [ ws, ...statement.children ]}
    }
    return [statement, delimiter]

# https://262.ecma-international.org/#prod-Literal
Literal
  LiteralContent ->
    return {
      type: "Literal",
      subtype: $1.type,
      children: $0,
      raw: $1.token,
    }

LiteralContent
  NullLiteral
  BooleanLiteral
  NumericLiteral
  StringLiteral

# https://262.ecma-international.org/#prod-NullLiteral
NullLiteral
  "null" NonIdContinue ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-BooleanLiteral
BooleanLiteral
  CoffeeBooleansEnabled CoffeeScriptBooleanLiteral -> $2
  ( "true" / "false" ) NonIdContinue ->
    return { $loc, token: $1 }

CoffeeScriptBooleanLiteral
  ( "yes" / "on" ) NonIdContinue ->
    return { $loc, token: "true" }
  ( "no" / "off" ) NonIdContinue ->
    return { $loc, token: "false" }

# https://262.ecma-international.org/#prod-Identifier
Identifier
  !ReservedWord IdentifierName -> $2

# https://262.ecma-international.org/#prod-IdentifierName
IdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$])*/ ->
    return {
      type: "Identifier",
      name: $0,
      names: [$0],
      children: [{
        $loc: $loc,
        token: $0,
      }],
    }

# https://262.ecma-international.org/#prod-IdentifierReference
IdentifierReference
  Identifier

UpcomingAssignment
  &( __ "=" !( "=" / ">" ) )

# https://262.ecma-international.org/#prod-ArrayLiteral
ArrayLiteral
  # NOTE: Check ArrayBindingPattern case of lhs destructuring
  ArrayBindingPattern UpcomingAssignment -> $1
  OpenBracket:open AllowAll ( ArrayLiteralContent __ CloseBracket )? RestoreAll ->
    if (!$3) return $skip
    const [ content, ws, close ] = $3

    if (content.type === "RangeExpression") {
      return {...content,
        children: [...content.children, ...ws],
      }
    }

    let children
    if (Array.isArray(content)) {
      children = [open, ...content, ...ws, close]
    } else {
      children = [open, content, ...ws, close]
    }

    // Gather names when ArrayLiteral is used as a destructuring pattern
    const names = children.flatMap((c) => {
      return c.names || []
    })

    return {
      type: "ArrayExpression",
      children,
      names,
    }

RangeExpression
  ExtendedExpression:s __:ws ( DotDotDot / DotDot ):range ExtendedExpression:e ->
    const inclusive = range.token === ".."
    range.token = ","

    if (s.type === "Literal" && e.type === "Literal") {
      const start = literalValue(s)
      const end = literalValue(e)

      if (typeof start !== typeof end) {
        throw new Error("Range start and end must be of the same type")
      }

      if (typeof start === "string") {
        if (start.length !== 1 || end.length !== 1) {
          throw new Error("String range start and end must be a single character")
        }

        const startCode = start.charCodeAt(0)
        const endCode = end.charCodeAt(0)
        const step = startCode < endCode ? 1 : -1

        const length = Math.abs(endCode - startCode) + (inclusive ? 1 : 0)
        if (length <= 26) {
          return {
            type: "RangeExpression",
            children: ["[", Array.from({ length }, (_, i) => JSON.stringify(String.fromCharCode(startCode + i * step))).join(", "), "]"],
            inclusive,
            start: s,
            end: e
          }
        } else {
          const inclusiveAdjust = inclusive ? " + 1" : ""
          const children = ["((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)", inclusiveAdjust, "}, (_, i) => String.fromCharCode(s + i * step))})(", startCode.toString(), ws, range, endCode.toString(), ")"]
          return {
            type: "RangeExpression",
            children,
            inclusive,
            start: s,
            end: e,
          }
        }
      } else if (typeof start === "number") {
        const step = end > start ? 1 : -1

        const length = Math.abs(end - start) + (inclusive ? 1 : 0)
        if (length <= 20) {
          // Use array of literal values
          return {
            type: "RangeExpression",
            children: ["[", Array.from({ length }, (_, i) => start + i * step).join(", "), "]"],
            inclusive,
            start: s,
            end: e,
          }
        }
      }
    }

    const inclusiveAdjust = inclusive ? " + 1" : ""
    const children = ["((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)", inclusiveAdjust, "}, (_, i) => s + i * step)})(", s, ws, range, e, ")"]

    return {
      type: "RangeExpression",
      children,
      inclusive,
      start: s,
      end: e,
    }

ArrayLiteralContent
  RangeExpression
  NestedImplicitObjectLiteral ( __ Comma NestedImplicitObjectLiteral )*
  NestedElementList
  ElementListWithIndentedApplicationForbidden:list InsertComma:comma NestedElementList?:nested ->
    if (nested) {
      // ElementList never ends in comma; otherwise, the next line of elements
      // would be absorbed into the ElementList.
      return [...list, comma, ...nested]
    } else {
      return list
    }

NestedElementList
  PushIndent NestedElement*:elements PopIndent ->
    if (elements.length)
      return elements.flat()
    return $skip

NestedElement
  Nested:indent ElementList:list ArrayElementDelimiter:delimiter ->
    const {length} = list
    if (length) {
      // Prepend indent to first element and append delimiter to last element
      return list.map((e, i) => {
        if (i === 0 && i === length - 1) {
          return {...e, children: [indent, ...e.children, delimiter]}
        }
        if (i === 0) {
          return {...e, children: [indent, ...e.children]}
        }
        if (i === length - 1) {
          return {...e, children: [...e.children, delimiter]}
        }
        return e
      })
    }

ArrayElementDelimiter
  __ Comma
  # NOTE: Don't insert comma before closing bracket
  # Ideally it would be nice to insert a trailing comma before newline followed by closing bracket, but in practice
  # it is difficult to keep the correct number of commas for elision elements. This is also closer to keeping source
  # verbatim.
  &( __ "]" )
  &EOS InsertComma -> $2

ElementListWithIndentedApplicationForbidden
  ForbidIndentedApplication ElementList? RestoreIndentedApplication ->
    if ($2) return $2
    return $skip

# https://262.ecma-international.org/#prod-ElementList
# NOTE: Modified and simplified from the spec
ElementList
  ArrayElementExpression:first ElementListRest*:rest ->
    if (rest.length) {
      return [{
        ...first,
        children: [...first.children, rest[0][0]],
      }].concat(rest.map(([_, e], i) => {
        const delim = rest[i+1]?.[0]
        return {
          ...e,
          children: [...e.children, delim],
        }
      }))
    }

    return [first]

ElementListRest
  # NOTE: This is an explicit comma because we could be in a nested list and we don't want to match
  # the &EOS delimiter
  ( __ Comma ) ArrayElementExpression

# NOTE: Modified and simplified from the spec
ArrayElementExpression
  # NOTE: Prevent multiple JSX tags from combining implicitly into a fragment
  JSXTag
  # NOTE: Allow for postfix splat like CoffeeScript
  # NOTE: Allow empty exp spread for destructuring
  ExtendedExpression?:exp __:ws DotDotDot:dots &ArrayElementDelimiter ->
    if (!exp) {
      exp = {
        type: "Ref",
        base: "ref",
        id: "ref",
        names: [],
      }
    }

    return {
      type: "SpreadElement",
      children: [...ws, dots, exp],
      names: exp.names,
    }

  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  ( ( __ DotDotDot __ )? ExtendedExpression )?:expMaybeSpread &ArrayElementDelimiter ->
    if (expMaybeSpread) {
      const [spread, exp] = expMaybeSpread

      if(!spread) {
        return {
          type: "ArrayElement",
          children: [exp],
          names: exp.names,
        }
      } else {
        return {
          type: "SpreadElement",
          children: [...spread, exp],
          names: exp.names,
        }
      }
    }

    return {
      type: "ElisionElement",
      children: [],
    }

# https://262.ecma-international.org/#prod-ObjectLiteral
# NOTE: Slightly simplified from spec
ObjectLiteral
  # NOTE: Check for object binding pattern in case of destructuring to an object lhs
  ObjectBindingPattern UpcomingAssignment -> $1
  BracedObjectLiteral
  NestedImplicitObjectLiteral
  InlineObjectLiteral

BracedObjectLiteral
  OpenBrace:open AllowAll ( BracedObjectLiteralContent? __ CloseBrace )? RestoreAll ->
    if (!$3) return $skip
    const [ content, ...close ] = $3

    if(content) {
      const children = [open, ...content, close]

      return {
        type: "ObjectExpression",
        content,
        children,
        names: children.flatMap((c) => {
          return c.names || []
        }),
      }
    }

    return {
      type: "ObjectExpression",
      children: [open, close],
      names: [],
    }

BracedObjectLiteralContent
  NestedPropertyDefinitions
  PropertyDefinitionList

NestedImplicitObjectLiteral
  InsertOpenBrace NestedImplicitPropertyDefinitions InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "ObjectExpression",
      children: [$1, ...$2, $3, $4, $5],
    }

NestedImplicitPropertyDefinitions
  PushIndent NestedImplicitPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs.flat()

NestedImplicitPropertyDefinition
  Nested:ws ImplicitNamedProperty:prop ObjectPropertyDelimiter:delimiter ->
    return {
      ...prop,
      children: [...ws, ...prop.children, delimiter],
    }

NestedPropertyDefinitions
  PushIndent NestedPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs.flat()

NestedPropertyDefinition
  # TODO: This may be a little weird/ambiguous with single identifier shorthand
  Nested:ws ( PropertyDefinition ObjectPropertyDelimiter )+:inlineProps ->
    return inlineProps.map( ([prop, delimiter], i) => ({
      ...prop,
      children: [ ...(i === 0 ? ws : []), ...prop.children, delimiter],
    }))

InlineObjectLiteral
  InsertInlineOpenBrace:open SnugNamedProperty ImplicitInlineObjectPropertyDelimiter ( ( Samedent / _* ) ImplicitNamedProperty ImplicitInlineObjectPropertyDelimiter )* InsertCloseBrace:close ->
    return {
      type: "ObjectExpression",
      children: [open, $2, $3, ...$4, close],
    }

# This is different from ObjectPropertyDelimiter because the braces are implicit so we can't look ahead to find the closing one
# Instead we see if the next line matches a NamedProperty and if so we insert a comma
ImplicitInlineObjectPropertyDelimiter
  _? Comma
  &( ( Samedent / _* ) NamedProperty ) InsertComma -> $2
  # NOTE: This is hacky but used when an inline object is inside a ternary conditional
  # Also if inline object is in an argument list or subexpression
  &( __  ( ":" / ")" / "]" / "}" / ReservedWord ) ) -> ""
  &EOS -> ""

ObjectPropertyDelimiter
  _* Comma
  # Object closing delimits the property
  &( __ "}" )
  &EOS InsertComma -> $2

PropertyDefinitionList
  ( PropertyDefinition ObjectPropertyDelimiter )+ ->
    return $0.map(([prop, delim]) => {
      return {
        ...prop,
        delim,
        children: [...prop.children, delim],
      }
    })

# https://262.ecma-international.org/#prod-PropertyDefinition
PropertyDefinition
  # NOTE: Added CoffeeScript {@id} -> {id: this.id} shorthand
  __:ws At:at IdentifierReference:id ->
    const value = [{...at, token: "this."}, id]
    return {
      type: "Property",
      children: [ws, id, ": ", ...value],
      name: id,
      names: id.names,
      value,
    }
  __:ws NamedProperty:prop ->
    return {
      ...prop,
      children: [ws, ...prop.children],
    }
  # NOTE: Added LiveScript flagging shorthand {+x, -y} -> {x: true, y: false}
  # NOTE: extended to allow {!y} -> {y: false}
  # NOTE: Must be after NamedProperty
  __:ws $[!+-]:toggle PropertyName:id ->
    const value = toggle === "+" ? "true" : "false"
    return {
      type: "Property",
      children: [ws, id, ": ", value],
      name: id,
      names: id.names,
      value,
    }
  # NOTE: Forbidding EmptyBlock in MethodDefinition to allow `foo()` shorthand
  # for `foo: foo()`
  __:ws MethodDefinition:def ->
    if (def.block.empty) return $skip
    return {
      ...def,
      children: [ws, ...def.children],
    }
  __:ws DotDotDot:dots ExtendedExpression:exp ->
    return {
      type: "SpreadProperty",
      children: [ws, dots, exp],
      names: exp.names,
      dots,
      value: exp,
    }
  # NOTE: Added `{x.y?.z()}` shorthand for `{z: x.y?.z()}`
  # NOTE: this needs to be at the bottom to prevent shadowing NamedProperty
  __:ws CallExpression:value ->
    // `{identifier}` remains `{identifier}`, the one shorthand JS supports
    if (value.type === "Identifier") {
      return {...value, children: [ws, ...value.children]}
    }
    // More complicated expressions gains `name:` prefix
    // Look for last PropertyAccess like `.foo` or Identifier,
    // before any calls like `(args)`.
    let exp = value, children, i
    do {
      ({children} = exp)
      i = children.length-1
      while (i >= 0 && (
        children[i].type === "Call" ||
        children[i].type === "NonNullAssertion" ||
        children[i].type === "Optional"
      )) i--
      if (i < 0) return $skip
      // Recurse into nested MemberExpression, e.g. from `x.y()`
    } while (children[i].type === "MemberExpression" && (exp = children[i]))
    const last = children[i]
    let name
    if (last.name) {
      ({name} = last)
    } else if (last.type === "Index") {
      // TODO: If `last` is a suitable string literal, could use it for `name`.
      // TODO: Should use a ref instead of duplicating the expression.
      name = {
        type: "ComputedPropertyName",
        children: last.children,
      }
    } else {
      return $skip
    }
    return {
      type: "Property",
      children: [ws, name, ": ", value],
      name, value,
      names: [],
    }
  # NOTE: basic identifiers are now part of the rule above
  #__:ws IdentifierReference:id ->
  #  return {...id, children: [...ws, ...id.children]}

NamedProperty
  # NOTE: CoverInitializedName early error doesn't seem necessary with this parser
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  PropertyName:name _? Colon ExtendedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      name: name,
      names: exp.names || [],
      value: exp,
    }

# NOTE: Variation on NamedProperty that forbids newlines after colon
# when forbidMultiLineImplicitObjectLiteral is set
ImplicitNamedProperty
  PropertyName:name _? Colon ( MultiLineImplicitObjectLiteralAllowed / !EOS ) ExtendedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      name: name,
      names: exp.names || [],
      value: exp,
    }

# Named property but doesn't allow any space between name and colon
# used to distinguish between braceless inline objects and ternary expression conditions
# Only used by implicit object literals, so forbid newlines after colon
SnugNamedProperty
  PropertyName Colon ( MultiLineImplicitObjectLiteralAllowed / !EOS ) ExtendedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      names: exp.names || [],
    }

PropertyName
  # https://262.ecma-international.org/#prod-LiteralPropertyName
  NumericLiteral
  ComputedPropertyName
  # NOTE: ComputedPropertyName must be before StringLiteral,
  # so that CoffeeScript interpolated strings get checked first.
  StringLiteral
  IdentifierName

ComputedPropertyName
  # https://262.ecma-international.org/#prod-ComputedPropertyName
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  OpenBracket PostfixedExpression:expression __ CloseBracket ->
    return {
      type: "ComputedPropertyName",
      children: $0,
      expression,
    }
  # NOTE: Extending to allow template literals without brackets
  InsertOpenBracket TemplateLiteral:expression InsertCloseBracket ->
    // Check for CoffeeScript interpolated double-quote string
    // without interpolation
    if ($2.type === "StringLiteral") return $2
    return {
      type: "ComputedPropertyName",
      children: $0,
      expression,
    }
  InsertOpenBracket "-" NumericLiteral InsertCloseBracket ->
    return {
      type: "ComputedPropertyName",
      children: $0,
    }

Decorator
  # Might want to disallow import, super, and return CallExpressions
  AtAt CallExpression

Decorators
  ForbidClassImplicitCall ( __ Decorator )*:decorators __ RestoreClassImplicitCall ->
    if (!decorators.length) return $skip
    return $0

# https://262.ecma-international.org/#prod-MethodDefinition
MethodDefinition
  Abstract __ MethodSignature:signature ->
    return {
      type: "MethodDefinition",
      children: $0,
      name: signature.name,
      signature,
      parameters: signature.parameters,
      ts: true
    }
  # NOTE: Not adding extra validation using PropertySetParameterList
  # NOTE: If this node layout changes, be sure to update `convertMethodTOFunction`
  MethodSignature:signature !PropertyAccess BracedOrEmptyBlock:block ->
    let children = $0
    let generatorPos = 0
    const { modifier } = signature

    if (hasAwait(block)) {
      generatorPos++
      children = children.slice()
      // get or set
      if (modifier?.get || modifier?.set) {
        children.push({
          type: "Error",
          message: "Getters and setters cannot be async",
        })
      } else if(modifier?.async) {
        // Do nothing, already async
      } else {
        // Insert implicit async
        children.unshift("async ")
      }
    }

    if (hasYield(block)) {
      if (children === $0) children = children.slice()

      // get or set
      if (modifier?.get || modifier?.set) {
        children.push({
          type: "Error",
          message: "Getters and setters cannot be generators",
        })
      } else if(modifier?.generator) {
        // Do nothing, already generator
      } else {
        // Insert implicit generator
        children.splice(generatorPos, 0, "*")
      }
    }

    return {
      type: "MethodDefinition",
      children,
      name: signature.name,
      signature,
      block,
      parameters: signature.parameters,
    }

MethodModifier
  # NOTE: Merged get/set definitions
  GetOrSet:kind _? ->
    return {
      type: "MethodModifier",
      async: false,
      generator: false,
      get: kind.token === "get",
      set: kind.token === "set",
      children: $0,
    }
  # NOTE: Merged async and generator into MethodModifier
  ( Async __ ) ( Star __ )? ->
    return {
      type: "MethodModifier",
      async: true,
      get: false,
      set: false,
      generator: !!$1,
      children: $0,
    }
  Star __ ->
    return {
      type: "MethodModifier",
      async: false,
      get: false,
      set: false,
      generator: true,
      children: $0,
    }

# TypeScript method signature
MethodSignature
  ConstructorShorthand NonEmptyParameters:parameters ->
    return {
      type: "MethodSignature",
      children: $0,
      name: $1.token,
      returnType: undefined,
      parameters,
    }

  # NOTE: If this node layout changes, be sure to update `convertMethodToFunction`
  MethodModifier?:modifier ClassElementName:name _? NonEmptyParameters:parameters ReturnTypeSuffix?:suffix ->
    // Normalize name so we can check if it is `constructor`
    if (name.name) {
      name = name.name
    } else if (name.token) {
      name = name.token.match(/^(?:"|')/) ? name.token.slice(1, -1) : name.token
    }

    return {
      type: "MethodSignature",
      children: $0,
      name: name,
      modifier, // get/set/async/generator
      returnType: suffix,
      parameters,
    }

ClassElementName
  PropertyName
  PrivateIdentifier

PrivateIdentifier
  $("#" IdentifierName) ->
    return {
      type: "Identifier",
      name: $0,
      names: [$0],
      children: [{
        $loc: $loc,
        token: $0,
      }],
    }

# https://262.ecma-international.org/#prod-GeneratorDeclaration
# https://262.ecma-international.org/#prod-GeneratorExpression
# NOTE: Merged GeneratorExpression and GeneratorDeclaration into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncFunctionDeclaration
# https://262.ecma-international.org/#prod-AsyncFunctionExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorDeclaration
# https://262.ecma-international.org/#prod-AsyncGeneratorExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorMethod
# https://262.ecma-international.org/#prod-AsyncGeneratorBody
# https://262.ecma-international.org/#prod-AsyncMethod
# https://262.ecma-international.org/#prod-AsyncFunctionBody
# https://262.ecma-international.org/#prod-GeneratorMethod
# https://262.ecma-international.org/#prod-GeneratorBody
# NOTE: Merged into MethodDefinition

# NOTE: Allow arbitrary whitespace before regular assignment,
# but require nonnewline whitespace before operator assignment.
WAssignmentOp
  __ AssignmentOp
  _ OperatorAssignmentOp

# https://262.ecma-international.org/#prod-AssignmentOperator
AssignmentOp
  AssignmentOpSymbol _? ->
    if ($2?.length) {
      return {
        token: $1,
        children: [$1, ...$2]
      }
    }

    return { $loc, token: $1 }

# NOTE: x foo= y expands to x = foo(x, y)
# This is separate from AssignmentOp because it only works in certain contexts
# (in particular, not at the beginning of a line).
OperatorAssignmentOp
  Xor "=" &Whitespace _? ->
    return {
      special: true,
      call: module.getRef("xor"),
      children: [$2, ...$4]
    }
  Xnor "=" &Whitespace _? ->
    return {
      special: true,
      call: module.getRef("xnor"),
      children: [$2, ...$4]
    }
  Identifier "=" &Whitespace _? ->
    return {
      special: true,
      call: $1,
      children: [$2, ...$4]
    }

AssignmentOpSymbol
  "**="
  "*="
  "/="
  "%="
  "+="
  "-="
  "<<="
  ">>>="
  ">>="
  "&&="
  "&="
  "^="
  "||="
  "|="
  "??="
  "?=" -> "??="
  # NOTE: assertion to avoid matching part of a comparison op
  "=" !"=" -> $1
  CoffeeWordAssignmentOp -> $1

CoffeeWordAssignmentOp
  "and=" -> "&&="
  "or=" -> "||="

BinaryOp
  BinaryOpSymbol ->
    if (typeof $1 === "string") return { $loc, token: $1 }
    return $1
  Identifier:id ->
    if (!module.operators.has(id.name)) return $skip
    return {
      call: id,
      special: true,
    }
  "not" NonIdContinue __ Identifier:id ->
    if (!module.operators.has(id.name)) return $skip
    return {
      call: id,
      special: true,
      negated: true,
    }

# NOTE: Condensed binary operator symbols into one rule
BinaryOpSymbol
  "**"
  "*"
  "/"
  "%%" ->
    return {
      call: module.getRef("modulo"),
      special: true,
    }
  # NOTE: %% must be above %
  "%"
  "+"
  "-"
  "<="
  ">="
  # NOTE: added <? instanceof shorthand
  "<?" ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
    }
  "!<?" ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
      negated: true,
    }
  "<<"
  # NOTE: Avoid matching JSX opening tag by requiring non-identifier character
  # (e.g. whitespace) after "<".  This does forbid 1<2 or x<y.
  /<(?!\p{ID_Start}|[_$])/ ->
    return "<"
  ">>>"
  ">>"
  ">"
  "!=="
  # NOTE: CoffeeScript converts "!=" -> "!=="
  # Convert if CoffeeScript compat flag is set
  "!=" ->
    if(module.config.coffeeEq) return "!=="
    return $1
  "isnt" NonIdContinue ->
    if(module.config.coffeeIsnt) return "!=="
    return $skip
  "==="
  # NOTE: CoffeeScript converts "==" -> "==="
  # Convert if CoffeeScript compat flag is set
  "==" ->
    if(module.config.coffeeEq) return "==="
    return $1
  "and" NonIdContinue -> "&&"
  "&&"
  CoffeeOfEnabled "of" NonIdContinue -> "in"
  "or" NonIdContinue -> "||"
  "||"
  # NOTE: ^^ must be above ^
  "^^" / ( "xor" NonIdContinue ) ->
    return {
      call: module.getRef("xor"),
      special: true,
    }
  /!\^\^?/ / ( "xnor" NonIdContinue ) ->
    return {
      call: module.getRef("xnor"),
      special: true,
    }
  "??"
  CoffeeBinaryExistentialEnabled "?" -> "??"
  "instanceof" NonIdContinue ->
    return {
      $loc,
      token: $1,
      relational: true,
      special: true, // for typeof shorthand
    }
  "not" NonIdContinue __ "instanceof" NonIdContinue ->
    return {
      $loc,
      token: "instanceof",
      relational: true,
      special: true,
      negated: true,
    }
  ( !CoffeeOfEnabled "not" NonIdContinue __ "in" NonIdContinue ) / ( CoffeeOfEnabled "not" NonIdContinue __ "of" NonIdContinue ) ->
    return {
      $loc,
      token: "in",
      special: true,
      negated: true,
    }
  "is" NonIdContinue __ "in" NonIdContinue ->
    return {
      method: "includes",
      relational: true,
      reversed: true,
      special: true,
    }
  CoffeeOfEnabled "in" NonIdContinue ->
    return {
      call: [module.getRef("indexOf"), ".call"],
      relational: true,
      reversed: true,
      suffix: " >= 0",
      special: true,
    }
  "is" NonIdContinue __ "not" NonIdContinue __ "in" NonIdContinue ->
    return {
      method: "includes",
      relational: true,
      reversed: true,
      special: true,
      negated: true,
    }
  CoffeeOfEnabled "not" NonIdContinue __ "in" NonIdContinue ->
    return {
      call: [module.getRef("indexOf"), ".call"],
      relational: true,
      reversed: true,
      suffix: " < 0",
      special: true,
    }
  # NOTE: "is not" must come after "is not in"
  !CoffeeNotEnabled "is" NonIdContinue __ "not" NonIdContinue ->
    if (module.config.objectIs) {
      return {
        call: module.getRef("is"),
        relational: true,
        special: true,
        asConst: true,
        negated: true,
      }
    }
    return "!=="
  # NOTE: "is" must come after "is not" and "is in"
  "is" NonIdContinue ->
    if (module.config.objectIs) {
      return {
        call: module.getRef("is"),
        relational: true,
        special: true,
        asConst: true,
      }
    }
    return "==="
  "in" NonIdContinue ->
    return $1
  "&"
  "^"
  "|"

Xor
  "^^" / ( "xor" NonIdContinue )
Xnor
  /!\^\^?/ / "xnor"

UnaryOp
  # Lookahead to prevent unary operators from overriding update operators
  # ++/-- or block unary operator shorthand
  /(?!\+\+|--)[!~+-](?!\s|[!~+-]*&)/ ->
    return { $loc, token: $0 }
  ( Await / Delete / Void / Typeof ) __
  Not # only when CoffeeNotEnabled (see definition of `Not`)

# https://262.ecma-international.org/#prod-ModuleItem
ModuleItem
  ImportDeclaration
  ExportDeclaration
  StatementListItem

# https://262.ecma-international.org/#prod-StatementListItem
StatementListItem
  Declaration
  # NOTE: Added postfix conditionals/loops
  PostfixedStatement

PostfixedStatement
  Statement:statement ( _? PostfixStatement )?:post ->
    if (post) return module.addPostfixStatement(statement, ...post)
    return statement

PostfixedExpression
  ExtendedExpression:expression ( _? PostfixStatement )?:post ->
    if (post) return module.attachPostfixStatementAsExpression(expression, post)
    return expression

NonPipelinePostfixedExpression
  NonPipelineExtendedExpression:expression ( _? PostfixStatement )?:post ->
    if (post) return module.attachPostfixStatementAsExpression(expression, post)
    return expression

PostfixStatement
  ForClause
  IfClause
  LoopClause
  UnlessClause
  WhileClause

# https://262.ecma-international.org/#prod-Statement
Statement
  KeywordStatement
  VariableStatement
  IfStatement
  IterationStatement
  SwitchStatement
  TryStatement

  EmptyStatement

  # NOTE: LabelledStatment is before ExpressionStatement so that `$:` is
  # treated as a label, not an implicit object literal, for Svelte compatibility
  LabelledStatement

  # Wrap object literal with parens to disambiguate from block statements.
  # Also wrap nameless functions from `->` expressions with parens
  # as needed in JS.
  ExpressionStatement ->
    if ($1.type === "ObjectExpression" ||
        ($1.type === "FunctionExpression" && !$1.id)) {
      return module.makeLeftHandSideExpression($1)
    }
    return $1

  # NOTE: Block statement is after expression statement because valid ObjectLiterals should take priority over blocks
  BlockStatement

  # NOTE: no WithStatement

# NOTE: EmptyStatement handled differently than spec, consuming inline whitespace and comments then asserting following semi-colon
EmptyStatement
  _? &";" ->
    return { type: "EmptyStatement", children: $1 || [] }

# https://262.ecma-international.org/#prod-BlockStatement
BlockStatement
  # NOTE: Added lookahead for `=` to allow for destructuring assignment without parens
  ExplicitBlock !( __ "=" ) -> $1

# https://262.ecma-international.org/#prod-LabelledStatement
LabelledStatement
  Label LabelledItem

Label
  # NOTE: `:label` instead of `label:` to not clash with implicit object literal
  Colon:colon Identifier:id Whitespace:w ->
    return [ id, colon, w ]
  # NOTE: Make $: into label, not implicit object literal, for Svelte compat
  "$:" Whitespace

LabelledItem
  Statement
  FunctionDeclaration

# https://262.ecma-international.org/#prod-IfStatement
IfStatement
  # NOTE: Added paren-less condition
  # NOTE: Block isn't Statement so we can handle implied braces by nesting
  (IfClause / UnlessClause):clause Block:block ElseClause?:e ->
    const children = [...clause.children]
    block = blockWithPrefix(clause.condition.expression.blockPrefix, block)
    children.push(block)
    if (block.bare && e) children./**/push(";")
    if (e) children./**/push(e)

    return {
      ...clause,
      children,
      then: block,
      else: e,
    }

ElseClause
  Samedent Else Block
  _? Else Block

IfClause
  If Condition:condition ->
    return {
      type: "IfStatement",
      children: $0,
      condition,
    }

UnlessClause
  Unless:kind Condition:condition ->
    // Rewrite unless to if
    kind = { ...kind, token: "if" }

    return {
      type: "IfStatement",
      // TODO: Don't add unnecessary parens
      children: [kind, ["(!", condition, ")"]],
      condition,
    }

# NOTE: Added IfExpression from CoffeeScript
IfExpression
  IfClause:clause ExpressionBlock:b ElseExpressionClause?:e ->
    return module.expressionizeIfClause(clause, b, e)

UnlessExpression
  UnlessClause:clause ExpressionBlock:b ElseExpressionClause?:e ->
    return module.expressionizeIfClause(clause, b, e)

ElseExpressionClause
  ( ( Samedent Else ) / ( _? Else ) ) ElseExpressionBlock ->
    return [...$1, $2]

# Block of expressions that can't include pure statements
ExpressionBlock
  InsertOpenParen NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseParen ->
    // Each element of exps is a list of same-line expressions. Flatten.
    exps = exps.flat()

    // If there is only one expression and it doesn't require parens, then return it as is, preserving whitespace
    if (exps.length === 1) {
      let [ws, exp] = exps[0]
      switch (exp.type) {
        case "Identifier":
        case "Literal":
          return [ws, exp]
      }
    }

    // Remove final trailing expression delimiter
    exps = exps.map((e, i) => {
      if (i === exps.length - 1) {
        return e.slice(0, -1)
      }
      return e
    })

    return {
      type: "BlockExpressions",
      expressions: exps,
      children: [$1, exps, $3, $4, $5],
    }
  Then ExtendedExpression

ElseExpressionBlock
  InsertOpenParen NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseParen ->
    // Each element of exps is a list of same-line expressions. Flatten.
    exps = exps.flat()

    // If there is only one expression and it doesn't require parens, then return it as is, preserving whitespace
    if (exps.length === 1) {
      let [ws, exp] = exps[0]
      switch (exp.type) {
        case "Identifier":
        case "Literal":
          return [ws, exp]
      }
    }

    // Remove final trailing expression delimiter
    exps = exps.map((e, i) => {
      if (i === exps.length - 1) {
        return e.slice(0, -1)
      }
      return e
    })

    return {
      type: "BlockExpressions",
      expressions: exps,
      children: [$1, exps, $3, $4, $5],
    }
  !EOS ExpressionWithIndentedApplicationForbidden -> $2

NestedBlockExpressions
  PushIndent NestedBlockExpression*:exps PopIndent ->
    if (!exps.length) return $skip
    return exps

NestedBlockExpression
  Nested:nested BlockExpressionPart+:expressions ->
    return [
      [nested, ...expressions[0]],
      ...expressions.slice(1).map(s => ["", ...s]),
    ]

BlockExpressionPart
  # NOTE: !EOS forces semicolon after all but last statement, forbids leading __
  # NOTE: _? allows for leading inline comments
  !EOS _?:ws PostfixedExpression:exp ExpressionDelimiter:delimiter ->
    if (ws) {
      exp = {...exp, children: [ ws, ...exp.children ]}
    }
    return [exp, delimiter]

# https://262.ecma-international.org/#prod-IterationStatement
IterationStatement
  # NOTE: Added `loop` from CoffeeScript
  LoopStatement
  !CoffeeDoEnabled DoWhileStatement -> $2
  # DoStatement must come after DoWhile statement
  !CoffeeDoEnabled DoStatement -> $2
  WhileStatement
  ForStatement

IterationExpression
  ( Async __ )?:async IterationStatement:statement ->
    return {
      type: "IterationExpression",
      subtype: statement.type,
      children: [statement],
      block: statement.block,
      async,
    }

# NOTE: Added from CoffeeScript
LoopStatement
  LoopClause:clause Block:block ->
    return {
      type: "IterationStatement",
      children: [...clause.children, block],
      block,
    }

LoopClause
  Loop -> {
    type: "IterationStatement",
    children: [$1],
  }

# https://262.ecma-international.org/#prod-DoWhileStatement
DoWhileStatement
  # NOTE: Condition provides optional parens
  Do NoPostfixBracedBlock:block __ WhileClause -> {
    type: "IterationStatement",
    children: $0,
    block: block
  }

DoStatement
  Do NoPostfixBracedBlock:block ->
    block = insertTrimmingSpace(block, "")
    return {
      type: "DoStatement",
      children: [block],
      block,
    }

# https://262.ecma-international.org/#prod-WhileStatement
WhileStatement
  # NOTE: Condition provides optional parens
  WhileClause:clause Block:block ->
    block = blockWithPrefix(clause.condition.expression.blockPrefix, block)
    return {
      ...clause,
      children: [...clause.children, block],
      block,
    }

WhileClause
  ( While / Until ):kind _?:ws Condition:condition ->
    if (kind.token === "until") {
      kind.token = "while"

      // TODO: Don't add unnecessary parens
      return {
        type: "IterationStatement",
        children: [kind, ...ws, ["(!", ...condition.children, ")"]],
        condition,
      }
    }

    return {
      type: "IterationStatement",
      children: [kind, ...ws, ...condition.children],
      condition,
    }

# https://262.ecma-international.org/#prod-ForStatement
# https://262.ecma-international.org/#prod-ForInOfStatement
# NOTE: Merged into single rule
ForStatement
  ForClause:clause Block:block ->
    block = blockWithPrefix(clause.blockPrefix, block)

    return {
      ...clause,
      children: [...clause.children, block],
      block,
    }

ForClause
  For __ ForStatementControl:c  ->
    const {children, declaration} = c

    return {
      type: "ForStatement",
      children: [$1, ...$2, ...children],
      declaration: declaration,
      block: null,
      blockPrefix: c.blockPrefix,
    }

ForStatementControl
  !CoffeeForLoopsEnabled ForStatementParameters -> $2
  CoffeeForLoopsEnabled CoffeeForStatementParameters WhenCondition? ->
    if ($3) {
      // TODO: actual block and continue ast nodes
      const block = "continue;"
      $2 = {
        ...$2,
        blockPrefix: [...$2.blockPrefix,
          ["", {
            type: "IfStatement",
            then: block,
            children: ["if (!(", insertTrimmingSpace($3, ""), ")) ", block],
          }]
        ],
      }
    }

    return $2

WhenCondition
  __ When ExpressionWithIndentedApplicationForbidden:exp -> exp

CoffeeForStatementParameters
  # NOTE: Coffee for loops can't have parens
  ( Await __ )? InsertOpenParen:open CoffeeForDeclaration:declaration CoffeeForIndex?:index __ ( In / Of / From ):kind ExpressionWithIndentedApplicationForbidden:exp ( _? By ExpressionWithIndentedApplicationForbidden )?:step InsertCloseParen:close ->
    let blockPrefix = []
    exp = insertTrimmingSpace(exp, "")
    declaration = insertTrimmingSpace(declaration, "")

    if (kind.token === "from") {
      if (step) {
        throw new Error("Can't use 'by' with 'from' in CoffeeScript for loops")
      }
      kind.token = "of"
    } else if (kind.token === "of") {
      if (step) {
        throw new Error("Can't use 'by' with 'of' in CoffeeScript for loops")
      }

      // TODO: Exp ref if exp is not a literal or identifier

      if (declaration.own) {
        const hasPropRef = module.getRef("hasProp")

        blockPrefix./**/push(["", "if (!", hasPropRef, ".call(", exp, ", ", declaration, ")) continue", ";"])
      }

      // index is actually value in Coffee "for of", y = z[x]
      if (index) {
        blockPrefix./**/push(["", {
          type: "AssignmentExpression",
          children: [index, " = ", exp, "[", declaration, "]"],
          names: index.names,
        }, ";"])
      }

      kind.token = "in"
    } else if (kind.token === "in") { // CoffeeScript loop comprehensions
      const counterRef = {
        type: "Ref",
        base: "i",
        id: "i",
      }

      const lenRef = {
        type: "Ref",
        base: "len",
        id: "len",
      }

      // If exp isn't a simple identifier use a ref
      let expRef
      switch(exp.type) {
        case "Identifier":
          expRef = exp
          break
        case "RangeExpression":
          return forRange(open, declaration, exp, step?.[2], close)
        default:
          expRef = {
            type: "Ref",
            base: "ref",
            id: "ref",
          }
      }

      const varRef = declaration
      let increment = "++",
        indexAssignment,
        assignmentNames = [...varRef.names]

      if (index) {
        index = insertTrimmingSpace(index, "")
        indexAssignment = [index, "="]
        assignmentNames./**/push(...index.names)
      }

      const expRefDec = (expRef !== exp)
        // Trim a single leading space if present
        ? [expRef, " = ", insertTrimmingSpace(exp, ""), ", "]
        : []

      blockPrefix./**/push(["", {
        type: "AssignmentExpression",
        children: [varRef, " = ", expRef, "[", indexAssignment, counterRef, "]"],
        names: assignmentNames,
      }, ";"])

      declaration = {
        type: "Declaration",
        children: ["let ", ...expRefDec, counterRef, " = 0, ", lenRef, " = ", expRef, ".length"],
        names: []
      }

      let condition = [counterRef, " < ", lenRef, "; "]

      if (step) {
        let [stepWs, , stepExp] = step
        stepWs = insertTrimmingSpace(stepWs, "")
        if (stepExp.type === "Literal") {
          increment = [" +=", ...stepWs, stepExp]
          // Negative step loops are reversed
          if ( stepExp.raw[0] === "-") {
            declaration = {
              type: "Declaration",
              children: ["let ", ...expRefDec, counterRef, " = ", expRef, ".length - 1"],
              names: []
            }
            condition = [counterRef, " >= 0; "]
          }
        } else {
          throw new Error("TODO: Support non-literal step in CoffeeScript for loops")
        }

        return {
          declaration,
          children: [$1, open, declaration, "; ", ...condition, counterRef, increment, close],
          blockPrefix,
        }
      }

      return {
        declaration,
        children: [$1, open, declaration, "; ", ...condition, counterRef, increment, close],
        blockPrefix,
      }
    }

    return {
      declaration,
      children: [$1, open, declaration, $5, kind, " ", exp, close],
      blockPrefix,
    }
  ForRangeParameters

CoffeeForIndex
  _?:ws1 Comma _?:ws2 BindingIdentifier:id ->
    ws2 = insertTrimmingSpace(ws1, "")

    return {
      ...id,
      children: [...(ws1 || []), ...(ws2 || []), ...id.children]
    }

CoffeeForDeclaration
  # NOTE: Coffee doesn't allow expression bindings like `for a.x in b`
  ( __ "own" NonIdContinue )?:own ForBinding:binding ->
    return {
      type: "AssignmentExpression",
      own: Boolean(own),
      children: [$2],
      names: $2.names,
    }

ForStatementParameters
  # https://262.ecma-international.org/#prod-ForStatement
  OpenParen __       ( LexicalDeclaration / VariableStatement / Expression? ):declaration __ Semicolon Expression? Semicolon Expression? __ CloseParen ->
    return {
      declaration,
      children: $0,
    }
  # NOTE: Added optional parens
  InsertOpenParen __ ( LexicalDeclaration / VariableStatement / Expression? ):declaration __ Semicolon Expression? Semicolon (!EOS Expression)? InsertCloseParen ->
    return {
      declaration,
      children: $0,
    }

  # https://262.ecma-international.org/#prod-ForInOfStatement
  # NOTE: Consolidated declarations
  # NOTE: Consolidated optional 'await'
  ( Await __ )? OpenParen:open __    ForInOfDeclaration:declaration __ ( In / Of ):op ExpressionWithIndentedApplicationForbidden:exp ( __ By ExpressionWithIndentedApplicationForbidden )?:step __ CloseParen:close ->
    if (exp.type === "RangeExpression" && op.token === "of") {
      return forRange(open, declaration, exp, step, close)
    } else if (step) {
      throw new Error("for..of/in cannot use 'by' except with range literals")
    }
    return {
      declaration,
      children: $0,
    }
  # NOTE: Added optional parens
  ( Await __ )? InsertOpenParen:open ForInOfDeclaration:declaration __ ( In / Of ):op ExpressionWithIndentedApplicationForbidden:exp ( __ By ExpressionWithIndentedApplicationForbidden )?:step InsertCloseParen:close ->
    if (exp.type === "RangeExpression" && op.token === "of") {
      return forRange(open, declaration, exp, step, close)
    } else if (step) {
      throw new Error("for..of/in cannot use 'by' except with range literals")
    }
    return {
      declaration: declaration,
      children: $0,
    }
  ForRangeParameters

ForRangeParameters
  # NOTE: CoffeeScript-style `for [start..end] by step` without declaration
  ( Await __ )? OpenParen:open OpenBracket RangeExpression:exp CloseBracket ( __ By ExpressionWithIndentedApplicationForbidden )?:step CloseParen:close ->
    return forRange(open, null, exp, step, close)
  ( Await __ )? InsertOpenParen:open OpenBracket RangeExpression:exp CloseBracket ( __ By ExpressionWithIndentedApplicationForbidden )?:step InsertCloseParen:close ->
    return forRange(open, null, exp, step, close)

# NOTE: Consolidated declarations
ForInOfDeclaration
  Var ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: $0,
      declare: $1,
      names: binding.names,
    }
  ForDeclaration
  LeftHandSideExpression

# https://262.ecma-international.org/#prod-ForDeclaration
ForDeclaration
  LetOrConst:c ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      declare: c,
      names: binding.names,
    }
  # NOTE: Added default implicit const to for bindings
  # NOTE: the assertion is a bit of a hack to prevent valid LHS expressions from only parsing the identifier and matching this rule
  # i.e. a.x would match as identifier `a` without this lookahead
  InsertConst:c ForBinding:binding /(?=[\s\)])/ ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      declare: c,
      names: binding.names,
    }

# https://262.ecma-international.org/#prod-ForBinding
ForBinding
  BindingIdentifier
  BindingPattern

# https://262.ecma-international.org/#prod-SwitchStatement
SwitchStatement
  Switch ( EmptyCondition / Condition ):condition CaseBlock:caseBlock ->
    if (condition.type === "EmptyCondition") {
      // Negate all case condition expressions. This converts them to booleans
      // and is slightly smaller than switch(true) {case: !!exp ... }
      caseBlock.clauses.forEach(({cases}) => {
        if (cases) {
          cases.forEach((c) => {
            const exp = c[1]
            switch(exp.type) {
              case "Identifier":
              case "Literal":
                c.splice(1, 0, "!")
                break;
              default:
               c.splice(1, 1, "!(", exp, ")")
            }
          })
        }
      })
    }

    return {
      type: "SwitchStatement",
      children: $0,
      expression: condition,
      caseBlock,
    }

EmptyCondition
  &EOS ->
    return {
      type: "EmptyCondition",
      children: [{
        $loc,
        token: " (false)",
      }]
    }

# NOTE: Added from CoffeeScript
SwitchExpression
  SwitchStatement:e ->
    return {
      type: "SwitchExpression",
      // wrap with IIFE
      children: module.wrapIIFE(e.children),
      expression: e.expression,
      caseBlock: e.caseBlock,
    }

# https://262.ecma-international.org/#prod-CaseBlock
CaseBlock
  ( Samedent / _ )? OpenBrace NestedCaseClauses:clauses __ CloseBrace ->
    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

  # NOTE: Added optional braces with nesting
  InsertOpenBrace NestedCaseClauses:clauses InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

NestedCaseClauses
  PushIndent NestedCaseClause*:clauses PopIndent ->
    if (clauses.length) return clauses
    return $skip

NestedCaseClause
  Nested:indent CaseClause:clause ->
    return {
      ...clause,
      // Bring the indent into the clause
      children: [indent, ...clause.children],
    }

# https://262.ecma-international.org/#prod-CaseClause
CaseClause
  MatchingPattern:pattern ( ThenClause / NestedBlockStatements / EmptyBareBlock ):block ->
    return {
      type: "PatternClause",
      children: $0,
      block,
      pattern,
    }
  Case CaseExpressionList ( NestedBlockStatements / EmptyBareBlock ) -> {
    type: "CaseClause",
    children: $0
  }
  # NOTE: Added "when" from CoffeeScript. `when` always inserts `break;`.
  When CaseExpressionList:cases InsertOpenBrace ( ThenClause / NestedBlockStatements / EmptyBareBlock ):block InsertBreak:b InsertNewline InsertIndent InsertCloseBrace ->
    return {
      type: "WhenClause",
      cases,
      block,
      break: b,
      children: $0,
    }
  # NOTE: Merged in default clause
  Default ImpliedColon ( NestedBlockStatements / EmptyBareBlock ):block ->
    return {
      type: "DefaultClause",
      block,
      children: $0
    }
  # NOTE: Added else from CoffeeScript
  Else ImpliedColon ( ThenClause / BracedBlock / EmptyBlock ):block ->
    $1.token = "default"
    return {
      type: "DefaultClause",
      block,
      children: $0
    }

CaseExpressionList
  ForbidMultiLineImplicitObjectLiteral ( _* ExpressionWithIndentedApplicationForbidden ImpliedColon )?:first ( __ Comma ExpressionWithIndentedApplicationForbidden ImpliedColon )*:rest RestoreMultiLineImplicitObjectLiteral ->
    if (!first) return $skip
    // Convert comma separated expression list to `case <exp>:`
    const result = rest.map(([ws, _comma, exp, col]) => {
      exp = insertTrimmingSpace(exp, "")

      if (ws.length) return [insertTrimmingSpace("case ", ws), exp, col]
      return ["case ", exp, col]
    })
    result./**/unshift(first)

    return result

ImpliedColon
  _? Colon
  "" ->
    return { $loc, token: ":" }

# https://262.ecma-international.org/#prod-TryStatement
TryStatement
  Try:t NoPostfixBracedOrEmptyBlock:b CatchClause?:c FinallyClause?:f ->
    if (!c && !f) {
      const e = []
      const emptyCatchBlock = {
        type: "BlockStatement",
        expressions: e,
        children: ["{", e, "}"],
        bare: false,
        empty: true,
      }

      c = {
        type: "CatchClause",
        children: [" catch(e) ", emptyCatchBlock],
        block: emptyCatchBlock,
      }

      return {
        type: "TryStatement",
        blocks: [ b, emptyCatchBlock ],
        children: [t, b, c],
      }
    }

    const blocks = [b]
    if (c) blocks.push(c.block)

    return {
      type: "TryStatement",
      blocks,
      children: [t, b, c, f],
    }

TryExpression
  TryStatement:t ->
    return {
      type: "TryExpression",
      blocks: t.blocks,
      children: module.wrapIIFE(t)
    }

# https://262.ecma-international.org/#prod-Catch
CatchClause
  ( Samedent / _ ) Catch CatchBind? ( ThenClause / BracedOrEmptyBlock ):block ->
    return {
      type: "CatchClause",
      children: $0,
      block,
    }

# NOTE: Added optional parentheses to catch binding
CatchBind
  _? OpenParen __ CatchParameter __ CloseParen
  _ InsertOpenParen CatchParameter InsertCloseParen

# https://262.ecma-international.org/#prod-Finally
FinallyClause
  ( Samedent / _ ) Finally ( ThenClause / BracedOrEmptyBlock )

# https://262.ecma-international.org/#prod-CatchParameter
CatchParameter
  BindingIdentifier TypeSuffix?
  BindingPattern TypeSuffix?

# An expression with explicit or implied parentheses, for use in if/while/switch
Condition
  # NOTE: DeclarationCondition must come before the ExpressionCondition because we need to look ahead to potentially match `:=` or `.=`
  OpenParen:open _?:ws DeclarationCondition:expression CloseParen:close ->
    return {
      type: "ParenthesizedExpression",
      children: [open, ws, expression, close],
      expression,
    }
  ParenthesizedExpression !( _? ( BinaryOp / AssignmentOp / Dot / QuestionMark ) ) !( _ OperatorAssignmentOp ) -> $1
  # NOTE: DeclarationCondition must come before the ExpressionCondition because we need to look ahead to potentially match `:=` or `.=`
  InsertOpenParen:open DeclarationCondition:expression InsertCloseParen:close ->
    return {
      type: "ParenthesizedExpression",
      children: [open, expression, close],
      expression,
    }

  InsertOpenParen:open ExpressionWithIndentedApplicationForbidden:expression InsertCloseParen:close ->
    // Don't double wrap parethesized expressions
    if (expression.type === "ParenthesizedExpression") return expression
    expression = insertTrimmingSpace(expression, "")
    return {
      type: "ParenthesizedExpression",
      children: [open, expression, close],
      expression,
    }

DeclarationCondition
  LexicalDeclaration:dec ->
    const ref = {
      type: "Ref",
      base: "ref",
    }

    const { binding, initializer } = dec

    const initCondition = {
      type: "AssignmentExpression",
      children: [ref, " ", initializer],
      hoistDec: [["", ["let ", ref], ";"]],
      blockPrefix: [["", [ binding, "= ", ref ], ";"]],
    }

    return initCondition

ExpressionWithIndentedApplicationForbidden
  ForbidIndentedApplication ExtendedExpression?:exp RestoreIndentedApplication ->
    if (exp) return exp
    return $skip

ForbidClassImplicitCall
  "" ->
    module.forbidIndentedApplication.push(true)

AllowClassImplicitCall
  "" ->
    module.forbidIndentedApplication.push(false)

RestoreClassImplicitCall
  "" ->
    module.forbidIndentedApplication.pop()

ClassImplicitCallForbidden
  "" ->
    if (module.classImplicitCallForbidden) return $skip
    return

ForbidIndentedApplication
  "" ->
    module.forbidIndentedApplication.push(true)

AllowIndentedApplication
  "" ->
    module.forbidIndentedApplication.push(false)

RestoreIndentedApplication
  "" ->
    module.forbidIndentedApplication.pop()

IndentedApplicationAllowed
  "" ->
    if (module.config.verbose) {
      console.log("forbidIndentedApplication:", module.forbidIndentedApplication)
    }
    if (module.indentedApplicationForbidden) return $skip
    return

ForbidTrailingMemberProperty
  "" ->
    module.forbidTrailingMemberProperty.push(true)

AllowTrailingMemberProperty
  "" ->
    module.forbidTrailingMemberProperty.push(false)

RestoreTrailingMemberProperty
  "" ->
    module.forbidTrailingMemberProperty.pop()

TrailingMemberPropertyAllowed
  "" ->
    if (module.config.verbose) {
      console.log("forbidTrailingMemberProperty:", module.forbidTrailingMemberProperty)
    }
    if (module.trailingMemberPropertyForbidden) return $skip

ForbidMultiLineImplicitObjectLiteral
  "" ->
    module.forbidMultiLineImplicitObjectLiteral.push(true)

AllowMultiLineImplicitObjectLiteral
  "" ->
    module.forbidMultiLineImplicitObjectLiteral.push(false)

RestoreMultiLineImplicitObjectLiteral
  "" ->
    module.forbidMultiLineImplicitObjectLiteral.pop()

MultiLineImplicitObjectLiteralAllowed
  "" ->
    if (module.config.verbose) {
      console.log("forbidMultiLineImplicitObjectLiteral:", module.forbidMultiLineImplicitObjectLiteral)
    }
    if (module.multiLineImplicitObjectLiteralForbidden) return $skip

AllowAll
  AllowTrailingMemberProperty AllowIndentedApplication AllowMultiLineImplicitObjectLiteral AllowClassImplicitCall

RestoreAll
  RestoreTrailingMemberProperty RestoreIndentedApplication RestoreMultiLineImplicitObjectLiteral RestoreClassImplicitCall

# https://262.ecma-international.org/#prod-ExpressionStatement
ExpressionStatement
  # NOTE: semi-colons are being handled elsewhere
  # NOTE: Shouldn't need negative lookahead if shadowed in the proper order
  # NOTE: Allow for e.g. await forms of IterationExpression that weren't
  # already parsed as IterationStatement. Must be before Expression to avoid
  # treated `async do ...` like a function call `async(do ...)`.
  IterationExpression
  # NOTE: Expression enables , operator
  Expression

KeywordStatement
  # https://262.ecma-international.org/#prod-BreakStatement
  # NOTE: Also allow `break :label` for symmetry
  Break ( _ Colon? Identifier:id )? ->
    return {
      type: "BreakStatement",
      children: $2 ? [ $1, $2[0], $2[2] ] : [ $1 ],
                           // omit colon
    }

  # https://262.ecma-international.org/#prod-ContinueStatement
  # NOTE: Also allow `continue :label` for symmetry
  Continue ( _ Colon? Identifier:id )? ->
    return {
      type: "ContinueStatement",
      children: $2 ? [ $1, $2[0], $2[2] ] : [ $1 ],
                           // omit colon
    }

  # https://262.ecma-international.org/#sec-debugger-statement
  Debugger -> {
    type: "DebuggerStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ReturnStatement
  # NOTE: Modified to leave room for `return.value` and `return =`
  Return !("." / AfterReturnShorthand) MaybeNestedExpression?:expression -> {
    type: "ReturnStatement",
    expression,
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ThrowStatement
  Throw ExtendedExpression -> {
    type: "ThrowStatement",
    children: $0,
  }

Break
  "break" NonIdContinue ->
    return { $loc, token: $1 }

Continue
  "continue" NonIdContinue ->
    return { $loc, token: $1 }

Debugger
  "debugger" NonIdContinue ->
    return { $loc, token: $1 }

DebuggerExpression
  Debugger ->
    return {
      type: "DebuggerExpression",
      children: module.wrapIIFE($1),
    }

ThrowExpression
  Throw ExtendedExpression ->
    return {
      type: "ThrowExpression",
      children: module.wrapIIFE($0),
    }

MaybeNestedExpression
  # Not nested case
  !EOS ExtendedExpression ->
    return $2
  # Avoid wrapping object return value in parentheses.
  &EOS ObjectLiteral ->
    return $2
  # Value after `return` needs to be wrapped in parentheses
  # if it starts on another line.
  &EOS InsertSpace InsertOpenParen PushIndent Nested ExtendedExpression PopIndent InsertNewline InsertIndent InsertCloseParen

# https://262.ecma-international.org/#prod-ImportDeclaration
ImportDeclaration
  Import __ TypeKeyword __ ImportClause __ FromClause ImportAssertion? -> { type: "ImportDeclaration", ts: true, children: $0 }
  Import __ ImportClause __ FromClause ImportAssertion? -> { type: "ImportDeclaration", children: $0 }
  Import __ ModuleSpecifier ImportAssertion? -> { type: "ImportDeclaration", children: $0 }
  # NOTE: Added import shorthand
  # NOTE: Not adding $loc to source map here yet because it will point to the start of the identifier
  # the proper place may be to use the From location
  ImpliedImport:i ( TypeKeyword __ )?:t ImportClause:c __:w FromClause:f ImportAssertion?:a ->
    // Map implied import location to `from`
    // The pos and length adjustment better match how tsc outputs to include the space before `from` with the `from` token
    i.$loc = {
      pos: f[0].$loc.pos-1,
      length: f[0].$loc.length+1,
    }
    const children = [i, t, c, w, f, a]
    if (!t) return children
    return { type: "ImportDeclaration", ts: true, children }

ImpliedImport
  "" ->
    return { $loc, token: "import " }

# https://262.ecma-international.org/#prod-ImportClause
ImportClause
  ImportedBinding:binding ( __ Comma __ ( NameSpaceImport / NamedImports ) )?:rest ->
    if (rest) {
      return {
        type: "Declaration",
        children: $0,
        names: [...binding.names, ...rest[3].names],
      }
    }

    return {
      type: "Declaration",
      children: $0,
      names: binding.names,
    }
  NameSpaceImport
  NamedImports

# https://262.ecma-international.org/#prod-NameSpaceImport
NameSpaceImport
  Star ImportAsToken __ ImportedBinding:binding  ->
    return {
      type: "Declaration",
      children: $0,
      names: binding.names
    }

# https://262.ecma-international.org/#prod-NamedImports
NamedImports
  OpenBrace TypeAndImportSpecifier*:specifiers ( __ Comma )? __ CloseBrace ->
    const names = specifiers.flatMap(({binding}) => binding.names)

    return {
      type: "Declaration",
      children: $0,
      names
    }

# https://262.ecma-international.org/#prod-FromClause
FromClause
  From __ ModuleSpecifier

# https://github.com/tc39/proposal-import-assertions
# https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#import-assertions
# NOTE: Forbid newline before `assert` which could mean a function call
ImportAssertion
  _? "assert" NonIdContinue _? ObjectLiteral

# https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports
TypeAndImportSpecifier
  ( __ TypeKeyword )? ImportSpecifier ->
    if (!$1) return $2
    return { ts: true, children: $0, binding: $2.binding }
  # `operator id` blesses `id` as operator; doesn't make sense with `type`
  __:ws Operator ImportSpecifier:spec ->
    if (spec.binding.type !== "Identifier") {
      throw new Error("Expected identifier after `operator`")
    }
    module.operators.add(spec.binding.name)
    return {
      ...spec,
      children: [
        ws, insertTrimmingSpace(spec[0], ""),
        spec.children.slice(1),
      ],
    }

# https://262.ecma-international.org/#prod-ImportSpecifier
ImportSpecifier
  __ ModuleExportName ImportAsToken __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding: binding,
      children: $0,
    }
  __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding: binding,
      children: $0,
    }

ImportAsToken
  __ As
  # NOTE: Allowing ':' in place of 'as', a preliminary step towards unifying
  # imports and destructuring.
  Loc:l __:ws Colon:c " "? ->
    const children = [
      ...ws,
      { ...c, token: "as " },
    ]

    if (!ws.length) {
      children.unshift({ $loc: l.$loc, token: " " })
    }

    return {
      children,
    }

# https://262.ecma-international.org/#prod-ModuleExportName
ModuleExportName
  StringLiteral
  IdentifierName

# https://262.ecma-international.org/#prod-ModuleSpecifier
ModuleSpecifier
  UnprocessedModuleSpecifier ->
    if (!module.config.rewriteTsImports) return $1

    // Workaround to fix:
    // https://github.com/microsoft/TypeScript/issues/42151
    // import t.ts
    // "An import path cannot end with a '.ts' extension. Consider importing './t.js' instead."
    const { token } = $1
    // convert .[mc]?ts to .[mc]?js
    return { $loc, token: token.replace(/\.([mc])?ts(['"])$/, ".$1js$2") }

UnprocessedModuleSpecifier
  StringLiteral
  UnquotedSpecifier

UnquotedSpecifier
  # Currently allowing all characters except for whitespace, double quotes, and semi-colon
  # It may make sense to restrict this to only allow characters that are valid in a module specifier
  # Also consider URLs
  /[^;"\s]+/:spec ->
    return { $loc, token: `"${spec}"` }

# https://262.ecma-international.org/#prod-ImportedBinding
ImportedBinding
  BindingIdentifier

# https://262.ecma-international.org/#prod-ExportDeclaration
ExportDeclaration
  # NOTE: Using ExtendedExportDeclaration to allow If/Switch expressions
  Export __ Default __ ( HoistableDeclaration / ClassDeclaration / ExtendedExpression ) ->
    return { type: "ExportDeclaration", children: $0 }
  Export __ ExportFromClause __ FromClause ->
    return { type: "ExportDeclaration", ts: $3.ts, children: $0 }
  # NOTE: Declaration and VariableStatement should come before NamedExports
  # so that NamedExports doesn't grab function, async, type, var, etc.
  # NOTE: TS decorators come before `export` keyword but TC39 stage 3 decorators proposal come after
  Decorators? Export __ ( Declaration / VariableStatement / TypeAndNamedExports / ExportVarDec ):decl ->
    return { type: "ExportDeclaration", ts: decl.ts, children: $0 }

# CoffeeScript style `export x = 3` -> `export var x = 3`
ExportVarDec
  InsertVar VariableDeclarationList ->
    return {
      ...$2,
      children: [$1, ...$2.children]
    }

# https://262.ecma-international.org/#prod-ExportFromClause
ExportFromClause
  Star ( __ As __ ModuleExportName )?
  TypeAndNamedExports

# https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports
TypeAndNamedExports
  ( TypeKeyword __ )? NamedExports ->
    if (!$1) return $2
    return { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-NamedExports
NamedExports
  OpenBrace ExportSpecifier* (__ Comma )? __ CloseBrace
  # Unbraced version: export x, y
  InsertInlineOpenBrace:open ImplicitExportSpecifier ( _ ImplicitExportSpecifier )* InsertCloseBrace:close ->
    return [open, $2, ...$3, close]

# https://262.ecma-international.org/#prod-ExportSpecifier
ExportSpecifier
  __ ( TypeKeyword __ )? ModuleExportName ( __ As __ ModuleExportName )? ObjectPropertyDelimiter ->
    if (!$2) return $0
    return { ts: true, children: $0 }

ImplicitExportSpecifier
  !Default ModuleExportName ( __ As __ ModuleExportName )? ( &( __ From ) / ImplicitInlineObjectPropertyDelimiter )

# https://262.ecma-international.org/#prod-Declaration
Declaration
  HoistableDeclaration
  ClassDeclaration
  LexicalDeclaration
  TypeDeclaration
  EnumDeclaration
  OperatorDeclaration

# https://262.ecma-international.org/#prod-HoistableDeclaration
HoistableDeclaration
  FunctionDeclaration

# https://262.ecma-international.org/#prod-LexicalDeclaration
LexicalDeclaration
  # NOTE: Eliminated left recursion
  LetOrConst LexicalBinding:binding ( __ Comma LexicalBinding )*:tail ->
    return {
      type: "Declaration",
      children: $0,
      names: [...binding.names].concat(tail.flatMap(([,,b]) => b.names)),
    }
  # NOTE: Added const shorthand
  # NOTE: Using ExtendedExpression to allow for If/SwitchExpressions
  InsertConst ( BindingPattern / BindingIdentifier ) TypeSuffix? __ ConstAssignment ExtendedExpression ->
    return processConstAssignmentDeclaration(...$0)

  # Note added let shorthand
  InsertLet:l ( BindingPattern / BindingIdentifier ):id TypeSuffix?:suffix __:ws LetAssignment:la ExtendedExpression:e ->
    return processLetAssignmentDeclaration(...$0)

ConstAssignment
  ":=" ->
    return { $loc, token: "=" }

LetAssignment
  ".=" ->
    return { $loc, token: "=" }

# https://262.ecma-international.org/#prod-LexicalBinding
LexicalBinding
  BindingPattern TypeSuffix? Initializer ->
    const children = [...$1.children]
    if ($2) children./**/push($2)
    children./**/push($3)
    return {
      children,
      names: $1.names,
    }

  BindingIdentifier TypeSuffix? Initializer? ->
    const children = [...$1.children]
    if ($2) children./**/push($2)
    if ($3) children./**/push($3)
    return {
      children,
      names: $1.names,
    }

# https://262.ecma-international.org/#prod-Initializer
Initializer
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  __ Equals ExtendedExpression

# https://262.ecma-international.org/#prod-VariableStatement
VariableStatement
  Var __ VariableDeclarationList ->
    return Object.assign({}, $3, {
      children: [$1, ...$2, ...$3.children],
    })

# https://262.ecma-international.org/#prod-VariableDeclarationList
VariableDeclarationList
  VariableDeclaration ( __ Comma __ VariableDeclaration )* ->
    let children
    if ($2.length) {
      children = [$1, ...$2]
    }else {
      children = [$1]
    }

    const names = children.flatMap((c) => c.names || [])

    return {
      type: "Declaration",
      children,
      names,
    }

# https://262.ecma-international.org/#prod-VariableDeclaration
VariableDeclaration
  BindingPattern TypeSuffix? Initializer ->
    const children = [...$1.children]
    if ($2) children./**/push($2)
    children./**/push($3)
    return {
      children,
      names: $1.names,
    }

  BindingIdentifier TypeSuffix? Initializer? ->
    const children = [...$1.children]
    if ($2) children./**/push($2)
    if ($3) children./**/push($3)
    return {
      children,
      names: $1.names,
    }

# https://262.ecma-international.org/#prod-NumericLiteral
# NOTE: No leading minus sign
NumericLiteral
  NumericLiteralKind ->
    return { type: "NumericLiteral", $loc, token: $1 }

NumericLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral
  DecimalLiteral

# https://262.ecma-international.org/#prod-DecimalBigIntegerLiteral
DecimalBigIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)n/
  # /[_0-9]*n/

# https://262.ecma-international.org/#prod-DecimalLiteral
DecimalLiteral
  # NOTE: Not matching the dot as part of a number if it is followed by a valid JS identifier so that it will match as a property access
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?=\.(?:\p{ID_Start}|[_$]))/ ) ->
    // Insert an extra dot to make property access work
    return $1 + "."
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?:\.(?:[0-9](?:_[0-9]|[0-9])*))?/ ExponentPart? )
  $( /(?:\.[0-9](?:_[0-9]|[0-9])*)/ ExponentPart? )

ExponentPart
  /(?:[eE][+-]?[0-9]+(?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-BinaryIntegerLiteral
BinaryIntegerLiteral
  /0[bB][01](?:[01]|_[01])*n?/

# https://262.ecma-international.org/#prod-OctalIntegerLiteral
OctalIntegerLiteral
  /0[oO][0-7](?:[0-7]|_[0-7])*n?/

# https://262.ecma-international.org/#prod-HexIntegerLiteral
HexIntegerLiteral
  /0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_[0-9a-fA-F])*n?/

# NOTE: Integer variation of NumericLiteral
IntegerLiteral
  IntegerLiteralKind ->
    return { $loc, token: $1 }

IntegerLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral
  DecimalIntegerLiteral

DecimalIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-StringLiteral
# NOTE: This includes unprocessed double-quoted strings.  If you might want to
# accept a template literal in the form of a CoffeeScript double-quoted string
# interpolation, be sure to check TemplateLiteral before StringLiteral.
StringLiteral
  DoubleQuote DoubleStringCharacters:str DoubleQuote ->
    return {
      type: "StringLiteral",
      token: `"${modifyString(str.token)}"`,
      $loc,
    }

  SingleQuote SingleStringCharacters:str SingleQuote ->
    return {
      type: "StringLiteral",
      token: `'${modifyString(str.token)}'`,
      $loc,
    }

DoubleStringCharacters
  /(?:\\.|[^"])*/ ->
    return { $loc, token: $0 }

SingleStringCharacters
  /(?:\\.|[^'])*/ ->
    return { $loc, token: $0 }

TripleDoubleStringCharacters
  /(?:"(?!"")|#(?!\{)|\\.|[^#"])+/ ->
    return { $loc, token: $0 }

TripleSingleStringCharacters
  /(?:'(?!'')|\\.|[^'])*/ ->
    return { $loc, token: $0 }

CoffeeStringSubstitution
  CoffeeSubstitutionStart PostfixedExpression __ CloseBrace

CoffeeInterpolatedDoubleQuotedString
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringSubstitution )*:parts DoubleQuote:e ->
    return processCoffeeInterpolation(s, parts, e, $loc)

CoffeeDoubleQuotedStringCharacters
  /(?:\\.|#(?!\{)|[^"#])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#prod-RegularExpressionLiteral
RegularExpressionLiteral
  HeregexLiteral
  $("/" RegularExpressionBody "/" RegularExpressionFlags) ->
    return { type: "RegularExpressionLiteral", $loc, token: $1 }

RegularExpressionClass
  $(OpenBracket RegularExpressionClassCharacters CloseBracket) ->
    return { $loc, token: $1 }

RegularExpressionClassCharacters
  /(?:\\.|[^\]])*/ ->
    return { $loc, token: $0 }

HeregexLiteral
  TripleSlash:open HeregexBody:body TripleSlash:close RegularExpressionFlags:flags ->
    let hasSubstitutions = body.some((part) => part.type === "Substitution")

    if (hasSubstitutions) {
      const result = [
        {...open, token: "RegExp(`"},
        // Escape backticks, backslashes, and '$' in the body text
        body.map(e => e.type === "Substitution"
          ? e
          : {
            ...e,
            token: e.token.replace(/`|\\|\$/g, "\\$&"),
          }
        ),
        "`"
      ]

      if (flags.length) {
        result.push(
          ", ",
          JSON.stringify(flags)
        )
      }
      result.push( {...close, token: ")" })
      return result
    }

    return {
      type: "RegularExpressionLiteral",
      children: $0,
    }

HeregexBody
  !TripleSlash HeregexPart* -> $2

HeregexPart
  RegularExpressionClass

  CoffeeStringSubstitution -> { type: "Substitution", children: $1 }
  TemplateSubstitution -> { type: "Substitution", children: $1 }

  /(?:\\.)/ ->
    let token = $0
    switch ($0[1]) {
      case "\n": token = "\\n"; break
      case "\r": token = "\\r"; break
      case " ": token =   " "; break
    }
    return { $loc, token }

  HeregexComment ->
    return { $loc, token: "" }
  # NOTE: CoffeeScript strips out all unescaped whitespace chars
  # but Python doesn't strip out whitespace inside character classes
  # or inside '(?' groups and assertions
  # TODO: this behavior should be toggled by a coffeeCompat directive
  /[\s]+/ ->
    return { $loc, token: "" }
  # Escape forward slashes (that aren't part of a triple slash)
  /\/(?!\/\/)/ ->
    return { $loc, token: "\\/" }
  /[^[\/\s#\\]+/ ->
    return { $loc, token: $0 }

HeregexComment
  # NOTE: CoffeeScript doesn't treat JS comments as regex comments
  # TODO: this behavior should be toggled by a coffeeCompat directive
  JSSingleLineComment
  CoffeeSingleLineComment

# https://262.ecma-international.org/#prod-RegularExpressionBody
# NOTE: Simplified a little from the spec, ignoring <PS>, <LS>
RegularExpressionBody
  ![*\/\r\n] RegExpPart*

RegExpPart
  RegularExpressionClass
  RegExpCharacter

RegExpCharacter
  /(?:\\.|[^[\/\r\n])+/

# https://262.ecma-international.org/#prod-RegularExpressionFlags
RegularExpressionFlags
  /(?:\p{ID_Continue}|[\u200C\u200D$])*/

# https://262.ecma-international.org/#prod-TemplateLiteral
# NOTE: Simplified template grammar
TemplateLiteral
  TripleTick ( TemplateBlockCharacters / TemplateSubstitution )* TripleTick ->
    return module.dedentBlockSubstitutions($0)

  Backtick ( TemplateCharacters / TemplateSubstitution )* Backtick ->
    return {
      type: "TemplateLiteral",
      children: $0,
    }

  # NOTE: actual CoffeeScript """ string behaviors are pretty weird, this is simplifed
  TripleDoubleQuote ( TripleDoubleStringCharacters / CoffeeStringSubstitution )* TripleDoubleQuote ->
    return module.dedentBlockSubstitutions($0)

  # NOTE: ''' don't have interpolation so could be converted into a regular
  # String, but currently we use `template`s so the output looks similar to
  # the input.  Also, this enables tagged template literals such as tag'''x''',
  # which CoffeeScript also allows.
  TripleSingleQuote:s TripleSingleStringCharacters:str TripleSingleQuote:e ->
    return {
      type: "TemplateLiteral",
      children: [s, module.dedentBlockString(str), e]
    }

  # CoffeeScript Interpolation is enabled when "civet coffee-compat" or "civet coffee-interpolation" directive is present
  CoffeeInterpolatedDoubleQuotedString

# NOTE: Simplified grammar
TemplateSubstitution
  SubstitutionStart PostfixedExpression __ CloseBrace

# https://262.ecma-international.org/#prod-TemplateCharacter
TemplateCharacters
  /(?:\$(?!\{)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

TemplateBlockCharacters
  /(?:\$(?!\{)|`(?!``)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#sec-comments
ReservedWord
  CoffeeBooleansEnabled /(?:on|off|yes|no)(?!\p{ID_Continue})/
  CoffeeIsntEnabled /(?:isnt)(?!\p{ID_Continue})/
  CoffeeForLoopsEnabled /(?:by)(?!\p{ID_Continue})/
  CoffeeOfEnabled /(?:of)(?!\p{ID_Continue})/
  # NOTE: Added `let`, Civet assumes strict mode
  /(?:and|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|import|in|instanceof|interface|is|let|loop|new|not|null|or|private|protected|public|return|static|super|switch|this|throw|true|try|typeof|unless|until|var|void|while|with|yield)(?!\p{ID_Continue})/

# https://262.ecma-international.org/#sec-comments
Comment
  MultiLineComment
  SingleLineComment

# https://262.ecma-international.org/#prod-SingleLineComment
# This is more accurately called "RestOfLineComment"
SingleLineComment
  JSSingleLineComment
  CoffeeCommentEnabled CoffeeSingleLineComment

JSSingleLineComment
  # JS Comments are two slashes not followed by a third (because that is a heregex)
  /\/\/(?!\/)[^\r\n]*/ ->
    return { type: "Comment", $loc, token: $0 }

# https://262.ecma-international.org/#prod-MultiLineComment
MultiLineComment
  JSMultiLineComment
  # NOTE: Added CoffeeScript style ### multiline comments
  CoffeeMultiLineComment

JSMultiLineComment
  $( "/*" (!"*/" . )* "*/" ) ->
    return { type: "Comment", $loc, token: $1 }

CoffeeSingleLineComment
  # NOTE: CoffeeScript style single line comments
  /#(?!##(?!#))([^\r\n]*)/ ->
    return { type: "Comment", $loc, token: `//${$1}` }

CoffeeMultiLineComment
  CoffeeHereCommentStart $/[^]*?###/ ->
    $2 = $2.slice(0, $2.length-3).replace(/\*\//g, "* /")
    return { type: "Comment", $loc, token: `/*${$2}*/` }

CoffeeHereCommentStart
  /###(?!#)/

# InlineComment is a multi-line comment with no line separators
InlineComment
  $( "/*" $(!"*/" [^\r\n] )* "*/" ) ->
    return { $loc, token: $1 }

RestOfLine
  (NonNewlineWhitespace / SingleLineComment / MultiLineComment)* EOL

# Matches any whitespace optionally followed by a rest of line comment
# This will always succeed since each part is optional that's why it
# doesn't have `?` when used in other rules.
TrailingComment
  _? SingleLineComment?

# Non-newline "white space" (includes inline comments)
# TODO: Allow for inline Coffee comments when enabled
_
  ( NonNewlineWhitespace / InlineComment )+

NonNewlineWhitespace
  [ \t]+ ->
    return { $loc, token: $0 }
  CoffeeLineContinuationEnabled "\\" EOL -> ""

# Whitespace / comments with a single leading space trimmed off if possible
Trimmed_
  _*:ws ->
    return insertTrimmingSpace(ws, "")

# Optional whitespace including newlines and comments
__
  # Fast path for whitespace without comments
  # /(?!(?=\s|#|\/\/|\/\*))|[\s]+(?!(?:#|\/\/|\/\*))/ ->
  #   return [{ $loc, token: $0 }]
  ( Whitespace / Comment )*

Whitespace
  [\s]+ ->
    return { $loc, token: $0 }

# Fake a blocklike form for single expressions
ExpressionDelimiter
  _? Semicolon InsertComma TrailingComment ->
    // Replace semicolon with comma
    return [$1, $3, $4]
  &EOS InsertComma -> $2

SimpleStatementDelimiter
  SemicolonDelimiter
  &EOS

StatementDelimiter
  SemicolonDelimiter
  # NOTE: Avoid automatic continuation onto lines that start with
  # certain characters by adding an explicit semicolon.  See
  # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion
  # TODO: Would be better to do this in a `processBlocks` postprocessing step,
  # to avoid adding semicolons when they're not needed (e.g. `return` inserted
  # before value, or parens not actually added around ObjectLiteral).
  &( Samedent ( "(" / "[" / "`" / "+" / "-" / "*" / "/" / ObjectLiteral / Arrow / FatArrow / ( Function ( _? Star )? _? "(" ) ) ) InsertSemicolon
  &EOS

SemicolonDelimiter
  _? Semicolon TrailingComment ->
    return {
      type: "SemicolonDelimiter",
      children: $0
    }

NonIdContinue
  /(?!\p{ID_Continue})/

Loc
  "" ->
    return { $loc, token: "" }

## Tokens

Abstract
  $("abstract" NonIdContinue " "?) ->
    return { $loc, token: $1, ts: true }

Ampersand
  "&" ->
    return { $loc, token: $1 }

As
  "as" NonIdContinue ->
    return { $loc, token: $1 }

At
  "@" ->
    return { $loc, token: $1 }

# hack for experimentalDecorators
# Since `@` is premium real estate we use `@@` for decorators with all the shame that entails.
AtAt
  "@@" ->
    return { $loc, token: "@" }

Async
  "async" NonIdContinue ->
    return { $loc, token: $1, type: 'Async' }

Await
  "await" NonIdContinue ->
    return { $loc, token: $1, type: 'Await' }

Backtick
  "`" ->
    return { $loc, token: $1 }

By
  "by" NonIdContinue ->
    return { $loc, token: $1 }

Case
  "case" NonIdContinue ->
    return { $loc, token: $1 }

Catch
  "catch" NonIdContinue ->
    return { $loc, token: $1 }

Class
  "class" NonIdContinue ->
    return { $loc, token: $1 }

CloseBrace
  "}" ->
    return { $loc, token: $1 }

CloseBracket
  "]" ->
    return { $loc, token: $1 }

CloseParen
  ")" ->
    return { $loc, token: $1 }

CoffeeSubstitutionStart
  "#{" ->
    return { $loc, token: "${" }

Colon
  ":" !"=" ->
    return { $loc, token: $1 }

Comma
  "," ->
    return { $loc, token: $1 }

ConstructorShorthand
  "@" ->
    return { $loc, token: "constructor" }

Declare
  "declare" NonIdContinue ->
    return { $loc, token: $1 }

Default
  "default" NonIdContinue ->
    return { $loc, token: $1 }

Delete
  "delete" NonIdContinue ->
    return { $loc, token: $1 }

Do
  "do" NonIdContinue ->
    return { $loc, token: $1 }

Dot
  "." ->
    return { $loc, token: $1 }

DotDot
  ".." !"." ->
    return { $loc, token: $1 }

DotDotDot
  "..." ->
    return { $loc, token: $1 }

DoubleColon
  "::" ->
    return { $loc, token: $1 }

DoubleQuote
  "\"" ->
    return { $loc, token: $1 }

Else
  "else" NonIdContinue ->
    return { $loc, token: $1 }

Equals
  "=" ->
    return { $loc, token: $1 }

Export
  "export" NonIdContinue ->
    return { $loc, token: $1 }

Extends
  "extends" NonIdContinue ->
    return { $loc, token: $1 }

Finally
  "finally" NonIdContinue ->
    return { $loc, token: $1 }

For
  "for" NonIdContinue ->
    return { $loc, token: $1 }

From
  "from" NonIdContinue ->
    return { $loc, token: $1 }

Function
  "function" NonIdContinue ->
    return { $loc, token: $1 }

GetOrSet
  ( "get" / "set" ) NonIdContinue ->
    return { $loc, token: $1, type: 'GetOrSet' }

If
  # NOTE: Pull a single space into the 'if ' token so if it is replaced
  # with a ternary in expressions it doesn't add an extra space
  $("if" NonIdContinue " "?) ->
    return { $loc, token: $1 }

Import
  # NOTE: this is a hack so import.meta will parse correctly
  "import" &/\s/ ->
    return { $loc, token: $1 }

In
  "in" NonIdContinue ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-LetOrConst
LetOrConst
  ( "let" / "const" ) NonIdContinue ->
    return { $loc, token: $1 }

Const
  "const" NonIdContinue ->
    return { $loc, token: $1 }

LetOrConstOrVar
  LetOrConst
  Var

Loop
  # NOTE: loop becomes while
  "loop" NonIdContinue ->
    return { $loc, token: "while(true)" }

New
  "new" NonIdContinue ->
    return { $loc, token: $1 }

Not
  # Not keyword only active in compat mode
  CoffeeNotEnabled "not" NonIdContinue " "? ->
    return { $loc, token: "!" }

Of
  "of" NonIdContinue ->
    return { $loc, token: $1 }

OpenAngleBracket
  "<" ->
    return { $loc, token: $1 }

OpenBrace
  "{" ->
    return { $loc, token: $1 }

OpenBracket
  "[" ->
    return { $loc, token: $1 }

OpenParen
  "(" ->
    return { $loc, token: $1 }

Operator
  "operator" NonIdContinue ->
    return { $loc, token: $1 }

Public
  "public" NonIdContinue ->
    return { $loc, token: $1 }

Private
  "private" NonIdContinue ->
    return { $loc, token: $1 }

Protected
  "protected" NonIdContinue ->
    return { $loc, token: $1 }

Pipe
  "||>" ->
    return { $loc, token: $1 }

  "|>=" ->
    return { $loc, token: $1 }

  "|>" ->
    return { $loc, token: $1 }

QuestionMark
  "?" ->
    return { $loc, token: $1 }

Readonly
  "readonly" NonIdContinue ->
    return { $loc, token: $1, ts: true }

Return
  "return" NonIdContinue ->
    return { $loc, token: $1 }

Satisfies
  "satisfies" NonIdContinue ->
    return { $loc, token: $1 }

Semicolon
  ";" ->
    return { $loc, token: $1 }

SingleQuote
  "'" ->
    return { $loc, token: $1 }

Star
  "*" ->
    return { $loc, token: $1 }

Static
  "static" NonIdContinue ->
    return { $loc, token: $1 }
  # NOTE: In ClassElements @ is a shorthand for 'static'
  # NOTE: added negative assertion to prevent overlapping constructor shorthand and `@@` decorator syntax
  "@" !( "(" / "@" ) ->
    return { $loc, token: "static " }

SubstitutionStart
  "${" ->
    return { $loc, token: $1 }

Switch
  "switch" NonIdContinue ->
    return { $loc, token: $1 }

Target
  "target" NonIdContinue ->
    return { $loc, token: $1 }

Then
  # TODO: comments/whitespace get lost here
  __ "then" NonIdContinue ->
    return { $loc, token: "" }

This
  "this" NonIdContinue ->
    return { $loc, token: $1 }

Throw
  "throw" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: These become a single backtick, to properly escape "s and newlines
# and in case there are interpolations
TripleDoubleQuote
  "\"\"\"" ->
    return { $loc, token: "`" }

# NOTE: These become a single backtick, to properly escape 's and newlines
TripleSingleQuote
  "'''" ->
    return { $loc, token: "`" }

# Used in Heregex
TripleSlash
  "///" ->
    return { $loc, token: '/' }

TripleTick
  "```" ->
    return { $loc, token: "`" }

Try
  "try" NonIdContinue ->
    return { $loc, token: $1 }

Typeof
  "typeof" NonIdContinue ->
    return { $loc, token: $1 }

Unless
  "unless" NonIdContinue ->
    return { $loc, token: $1 }

Until
  "until" NonIdContinue ->
    return { $loc, token: $1 }

Var
  "var" NonIdContinue ->
    return { $loc, token: $1 }

Void
  "void" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: When maps to 'case'
When
  "when" NonIdContinue ->
    return { $loc, token: "case" }

While
  "while" NonIdContinue ->
    return { $loc, token: $1 }

Yield
  "yield" NonIdContinue ->
    return { $loc, token: $1, type: "Yield" }

## JSX

JSXImplicitFragment
  JSXTag ( Samedent JSXTag )* ->
    const jsx = $2.length === 0 ? $1 : {
      type: "JSXFragment",
      children: [
        "<>\n",
        module.currentIndent.token,
        ...$0,
        "\n",
        module.currentIndent.token,
        "</>",
      ],
      jsxChildren: [$1].concat($2.map(([, tag]) => tag)),
    }
    const type = module.typeOfJSX(jsx)
    return type ? [
      { ts: true, children: ["("] },
      jsx,
      { ts: true, children: [" as any as ", type, ")"] }
    ] : jsx

JSXTag
  JSXElement
  JSXFragment
  JSXComment

# https://facebook.github.io/jsx/#prod-JSXElement
JSXElement
  JSXSelfClosingElement
  # NOTE: In default JSX mode, JSX children must be properly indented,
  # and closing tags are optional (but still allowed).
  !CoffeeJSXEnabled PushJSXOpeningElement:open JSXMixedChildren?:children JSXOptionalClosingElement:close PopJSXStack ->
    if (!children) return $skip
    $0 = $0.slice(1)
    let parts
    if (close) {
      parts = $0
    } else if (children.jsxChildren.length) {
      parts = [
        ...$0,
        "\n", // InsertNewline
        module.currentIndent.token, // InsertIndent
        ["</", open[1], ">"],
      ]
    } else {
      parts = [open.slice(0, -1), " />"]
    }
    return { type: "JSXElement", children: parts, tag: open[1] }
  # NOTE: In CoffeeScript JSX mode, JSX children do not need to be properly
  # indented, but tags must be explicitly closed.
  CoffeeJSXEnabled JSXOpeningElement:open JSXChildren? Whitespace? JSXClosingElement:close ->
    $0 = $0.slice(1)
    // Check that tags match
    if (open[1] !== close[2]) return $skip
    return { type: "JSXElement", children: $0, tag: open[1] }

# https://facebook.github.io/jsx/#prod-JSXSelfClosingElement
JSXSelfClosingElement
  "<" $JSXElementName TypeArguments? JSXAttributes? Whitespace? "/>" ->
    return { type: "JSXElement", children: $0, tag: $2 }

PushJSXOpeningElement
  JSXOpeningElement ->
    module.JSXTagStack.push($1[1])
    return $1

PopJSXStack
  "" ->
    module.JSXTagStack.pop()

# https://facebook.github.io/jsx/#prod-JSXOpeningElement
JSXOpeningElement
  "<" $JSXElementName TypeArguments? JSXAttributes? Whitespace? ">"

JSXOptionalClosingElement
  Whitespace? JSXClosingElement:close ->
    if (module.currentJSXTag !== close[2]) return $skip
    return $0
  ""

# https://facebook.github.io/jsx/#prod-JSXClosingElement
JSXClosingElement
  "</" Whitespace? $JSXElementName Whitespace? ">"

# https://facebook.github.io/jsx/#prod-JSXFragment
JSXFragment
  # NOTE: In default JSX mode, JSX children must be properly indented,
  # and closing tags are optional (but still allowed).
  !CoffeeJSXEnabled PushJSXOpeningFragment:open JSXMixedChildren?:children JSXOptionalClosingFragment:close PopJSXStack ->
    if (!children) return $skip
    $0 = $0.slice(1)
    const parts = close ? $0 :
      [
        ...$0,
        "\n", // InsertNewline
        module.currentIndent.token, // InsertIndent
        "</>",
      ]
    return { type: "JSXFragment", children: parts, jsxChildren: children.jsxChildren }
  # NOTE: In CoffeeScript JSX mode, JSX children do not need to be properly
  # indented, but tags must be explicitly closed.
  CoffeeJSXEnabled "<>" JSXChildren?:children Whitespace? JSXClosingFragment ->
    $0 = $0.slice(1)
    return {
      type: "JSXFragment",
      children: $0,
      jsxChildren: children ? children.jsxChildren : []
    }

PushJSXOpeningFragment
  "<>" ->
    module.JSXTagStack.push("")
    return $1

JSXOptionalClosingFragment
  Whitespace? JSXClosingFragment ->
    if (module.currentJSXTag !== "") return $skip
    return $0
  ""

JSXClosingFragment
  "</>"

# https://facebook.github.io/jsx/#prod-JSXElementName
JSXElementName
  # Merged in https://facebook.github.io/jsx/#prod-JSXNamespacedName
  # Merged in https://facebook.github.io/jsx/#prod-JSXMemberExpression
  JSXIdentifierName ( (Colon JSXIdentifierName) / ( Dot JSXIdentifierName )* )

# NOTE: Like IdentifierName but includes hyphens after start
# NOTE: Combined from recursive https://facebook.github.io/jsx/#prod-JSXIdentifier definition
JSXIdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$-])*/

# https://facebook.github.io/jsx/#prod-JSXAttributes
JSXAttributes
  ( Whitespace? JSXAttribute )* ->
    // Extract all .class shorthands into `classes` array
    const classes = []
    let attrs = $0.filter((pair) => {
      const [, attr] = pair
      if (attr.type === "JSXClass") {
        classes.push(attr.class)
        return false
      }
      return true
    })
    if (classes.length) {
      // Check for non-shorthand class or className attribute
      let className = module.config.react ? "className" : "class"
      attrs = attrs.filter((pair) => {
        const [, attr] = pair
        if ((attr[0][0] === "class" || attr[0][0] === "className") &&
            !attr[0][1]) {
          className = attr[0][0]
          classes.push(attr[1][attr[1].length-1])
          return false
        }
        return true
      })
      function isBraced(c) {
        return c[0] === "{" || c[0]?.token === "{"
      }
      function unbrace(c) {
        // Remove leading "{" and trailing "}" tokens
        return c.slice(1, -1)
      }
      function parseClass(c) {
        c = c.token || c
        if (c.startsWith("'")) {
          c = '"' +
            c.slice(1, -1)
            .replace(/\\*"/g, (m) => m.length % 2 == 0 ? m : "\\"+m) +
            '"'
        }
        return JSON.parse(c)
      }
      const strings = [], exprs = []
      classes.forEach((c) => {
        if (isBraced(c)) {
          exprs.push(unbrace(c))
          exprs.push(", ")
        } else {
          strings.push(parseClass(c))
        }
      })
      const stringPart = strings.filter(Boolean).join(" ")
      let classValue
      if (exprs.length) { // some expressions
        exprs.pop()  // remove trailing comma
        if (stringPart) { // some strings too
          exprs.unshift(JSON.stringify(stringPart), ", ")
        }
        if (exprs.length === 1) {
          // Single expression doesn't need array, filter, or join.
          let root = exprs[0]
          // Remove trailing whitespace, e.g. in JSXShorthandString rule
          while (root.length &&
                 module.isWhitespaceOrEmpty(root[root.length-1])) {
            root = root.slice(0, -1)
          }
          // Unwrap possibly resulting singleton arrays
          while (root?.length === 1) root = root[0]
          // processUnaryExpression wraps in {children: [...]}
          if (root?.children) root = root.children
          if (root?.[0]?.token === "`") {
            // Template literals work just as-is.
            classValue = ["{", ...exprs, "}"]
          } else {
            // Other expressions get `|| ""` to avoid e.g. `undefined` class.
            classValue = ["{(", ...exprs, ") || \"\"}"]
          }
        } else {
          // In general, wrap expressions in array and filter out falsy values,
          // to avoid accidental e.g. `undefined` classes.
          classValue = ["{[", ...exprs, "].filter(Boolean).join(\" \")}"]
        }
      } else { // strings only
        classValue = JSON.stringify(stringPart)
      }
      attrs.splice(0, 0, [" ", [className, ["=", classValue]]])
    }
    return attrs.map((pair) => {
      const [space, attr] = pair
      // Sometimes JSXAttribute adds a leading space to separate from previous.
      // Remove that space if there's already whitespace here.
      if (space && attr[0] === " ") {
        pair = [space, attr.slice(1)]
      }
      return pair
    })

# NOTE: Merged SpreadAttribute and Attribute
JSXAttribute
  # https://facebook.github.io/jsx/#prod-JSXSpreadAttribute
  # allows something like
  #   OpenBrace __ DotDotDot ExtendedExpression __ CloseBrace
  # (where ExtendedExpression additionally allows If/Switch expressions).
  # More generally, we allow any braced object literal:
  # {foo} is equivalent to foo={foo}, and
  # {foo, bar: baz} is equivalent to foo={foo} and bar={baz}.
  # {...foo} is a special case.
  BracedObjectLiteral ->
    const {children} = $1
    const parts = [] // JSX attributes
    const rest = []  // parts that need to be in {...rest} form
    for (let i = 1; i < children.length - 1; i++) {
      if (i > 1) parts.push(' ')
      const part = children[i]
      switch (part.type) {
        case 'Identifier':
          parts.push([part.name, '={', part.name, '}'])
          break
        case 'Property':
          if (part.name.type === 'ComputedPropertyName') {
            rest.push(part)
          } else {
            parts.push([part.name, '={', insertTrimmingSpace(part.value, ''), '}'])
          }
          break
        case 'SpreadProperty':
          parts.push(['{', part.dots, part.value, '}'])
          break
        case 'MethodDefinition':
          try {
            parts.push([part.name, '={', module.convertMethodToFunction(part), '}'])
          } catch {  // get or set
            rest.push(part)
          }
          break
        default:
          throw new Error(`invalid object literal type in JSX attribute: ${part.type}`)
      }
    }
    if (rest.length) {
      parts.push(['{...{', ...rest, '}}'])
    }
    return parts

  # https://facebook.github.io/jsx/#prod-JSXAttribute
  JSXAttributeName:name ( JSXAttributeInitializer / &JSXAttributeSpace ):value ->
    if (name.type === "ComputedPropertyName") {
      if (value) {
        // Strip off equals sign and whitespace from JSXAttributeInitializer
        value = value[value.length-1]
        // Strip off braces if present
        if (value[0]?.token === "{" &&
            value[value.length-1]?.token === "}") {
          value = value.slice(1, -1)
        }
      } else {
        // React and SolidJS define a bare attribute to mean setting it to true.
        // We need to specify a value here, so this seems a reasonable choice.
        value = "true"
      }
      return ["{...{", name, ": ", value, "}}"]
    } else {
      return $0
    }

  # NOTE: Adding ...foo shorthand for {...foo}
  InsertInlineOpenBrace DotDotDot InlineJSXAttributeValue InsertCloseBrace &JSXAttributeSpace

  # NOTE: #id shorthand
  "#" JSXShorthandString ->
    return [ " ", "id=", $2 ]
  Dot JSXShorthandString ->
    return {
      type: "JSXClass",
      class: $2,
    }

  # NOTE: Matching LiveScript flagging shorthand in addition +x -y !z -> x={true} y={false} z={false}
  $[!+-]:toggle JSXAttributeName:id ->
    const value = toggle === "+" ? "true" : "false"
    return [ " ", id, "={", value, "}" ]

JSXAttributeSpace
  /[\s>]/

JSXShorthandString
  /(?:[\w\-:]+|\([^()]*\)|\[[^\[\]]*\])+/ ->
    return quoteString($0)
  TemplateLiteral ->
    return [ "{", $1, "}" ]
  # NOTE: TemplateLiteral must be before StringLiteral,
  # so that CoffeeScript interpolated strings get checked first.
  StringLiteral
  OpenBrace PostfixedExpression Whitespace? CloseBrace

# https://facebook.github.io/jsx/#prod-JSXAttributeName
JSXAttributeName
  # NOTE: Merged JSXIdentifier and JSXNamespacedName
  JSXIdentifierName ( Colon JSXIdentifierName )?
  ComputedPropertyName

# https://facebook.github.io/jsx/#prod-JSXAttributeInitializer
JSXAttributeInitializer
  Whitespace? Equals Whitespace? JSXAttributeValue

# https://facebook.github.io/jsx/#prod-JSXAttributeValue
JSXAttributeValue
  # https://facebook.github.io/jsx/#prod-JSXDoubleStringCharacters
  # https://facebook.github.io/jsx/#prod-JSXSingleStringCharacters
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  OpenBrace PostfixedExpression Whitespace? CloseBrace
  JSXElement
  JSXFragment
  InsertInlineOpenBrace InlineJSXAttributeValue InsertCloseBrace ->
    // Check for string literal resulting from CoffeeScript interpolated
    // double-quoted string that didn't end up actually interpolating.
    if ($2.children?.length === 1 && $2.children[0].type === "StringLiteral") {
      // Instead parse using the following string literal rule,
      // which avoids e.g. converting newlines into \n.
      return $skip
    }
    return $0
  # NOTE: InlineJSXAttributeValue which contains TemplateLiteral must be before
  # StringLiteral, so that CoffeeScript interpolated strings get checked first.
  # NOTE: JSX strings allow newlines, and they get passed through as-is.
  /"[^"]*"|'[^']*'/

# JSX shorthand to avoid explicit braces when unnecessary (no whitespace)
InlineJSXAttributeValue
  InlineJSXUnaryExpression InlineJSXBinaryOpRHS* ->
    if ($2.length) return module.processBinaryOpExpression($0)
    return $1

# BinaryOpRHS without whitespace and without ExpressionizedStatement,
# forbidding operators starting with < or > (possible JSX tags),
# and forbidding implicitly parenthesized assignments.
InlineJSXBinaryOpRHS
  ![<>] BinaryOp:op InlineJSXUnaryExpression:rhs ->
    // NOTE: Inserting empty whitespace arrays to be compatible with BinaryOpRHS and `processBinaryOpExpression`
    return [[], op, [], rhs]

# JSXUnaryExpression, with InlineJSX prefixes and no Do (which has whitespace)
InlineJSXUnaryExpression
  InlineJSXUnaryOp*:pre InlineJSXUpdateExpression:exp InlineJSXUnaryPostfix?:post ->
    return module.processUnaryExpression(pre, exp, post)

# UnaryOp, restricted to whitespace-free symbol operators
InlineJSXUnaryOp
  /[!~+-](?!\s|[!~+-]*&)/ ->
    return { $loc, token: $0 }

# UnaryPostfix, restricted to whitespace-free symbol operators
InlineJSXUnaryPostfix
  QuestionMark

# UpdateExpression, with LeftHandSideExpression -> InlineJSXCallExpression
InlineJSXUpdateExpression
  UpdateExpressionSymbol UnaryExpression
  InlineJSXCallExpression UpdateExpressionSymbol? ->
    if ($2) return $0
    return $1

# CallExpression, with only explicit function calls.
# This also acts as a replacement for LeftHandSideExpression
# (we don't allow New because that has whitespace).
InlineJSXCallExpression
  "super" ExplicitArguments
  "import" OpenParen PostfixedExpression __ CloseParen
  InlineJSXMemberExpression InlineJSXCallExpressionRest* ->
    if ($2.length) return $0
    return $1

# CallExpressionRest, with only explicit function calls.
InlineJSXCallExpressionRest
  MemberExpressionRest
  TemplateLiteral
  ( OptionalShorthand / NonNullAssertion )? ExplicitArguments

# MemberExpression, with PrimaryExpression -> InlineJSXPrimaryExpression
InlineJSXMemberExpression
  InlineJSXPrimaryExpression InlineJSXMemberExpressionRest* ->
    if ($2.length) return $0
    return $1
  SuperProperty
  MetaProperty

# MemberExpressionRest without optional IndentFurther before PropertyAccess
InlineJSXMemberExpressionRest
  ( OptionalShorthand / NonNullAssertion )? MemberBracketContent ->
    if ($1) {
      // Optional followed by a slice expression
      if ($1.type === "Optional" && $2.type === "SliceExpression") {
        // Remove '.' from optional since it is present in '.slice'
        return [$1.children[0], $2]
      }
      return $0
    }
    return $2
  PropertyAccess
  NonNullAssertion

# Subset of PrimaryExpression; omissions documented below.
InlineJSXPrimaryExpression
  NullLiteral
  BooleanLiteral
  NumericLiteral
  TemplateLiteral
  # Omitting StringLiteral already matched in JSXAttributeValue
  ThisLiteral
  ArrayLiteral
  # Requiring braces on ObjectLiteral; this allows {a, b} even though `a, b` doesn't work as an inline object
  BracedObjectLiteral
  IdentifierReference
  # Omitting FunctionExpression and ClassExpression which have whitespace
  RegularExpressionLiteral
  ParenthesizedExpression
  # Omitting JSXElement and JSXFragment which don't need braces

JSXMixedChildren
  # NOTE: c1 matches "same-line" children, while c2 matches indented children
  # Used in indentation-based JSX
  JSXChild*:c1 JSXNestedChildren:c2 ->
    return {
      children: c1.concat(c2),
      jsxChildren: c1.concat(c2.jsxChildren),
    }

# https://facebook.github.io/jsx/#prod-JSXChildren
# JSX eats whitespace around newlines
JSXChildren
  ( ( NonNewlineWhitespace? EOL NonNewlineWhitespace? )* JSXChild )* ->
    return {
      children: $1,
      jsxChildren: $1.map(children => children[1]),
    }

JSXNestedChildren
  PushIndent ( JSXNested JSXChild+ )* PopIndent ->
    if ($2.length) {
      return {
        children: $2,
        jsxChildren: [].concat(...$2.map(nestedChildren => nestedChildren[1])),
      }
    }
    return $skip
  # NOTE: Empty JSXNestedChildren can be from newline or unmatched close brace
  # (e.g. when used in an attribute) or a following closing tag.
  &( JSXEOS / "}" / JSXClosingElement / JSXClosingFragment ) ->
    return { children: [], jsxChildren: [] }

# NOTE: Special variations of EOS and Nested that forbid end-of-line JS
# comments, as JS comments are not allowed in JSX (they get treated as text).
JSXEOS
  ( NonNewlineWhitespace? EOL )+

JSXNested
  JSXEOS:eos Indent:indent ->
    const { level } = indent
    const currentIndent = module.currentIndent
    if (level !== currentIndent.level) return $skip
    return $0

# https://facebook.github.io/jsx/#prod-JSXChild
JSXChild
  JSXElement
  JSXFragment
  # NOTE: Adding support for XML comments
  JSXComment
  OpenBrace IndentedJSXChildExpression:expression __ CloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  OpenBrace JSXChildExpression?:expression __ CloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  # NOTE: Adding support for arrow functions without wrapping braces
  InsertInlineOpenBrace ArrowFunction:expression InsertCloseBrace ->
    return {
      type: "JSXChildExpression",
      children: $0,
      expression,
    }
  # NOTE: JSXText must come after attempt to match ArrowFunction
  JSXText

# XML comments: https://www.w3.org/TR/xml/#sec-comments
JSXComment
  "<!--" JSXCommentContent "-->" ->
    return [ "{/*", $2, "*/}" ]

JSXCommentContent
  /(?:-[^-]|[^-]*)*/ ->
    return { $loc, token: $0.replace(/\*\//g, "* /") }

# https://facebook.github.io/jsx/#prod-JSXText
JSXText
  # NOTE: not currently excluding https://facebook.github.io/jsx/#prod-HTMLCharacterReference
  # NOTE: additionally excluding newlines to leave the next indentation;
  # leading whitespace will actually be consumed by JSXChildren or
  # JSXNestedChildren (where it's used for indentation).
  [^{}<>\r\n]+ ->
    return {
      type: "JSXText",
      token: $0,
      $loc,
    }

# https://facebook.github.io/jsx/#prod-JSXChildExpression
JSXChildExpression
  # NOTE: Using PostfixedExpression to allow If/Switch expressions and postfixes
  Whitespace? ( DotDotDot Whitespace? )? PostfixedExpression

IndentedJSXChildExpression
  PushIndent NestedJSXChildExpression? PopIndent ->
    if (!$2) return $skip
    return $2

NestedJSXChildExpression
  JSXNested JSXChildExpression

## Type Stuff

TypeDeclaration
  # NOTE: First check for forms with a `declare` keyword present
  ( Export _? )? ( Declare _? )  TypeLexicalDeclaration -> { ts: true, children: $0 }
  ( Export _? )? ( Declare _? )? TypeDeclarationRest    -> { ts: true, children: $0 }

# NOTE: These are declarations even without a `declare` prefix
TypeDeclarationRest
  # TODO: ( __ Type ) can be refined further to check for consistently nested binary ops, etc.
  TypeKeyword _? IdentifierName TypeParameters? __ Equals ( ( _? Type ) / ( __ Type ) )
  Interface   _? IdentifierName TypeParameters? InterfaceExtendsClause? InterfaceBlock
  Namespace   _? IdentifierName ModuleBlock
  FunctionSignature

# NOTE: These are all guaranteed to be preceded by a `declare` keyword
TypeLexicalDeclaration
  __ LetOrConstOrVar TypeDeclarationBinding ( CommaDelimiter __ TypeDeclarationBinding )*
  __ EnumDeclaration
  ClassSignature
  Namespace _? IdentifierName DeclareBlock
  Module _ StringLiteral DeclareBlock?
  Global DeclareBlock?

TypeDeclarationBinding
  # NOTE: This is almost the same as LexicalBinding except it cannot have an initializer
  ( BindingPattern / BindingIdentifier ) TypeSuffix?

InterfaceExtendsClause
  ExtendsToken InterfaceExtendsTarget ( Comma InterfaceExtendsTarget )*

InterfaceExtendsTarget
  ImplementsTarget

TypeKeyword
  "type" NonIdContinue ->
    return { $loc, token: $1 }

Enum
  "enum" NonIdContinue ->
    return { $loc, token: $1 }

Interface
  "interface" NonIdContinue ->
    return { $loc, token: $1 }

Global
  "global" NonIdContinue ->
    return { $loc, token: $1 }

Module
  "module" NonIdContinue ->
    return { $loc, token: $1 }

Namespace
  "namespace" NonIdContinue ->
    return { $loc, token: $1 }


InterfaceBlock
  __ OpenBrace NestedInterfaceProperties __ CloseBrace
  __ OpenBrace ( __ InterfaceProperty )* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedInterfaceProperties InsertNewline InsertIndent InsertCloseBrace

NestedInterfaceProperties
  PushIndent NestedInterfaceProperty*:props PopIndent ->
    if (props.length) return props
    return $skip

NestedInterfaceProperty
  Nested InterfaceProperty

InterfaceProperty
  BasicInterfaceProperty
  NonEmptyParameters TypeSuffix InterfacePropertyDelimiter
  MethodSignature InterfacePropertyDelimiter

BasicInterfaceProperty
  ( TypeIndexSignature / PropertyName ) TypeSuffix InterfacePropertyDelimiter

InterfacePropertyDelimiter
  _? ( Semicolon / Comma )
  &( __ CloseBrace )
  &EOS

# Namespace blocks are like self-contained modules
ModuleBlock
  __ OpenBrace NestedModuleItems __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedModuleItems InsertNewline InsertIndent InsertCloseBrace

NestedModuleItems
  PushIndent NestedModuleItem*:items PopIndent ->
    if (items.length) return items
    return $skip

# Based on TopLevelStatement
NestedModuleItem
  Nested ModuleItem StatementDelimiter

DeclareBlock
  __ OpenBrace NestedDeclareElements __ CloseBrace
  __ OpenBrace ( __ DeclareElement InterfacePropertyDelimiter)* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedDeclareElements InsertNewline InsertIndent InsertCloseBrace

NestedDeclareElements
  PushIndent NestedDeclareElement*:decs PopIndent ->
    if (decs.length) return decs
    return $skip

NestedDeclareElement
  Nested DeclareElement InterfacePropertyDelimiter

# NOTE: Variation on TypeDeclaration where Declare already applied.
DeclareElement
  Decorators? ( Export _? )? TypeLexicalDeclaration -> { ts: true, children: $0 }
  ( Export _? )? TypeDeclarationRest    -> { ts: true, children: $0 }

EnumDeclaration
  ( Const _ )?:isConst Enum _? IdentifierName:id EnumBlock:block ->
    const ts = {
      ts: true,
      children: $0,
    }
    // const enums do not generate any JavaScript code
    if (isConst) return ts
    // Generate JS output for enum similar to how TypeScript does
    const names = new Set(block.properties.map(p => p.name.name))
    return [ts,
      {
        js: true,
        children: [
          ["let ", id, " = {};\n"],
          ...block.properties.map((property, i) => {
            let init, isString
            if (property.init) {
              // Replace references to other enum members.
              // TS further restricts this to past enum members,
              // but we don't need to enforce that here.
              init = module.replaceNodes(deepCopy(property.init),
                n => n.type === "Identifier" && names.has(n.name),
                n => [id, '["', n.name, '"]'])
              const value = init[init.length - 1]
              isString = value.type === "TemplateLiteral" ||
                (value.type === "Literal" && value.subtype === "StringLiteral")
            } else {
              // Default initializer is previous property + 1, or 0 if first.
              // TS further restricts this to when previous property is
              // constant, but we don't need to enforce that here.
              init = i === 0 ? " = 0" :
                [" = ", id, '["', block.properties[i-1].name, '"] + 1']
            }
            // String enums do not get back references
            if (isString) {
              return [
                id, '["', property.name, '"]', init, ";\n",
              ]
            } else {
              return [
                id, "[", id, '["', property.name, '"]', init,
                '] = "', property.name, '";\n',
              ]
            }
          }),
        ],
      }
    ]

EnumBlock
  __ OpenBrace NestedEnumProperties:props __ CloseBrace ->
    return {
      properties: props.properties,
      children: $0,
    }
  __ OpenBrace ( __ EnumProperty )*:props __ CloseBrace ->
    return {
      properties: props.map(p => p[1]),
      children: $0,
    }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace NestedEnumProperties:props InsertNewline InsertIndent InsertCloseBrace ->
    return {
      properties: props.properties,
      children: $0,
    }

NestedEnumProperties
  PushIndent NestedEnumProperty*:props PopIndent ->
    if (!props.length) return $skip
    return {
      properties: props.map((p) => p.property),
      children: $0,
    }

NestedEnumProperty
  Nested EnumProperty ->
    return {
      property: $2,
      children: $0,
    }

EnumProperty
  Identifier:name ( __ Equals ExtendedExpression )?:init ObjectPropertyDelimiter ->
    return {
      type: "EnumProperty",
      name,
      init,
      children: $0,
    }

TypeIndexSignature
  ( [+-]? "readonly" __ )? OpenBracket TypeIndex CloseBracket ( __ [+-] QuestionMark )?

TypeIndex
  __ Identifier TypeSuffix
  __ PropertyName __ In Type ( __ As Type )?

# NOTE: TypeScript allows ? only in some circumstances (function parameters
# and class properties, but not let/const) and ! only in some circumstances
# (let/const and class properties, but not function parameters), and can't
# parse both (?!).  For simplicity, we allow either in all cases.
TypeSuffix
  QuestionMark? _? Colon Type -> {
    type: "TypeSuffix",
    ts: true,
    children: $0
  }
  QuestionMark _? -> {
    type: "TypeSuffix",
    ts: true,
    children: $0
  }
  # TypeScript has a special error for ! without : ("Declarations with definite
  # assignment assertions must also have type annotations.") but we parse it
  # so that the user can get this more useful error message.
  NonNullAssertion _? (Colon Type)? -> {
    type: "TypeSuffix",
    ts: true,
    children: $0
  }

ReturnTypeSuffix
  _? Colon ( __ "asserts" NonIdContinue )?:asserts TypePredicate:t ->
    if (asserts) {
      t = {
        type: "AssertsType",
        t,
        children: [asserts[0], asserts[1], t],
      }
    }

    return {
      type: "ReturnTypeAnnotation",
      children: [$1, $2, t],
      t,
      ts: true,
    }

TypePredicate
  Type:lhs ( __ "is" NonIdContinue Type )?:rhs ->
    if (!rhs) return lhs
    return {
      type: "TypePredicate",
      lhs,
      rhs: rhs[3],
      children: [lhs, ...rhs],
    }

Type
  TypeConditional

TypeBinary
  TypeUnary ( __ TypeBinaryOp __ TypeUnary )* ->
    if ($2.length) return $0
    return $1

TypeUnary
  ( __ TypeUnaryOp NonIdContinue )* TypePrimary TypeUnarySuffix* ->
    if (!$1.length && !$3.length) return $2
    return [...$1, $2, ...$3]

TypeUnarySuffix
  TypeIndexedAccess
  QuestionMark

TypeUnaryOp
  "keyof" NonIdContinue
  "typeof" NonIdContinue
  "infer" NonIdContinue
  "readonly" NonIdContinue

TypeIndexedAccess
  OpenBracket Type? __ CloseBracket

TypePrimary
  InterfaceBlock
  _? FunctionType
  _? InlineInterfaceLiteral
  _? TypeTuple
  _? ImportType
  _? TypeLiteral:t ->
    return {
      type: "LiteralType",
      t,
      children: $0,
    }
  _? IdentifierName (Dot IdentifierName)* TypeArguments?:args ->
    return {
      type: "IdentifierType",
      children: $0,
      raw: [$2.name, ...$3.map(([dot, id]) => dot.token + id.name), ].join(''),
      args,
    }
  # NOTE: Check FunctionType before parenthesized in order to distinguish between (a: T) => U and
  # A parenthesized inline interface (a: T) ---> ({a: T})
  # NOTE: Check Type before ( EOS Type ) to find implicit nested interfaces first. EOS would swallow the
  # newline so Nested wouldn't match otherwise.
  __ OpenParen ( Type / ( EOS Type ) ) __ CloseParen

ImportType
  "import" OpenParen __ StringLiteral __ CloseParen ( Dot IdentifierName )? TypeArguments?
  # NOTE: Added implicit import without parens
  "import" InsertOpenParen Trimmed_ StringLiteral InsertCloseParen

TypeTuple
  OpenBracket NestedTypeList __ CloseBracket
  OpenBracket TypeList? __ CloseBracket

TypeList
  Type (__ Comma Type)*

NestedTypeList
  PushIndent NestedType*:types PopIndent ->
    if (types.length)
      return types
    return $skip

NestedType
  Nested Type ArrayElementDelimiter

TypeConditional
  TypeBinary ( __ "extends" NonIdContinue Type ( __ QuestionMark Type __ Colon Type )? )? ->
    if ($2) return $0
    return $1

TypeTemplateSubstitution
  SubstitutionStart Type __ CloseBrace

TypeTemplateLiteral
  Backtick ( TemplateCharacters / TypeTemplateSubstitution )* Backtick ->
    return {
      type: "TemplateLiteral",
      children: $0,
    }
  CoffeeInterpolatedDoubleQuotedTypeLiteral

CoffeeStringTypeSubstitution
  CoffeeSubstitutionStart Type __ CloseBrace

CoffeeInterpolatedDoubleQuotedTypeLiteral
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringTypeSubstitution )*:parts DoubleQuote:e ->
    return processCoffeeInterpolation(s, parts, e, $loc)

TypeLiteral
  TypeTemplateLiteral
  # NOTE: TemplateLiteral must be before Literal, so that CoffeeScript
  # interpolated strings get checked first before StringLiteral.
  Literal
  "void" NonIdContinue ->
    return { type: "VoidType", $loc, token: $1 }
  "[]" ->
    return { $loc, token: "[]" }

InlineInterfaceLiteral
  InsertInlineOpenBrace InlineBasicInterfaceProperty ( ( IndentedFurther / _? ) InlineBasicInterfaceProperty )* InsertCloseBrace

InlineBasicInterfaceProperty
  ( TypeIndexSignature / PropertyName ) QuestionMark? Colon Type InlineInterfacePropertyDelimiter

InlineInterfacePropertyDelimiter
  ( _? Semicolon ) / CommaDelimiter
  &( ( IndentedFurther / _? ) InlineBasicInterfaceProperty ) InsertComma -> $2
  &( __  ( ":" / ")" / "]" / "}" ) )
  &EOS

TypeBinaryOp
  "|" ->
    return { $loc, token: "|" }
  "&" ->
    return { $loc, token: "&" }

FunctionType
  Parameters __ TypeArrowFunction Type?:type ->
    if (type) {
      return $0
    }

    return [...$0, "void"]

TypeArrowFunction
  "=>" ->
    return { $loc, token: "=>" }
  "->" ->
    return { $loc, token: "=>" }

TypeArguments
  "<" TypeArgument+ __ ">" ->
    return { ts: true, children: $0 }

TypeArgument
  __ Type TypeArgumentDelimiter

TypeArgumentDelimiter
  TypeParameterDelimiter

TypeParameters
  __ "<" TypeParameter+:parameters __ ">" ->
    return {
      type: "TypeParameters",
      parameters,
      ts: true,
      children: $0
    }

TypeParameter
  __ Identifier TypeConstraint? TypeInitializer? TypeParameterDelimiter

TypeConstraint
  __ "extends" NonIdContinue Type

TypeInitializer
  __ "=" Type

TypeParameterDelimiter
  _* Comma
  &( __ ">" )
  &EOS InsertComma -> $2

# TypeScript's this: T syntax in function parameters
ThisType
  ( This / AtThis ) Colon Type ParameterElementDelimiter -> {
    type: "ThisType",
    ts: true,
    children: $0
  }

## Utility

Shebang
  /#![^\r\n]*/ EOL

CivetPrologue
  [\t ]* DoubleQuote CivetPrologueContent:content DoubleQuote $SimpleStatementDelimiter EOS? -> content
  [\t ]* SingleQuote CivetPrologueContent:content SingleQuote $SimpleStatementDelimiter EOS? -> content

CivetPrologueContent
  "civet" NonIdContinue CivetOption*:options [\s]* ->
    return {
      type: "CivetPrologue",
      children: [],
      config: Object.fromEntries(options),
    }

CivetOption
  /\s+([+-]?)([a-zA-Z0-9-]+)(\s*=\s*([a-zA-Z0-9.+-]*))?/ ->
    // Normalize option names to camelCase
    const optionName = $2.replace(/-+([a-z]?)/g, (_, l) => {
      if (l) return l.toUpperCase()
      return ""
    })
    // - is disabled, + is enabled, no prefix is enabled
    // =value sets the value to any value (used for `tab`)
    let value =
      $3 ? $4 : ($1 === "-") ? false : true
    // Some options are automatically converted to numbers
    if (optionName === "tab") {
      value = parseFloat(value)
      if (isNaN(value)) value = 0
    }

    return [optionName, value]

UnknownPrologue
  # NOTE: $ is to keep source verbatim and not insert a semicolon if one was omitted
  # Can't use $EOS because it will prevent re-writing of coffee style comments
  [\t ]* StringLiteral:s $SimpleStatementDelimiter EOS

DirectivePrologue
  CivetPrologue
  UnknownPrologue

EOS
  RestOfLine+

# End of line, including EOF
EOL
  /\r\n|\n|\r|$/ ->
    return { $loc, token: $0 }

DebugHere
  "" ->
    debugger

# Insertions

InsertSemicolon
  "" ->
    return { $loc, token: ";" }

InsertOpenParen
  "" ->
    return { $loc, token: "(" }

InsertCloseParen
  "" ->
    return { $loc, token: ")" }

InsertOpenBrace
  # NOTE: Includes a preceding space
  "" ->
    return [{ $loc, token: " " }, { $loc, token: "{" } ]

InsertInlineOpenBrace
  "" ->
    return { $loc, token: "{" }

InsertCloseBrace
  "" ->
    return { $loc, token: "}" }

InsertOpenBracket
  "" ->
    return { $loc, token: "[" }

InsertCloseBracket
  "" ->
    return { $loc, token: "]" }

InsertComma
  "" ->
    return { $loc, token: "," }

InsertConst
  # NOTE: Includes a trailing space
  "" ->
    return { $loc, token: "const " }

InsertLet
  "" ->
    return { $loc, token: "let " }

InsertReadonly
  # NOTE: Includes a trailing space
  "" ->
    return { ts: true, children: [ { $loc, token: "readonly " } ] }

InsertNewline
  "" ->
    return "\n"

InsertIndent
  "" ->
    return module.currentIndent.token

InsertSpace
  "" ->
    return { $loc, token: " " }

InsertDot
  "" ->
    return { $loc, token: "." }

InsertBreak
  "" ->
    return { $loc, token: ";break;" }

InsertVar
  "" ->
    return { $loc, token: "var " }

CoffeeBinaryExistentialEnabled
  "" ->
    if(module.config.coffeeBinaryExistential) return
    return $skip

CoffeeBooleansEnabled
  "" ->
    if(module.config.coffeeBooleans) return
    return $skip

CoffeeClassesEnabled
  "" ->
    if(module.config.coffeeClasses) return
    return $skip

CoffeeCommentEnabled
  "" ->
    if(module.config.coffeeComment) return
    return $skip

CoffeeDoEnabled
  "" ->
    if(module.config.coffeeDo) return
    return $skip

CoffeeForLoopsEnabled
  "" ->
    if(module.config.coffeeForLoops) return
    return $skip

CoffeeInterpolationEnabled
  "" ->
    if(module.config.coffeeInterpolation) return
    return $skip

CoffeeIsntEnabled
  "" ->
    if(module.config.coffeeIsnt) return
    return $skip

CoffeeJSXEnabled
  "" ->
    if(module.config.coffeeJSX) return
    return $skip

CoffeeLineContinuationEnabled
  "" ->
    if(module.config.coffeeLineContinuation) return
    return $skip

CoffeeNotEnabled
  "" ->
    if(module.config.coffeeNot) return
    return $skip

CoffeeOfEnabled
  "" ->
    if(module.config.coffeeOf) return
    return $skip

CoffeePrototypeEnabled
  "" ->
    if(module.config.coffeePrototype) return
    return $skip

ObjectIsEnabled
  "" ->
    if(module.config.objectIs) return
    return $skip

# Reset module level data
Reset
  "" ->
    // Storage for PushIndent/PopIndent
    module.indentLevels = [{
      level: 0,
      token: "",
    }]

    module.forbidClassImplicitCall = [false]
    module.forbidIndentedApplication = [false]
    module.forbidTrailingMemberProperty = [false]
    module.forbidMultiLineImplicitObjectLiteral = [false]
    module.JSXTagStack = []

    module.operators = new Set

    if (!module._init) {
      module._init = true
      Object.defineProperties(module, {
        currentIndent: {
          get() {
            const {indentLevels: l} = module
            return l[l.length-1]
          },
        },
        classImplicitCallForbidden: {
          get() {
            const {forbidClassImplicitCall: s} = module
            return s[s.length-1]
          },
        },
        indentedApplicationForbidden: {
          get() {
            const {forbidIndentedApplication: s} = module
            return s[s.length-1]
          },
        },
        trailingMemberPropertyForbidden: {
          get() {
            const {forbidTrailingMemberProperty: s} = module
            return s[s.length-1]
          },
        },
        multiLineImplicitObjectLiteralForbidden: {
          get() {
            const {forbidMultiLineImplicitObjectLiteral: s} = module
            return s[s.length-1]
          },
        },
        currentJSXTag: {
          get() {
            const {JSXTagStack: s} = module
            return s[s.length-1]
          },
        },
      })
    }

    module.config = parse.config = {
      autoVar: false,
      autoLet: false,
      coffeeBinaryExistential: false,
      coffeeBooleans: false,
      coffeeClasses: false,
      coffeeComment: false,
      coffeeDo: false,
      coffeeEq: false,
      coffeeForLoops: false,
      coffeeInterpolation: false,
      coffeeIsnt: false,
      coffeeJSX: false,
      coffeeLineContinuation: false,
      coffeeNot: false,
      coffeeOf: false,
      coffeePrototype: false,
      implicitReturns: true,
      objectIs: false,
      react: false,
      solid: false,
      client: false, // default behavior: client only
      rewriteTsImports: true,
      server: false,
      tab: undefined, // default behavior = same as space
      verbose: false,
    }

    module.asAny = {
      ts: true,
      children: [" as any"]
    }
    module.asConst = {
      ts: true,
      children: [" as const"]
    }
    module.prelude = []

    const preludeVar = "var "
    const declareRef = {
      indexOf(indexOfRef) {
        const typeSuffix = {
          ts: true,
          children: [": <T>(this: T[], searchElement: T) => boolean"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, indexOfRef, typeSuffix, " = [].indexOf", module.asAny, ";\n"]])
      },
      hasProp(hasPropRef) {
        const typeSuffix = {
          ts: true,
          children: [": <T>(this: T, prop: keyof T) => boolean"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, hasPropRef, typeSuffix, " = {}.hasOwnProperty", module.asAny, ";\n"]])
      },
      is(isRef) {
        // Thanks to @thetarnav for help with this TypeScript magic.
        // If the second argument is more general, narrow it.
        // Otherwise (including when the first argument is more general,
        // or partial overlap), always narrow the first argument,
        // as that's usually the one that matters.
        // Waiting on https://github.com/Microsoft/TypeScript/issues/26916
        // for proper narrowing of both arguments.
        const typeSuffix = {
          ts: true,
          children: [": { <B, A extends B> (a: A, b: B): b is A, <A, B> (a: A, b: B): a is A & B }"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, isRef, typeSuffix, " = Object.is", module.asAny, ";\n"]])
      },
      modulo(moduloRef) {
        const typeSuffix = {
          ts: true,
          children: [": (a: number, b: number) => number"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, moduloRef, typeSuffix, " = (a, b) => (a % b + b) % b;", "\n"]])
      },
      xor(xorRef) {
        const typeSuffix = {
          ts: true,
          children: [": (a: unknown, b: unknown) => boolean"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, xorRef, typeSuffix, " = (a, b) => a ? !b && a : b;", "\n"]])
      },
      xnor(xnorRef) {
        const typeSuffix = {
          ts: true,
          children: [": (a: unknown, b: unknown) => boolean"]
        }
        // [indent, statement]
        module.prelude.push(["", [preludeVar, xnorRef, typeSuffix, " = (a, b) => a ? b : !b || a;", "\n"]])
      },
      returnSymbol(ref) {
        module.prelude.push({
          children: [
            preludeVar, ref, " = Symbol(\"return\")';\n",
          ],
        })
      },
      JSX(jsxRef) {
        module.prelude.push({
          ts: true,
          children: [
            "import type { JSX as ", jsxRef, " } from 'solid-js';\n",
          ],
        })
      },
      IntrinsicElements(intrinsicElementsRef) {
        // JSX.IntrinsicElements[TagName] gives HTMLAttributes<ElementType> or
        // SVGCoreAttributes<ElementType> or various subinterfaces of those.
        // All of them extend DOMAttributes<ElementType>, though.  See
        // https://raw.githubusercontent.com/ryansolid/dom-expressions/main/packages/dom-expressions/src/jsx.d.ts
        // Thanks to @thetarnav for the TypeScript magic to extract ElementType.
        // (TypeScript's HTMLElementTagNameMap and SVGElementTagNameMap are an
        // alternative, but don't necessary match Solid's IntrinsicElements.)
        const JSX = module.getRef("JSX")
        module.prelude.push({
          ts: true,
          children: [
            "type ", intrinsicElementsRef, "<K extends keyof ", JSX, ".IntrinsicElements> =\n",
            "  ", JSX, ".IntrinsicElements[K] extends ", JSX, ".DOMAttributes<infer T> ? T : unknown;\n",
          ],
        })
      },
    }
    const refs = {}

    module.getRef = function (base) {
      if (refs.hasOwnProperty(base)) return refs[base]
      const ref = {
        type: "Ref",
        base,
        id: base,
      }
      if (declareRef.hasOwnProperty(base)) declareRef[base](ref)
      return refs[base] = ref
    }

    module.makeAsConst = function(node) {
      // TS allows "as const" assertions for string, number, boolean, array,
      // and object literals (and enum members), but not for null/undefined.
      if ((node.type === "Literal" && node.raw !== "null") ||
          node.type === "ArrayExpression" ||
          node.type === "ObjectExpression") {
        return {...node, children: [...node.children, module.asConst]}
      }
      return node
    }

    module.typeOfJSX = function(node) {
      switch (node.type) {
        case "JSXElement":
          return module.typeOfJSXElement(node)
        case "JSXFragment":
          return module.typeOfJSXFragment(node)
      }
    }

    module.typeOfJSXElement = function(node) {
      if (module.config.solid) {
        if (module.config.server && !module.config.client) {  // server only
          return ["string"]
        }
        let {tag} = node
        // "An intrinsic element always begins with a lowercase letter,
        // and a value-based element always begins with an uppercase letter."
        // [https://www.typescriptlang.org/docs/handbook/jsx.html]
        const clientType =
          tag[0] === tag[0].toLowerCase() ?
          [module.getRef("IntrinsicElements"), '<"', tag, '">'] :
          ['ReturnType<typeof ', tag, '>']
        if (module.config.server) {  // isomorphic code for client + server
          return ["string", " | ", clientType]
        } else {  // client only (default)
          return clientType
        }
      }
    }

    module.typeOfJSXFragment = function(node) {
      if (module.config.solid) {
        let type = []
        let lastType
        for (let child of node.jsxChildren) {
          switch (child.type) {
            case "JSXText":
              // Solid combines multiple consecutive texts into one string
              if (lastType !== "JSXText") {
                type.push("string")
              }
              break
            case "JSXElement":
              type.push(module.typeOfJSXElement(child))
              break
            case "JSXFragment":
              // Solid flattens fragments of fragments into one array.
              type.push(...module.typeOfJSXFragment(child))
              break
            case "JSXChildExpression":
              // Solid discards empty expressions
              if (child.expression) {
                type.push(["typeof ", child.expression])
              }
              break
            default:
              throw new Error(`unknown child in JSXFragment: ${JSON.stringify(child)}`)
          }
          lastType = child.type
        }
        // Solid doesn't wrap single fragment child in an array
        if (type.length === 1) {
          return type[0]
        } else {
          type = type.flatMap((t) => [t, ", "])
          type.pop() // remove trailing comma
          return ["[", type, "]"]
        }
      }
    }

    Object.defineProperty(module.config, "deno", {
      set(b) {
        module.config.rewriteTsImports = !b
      }
    })
    // default to deno compatibility if running in deno
    module.config.deno = typeof Deno !== "undefined"

    // Expand setting coffeeCompat to the individual options
    Object.defineProperty(module.config, "coffeeCompat", {
      set(b) {
        for (const option of [
          "autoVar",
          "coffeeBinaryExistential",
          "coffeeBooleans",
          "coffeeClasses",
          "coffeeComment",
          "coffeeDo",
          "coffeeEq",
          "coffeeForLoops",
          "coffeeInterpolation",
          "coffeeIsnt",
          "coffeeJSX",
          "coffeeLineContinuation",
          "coffeeNot",
          "coffeeOf",
          "coffeePrototype",
        ]) {
          module.config[option] = b
        }
        if (b) {
          module.config.objectIs = false
        }
      }
    })

Init
  Shebang? DirectivePrologue*:directives "" ->
    directives.forEach((directive) => {
      if (directive.type === "CivetPrologue") {
        Object.assign(module.config, directive.config)
      }
    })

    module.processGlob = (node) => {
      const {children} = node
      for (let i = 0; i < children.length; i++) {
        const glob = children[i]
        if (glob?.type === "PropertyGlob") {
          // TODO: add ref to ensure object base evaluated only once
          const prefix = children.slice(0, i)
          .concat(glob.children[0]) // dot
          const parts = []
          for (const part of glob.object.content) {
            if (part.type === "MethodDefinition") {
              throw new Error("Glob pattern cannot have method definition")
            }
            if (part.value && !["CallExpression", "MemberExpression", "Identifier"].includes(part.value.type)) {
              throw new Error("Glob pattern must have call or member expression value")
            }
            let value = part.value ?? part.name
            const wValue = getTrimmingSpace(part.value)
            value = prefix.concat(insertTrimmingSpace(value, ""))
            if (wValue) value.unshift(wValue)
            if (part.type === "SpreadProperty") {
              parts.push({
                type: part.type,
                value,
                dots: part.dots,
                delim: part.delim,
                names: part.names,
                children: part.children.slice(0, 2) // whitespace, ...
                          .concat(value, part.delim)
              })
            } else {
              parts.push({
                type: part.type,
                name: part.name,
                value,
                delim: part.delim,
                names: part.names,
                children: [
                  module.isWhitespaceOrEmpty(part.children[0]) && part.children[0],
                  part.name,
                  module.isWhitespaceOrEmpty(part.children[2]) && part.children[2],
                  part.children[3]?.token === ":" ? part.children[3] : ":",
                  value,
                  part.delim, // comma delimiter
                ]
              })
            }
          }
          const object = {
            type: "ObjectExpression",
            children: [
              glob.object.children[0], // {
              ...parts,
              glob.object.children.at(-1), // whitespace and }
            ],
          }
          if (i === children.length-1) return object
          return module.processGlob({  // in case there are more globs
            ...node,
            children: [ object, ...children.slice(i+1) ]
          })
        }
      }
      return node
    }

    module.processUnaryExpression = (pre, exp, post) => {
      // Handle "?" postfix
      if (post?.token === "?") {
        post = {
          $loc: post.$loc,
          token: " != null",
        }

        switch (exp.type) {
          case "Identifier":
          case "Literal":
            return {...exp,
              children: [...pre, ...exp.children, post]
            }
          default:
            const expression = {
              ...exp,
              children: [...pre, "(", exp.children, ")", post]
            }

            return {
              type: "ParenthesizedExpression",
              children: ["(", expression, ")"],
              expression,
            }
        }
      }

      // Combine unary - to create negative numeric literals
      if (exp.type === "Literal") {
        if (pre.length === 1 && pre[0].token === "-") {
          const children = [pre[0], ...exp.children]
          if (post) exp.children./**/push(post)

          return {
            type: "Literal",
            children,
            raw: `-${exp.raw}`
          }
        }
      }

      if (exp.children) {
        const children = [...pre, ...exp.children]
        if (post) children./**/push(post)
        return Object.assign({}, exp, { children })
      } else if (Array.isArray(exp)) {
        const children = [...pre, ...exp]
        if (post) children./**/push(post)
        return { children }
      } else {
        const children = [...pre, exp]
        if (post) children./**/push(post)
        return { children }
      }
    }

    module.needsRef = function(expression, base="ref") {
      switch (expression.type) {
        case "Ref":
        case "Identifier":
        case "Literal":
          return
        default:
          return {
            type: "Ref",
            base,
            id: base,
          }
      }
    }

    module.expressionizeIfClause = function(clause, b, e) {
      const children = clause.children.slice(1) // Remove 'if'
      children./**/push("?", b) // Add ternary
      if (e) {
        // Remove 'else'
        children./**/push(e[0], ":", ...e.slice(2))
      }
      else {
        children.push(":void 0")
      }

      return {
        type: "IfExpression",
        children,
      }
    }

    module.addPostfixStatement = function(statement, ws, post) {
      let children, expressions
      if (post.blockPrefix?.length) {
        let indent = post.blockPrefix[0][0]
        expressions = [...post.blockPrefix, [indent, statement]]
        children = [" {\n", ...expressions, "\n", indent?.slice?.(0, -2), "}"]
      } else {
        expressions = [["", statement]]
        children = [" { ", ...expressions, " }"]
      }

      const block = {
        type: "BlockStatement",
        children,
        expressions,
      }

      children = [...post.children]
      children./**/push(block)

      // This removes trailing whitespace for easier testing
      if (!module.isWhitespaceOrEmpty(ws)) children./**/push(ws)

      post = {...post, children, block }
      if (post.type === "IfStatement") {
        post.then = block
      }
      return post
    }

    function expressionizeIteration(exp) {
      const i = exp.children.indexOf(exp.block)

      if (exp.subtype === "DoStatement") {
        // Just wrap with IIFE
        insertReturn(exp.block)
        exp.children.splice(i, 1, ...module.wrapIIFE(exp.children, exp.async))
        return
      }

      const resultsRef = {
        type: "Ref",
        base: "results",
        id: "results",
      }

      // insert `results.push` to gather results array
      insertPush(exp.block, resultsRef)

      // Wrap with IIFE
      exp.children.splice(i, 1,
        module.wrapIIFE([
          "const ", resultsRef, "=[];", ...exp.children, "; return ", resultsRef
        ], exp.async)
      )
    }

    // Wrap an expression in an IIFE, adding async/await if expression
    // uses await, or just adding async if specified.
    // Returns an Array suitable for `children`.
    module.wrapIIFE = (exp, async) => {
      let prefix, suffix
      if (async) {
        prefix = "(async ()=>{"
        suffix = "})()"
      } else if (hasAwait(exp)) {
        prefix = "(await (async ()=>{"
        suffix = "})())"
      } else {
        prefix = "(()=>{"
        suffix = "})()"
      }
      if (Array.isArray(exp)) {
        return [prefix, ...exp, suffix]
      } else {
        return [prefix, exp, suffix]
      }
    }

    function wrapIterationReturningResults(statement, outerRef) {
      if (statement.type === "DoStatement") {
        if (outerRef) {
          insertPush(statement.block, outerRef)
        } else {
          insertReturn(statement.block)
        }
        return
      }

      const resultsRef = {
        type: "Ref",
        base: "results",
        id: "results",
      }

      const declaration = {
        type: "Declaration",
        children: ["const ", resultsRef, "=[];"],
      }

      insertPush(statement.block, resultsRef)

      statement.children.unshift(declaration)
      if (outerRef) {
        statement.children.push(";", outerRef, ".push(", resultsRef, ");")
      } else {
        statement.children.push(";return ", resultsRef, ";")
      }
    }

    // NOTE: this is almost the same as insertReturn but doesn't remove `breaks` in `when` and
    // does construct an else clause pushing undefined in if statements that lack them
    // and adds to the beginning and the end of the expression's children.
    // Maybe these insertion modifications can be refactored to be more DRY eventually.
    function insertPush(node, ref) {
      if (!node) return
      // TODO: unify this with the `exp` switch
      switch (node.type) {
        case "BlockStatement":
          if (node.expressions.length) {
            const last = node.expressions[node.expressions.length - 1]
            insertPush(last, ref)
          } else {
            node.expressions.push([ref, ".push(void 0);"])
          }
          return
        case "CaseBlock":
          node.clauses.forEach((clause) => {
            insertPush(clause, ref)
          })
          return
        // NOTE: "CaseClause"s don't push
        case "WhenClause":
          insertPush(node.block, ref)
          return
        case "DefaultClause":
          insertPush(node.block, ref)
          return
      }
      if (!Array.isArray(node)) return

      const [, exp] = node
      if (!exp) return
      const indent = getIndent(node)

      switch (exp.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "EmptyStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "Declaration":
          return
        case "ForStatement":
        case "IterationStatement":
        case "DoStatement":
          wrapIterationReturningResults(exp, ref)
          return
        case "BlockStatement":
          insertPush(exp.expressions[exp.expressions.length - 1], ref)
          return
        case "IfStatement":
          // if block
          insertPush(exp.then, ref)
          // else block
          if (exp.else) insertPush(exp.else[2], ref)
          // Add else block pushing undefined if no else block
          else exp.children.push([" else {\n", indent, ref, ".push(undefined)\n", indent, "}"])
          return
        case "PatternMatchingStatement":
          insertPush(exp.children[0][0], ref)
          return
        case "SwitchStatement":
          // insert a results.push in each case block
          insertPush(exp.children[2], ref)
          return
        case "TryStatement":
          // NOTE: CoffeeScript doesn't add a push to an empty catch block but does add if there is any statement in the catch block
          // we always add a push to the catch block
          // NOTE: does not insert a push in the finally block
          exp.blocks.forEach(block => insertPush(block, ref))
          return
      }

      // Don't push if there's a trailing semicolon
      if (node[node.length-1]?.type === "SemicolonDelimiter") return

      // Insert push wrapping expression
      node.splice(1, 0, ref, ".push(")
      node.push(")")
    }

    function wrapWithReturn(expression) {
      const children = expression ? ["return ", expression] : ["return"]

      return {
        type: "ReturnStatement",
        children,
      }
    }

    // insert a return in each when/else/default block
    // case blocks don't get implicit returns
    // maybe default blocks shouldn't either?
    function insertSwitchReturns(exp) {
      switch (exp.type) {
        case "SwitchStatement":
          exp.caseBlock.clauses.forEach((clause) => {
            insertReturn(clause)
          })
          return
        case "SwitchExpression":
          // TODO: insert IIFE returns
          // by altering "ReturnStatement" nodes
          exp.caseBlock.clauses.forEach(insertReturn)
          return
      }
    }

    // [indent, statement, semicolon]
    function insertReturn(node) {
      if (!node) return
      // TODO: unify this with the `exp` switch
      switch (node.type) {
        case "BlockStatement":
          if (node.expressions.length) {
            const last = node.expressions[node.expressions.length - 1]
            insertReturn(last)
          } else {
            // NOTE: Kind of hacky but I'm too much of a coward to make `->` add an implicit return
            if (node.parent.type === "CatchClause") {
              node.expressions.push(["return"])
            }
          }
          return
        // NOTE: "CaseClause"s don't get a return statements inserted
        case "WhenClause":
          // Remove inserted `break;`
          node.children.splice(node.children.indexOf(node.break), 1)
          if (node.block.expressions.length) {
            insertReturn(node.block)
          } else {
            node.block.expressions.push(wrapWithReturn())
          }
          return
        case "DefaultClause":
          insertReturn(node.block)
          return
      }
      if (!Array.isArray(node)) return

      const [, exp, semi] = node
      if (semi?.type === "SemicolonDelimiter") return
      let indent = getIndent(node)
      if (!exp) return

      switch (exp.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "EmptyStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "Declaration":
          return
        case "ForStatement":
        case "IterationStatement":
        case "DoStatement":
          wrapIterationReturningResults(exp)
          return
        case "BlockStatement":
          insertReturn(exp.expressions[exp.expressions.length - 1])
          return
        case "IfStatement":
          // if block
          insertReturn(exp.then)
          // else block
          if (exp.else) insertReturn(exp.else[2])
          // Add explicit return after if block if no else block
          else exp.children.push(["", {
            type: "ReturnStatement",
            // NOTE: add a prefixed semi-colon because the if block may not be braced
            children: [";return"],
          }])
          return
        case "PatternMatchingStatement":
          insertReturn(exp.children[0][0])
          return
        case "SwitchStatement":
          insertSwitchReturns(exp)
          return
        case "TryStatement":
          exp.blocks.forEach(block => insertReturn(block))
          // NOTE: do not insert a return in the finally block
          return
      }

      // Don't add return if there's a trailing semicolon
      if (node[node.length-1]?.type === "SemicolonDelimiter") return

      // Insert return after indentation and before expression
      const returnStatement = wrapWithReturn(node[1])
      node.splice(1, 1, returnStatement)
    }

    // Convert general ExtendedExpression into LeftHandSideExpression
    // by optionally wrapping in parentheses.
    // TODO: Avoid parentheses in more cases by adding more types.
    module.makeLeftHandSideExpression = function(expression) {
      switch (expression.type) {
        case "Ref":
        case "Identifier":
        case "Literal":
        case "CallExpression":
        case "MemberExpression":
        case "ParenthesizedExpression":
          return expression
        default:
          return {
            type: "ParenthesizedExpression",
            children: ["(", expression, ")"],
            expression,
          }
      }
    }

    module.isWhitespaceOrEmpty = function(node) {
      if (!node) return true
      if (node.type === "Ref") return false
      if (node.token) return node.token.match(/^\s*$/)
      if (node.children) node = node.children
      if (!node.length) return true
      if (typeof node === "string") return node.match(/^\s*$/)
      if (Array.isArray(node)) return node.every(module.isWhitespaceOrEmpty)
    }

    // Test whether a given StringLiteral is a
    module.isTemplateLiteral = function(node) {
      let s = node
      while (s && s[0] && !s.token) s = s[0]
      return s.token?.startsWith?.('`')
    }

    module.isEmptyBareBlock = function(node) {
      if (node?.type !== "BlockStatement") return false
      const {bare, expressions} = node
      return bare &&
        (expressions.length === 0 ||
         (expressions.length === 1 &&
          expressions[0][1]?.type === "EmptyStatement"))
    }

    module.processBinaryOpExpression = function($0) {
      const expandedOps = module.expandChainedComparisons($0)

      // Expanded ops is [a, __, op1, __, b, __, op2, __, c, __, op3, __, d], etc.
      // NOTE: all operators of higher precedence than relational have been merged into the operand expressions
      let i = 2
      while (i < expandedOps.length) {
        const op = expandedOps[i]
        // a in b -> indexOf.call(b, a) >= 0
        // a is in b -> indexOf.call(b, a) >= 0
        // a not in b -> indexOf.call(b, a) < 0
        // a is not in b -> indexOf.call(b, a) < 0
        // a not instanceof b -> !(a instanceof b)
        if (op.special) {
          let [a, wsOp, op, wsB, b] = expandedOps.slice(i - 2, i + 3)

          // typeof shorthand: x instanceof "String" -> typeof x === "string"
          if (op.token === "instanceof" && b.type === "Literal" &&
              b.children?.[0]?.type === "StringLiteral") {
            a = [ "typeof ", module.makeLeftHandSideExpression(a) ]
            if (op.negated) {
              op = { ...op, token: "!==", negated: false }
            } else {
              op = { ...op, token: "===" }
            }
          }

          if (op.asConst) {
            a = module.makeAsConst(a)
            b = module.makeAsConst(b)
          }

          let children
          if (op.call) {
            wsOp = insertTrimmingSpace(wsOp, "")

            if (op.reversed) {
              wsB = insertTrimmingSpace(wsB, "")
              children = [wsOp, op.call, "(", wsB, b, ", ", a, ")", op.suffix]
            } else {
              children = [wsOp, op.call, "(", a, ",", wsB, b, ")", op.suffix]
            }
          } else if (op.method) {
            wsOp = insertTrimmingSpace(wsOp, "")
            wsB = insertTrimmingSpace(wsB, "")
            if (op.reversed) {
              children = [wsB, b, wsOp, ".", op.method, "(", a, ")"]
            } else {
              children = [a, wsOp, ".", op.method, "(", wsB, b, ")"]
            }
          } else if (op.token) {
            children = [a, wsOp, op, wsB, b]
            if (op.negated) children = ["(", ...children, ")"]
          } else {
            throw new Error("Unknown operator: " + JSON.stringify(op))
          }
          if (op.negated) children.unshift("!")

          expandedOps.splice(i - 2, 5, {
            children
          })
        } else {
          i += 4
        }
      }

      return expandedOps
    }

    /**
    * binops is an array of [__, op, __, exp] tuples
    * first is an expression
    */
    module.expandChainedComparisons = function([first, binops]) {
      // TODO: add refs to ensure middle expressions are evaluated only once

      // all relational operators could be chained in theory, including in and instanceof
      const relationalOps = ["==", "===", "!=", "!==", "<", "<=", ">", ">=", "in"]

      // short circuit/bitwise ops have lower precedence than comparison ops
      // so we only need to look for chains in the sections between them
      const lowerPrecedenceOps = ["??", "&&", "||", "&", "|", "^"]

      // shift/arithmetic ops have higher precedence, they will bind to expressions inside the chains
      // const higherPrecedenceOps = ["<<", ">>", ">>>", "+", "-", "*", "**", "/", "%"]

      let results = []

      let i = 0
      let l = binops.length

      let start = 0
      // indexes of chainable ops
      let chains = []
      while (i < l) {
        const [, op] = binops[i]

        // NOTE: Treat Coffee `in` and `not in` ops as relational.
        if (relationalOps.includes(op.token) || op.relational) {
          chains.push(i)
        } else if (lowerPrecedenceOps.includes(op.token)) {
          // end of the chain
          processChains()
          first = []
        }

        i++
      }

      processChains()

      return results

      function processChains() {
        if (chains.length > 1) {
          chains.forEach((index, k) => {
            if (k > 0) {
              // NOTE: Inserting ws tokens to keep even operator spacing in the resulting array
              results.push(" ", "&&", " ")
            }
            const [pre, op, post, exp] = binops[index]

            let endIndex
            if (k < chains.length - 1) {
              endIndex = chains[k + 1]
            } else {
              endIndex = i + 1
            }

            results = results.concat(first, ...binops.slice(start, endIndex))
            first = [exp].concat(binops.slice(index + 1, endIndex))
            start = endIndex
          })
        } else {
          // Advance start if there was no chain
          results = results.concat(first, ...binops.slice(start, i + 1))
          start = i + 1
        }

        chains.length = 0
      }
    }

    // Return an array of Rule names that correspond to the current call stack
    module.parsePosition = function() {
      let s = Error().stack.split(/\n    at /)
      s./**/shift()
      s = s.filter((e) => !e.match(/^eval/)).map((e) => e.split(' ')[0])
      s = s.slice(1, s.indexOf('Program') + 1)

      return s
    }

    module.prune = function(node) {
      if(node === null || node === undefined) return
      if(node.length === 0) return

      if (Array.isArray(node)) {
        const a = node
        .map((n) => module.prune(n))
        .filter((n) => !!n)

        if(a.length > 1)  return a
        if(a.length === 1) return a[0]
        return
      }

      if(node.children != null) {
        node.children = module.prune(node.children)
        return node
      }

      return node
    }

    // Used to ignore the result of __ if it is only whitespace
    // Useful to preserve spacing around comments
    module.skipIfOnlyWS = function (target) {
      if (!target) return target
      if (Array.isArray(target)) {
        if (target.length === 1) {
          return module.skipIfOnlyWS(target[0])
        } else if (target.every(e => (module.skipIfOnlyWS(e) === undefined))) {
          return undefined
        }
        return target
      }
      if (target.token != null && target.token.trim() === '') {
        return undefined
      }
      return target
    }

    // Split out leading newlines from the first indented line
    const initialSpacingRe = /^(?:\r?\n|\n)*((?:\r?\n|\n)\s+)/

    module.dedentBlockSubstitutions = function($0) {
      const [s, strWithSubstitutions, e] = $0

      if (strWithSubstitutions.length === 0) {
        return $0
      }

      let initialSpacing, i=0, l=strWithSubstitutions.length, results=[s]
      // Get initial spacing from the first string token if it is not a substitution
      const {token} = strWithSubstitutions[0]

      if (token) {
        initialSpacing = token.match(initialSpacingRe)
      } else {
        initialSpacing = false
      }

      while (i < l) {
        let segment = strWithSubstitutions[i]

        if (segment.token) {
          segment = module.dedentBlockString(segment, initialSpacing, false)
          if (i === 0) {
            // Trim leading newline
            segment.token = segment.token.replace(/^(\r?\n|\n)/, "")
          }
          if (i === l - 1) {
            // Trim trailing newline
            segment.token = segment.token.replace(/(\r?\n|\n)[ \t]*$/, "")
          }
          results.push(segment)
        } else {
          results.push(segment)
        }

        i++
      }

      results.push(e)
      return {
        type: "TemplateLiteral",
        children: results,
      }
    }

    module.dedentBlockString = function({$loc, token: str}, spacing, trim=true) {
      // If string begins with a newline then indentation assume that it should be removed for all lines
      if (spacing == null) spacing = str.match(initialSpacingRe)

      if (spacing) {
        str = str.replaceAll(spacing[1], "\n")
        const l = spacing.length
        $loc.pos += l
        $loc.length -= l
      }

      if (trim) {
        // Remove leading newline
        str = str.replace(/^(\r?\n|\n)/, "")
        // Remove trailing newline
        .replace(/(\r?\n|\n)[ \t]*$/, "")
      }

      // escape unescaped backticks and `${`
      str = str.replace(/(\\.|`|\$\{)/g, s => {
        if (s[0] === "\\") {
          return s
        }
        return `\\${s}`
      })

      return {
        $loc,
        token: str,
      }
    }

    module.adjustBindingElements = function(elements) {
      const names = elements.flatMap((p) => p.names || []),
        { length } = elements

      let blockPrefix,
        restIndex = -1,
        restCount = 0

      elements.forEach(({rest}, i) => {
        if (rest) {
          if (restIndex < 0) restIndex = i
          restCount++
        }
      })

      if (restCount === 0) {
        return {
          children: elements,
          names,
          blockPrefix,
          length,
        }
      } else if (restCount === 1) {
        const rest = elements[restIndex]
        const after = elements.slice(restIndex + 1)

        let restIdentifier
        if (rest.ref) {
          restIdentifier = rest.ref
        } else {
          restIdentifier = rest.names[0]
          names./**/push(...rest.names)
        }

        if (after.length) {
          const spliceRef = module.getRef("splice")

          blockPrefix = {
            type: "PostRestBindingElements",
            children: ["[", insertTrimmingSpace(after, ""), "] = ", spliceRef, ".call(", restIdentifier, ", -", after.length.toString(), ")"],
            names: after.flatMap(p => p.names),
          }
        }

        return {
          names,
          children: [...elements.slice(0, restIndex), {
            ...rest,
            children: rest.children.slice(0, -1) // remove trailing comma
          }],
          blockPrefix,
          length,
        }
      }

      const err = {
        type: "Error",
        children: ["Multiple rest elements in array pattern"],
      }

      return {
        names,
        children: [...elements, err],
        blockPrefix,
        length,
      }
    }

    module.reorderBindingRestProperty = function(props) {
      const names = props.flatMap(p => p.names)

      let restIndex = -1
      let restCount = 0
      props.forEach(({type}, i) => {
        if (type === "BindingRestProperty") {
          if (restIndex < 0) restIndex = i
          restCount++
        }
      })

      if (restCount === 0) {
        return {
          children: props,
          names,
        }
      } else if (restCount === 1) {
        let after = props.slice(restIndex + 1)
        let rest = props[restIndex]

        props = props.slice(0, restIndex);

        // Swap delimiters of last property and rest so that an omitted trailing comma doesn't end up in the middle
        if (after.length) {
          const
            [restDelim]       = rest.children.slice(-1),
            lastAfterProp     = after[after.length - 1],
            lastAfterChildren = lastAfterProp.children,
            [lastDelim]       = lastAfterChildren.slice(-1)

          rest = {...rest, children: [...rest.children.slice(0, -1), lastDelim]}
          after = [...after.slice(0, -1), {...lastAfterProp, children: [...lastAfterChildren.slice(0, -1), restDelim]}]
        }

        const children = [...props, ...after, rest]

        return {
          children,
          names,
        }
      }

      return {
        children: [{
          type: "Error",
          message: "Multiple rest properties in object pattern",
        }, props]
      }
    }

    function addParentPointers(node, parent) {
      if (node == null) return
      if (typeof node !== "object") return

      // NOTE: Arrays are transparent and skipped when traversing via parent
      if (Array.isArray(node)) {
        for (const child of node) {
          addParentPointers(child, parent)
        }
        return
      }

      node.parent = parent
      if (node.children) {
        for (const child of node.children) {
          addParentPointers(child, node)
        }
      }
    }

    // Replace all nodes that match predicate with replacer(node)
    module.replaceNodes = (root, predicate, replacer) => {
      if (root == null) return root
      const array = Array.isArray(root) ? root : root.children
      if (!array) return root
      array.forEach((node, i) => {
        if (node == null) return
        if (predicate(node)) {
          array[i] = replacer(node, root)
        } else {
          module.replaceNodes(node, predicate, replacer)
        }
      })
      return root
    }

    function processParams(f) {
      const { type, parameters, block } = f
      // Check for singleton TypeParameters <Foo> before arrow function,
      // which TypeScript (in tsx mode) treats like JSX; replace with <Foo,>
      if (type === "ArrowFunction" && parameters && parameters.tp && parameters.tp.parameters.length === 1) {
        parameters.tp.parameters.push(",")
      }

      if (!block) return
      const { expressions } = block
      if (!expressions) return
      const { blockPrefix } = parameters

      let indent
      if (!expressions.length) {
        indent = ""
      } else {
        indent = expressions[0][0]
      }

      const [splices, thisAssignments] = gatherBindingCode(parameters, {
        injectParamProps: f.name === 'constructor'
      })

      const delimiter = {
        type: "SemicolonDelimiter",
        children: [";"],
      }

      const prefix = splices
        .map(s => ["let ", s])
        .concat(thisAssignments)
        .map((s) => s.type
          ? {
            ...s,
            children: [indent, ...s.children, delimiter]
          }
          : [indent, s, delimiter]
        )

      expressions.unshift(...prefix)
    }

    // Adjusts @binding inside object properties that need to be aliased
    // see test/function.civet binding pattern
    function adjustAtBindings(statements, asThis=false) {
      gatherRecursiveAll(statements, n => n.type === "AtBindingProperty")
      .forEach(binding => {
        const { ref } = binding

        if (asThis) {
          // Convert from @x to x: this.x keeping any whitespace or initializer to the right
          const atBinding = binding.children[0]
          atBinding.children.pop()
          atBinding.type = undefined

          binding.children.unshift(ref.id, ": this.", ref.base)
          binding.type = "Property"
          binding.ref = undefined
          return
        }

        if (ref.names[0] !== ref.base) {
          binding.children.unshift(ref.base, ": ")
        }
      })
    }

    // Support for `return.value` and `return =`
    // for changing automatic return value of function.
    // Returns whether any present (so shouldn't do implicit return).
    function processReturnValue(func) {
      const {block} = func
      const values = gatherRecursiveWithinFunction(block,
        ({type}) => type === "ReturnValue")
      if (!values.length) return false

      const ref = {
        type: "Ref",
        base: "ret",
        id: "ret",
      }

      let declared
      values.forEach(value => {
        value.children = [ref]

        // Check whether return.value already declared within this function
        const ancestor = findAncestor(value,
          ({type}) => type === "Declaration",
          isFunction)
        if (ancestor) declared = true
      })

      // Add declaration of return.value after {
      if (!declared) {
        let returnType = func.returnType ?? func.signature?.returnType
        if (returnType) {
          const {t} = returnType
          if (t.type === "TypePredicate") {
            returnType = ": boolean"
          } else if (t.type === "AssertsType") {
            returnType = undefined
          }
        }
        block.expressions.unshift([
          getIndent(block.expressions[0]),
          {
            type: "Declaration",
            children: ["let ", ref, returnType],
            names: [],
          },
          ";"
        ])
      }

      // Transform existing `return` -> `return ret`
      gatherRecursiveWithinFunction(block,
        r => r.type === "ReturnStatement" && !r.expression)
      .forEach((r) => {
        r.expression = ref
        r.children.splice(-1, 1, " ", ref)
      })

      // Implicit return before }
      if (block.children.at(-2)?.type !== "ReturnStatement") {
        block.expressions.push([
          [ getIndent(block.expressions.at(-1)) ],
          {
            type: "ReturnStatement",
            expression: ref,
            children: ["return ", ref]
          }
        ])
      }

      return true
    }

    function isVoidType(t) {
      return t?.type === "LiteralType" && t.t.type === "VoidType"
    }

    function processFunctions(statements) {
      gatherRecursiveAll(statements, ({type}) => type === "FunctionExpression" || type === "ArrowFunction")
      .forEach((f) => {
        processParams(f)
        if (!processReturnValue(f) && module.config.implicitReturns) {
          const { block, returnType } = f
          const isVoid  = isVoidType(returnType?.t)
          const isBlock = block?.type === "BlockStatement"
          if (!isVoid && isBlock) {
            insertReturn(block)
          }
        }
      })

      gatherRecursiveAll(statements, ({type}) => type === "MethodDefinition")
      .forEach((f) => {
        processParams(f)
        if (!processReturnValue(f) && module.config.implicitReturns) {
          const {signature, block} = f
          const isConstructor = signature.name       === "constructor"
          const isVoid        = isVoidType(signature.returnType?.t)
          const isSet         = signature.modifier?.set

          if (!isConstructor && !isSet && !isVoid) {
            insertReturn(block)
          }
        }
      })
    }

    function processSwitchExpressions(statements) {
      if (module.config.implicitReturns) {
        // Add returns to SwitchExpressions
        gatherRecursiveAll(statements, n => n.type === "SwitchExpression")
        .forEach(insertSwitchReturns)
      }
    }

    function processTryExpressions(statements) {
      if (module.config.implicitReturns) {
        // Add returns to TryExpressions
        gatherRecursiveAll(statements, n => n.type === "TryExpression")
        .forEach(({ blocks }) => {
          blocks.forEach(insertReturn);
        })
      }
    }

    function processBindingPatternLHS(lhs, tail) {
      // Expand AtBindings first before gathering splices
      adjustAtBindings(lhs, true)
      const [splices, thisAssignments] = gatherBindingCode(lhs)
      // TODO: This isn't quite right for compound assignments, may need to wrap with parens and use comma to return the complete value
      tail.push(...splices.map(s => [", ", s]), ...thisAssignments.map(a => [", ", a]))
    }

    function processAssignments(statements) {
      gatherRecursiveAll(statements, n => n.type === "AssignmentExpression" && n.names === null)
      .forEach(exp => {
        let {lhs: $1, exp: $2} = exp, tail = [], i = 0, len = $1.length

        // identifier=
        if ($1.some((left) => left[left.length-1].special)) {
          if ($1.length !== 1) {
            throw new Error("Only one assignment with id= is allowed")
          }
          const [, lhs, , op] = $1[0]
          const {call} = op
          // Replace id= with =
          op[op.length-1] = "="
          // Wrap right-hand side with call
          $2 = [ call, "(", lhs, ", ", $2, ")" ]
        }

        // Force parens around destructuring object assignments
        // Walk from left to right the minimal number of parens are added and enclose all destructured assignments
        // TODO: Could validate some lhs ecmascript rules here if we wanted to
        let wrapped = false
        while (i < len) {
          const lastAssignment = $1[i++]
          const [,lhs,,op] = lastAssignment
          if (op.token !== "=") continue

          if (lhs.type === "ObjectExpression" || lhs.type === "ObjectBindingPattern") {
            // Wrap with parens to distinguish from braced blocks
            if (!wrapped) {
              wrapped = true
              lhs.children./**/splice(0, 0, "(")
              tail./**/push(")")
            }
          }
        }

        // TODO: Handle optional assignment refs

        // Walk from right to left to handle splices
        i = len - 1
        while (i >= 0) {
          const lastAssignment = $1[i]

          if (lastAssignment[3].token === "=") {
            const lhs = lastAssignment[1]

            // Splice assignment
            if (lhs.type === "MemberExpression") {
              const members = lhs.children
              const lastMember = members[members.length-1]

              // TODO: this is kind of bonkers
              if(lastMember.type === "SliceExpression") {
                const {start, end, children: c} = lastMember
                // TODO: don't lose as many source mappings
                c[0].token = ".splice("
                c[1] = start
                c[2] = ", "
                if (end)
                  c[3] = [end, " - ", start]
                else
                  c[3] = ["1/0"]
                c[4] = [", ...", $2]
                c[5] = ")"

                // Remove assignment token
                lastAssignment./**/pop()
                if (module.isWhitespaceOrEmpty(lastAssignment[2])) lastAssignment./**/pop()
                // TODO: this only works for the last assignment, not multiple splice assignments, or splice assignments earlier in the chain
                if ($1.length > 1) {
                  throw new Error("Not implemented yet! TODO: Handle multiple splice assignments")
                }

                exp.children = [$1]
                exp.names = []
                return
              }
            } else if (lhs.type === "ObjectBindingPattern" || lhs.type === "ArrayBindingPattern") {
              processBindingPatternLHS(lhs, tail)
            }
            // NOTE: currently not processing any non-binding pattern ObjectExpression or ArrayExpressions
            // This might not be correct in all situations, esp BindingPatterns nested inside ObjectExpressions
          }
          i--
        }

        // Gather all identifier names from the lhs array
        const names = $1.flatMap(([,l]) => l.names || [])
        exp.children = [$1, $2, ...tail]
        exp.names = names
      })

      // Move assignments/updates within LHS of assignments/updates
      // to run earlier via comma operator
      gatherRecursiveAll(statements, n => n.type === "AssignmentExpression" || n.type === "UpdateExpression")
      .forEach(exp => {
        function extractAssignment(lhs) {
          let expr = lhs
          while (expr.type === "ParenthesizedExpression") {
            expr = expr.expression
          }
          if (expr.type === "AssignmentExpression" ||
              expr.type === "UpdateExpression") {
            if (expr.type === "UpdateExpression" &&
                expr.children[0] === expr.assigned) {  // postfix update
              post.push([", ", lhs])
            } else {
              pre.push([lhs, ", "])
            }
            // TODO: use ref to avoid duplicating function calls
            return expr.assigned
          }
        }
        const pre = [], post = []
        switch (exp.type) {
          case "AssignmentExpression":
            if (!exp.lhs) return
            exp.lhs.forEach((lhsPart, i) => {
              let newLhs = extractAssignment(lhsPart[1])
              if (newLhs) {
                lhsPart[1] = newLhs
              }
            })
            break
          case "UpdateExpression":
            let newLhs = extractAssignment(exp.assigned)
            if (newLhs) {
              const i = exp.children.indexOf(exp.assigned)
              exp.assigned = exp.children[i] = newLhs
            }
            break
        }
        if (pre.length) exp.children.unshift(...pre)
        if (post.length) exp.children.push(...post)
      })
    }

    // Don't push to prelude unless ref actually ends up in final parse tree,
    // the parse could backtrack and not actually use the ref!
    function checkSpliceRef(statements) {
      const spliceRef = module.getRef("splice")
      if (gatherRecursiveAll(statements, n => n === spliceRef).length) {
        const typeSuffix = {
          ts: true,
          children: [": <T>(this: T[], start: number, deleteCount?: number) => T[]"]
        }

        // [indent, statement]
        module.prelude.push(["", ["const ", spliceRef, typeSuffix, " = [].splice", module.asAny, "\n"]])
      }
    }

    module.attachPostfixStatementAsExpression = function (exp, post) {
      let clause
      switch (post[1].type) {
        case "ForStatement":
        case "IterationStatement":
        case "DoStatement":
          clause = module.addPostfixStatement(exp, ...post)
          return {
            type: "IterationExpression",
            children: [clause],
            block: clause.block,
          }
        case "IfStatement":
          clause = module.expressionizeIfClause(post[1], exp)
          return clause
        default:
          throw new Error("Unknown postfix statement")
      }
    }

    // Given a MethodDefinition, convert into a FunctionExpression
    module.convertMethodToFunction = function(method) {
      const {signature, block} = method
      let { modifier } = signature
      if (modifier) {
        if (modifier.get || modifier.set) {
          throw new Error('cannot convert get/set method to function')
        } else if (modifier.async) {
          // put function after async
          modifier = [modifier.children[0][0], " function ", ...modifier.children.slice(1)]
        } else {
          modifier = ["function ", ...modifier.children]
        }
      } else {
        modifier = "function ";
      }
      return {
        ...signature,
        id: signature.name,
        type: "FunctionExpression",
        children: [
          [modifier, ...signature.children.slice(1)],
          block,
        ],
        block,
      }
    }

    function getPatternConditions(pattern, ref, conditions) {
      switch (pattern.type) {
        case "ArrayMatchingPattern": {
          const { elements, length } = pattern,
            hasRest = elements.some(e => e.rest),
            comparator = hasRest ? " >= " : " === ",
            l = [comparator, (length - hasRest).toString()]

          conditions.push(
            ["Array.isArray(", ref, ")"],
            [ref, ".length", l],
          )

          // recursively collect nested conditions
          elements.forEach(({children: [,e]}, i) => {
            const subRef = [ref, "[", i.toString(), "]"]

            switch (e.type) {
              case "ArrayMatchingPattern":
              case "ObjectMatchingPattern":
              case "RegularExpressionLiteral":
                getPatternConditions(e, subRef, conditions)
                break
              case "BindingMatchElement":
                getPatternConditions(e.match, subRef, conditions)
                break
            }
          })

          // collect post rest conditions
          const postRest = pattern.children.find((c) => c?.blockPrefix)
          if (postRest) {
            const postElements = postRest.blockPrefix.children[1],
              {length: postLength} = postElements

            postElements.forEach(({children: [,e]}, i) => {
              const subRef = [ref, "[", ref, ".length - ", (postLength + i).toString(), "]"]

              switch (e.type) {
                case "ArrayMatchingPattern":
                case "ObjectMatchingPattern":
                case "RegularExpressionLiteral":
                case "Literal":
                  getPatternConditions(e, subRef, conditions)
                  break
                case "BindingMatchElement":
                  getPatternConditions(e.match, subRef, conditions)
                  break
              }
            })
          }

          break
        }
        case "ObjectMatchingPattern": {
          conditions.push(
            ["typeof ", ref, " === 'object'"],
            [ref, " != null"],
          )

          pattern.properties.forEach((p) => {
            switch(p.type) {
              case "BindingMatchProperty": {
                const {name, match} = p
                let subRef
                switch(name.type) {
                  case "ComputedPropertyName":
                    conditions.push([name.expression, " in ", ref])
                    subRef = [ref, name]
                    break
                  case "Literal":
                  case "StringLiteral":
                  case "NumericLiteral":
                    conditions.push([name, " in ", ref])
                    subRef = [ref, "[", name, "]"]
                    break
                  default:
                    conditions.push(["'", name ,"' in ", ref])
                    subRef = [ref, ".", name]
                }

                getPatternConditions(p.match, subRef, conditions)

                break
              } case "BindingProperty":
                conditions.push(["'", p.identifier ,"' in ", ref])
                break
            }
          })

          break
        }
        case "RegularExpressionLiteral": {
          conditions.push(
            ["typeof ", ref, " === 'string'"],
            [pattern, ".test(", ref, ")"],
          )

          break
        }
        default: {
          conditions.push([
            ref,
            " === ",
            pattern,
          ])
        }
      }
    }

    function elideMatchersFromArrayBindings(elements) {
      return elements.map(({ children: [ws, e, sep] }) => {
        switch (e.type) {
          case "Literal":
          case "RegularExpressionLiteral":
          case "StringLiteral":
            return sep
          default:
            return [ ws, nonMatcherBindings(e), sep ]
        }
      })
    }

    function elideMatchersFromPropertyBindings(properties) {
      return properties.map((p) => {
        switch (p.type) {
          case "BindingMatchProperty": {
            const { children, name, match } = p
            const [ws,,,,,, sep] = children

            switch (match.type) {
              case "ArrayMatchingPattern":
              case "ObjectMatchingPattern":
                return {
                  ...p,
                  children: [ws, name, ": ", nonMatcherBindings(match)],
                }
              case "Identifier":
                switch (name.type) {
                  case "ComputedPropertyName":
                  case "Literal":
                  case "StringLiteral":
                  case "NumericLiteral":
                    return {
                      ...p,
                      children: [ws, name, ": ", match, sep],
                    }
                }
              case "Literal":
              case "RegularExpressionLiteral":
              case "StringLiteral":
              default:
                return {
                  ...p,
                  children: [ws, name, sep],
                }
            }
          }
          case "BindingProperty":
          case "BindingRestProperty":
          default:
            return p
        }
      })
    }

    function nonMatcherBindings(pattern) {
      switch (pattern.type) {
        case "ArrayMatchingPattern":
          return ["[", elideMatchersFromArrayBindings(pattern.elements), "]"]
        case "PostRestBindingElements": {
          const els = elideMatchersFromArrayBindings(pattern.children[1])

          return {
            ...pattern,
            children: [
              pattern.children[0],
              els,
              ...pattern.children.slice(2),
            ],
          }
        }
        case "ObjectMatchingPattern":
          return ["{", elideMatchersFromPropertyBindings(pattern.properties), "}"]

        default:
          return pattern
      }
    }

    function aggregateDuplicateBindings(bindings) {
      const props = gatherRecursiveAll(bindings, n => n.type === "BindingMatchProperty")
      const declarations = []

      const propsGroupedByName = new Map

      for(const p of props) {
        const { name } = p

        const key = name.name
        if (propsGroupedByName.has(key)) {
          propsGroupedByName.get(key).push(p)
        } else {
          propsGroupedByName.set(key, [p])
        }
      }

      propsGroupedByName.forEach((shared, key) => {
        if (!key) return
        // NOTE: Allows pattern matching reserved word keys by binding to inaccessible refs
        // HACK: using the parser's ReservedWord rule here
        if (ReservedWord({
          pos: 0,
          input: key,
        })) {
          shared.forEach((p) => {
            const ref = {
              type: "Ref",
              base: `_${key}`,
              id: key,
            }
            p.children.push(": ", ref)
          });
          // Don't push declarations for reserved words
          return
        }

        if (shared.length === 1) return

        // Create a ref alias for each duplicate binding
        const refs = shared.map((p) => {
          const ref = {
            type: "Ref",
            base: key,
            id: key,
          }

          p.children.push(": ", ref)

          return ref
        })

        // Gather duplicates in an array
        declarations.push(["const ", key, " = [", ...refs.map((r, i) => {
          return i === 0 ? r : [", ", r]
        }), "]"])
      })

      return declarations
    }

    function processPatternMatching(statements) {
      gatherRecursiveAll(statements, n => n.type === "SwitchStatement" || n.type === "SwitchExpression")
      .forEach((s) => {
        const { caseBlock } = s
        const { clauses } = caseBlock

        let errors = false
        let isPattern = false
        if (clauses.some((c) => c.type === "PatternClause")) {
          isPattern = true
          clauses.forEach((c) => {
            // else/default clause is ok
            if (!(c.type === "PatternClause" || c.type === "DefaultClause")) {
              errors = true
              c.children.push({
                type: "Error",
                message: "Can't mix pattern matching and non-pattern matching clauses",
              })
            }
          })
        }

        if (errors || !isPattern) return

        let { expression } = s
        if (expression.type === "ParenthesizedExpression") {
          // Unwrap parenthesized expression
          expression = expression.expression
        }

        let ref = module.needsRef(expression, "m") || expression
        let prev = [],
          root = prev

        const l = clauses.length
        clauses.forEach((c, i) => {
          if (c.type === "DefaultClause") {
            prev.push(c.block)
            return
          }

          let { pattern, block } = c

          const indent = block.expressions?.[0]?.[0] || ""

          // TODO: intermediate refs and ref decs

          const conditions = []
          getPatternConditions(pattern, ref, conditions)

          const condition = {
            type: "ParenthesizedExpression",
            children: ["(", conditions.map((c, i) => {
              if (i === 0) return c
              return [" && ", ...c]
            }), ")"],
            expression: conditions,
          }

          const prefix = []

          switch (pattern.type) {
            case "ArrayMatchingPattern":
              if (pattern.length === 0) break
            case "ObjectMatchingPattern": {
              // NOTE: Array matching pattern falls through so we use the null check
              if (pattern.properties?.length === 0) break

              // Gather bindings
              let [splices, thisAssignments] = gatherBindingCode(pattern)
              const patternBindings = nonMatcherBindings(pattern)

              splices = splices.map(s => [", ", nonMatcherBindings(s)])
              thisAssignments = thisAssignments.map(a => [indent, a, ";"])

              const duplicateDeclarations = aggregateDuplicateBindings([patternBindings, splices])

              prefix.push([indent, "const ", patternBindings, " = ", ref, splices, ";"])
              prefix.push(...thisAssignments)
              prefix.push(...duplicateDeclarations.map(d => [indent, d, ";"]))

              break
            }
          }

          block.expressions.unshift(...prefix)

          const next = []

          // Add braces if necessary
          if (block.bare) {
            block.children.unshift(" {")
            block.children.push("}")
            block.bare = false
          }

          // Insert else if there are more branches
          if (i < l - 1) next.push("\n", "else ")

          prev.push(["", {
            type: "IfStatement",
            children: ["if", condition, block, next],
            then: block,
            else: next,
          }])
          prev = next
        })

        if (module.config.implicitReturns && s.type === "SwitchExpression") {
          insertReturn(root[0])
          root.splice(0, 1, module.wrapIIFE(root[0]))
        }

        s.type = "PatternMatchingStatement"
        s.children = [root]
        // Update parent pointers
        addParentPointers(s, s.parent)
      })
    }

    // head: expr
    // body: [ws, pipe, ws, expr][]

    function processPipelineExpressions(statements) {
      gatherRecursiveAll(statements, n => n.type === "PipelineExpression")
      .forEach((s) => {
        const [ ws, , body ] = s.children
        let   [ , arg ]   = s.children

        let i = 0, l = body.length

        const refDec = []
        const children = [ws, refDec]

        let usingRef = null

        for (i = 0; i < l; i++) {
          const step = body[i]
          const [leadingComment, pipe, trailingComment, expr] = step
          const returns = pipe.token === "||>"
          let ref, result,
            returning = returns ? arg : null

          if (pipe.token === "|>=") {
            let initRef
            if (i === 0) {
              outer: switch(arg.type) {
                case "MemberExpression":
                  // If there is only a single access then we don't need a ref
                  if (arg.children.length <= 2) break
                case "CallExpression":
                  const access = arg.children.pop()

                  switch (access.type) {
                    case "PropertyAccess":
                    case "SliceExpression":
                      break
                    default:
                      children.unshift({
                        type: "Error",
                        $loc: pipe.token.$loc,
                        message: `Can't assign to ${access.type}`,
                      })
                      arg.children.push(access)
                      break outer
                  }

                  usingRef = module.needsRef({}) // hacky: using this like a "createRef"
                  initRef = {
                    type: "AssignmentExpression",
                    children: [usingRef, " = ", arg, ","],
                  }

                  arg = {
                    type: "MemberExpression",
                    children: [usingRef, access]
                  }

                  break;
              }

              // remove refDec from children and put it inside lhs of assignment
              // TODO: should be attached to node to be hoisted
              children.pop()
              // assignment node
              const lhs = [[
                [refDec, initRef],
                arg,
                [],
                {token: "=", children: [" = "]}
              ]];

              Object.assign(s, {
                type: "AssignmentExpression",
                children: [ lhs, children ],
                names: null,
                lhs,
                assigned: arg,
                exp: children,
              })

              // Clone so that the same node isn't on the left and right because splice manipulation
              // moves things around and can cause a loop in the graph
              arg = clone(arg)

              // except keep the ref the same
              if (arg.children[0].type === "Ref") {
                arg.children[0] = usingRef
              }

            } else {
              children.unshift({
                type: "Error",
                $loc: pipe.token.$loc,
                message: "Can't use |>= in the middle of a pipeline",
              })
            }
          } else {
            s.children = children
          }

          if(returns && (ref = module.needsRef(arg))) {
            // Use the existing ref if present
            usingRef = usingRef || ref
            arg = {
              type: "ParenthesizedExpression",
              children: ["(", {
                type: "AssignmentExpression",
                children: [usingRef, " = ", arg],
              }, ")"],
            }
            returning = usingRef
          }

          [result, returning] = module.constructPipeStep(
            {
              leadingComment: module.skipIfOnlyWS(leadingComment),
              trailingComment: module.skipIfOnlyWS(trailingComment),
              expr
            },
            arg,
            returning,
          )

          if (result.type === "ReturnStatement") {
            // Attach errors/warnings if there are more steps
            if (i < l - 1) {
              result.children.push({
                type: "Error",
                message: "Can't continue a pipeline after returning",
              })
            }
            arg = result
            if (children[children.length - 1] === ",") {
              children.pop()
              children.push(";")
            }
            break
          }

          if (returning) {
            arg = returning
            children.push(result, ",")
          } else {
            arg = result
          }
        }

        // TODO: Hoistable ref declarations
        if (usingRef) {
          refDec.unshift("let ", usingRef, ";")
        }

        children.push(arg)
        // Update parent pointers
        addParentPointers(s, s.parent)
      })
    }

    module.processProgram = function(root) {
      // invariants
      assert.equal(module.forbidClassImplicitCall.length, 1, "forbidClassImplicitCall")
      assert.equal(module.forbidIndentedApplication.length, 1, "forbidIndentedApplication")
      assert.equal(module.forbidTrailingMemberProperty.length, 1, "forbidTrailingMemberProperty")
      assert.equal(module.forbidMultiLineImplicitObjectLiteral.length, 1, "forbidMultiLineImplicitObjectLiteral")
      assert.equal(module.JSXTagStack.length, 0, "JSXTagStack should be empty")

      addParentPointers(root)

      const { expressions: statements } = root

      processPipelineExpressions(statements)
      processAssignments(statements)
      processPatternMatching(statements)
      processFunctions(statements)
      processSwitchExpressions(statements)
      processTryExpressions(statements)

      hoistRefDecs(statements)

      // Modify iteration expressions
      gatherRecursiveAll(statements, n => n.type === "IterationExpression")
      .forEach((e) => expressionizeIteration(e))

      // NOTE: This must be done after function processing because that inserts the ref into the block body
      checkSpliceRef(statements)

      // Insert prelude
      statements.unshift(...module.prelude)

      if (module.config.autoLet) {
        createLetDecs(statements, [])
      } else if (module.config.autoVar) {
        createVarDecs(statements, [])
      }

      populateRefs(statements)
      adjustAtBindings(statements)
    }

    function findDecs(statements) {
      const declarationNames = gatherNodes(statements, ({type}) => type === "Declaration")
      .flatMap(d => d.names)

      return new Set(declarationNames)
    }

    function populateRefs(statements) {
      const refNodes = gatherRecursive(statements, ({type}) => type === "Ref")

      if (refNodes.length) {
        // Find all ids within nested scopes
        const ids = gatherRecursive(statements, (s) => s.type === "Identifier")
        const names = new Set(ids.flatMap(({names}) => names || []))

        // Populate each ref
        refNodes.forEach((ref) => {
          const {type, base} = ref
          if (type !== "Ref") return

          ref.type = "Identifier"

          let n = 0
          let name = base

          // check for name collisions and increment name suffix
          while (names.has(name)) {
            n++
            name = `${base}${n}`
          }

          names.add(name)
          ref.children = ref.names = [name]
        })
      }
    }

    // CoffeeScript compatible automatic var insertion
    function createVarDecs(statements, scopes, pushVar) {
      // NOTE: var and let/const have different scoping rules
      // need to keep var scopes when entering functions and within a var scope keep
      // track of lexical scopes within blocks
      function hasDec(name) {
        return scopes.some((s) => s.has(name))
      }

      function findAssignments(statements, decs) {
        let assignmentStatements = gatherNodes(statements, (node) => {
          return node.type === "AssignmentExpression"
        })

        if (assignmentStatements.length) {
          // Get nested assignments that could be in expressions
          assignmentStatements = assignmentStatements
          .concat(findAssignments(assignmentStatements.map(s => s.children), decs))
        }

        return assignmentStatements
      }

      // Let descendent blocks add the var at the outer enclosing function scope
      if (!pushVar) {
        pushVar = function(name) {
          varIds./**/push(name)
          decs.add(name)
        }
      }

      const decs = findDecs(statements)
      scopes.push(decs)
      const varIds = []
      const assignmentStatements = findAssignments(statements, scopes)
      const undeclaredIdentifiers = assignmentStatements.flatMap(a => a.names)

      // Unique, undeclared identifiers in this scope
      undeclaredIdentifiers.filter((x, i, a) => {
        if (!hasDec(x)) return a.indexOf(x) === i
      }).forEach(pushVar)

      const fnNodes  = gatherNodes(statements, (s) => s.type === "FunctionExpression")
      const forNodes = gatherNodes(statements, (s) => s.type === "ForStatement")

      const blockNodes = new Set(gatherNodes(statements, (s) => s.type === "BlockStatement"))
      // Remove function blocks and for statements, they get handled separately because they have additional parameter scopes and lexical scopes to add
      fnNodes .forEach(({block}) => blockNodes.delete(block))
      forNodes.forEach(({block}) => blockNodes.delete(block))

      // recurse into nested blocks
      blockNodes.forEach((block) => {
        createVarDecs(block.expressions, scopes, pushVar)
      })

      // recurse into for loops
      forNodes.forEach(({block, declaration}) => {
        scopes.push(new Set(declaration.names))
        createVarDecs(block.expressions, scopes, pushVar)
        scopes.pop()
      })

      // recurse into nested functions
      fnNodes.forEach(({block, parameters}) => {
        scopes.push(new Set(parameters.names))
        createVarDecs(block.expressions, scopes)
        scopes.pop()
      })

      if (varIds.length) {
        // get indent from first statement
        const indent = getIndent(statements[0])
        let delimiter = ";"
        if (statements[0][1]?.parent?.root) {
          delimiter = ";\n"
        }
        // TODO: Declaration ast node
        statements.unshift([indent, "var ", varIds.join(", "), delimiter])
      }

      scopes.pop()
    }

    function createLetDecs(statements, scopes) {
      function findVarDecs(statements, decs) {
        const declarationNames = gatherRecursive(statements,
          (node) =>
            node.type === "Declaration" &&
            node.children &&
            node.children.length > 0 &&
            node.children[0].token &&
            node.children[0].token.startsWith('var') ||
          node.type === "FunctionExpression")
          .filter(node => node.type === "Declaration")
          .flatMap(node => node.names)

        return new Set(declarationNames)
      }

      let declaredIdentifiers = findVarDecs(statements)

      function hasDec(name) {
        return declaredIdentifiers.has(name) || scopes.some((s) => s.has(name))
      }

      function gatherBlockOrOther(statement) {
        return gatherNodes(statement, (s) => s.type === "BlockStatement" || s.type === "AssignmentExpression" || s.type === "Declaration").flatMap((node) => {
          if (node.type == "BlockStatement")
            // bare blocks is not a safe position to insert let declaration
            return node.bare ? gatherBlockOrOther(node.expressions) : node
          else if (node.children && node.children.length)
            return [...gatherBlockOrOther(node.children), node]
          else
            return []
        })
      }

      let currentScope = new Set()
      scopes.push(currentScope)

      const fnNodes  = gatherNodes(statements, (s) => s.type === "FunctionExpression")
      const forNodes = gatherNodes(statements, (s) => s.type === "ForStatement")

      let targetStatements = []
      for (const statement of statements) {
        const nodes = gatherBlockOrOther(statement)
        let undeclaredIdentifiers = []
        for (const node of nodes) {
          if (node.type == "BlockStatement") {
            let block = node
            let fnNode  =  fnNodes.find((fnNode)  =>  fnNode.block === block)
            let forNode = forNodes.find((forNode) => forNode.block === block)
            if (fnNode != null) {
              scopes.push(new Set(fnNode.parameters.names))
              createLetDecs(block.expressions, scopes)
              scopes.pop()
            }
            else if (forNode != null) {
              scopes.push(new Set(forNode.declaration.names))
              createLetDecs(block.expressions, scopes)
              scopes.pop()
            }
            else
              createLetDecs(block.expressions, scopes)
            continue
          }
          // Assignment and Declaration all use 'names'.
          if (node.names == null) continue
          let names = node.names.filter(name => !hasDec(name))
          if (node.type == "AssignmentExpression")
            undeclaredIdentifiers.push(...names)
          names.forEach((name) => currentScope.add(name))
        }

        if (undeclaredIdentifiers.length > 0) {
          let indent = statement[0]
          // Is this statement a simple assingment like 'a = 1'?
          let firstIdentifier = gatherNodes(statement[1], (node) => node.type == "Identifier")[0]
          if (undeclaredIdentifiers.length == 1
          && statement[1].type == 'AssignmentExpression'
          && statement[1].names.length == 1
          && statement[1].names[0] == undeclaredIdentifiers[0]
          && firstIdentifier && firstIdentifier.names == undeclaredIdentifiers[0]
          && gatherNodes(statement[1], (node) => node.type === "ObjectBindingPattern").length == 0)
            statement[1].children.unshift(["let "])
          else {
            let tail = "\n"
            // Does this statement start with a newline?
            if (gatherNodes(indent, (node) => node.token && node.token.endsWith("\n")).length > 0)
              tail = undefined
            targetStatements.push([indent, "let ", undeclaredIdentifiers.join(", "), tail])
          }
        }
        targetStatements.push(statement)
      }

      scopes.pop()
      statements.splice(0, statements.length, targetStatements)
    }

    module.constructInvocation = function(
      fn,
      arg,
    ) {
      const fnArr = [fn.leadingComment, fn.expr, fn.trailingComment]

      // Unwrap ampersand blocks
      let expr = fn.expr
      while (expr.type === "ParenthesizedExpression") {
        expr = expr.expression
      }
      if (expr.ampersandBlock) {
        const { ref, body } = expr

        ref.type = "PipedExpression"
        ref.children = [ module.makeLeftHandSideExpression(arg) ]

        return {
          type: "UnwrappedExpression",
          children: [ module.skipIfOnlyWS(fn.leadingComment), ...body, module.skipIfOnlyWS(fn.trailingComment) ],
        }
      }

      expr = fn.expr
      const lhs = module.makeLeftHandSideExpression(expr)

      // Attach comments
      let comment = module.skipIfOnlyWS(fn.trailingComment)
      if (comment) lhs.children.splice(2, 0, comment)
      comment = module.skipIfOnlyWS(fn.leadingComment)
      if (comment) lhs.children.splice(1, 0, comment)

      switch (arg.type) {
        case "CommaExpression":
          arg = module.makeLeftHandSideExpression(arg)
          break
      }

      return {
        type: "CallExpression",
        children: [ lhs, "(", arg, ")" ],
      }
    }

    module.constructPipeStep = function(
      fn,
      arg,
      returning,
    ) {

      const children = [[fn.leadingComment, fn.expr, fn.trailingComment].map(module.skipIfOnlyWS), " ", arg]

      // Handle special non-function cases
      switch (fn.expr.token) {
        case "yield":
        case "await":
          if (returning) {
            return [
              children,
              returning
            ]
          }

          return [
            children,
            null
          ]

        case "return":
          // Return ignores ||> returning argument
          return [{
            type: "ReturnStatement",
            children,
          }, null]
      }

      if (returning) {
        return [
          module.constructInvocation(fn, arg),
          returning
        ]

      }

      return [module.constructInvocation(fn, arg), null]
    }

    return $0

# Indentation

# Holds the last indent level in `module.lastIndent`
# Can get weird with backtracking but should work out as long as
# EOS/Nested rules are used carefully and if we only compare to the
# pushed value.
Indent
  /[ \t]*/ ->
    let level
    if (module.config.tab) {
      const tabs = $0.match(/\t/g)
      const numTabs = tabs ? tabs.length : 0
      level = numTabs * module.config.tab + /*spaces*/ ($0.length - numTabs)
    } else {
      level = $0.length
    }

    return {
      $loc,
      token: $0,
      level
    }

# Used in PushIndent to keep track of the last indent level for nesting
TrackIndented
  Indent:indent ->
    const {level} = indent

    if (level <= module.currentIndent.level) {
      return $skip
    }
    if (module.config.verbose) {
      console.log("pushing indent", indent)
    }

    module.indentLevels.push(indent)
    return $1

Samedent
  EOS Indent:indent ->
    const { level } = indent
    const currentIndentLevel = module.currentIndent.level
    if (level === currentIndentLevel) {
      return $0
    }
    return $skip

IndentedFurther
  EOS Indent:indent ->
    const { level } = indent
    const currentIndentLevel = module.currentIndent.level
    if (level > currentIndentLevel) {
      return $0
    }
    return $skip

NotDedented
  ( Samedent / IndentedFurther )? _? ->
    const ws = []
    if ($1) ws.push(...$1)
    if ($2) ws.push(...$2)
    return ws.flat(Infinity).filter(Boolean)

# Indents one level deeper
# Must be matched with PopIndent
PushIndent
  # TrackIndented pushes the indent level if it is deeper than the current level
  # it will skip if it is not deeper
  &( EOS TrackIndented )

PopIndent
  "" ->
    if (module.config.verbose) {
      console.log("popping indent", module.indentLevels[module.indentLevels.length-1], "->", module.indentLevels[module.indentLevels.length-2])
    }
    module.indentLevels./**/pop()

Nested
  EOS:eos Indent:indent ->
    const { level } = indent
    const currentIndent = module.currentIndent
    if (module.config.verbose) {
      console.log("Indented", level, currentIndent)
    }
    if (level !== currentIndent.level) {
      if (module.config.verbose) {
        console.log("skipped nested")
      }
      return $skip
    }
    return $0
