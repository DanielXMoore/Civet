# Civet: A successor to CoffeeScript and alternative to TypeScript
# much more 1-to-1 with es6

# ECMA Reference
# https://262.ecma-international.org/13.0/

Program
  Reset Init __ TopLevelStatement* __

TopLevelStatement
  EOS? ModuleItem StatementDelimiter

# https://262.ecma-international.org/#prod-Expression
Expression
  # CommaOperator
  # https://262.ecma-international.org/#sec-comma-operator
  # NOTE: Eliminated left recursion
  AssignmentExpression (__ Comma AssignmentExpression)* ->
    if($2.length == 0) return $1
    return $0

# https://262.ecma-international.org/#prod-Arguments
Arguments
  OpenParen ArgumentList? ( __ Comma )? __ CloseParen
  # NOTE: Added spacing based implicit function application
  # Trailing (__ MemberExpressionRest)* is to capture trailing .someMethod and bind them at the right place
  ImplicitApplication

ArgumentsWithTrailingCallExpressions
  # Since this is recursive Arguments must consume input to avoid infinite recursion
  # NOTE: Do not allow trailing template literals to match
  TrackIndent (( Arguments ( &EOS Samedent !"`" CallExpressionRest )* PopIndent ) / PopIndent) ->
    // No match, only restored indent
    if (!$2) return $skip
    return $2

# https://262.ecma-international.org/#prod-ArgumentList
ArgumentList
  # NOTE: Added nested arguments on separate new lines
  &EOS NestedArgumentList
  Expression CommaExpression*

NestedArgumentList
  PushIndent NestedArgument*:args PopIndent ->
    if (args.length) return args
    return $skip

NestedArgument
  Nested Expression ParameterElementDelimiter

ImplicitApplication
  # Space / indentation based function application
  # Function application:
  # a b => a(b)
  # a b, c, d => a(b, c, d)
  # x y z => x(y(z))
  ApplicationStart ArgumentList InsertCloseParen

# Start of function application, inserts an open parenthesis, maintains spacing and comments when possible
ApplicationStart
  !EOS _:spacing !AdditionalReservedWords ->
    return module.insertTrimmingSpace(spacing, "(")
  # Nested application for nested objects
  # someMethod => someMethod({
  #   a: b          a: b
  #               })
  #
  # IndentedApplicationAllowed gets turned of inside if conditions and switch conditions to prevent
  # indentation based function application from being used inside them. It is a bit of a hack.
  IndentedApplicationAllowed &NestedObjectLiteral InsertOpenParen -> $3

IndentedApplicationAllowed
  "" ->
    if (module.suppressIndentedApplication) return $skip
    return

CommaExpression
  __ Comma Expression

BinaryOpExpression
  UnaryExpression (__ BinaryOp __ UnaryExpression)* ->
    if ($2.length) return $0
    return $1

# https://262.ecma-international.org/#prod-UnaryExpression
UnaryExpression
  # NOTE: Eliminated left recursion
  UnaryOp*:pre UpdateExpression:exp UnaryPostfix?:post ->
    // Handle "?" postfix
    if (post?.token === "?") {
      // v1.1 Can remove parens when unnecessary once exp returns a full AST node to determine if they are actually needed
      return ["(", pre, , "(", exp, ") != null)"]
    }

    return [pre, exp, post]

UnaryPostfix
  QuestionMark
  __ As NonIdContinue Type -> { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-UpdateExpression
UpdateExpression
  # NOTE: Not allowing whitespace betwen prefix and postfix increment operators and operand
  UpdateExpressionSymbol UnaryExpression
  LeftHandSideExpression UpdateExpressionSymbol? ->
    if ($2) return $0
    return $1

UpdateExpressionSymbol
  ("++" / "--") ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-AssignmentExpression
AssignmentExpression
  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  TrailingComment* AssignmentExpressionRest ->
    if ($1.length) return $0
    return $2
  __ AssignmentExpressionRest

AssignmentExpressionRest
  AwaitExpression
  YieldExpression
  (Async __)? ArrowFunction

  # NOTE: Eliminated left recursion
  # NOTE: Consolidated assignment ops

  (__ LeftHandSideExpression __ AssignmentOp)+ Expression -> { type: "AssignmentExpression", children: $0 }
  ConditionalExpression

AwaitExpression
  Await TrailingComment* AssignmentExpression

YieldExpression
  Yield ( TrailingComment* Star )? AssignmentExpression

# https://262.ecma-international.org/#prod-ArrowFunction
ArrowFunction
  ThinArrowFunction
  Parameters ReturnTypeSuffix? FatArrow FatArrowBody

FatArrow
  # Ensures at least one space before arrow
  __:ws "=>" ->
    if (!ws.length)
      return " =>"
    return $0

# NOTE Different from
# https://262.ecma-international.org/#prod-ConciseBody
FatArrowBody
  __ OpenBrace EOS NestedBlockExpressions __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS:eos NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseBrace
  AssignmentExpression
  __ AssignmentExpression
  # Implied empty block
  InsertOpenBrace InsertCloseBrace

# https://262.ecma-international.org/#prod-ConditionalExpression
ConditionalExpression
  ShortCircuitExpression ( __ QuestionMark AssignmentExpression __ Colon AssignmentExpression)? ->
    if ($2) return $0
    return $1

# https://262.ecma-international.org/#prod-ShortCircuitExpression
ShortCircuitExpression
  # NOTE: We don't need to track the precedence of all the binary operators so they all collapse into this
  BinaryOpExpression

# https://262.ecma-international.org/#prod-PrimaryExpression
PrimaryExpression
  This
  IdentifierReference
  Literal
  ArrayLiteral
  ObjectLiteral
  FunctionExpression
  ClassExpression
  RegularExpressionLiteral
  TemplateLiteral
  # https://262.ecma-international.org/#prod-ParenthesizedExpression
  # NOTE: Currently ignoring early error checking in https://262.ecma-international.org/#prod-CoverParenthesizedExpressionAndArrowParameterList
  OpenParen Expression __ CloseParen
  # https://facebook.github.io/jsx/#sec-jsx-PrimaryExpression
  JSXElement
  JSXFragment

# https://262.ecma-international.org/#prod-ClassDeclaration
ClassDeclaration
  # NOTE: skipping syntax directed operation for now
  ClassExpression

# https://262.ecma-international.org/#prod-ClassExpression
ClassExpression
  Class ( BindingIdentifier )? ( __ ClassHeritage )? ClassBody

# https://262.ecma-international.org/#prod-ClassHeritage
ClassHeritage
  # ExtendsToken __ LeftHandSideExpression
  # NOTE: This is a subset of member expression that doesn't have spaced function application
  # TODO: there are some other LeftHandSideExpressions that are valid here but aren't yet supported (new, super, import expression)
  ExtendsToken __ MemberExpression

ExtendsToken
  # NOTE: Added "<" extends shorthand
  "<" ->
    return { $loc, token: "extends" }
  "extends" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-ClassBody
# NOTE: Nesting and indentation sensitive
ClassBody
  __ OpenBrace (EOS NestedClassElements)? __ CloseBrace
  InsertOpenBrace EOS NestedClassElements InsertNewline InsertIndent InsertCloseBrace

NestedClassElements
  PushIndent NestedClassElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassElement
  Nested ClassElement StatementDelimiter

# https://262.ecma-international.org/#prod-ClassElement
ClassElement
  # NOTE: Combined optional static and Method/Field definition
  (Static TrailingComment*)? ( MethodDefinition / FieldDefinition )
  # ClassStaticBlock
  Static BracedBlock

# https://262.ecma-international.org/#prod-FieldDefinition
FieldDefinition
  # NOTE: Added readonly semantic equivalent of const field assignment
  InsertReadonly:r ClassElementName TypeSuffix? __ ConstAssignment:ca AssignmentExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    r.children[0].$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return $0

  ClassElementName TypeSuffix? Initializer?

This
  "this" ->
    return { $loc, token: $1 }
  # NOTE: Added @identifier shorthand, also works for private identifiers
  AtAccessor ( "#"? IdentifierName )
  # NOTE: Added '@' as a 'this' shorthand
  "@" ->
    return { $loc, token: "this" }

AtAccessor
  "@" ->
    return { $loc, token: "this." }

# https://262.ecma-international.org/#prod-LeftHandSideExpression
LeftHandSideExpression
  NewExpression
  CallExpression
  # NOTE: OptionalExpression is merged into CallExpression

# https://262.ecma-international.org/#prod-NewExpression
NewExpression
  # NOTE: Eliminated left recursion
  # NOTE: Changed to CallExpression to handle arguments
  (New __)+ CallExpression

# https://262.ecma-international.org/#prod-CallExpression
CallExpression
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  "super" ArgumentsWithTrailingCallExpressions
  "import" __ OpenParen AssignmentExpression __ CloseParen
  MemberExpression CallExpressionRest* ->
    if ($2.length) return $0
    return $1

CallExpressionRest
  MemberExpressionRest
  TemplateLiteral
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  (OptionalShorthand / NonNullAssertion)? ArgumentsWithTrailingCallExpressions

# NOTE: Added shorthand x?(3) -> x?.(3)
OptionalShorthand
  (QuestionMark ( Dot / InsertDot ))

NonNullAssertion
  "!" -> { ts: true, children: $1 }

# Reserved words that will prevent spaced function application
# ie: the 'of' in 'for x of ...'
AdditionalReservedWords
  /(of)(?!\p{ID_Continue})/

# https://262.ecma-international.org/#prod-MemberExpression
MemberExpression
  # NOTE: "new" MemberExpression Arguments seems to be handled fine by other rules already
  # NOTE: Eliminated left recursion
  PrimaryExpression MemberExpressionRest* ->
    if ($2.length) return $0
    return $1
  TrailingComment* SuperProperty
  TrailingComment* MetaProperty

MemberExpressionRest
  # NOTE: Added shorthand x?[3] -> x?.[3]
  ( OptionalShorthand / NonNullAssertion )? OpenBracket Expression __ CloseBracket
  # NOTE: Combined Optional and Property access
  # TODO: this doesn't yet work for arbitrarily deep nesting, only the first level
  ( &EOS IndentedFurther )? PropertyAccess
  # NOTE: Added CoffeeScript :: prototype shorthand
  ( &EOS IndentedFurther )? "::" IdentifierName?:id ->
    if (id)
      return [".prototype.", id]
    return ".prototype"
  # NOTE: Added TypeScript '!' non-null assertion
  NonNullAssertion

PropertyAccess
  ( QuestionMark / NonNullAssertion )? Dot (IdentifierName / PrivateIdentifier)

SuperProperty
  "super[" Expression __ CloseBracket

MetaProperty
  New Dot Target
  "import.meta" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-FormalParameters
# The parameters in a function definition
Parameters
  # NOTE: BindingElement -> ParameterElement
  # TODO: Rest parameter
  TypeParameters? OpenParen ParameterElement* __ CloseParen
  "" ->
    return { $loc, token: "()" }

# NOTE: Similar to BindingElement but appears in formal parameters list
ParameterElement
  # NOTE: Merged in SingleNameBinding
  __ (BindingIdentifier / BindingPattern) TypeSuffix? Initializer? ParameterElementDelimiter

ParameterElementDelimiter
  _* Comma
   # NOTE: Don't insert comma before inline closing paren
  &( _* ")" )
  # NOTE: Do insert comma before closing paren on following line
  &( __ ")" ) ->
    return { $loc, token: "," }
  &EOS ->
    return { $loc, token: "," }

# https://262.ecma-international.org/#prod-BindingIdentifier
BindingIdentifier
  __ Identifier

# https://262.ecma-international.org/#prod-BindingPattern
BindingPattern
  __ ObjectBindingPattern
  __ ArrayBindingPattern

# https://262.ecma-international.org/#prod-ObjectBindingPattern
# NOTE: Simplified from spec
ObjectBindingPattern
  # NOTE: Added indentation based binding properties
  OpenBrace &EOS NestedBindingProperties __ CloseBrace
  OpenBrace BindingProperty* ( __ BindingRestProperty )? __ CloseBrace

# https://262.ecma-international.org/#prod-ArrayBindingPattern
# NOTE: Simplified from spec
ArrayBindingPattern
  # Note: Added indentation based binding elements
  OpenBracket &EOS NestedBindingElements __ CloseBracket
  OpenBracket (BindingElement / Elision)* ( __ BindingRestElement )? __ CloseBracket

NestedBindingProperties
  PushIndent NestedBindingProperty*:props ( Nested BindingRestProperty )?:rest PopIndent ->
    if (!props.length) return $skip
    if (rest) props.push(rest)
    return props

NestedBindingProperty
  Nested BindingProperty

# https://262.ecma-international.org/#prod-BindingProperty
BindingProperty
  __ PropertyName __ Colon (BindingIdentifier / BindingPattern) Initializer? ObjectPropertyDelimiter
  BindingIdentifier Initializer? ObjectPropertyDelimiter

# https://262.ecma-international.org/#prod-BindingRestProperty
BindingRestProperty
  "..." BindingIdentifier

NestedBindingElements
  PushIndent NestedBindingElement*:props ( Nested BindingRestElement )?:rest PopIndent ->
    if (!props.length) return $skip
    if (rest) props.push(rest)
    return props

NestedBindingElement
  Nested BindingElement

# https://262.ecma-international.org/#prod-BindingElement
BindingElement
  # NOTE: Merged in SingleNameBinding
  __ (BindingIdentifier / BindingPattern) Initializer? ArrayElementDelimiter

# https://262.ecma-international.org/#prod-BindingRestElement
BindingRestElement
  "..." __ ( BindingIdentifier / BindingPattern )

# https://262.ecma-international.org/#prod-FunctionDeclaration
FunctionDeclaration
  FunctionExpression

# https://262.ecma-international.org/#prod-FunctionExpression
FunctionExpression
  # NOTE: Added CoffeeScript thin arrow function shorthand
  ThinArrowFunction
  # NOTE: Merged in async and generator with optionals
  ( Async __ )? Function ( Star __ )? ( BindingIdentifier )? __ Parameters ReturnTypeSuffix? BracedBlock -> {
    type: "FunctionExpression",
    children: $0,
  }

ThinArrowFunction
  Parameters:params ReturnTypeSuffix?:suffix _* Arrow:arrow BracedOrEmptyBlock:block ->
    if (module.implicitReturns && suffix?.children[3] !== "void") {
      block = module.addImplicitReturns(block)
    }

    return {
      type: "FunctionExpression",
      children: [
        { $loc: arrow.$loc, token: "function" },
        params,
        suffix,
        block
      ]
    }

Arrow
  "->" ->
    return { $loc, token: $1}

# NOTE: This is the body of if/else/for etc.
Block
  __ OpenBrace EOS NestedBlockExpressions:exps __ CloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  Statement
  __ Statement

BracedOrEmptyBlock
  BracedBlock
  # Implied empty block
  InsertOpenBrace InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: [],
    children: $0,
  }

# This is a block that must include braces (function body, try/catch/finally)
BracedBlock
  __ OpenBrace EOS NestedBlockExpressions:exps __ CloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # One liner
  InsertOpenBrace !EOS __ Statement:s InsertSpace InsertCloseBrace ->
    return {
      type: "BlockStatement",
      expressions: [s],
      children: $0,
    }

SingleNestedExpression
  # NOTE: Don't insert a statement delimiter for single nested expression
  # NOTE: this whole back half is mainly to guarantee we call PopIndent exactly once whether we've matched or not
  PushIndent (Nested Expression StatementDelimiter)?:exp ( (!(Nested Expression) PopIndent) / PopIndent ) ->
    if (exp) return exp
    return $skip

NestedBlockExpressions
  PushIndent BlockExpression*:exps PopIndent ->
    if (!exps.length) return $skip
    return exps

BlockExpression
  Nested StatementListItem StatementDelimiter

# https://262.ecma-international.org/#prod-Literal
Literal
  NullLiteral
  BooleanLiteral
  NumericLiteral
  StringLiteral

# https://262.ecma-international.org/#prod-NullLiteral
NullLiteral
  "null" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-BooleanLiteral
BooleanLiteral
  "true" / "false" ->
    return { $loc, token: $1 }

Comma
  _* Comma _*

# https://262.ecma-international.org/#prod-Identifier
Identifier
  !ReservedWord IdentifierName -> $2

# https://262.ecma-international.org/#prod-IdentifierName
IdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$])*/ ->
    return {
      $loc: $loc,
      token: $0,
    }

# https://262.ecma-international.org/#prod-IdentifierReference
IdentifierReference
  Identifier

# https://262.ecma-international.org/#prod-ArrayLiteral
ArrayLiteral
  OpenBracket NestedElementList __ CloseBracket
  OpenBracket ElementList __ CloseBracket

NestedElementList
  PushIndent NestedElement*:elements PopIndent ->
    if (elements.length)
      return elements
    return $skip

NestedElement
  Nested InlineElementList ArrayElementDelimiter

ArrayElementDelimiter
  _* Comma
  # NOTE: Don't insert comma before closing bracket
  # Ideally it would be nice to insert a trailing comma before newline followed by closing bracket, but in practice
  # it is difficult to keep the correct number of commas for elision elements. This is also closer to keeping source
  # verbatim.
  &( __ "]" )
  &EOS ->
    return { $loc, token: "," }

# https://262.ecma-international.org/#prod-ElementList
# NOTE: Modified and simplified from the spec
ElementList
  ArrayElementExpression ( __ Comma __ ArrayElementExpression )*

InlineElementList
  ArrayElementExpression ( _* Comma _* ArrayElementExpression )*

# NOTE: Modified and simplified from the spec
ArrayElementExpression
  (("..." __ )? AssignmentExpression)?

# https://262.ecma-international.org/#prod-Elision
Elision
  # NOTE: The repetition must be handled from outside rather than using left recursion here
  __ Comma

# https://262.ecma-international.org/#prod-ObjectLiteral
# NOTE: Slightly simplified from spec
ObjectLiteral
  OpenBrace &EOS NestedPropertyDefinitions __ CloseBrace
  OpenBrace __ PropertyDefinitionList __ (Comma __)? CloseBrace
  OpenBrace __ CloseBrace
  NestedObjectLiteral

NestedObjectLiteral
  InsertOpenBrace &EOS NestedPropertyDefinitions InsertNewline InsertIndent InsertCloseBrace

NestedPropertyDefinitions
  PushIndent NestedPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs

NestedPropertyDefinition
  # TODO: This may be a little weird/ambiguous with single identifier shorthand
  Nested PropertyDefinition ObjectPropertyDelimiter

ObjectPropertyDelimiter
  _* Comma
  # Object closing delimits the property
  &( __ "}" )
  &EOS ->
    return { $loc, token: "," }

PropertyDefinitionList
  PropertyDefinition (__ Comma __ PropertyDefinition)*

# https://262.ecma-international.org/#prod-PropertyDefinition
PropertyDefinition
  # NOTE: CoverInitializedName early error doesn't seem necessary with this parser
  PropertyName __ Colon AssignmentExpression
  MethodDefinition
  "..." AssignmentExpression
  # NOTE: this needs to be at the bottom to prevent shadowing PropertyName
  IdentifierReference

PropertyName
  # https://262.ecma-international.org/#prod-LiteralPropertyName
  NumericLiteral
  StringLiteral
  IdentifierName
  # https://262.ecma-international.org/#prod-ComputedPropertyName
  OpenBracket AssignmentExpression __ "]"

# https://262.ecma-international.org/#prod-MethodDefinition
MethodDefinition
  # TODO: Make compatible with CoffeeScript style comments by being more precise with __ whitespace here
  # NOTE: Not adding extra validation using PropertySetParameterList
  MethodSignature BracedBlock

MethodModifier
  # NOTE: Merged get/set definitions
  GetOrSet TrailingComment*
  # NOTE: Merged async and generator into MethodModifier
  ( Async __ ) ( Star __ )?
  Star __
  Async __

# TypeScript method signature
MethodSignature
  ConstructorShorthand Parameters
  MethodModifier? ClassElementName _* Parameters

ClassElementName
  PropertyName
  PrivateIdentifier

PrivateIdentifier
  "#" IdentifierName

# https://262.ecma-international.org/#prod-GeneratorDeclaration
# https://262.ecma-international.org/#prod-GeneratorExpression
# NOTE: Merged GeneratorExpression and GeneratorDeclaration into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncFunctionDeclaration
# https://262.ecma-international.org/#prod-AsyncFunctionExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorDeclaration
# https://262.ecma-international.org/#prod-AsyncGeneratorExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorMethod
# https://262.ecma-international.org/#prod-AsyncGeneratorBody
# https://262.ecma-international.org/#prod-AsyncMethod
# https://262.ecma-international.org/#prod-AsyncFunctionBody
# https://262.ecma-international.org/#prod-GeneratorMethod
# https://262.ecma-international.org/#prod-GeneratorBody
# NOTE: Merged into MethodDefinition

# https://262.ecma-international.org/#prod-AssignmentOperator
AssignmentOp
  AssignmentOpSymbol ->
    return { $loc, token: $1 }

AssignmentOpSymbol
  "**="
  "*="
  "/="
  "%="
  "+="
  "-="
  "<<="
  ">>>="
  ">>="
  "&&="
  "&="
  "^="
  "||="
  "|="
  "??="
  "?=" -> "??="
  "="

BinaryOp
  BinaryOpSymbol ->
    return { $loc, token: $1 }

# NOTE: Condensed binary operator symbols into one rule
BinaryOpSymbol
  "**"
  "*"
  "/"
  "%"
  "+"
  "-"
  "<="
  ">="
  "<<"
  "<"
  ">>>"
  ">>"
  ">"
  "!=="
  # NOTE: CoffeeScript converts "!=" -> "!=="
  # Convert if CoffeeScript compat flag is set
  "!=" ->
    if(module.coffeeCompat) return "!=="
    return $1
  "is" NonIdContinue -> "==="
  "==="
  # NOTE: CoffeeScript converts "==" -> "==="
  # Convert if CoffeeScript compat flag is set
  "==" ->
    if(module.coffeeCompat) return "==="
    return $1
  "and" NonIdContinue -> "&&"
  "&&"
  "or" NonIdContinue -> "||"
  "||"
  "??"
  "instanceof" NonIdContinue ->
    return $1
  "in" NonIdContinue ->
    return $1
  "&"
  "^"
  "|"

UnaryOp
  [!~+-]
  ( "delete" / "void" / "typeof" ) NonIdContinue __

# https://262.ecma-international.org/#prod-ModuleItem
ModuleItem
  ImportDeclaration
  ExportDeclaration
  StatementListItem

# https://262.ecma-international.org/#prod-StatementListItem
StatementListItem
  # NOTE: Added postfix conditionals
  (Declaration / Statement):statement PostfixConditional?:cond Loc:l ->
    if (cond)
      // TODO: Actually wrap the statement in a conditional AST node so implicit returns can use the same logic
      return [cond, statement, { $loc: l.$loc, token: "}" }]
    return statement

PostfixConditional
  TrailingComment*:ws (If / Unless):cond NonIdContinue Loc:l1 ExpressionWithIndentedApplicationSuppressed:exp Loc:l2 ->
    let openParens = { $loc: l1.$loc, token: "(!(" }
    let closingParens = { $loc: l2.$loc, token: "))" }
    let space = { $loc: l2.$loc, token: " " }
    let openingBrace = { $loc: l2.$loc, token: "{" }

    if (cond.token === "if") {
      cond.token = "if"
      closingParens.token = ")"
      openParens.token = "("
    } else {
      cond.token = "if"
    }

    return [ws, cond, openParens, exp, closingParens, space, openingBrace]

# https://262.ecma-international.org/#prod-Statement
Statement
  KeywordStatement
  BlockStatement
  VariableStatement
  IfStatement
  IterationStatement
  SwitchStatement
  TryStatement

  EmptyStatement
  ExpressionStatement

  # NOTE: no WithStatement
  # NOTE: no LabelledStatement

# NOTE: EmptyStatement handled differently than spec, consuming inline whitespace and comments then asserting following semi-colon
EmptyStatement
  TrailingComment* &";" -> { type: "EmptyStatement", children: $1 }

# https://262.ecma-international.org/#prod-BlockStatement
BlockStatement
  __ OpenBrace EOS NestedBlockExpressions __ CloseBrace

# https://262.ecma-international.org/#prod-IfStatement
IfStatement
  # NOTE: Added paren-less condition
  # NOTE: Block isn't Statement so we can handle implied braces by nesting
  If Condition Block ( __ Else Block )? -> { type: "IfStatement", children: $0 }
  Unless:kind Condition:condition Block:block ->
    // Rewrite unless to if
    condition.forEach((c) => {
      if (!c) return
      if (c.token === "(") c.token = "(!("
      if (c.token === ")") c.token = "))"
    })
    kind.token = "if"

    return {
      type: "IfStatement",
      children: [kind, condition, block],
    }

# https://262.ecma-international.org/#prod-IterationStatement
IterationStatement
  # NOTE: Added `loop` from CoffeeScript
  LoopStatement
  DoWhileStatement
  WhileStatement
  ForStatement -> {
    type: "IterationStatement",
    children: $0,
  }
  ForInOfStatement -> {
    type: "IterationStatement",
    children: $0,
  }

# NOTE: Added from CoffeeScript
LoopStatement
  Loop Block -> { type: "IterationStatement", children: $0 }

# https://262.ecma-international.org/#prod-DoWhileStatement
DoWhileStatement
  # NOTE: Condition provides optional parens
  "do" NonIdContinue Block __ WhileClause -> { type: "IterationStatement", children: $0 }

# https://262.ecma-international.org/#prod-WhileStatement
WhileStatement
  # NOTE: Condition provides optional parens
  WhileClause Block -> {
    type: "IterationStatement",
    children: $0
  }

WhileClause
  ( "while" / "until" ):kind NonIdContinue Condition:cond ->
    if (kind === "until") {
      cond[1] = "(!("
      cond[4] = "))"
      return ["while", cond]
    }
    return $0

# https://262.ecma-international.org/#prod-ForStatement
ForStatement
  For __ OpenParen __ ( LexicalDeclaration / VariableStatement / Expression? ) __ Semicolon Expression? Semicolon Expression? CloseParen Block
  # TODO: Optional parens

# https://262.ecma-international.org/#prod-ForInOfStatement
ForInOfStatement
  # NOTE: Consolidated declarations
  For __ OpenParen __          ( ( Var __ ForBinding ) / ForDeclaration / LeftHandSideExpression ) __ In Expression __ CloseParen           Block
  # NOTE: Added optional parens
  For __ InsertOpenParen ( ( Var __ ForBinding ) / ForDeclaration / LeftHandSideExpression ) __ In Expression InsertCloseParen Block
  # NOTE: Consolidated optional 'await' and declarations
  For ( __ Await )? __ OpenParen __          ( ( Var __ ForBinding ) / ForDeclaration / LeftHandSideExpression ) __ Of AssignmentExpression __ CloseParen           Block
  # NOTE: Added optional parens
  For ( __ Await )? __ InsertOpenParen ( ( Var __ ForBinding ) / ForDeclaration / LeftHandSideExpression ) __ Of AssignmentExpression InsertCloseParen Block

# https://262.ecma-international.org/#prod-ForDeclaration
ForDeclaration
  LetOrConst NonIdContinue __ ForBinding

# https://262.ecma-international.org/#prod-ForBinding
ForBinding
  BindingIdentifier
  BindingPattern

# https://262.ecma-international.org/#prod-SwitchStatement
SwitchStatement
  Switch Condition CaseBlock -> {
    type: "SwitchStatement",
    children: $0
  }

# https://262.ecma-international.org/#prod-CaseBlock
CaseBlock
  __ OpenBrace &EOS NestedCaseClauses:clauses __ CloseBrace ->
    $0.splice(2, 1)

    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

  # NOTE: Added optional braces with nesting
  &EOS InsertOpenBrace NestedCaseClauses:clauses InsertNewline InsertIndent InsertCloseBrace ->
    $0.shift()

    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

NestedCaseClauses
  PushIndent NestedCaseClause*:clauses PopIndent ->
    if (clauses.length) return clauses
    return $skip

NestedCaseClause
  Nested CaseClause ->
    // Bring the indent into the clause
    $2.children.unshift($1)
    return $2

# https://262.ecma-international.org/#prod-CaseClause
CaseClause
  # NOTE: This differs from ESTree significantly to be easier to work with for implicit returns
  Case CaseExpressionList ( NestedBlockExpressions / NoExpressions ):exps -> {
    type: "CaseClause",
    expressions: exps,
    children: $0
  }
  # NOTE: Added "when" from CoffeeScript. `when` always inserts `break;`.
  When CaseExpressionList NestedBlockExpressions:exps InsertBreak -> {
    type: "WhenClause",
    expressions: exps,
    children: $0
  }
  # NOTE: Merged in default clause
  Default ImpliedColon ( NestedBlockExpressions / NoExpressions ):exps -> {
    type: "DefaultClause",
    expressions: exps,
    children: $0
  }
  # NOTE: Added else from CoffeesScript
  Else ImpliedColon NestedBlockExpressions:exps ->
    $1.token = "default"
    return {
      type: "DefaultClause",
      expressions: exps,
      children: $0
    }

CaseExpressionList
  ( _* ExpressionWithIndentedApplicationSuppressed ImpliedColon ) ( __ Comma ExpressionWithIndentedApplicationSuppressed ImpliedColon )* ->
    // Convert comma separated expression list to `case <exp>:`
    const result = $2.map(([ws, _comma, exp, col]) => {
      module.insertTrimmingSpace(exp, "")

      if (ws.length) return [module.insertTrimmingSpace("case ", ws), exp, col]
      return ["case ", exp, col]
    })
    result.unshift($1)

    return result

NoExpressions
  "" -> []

ImpliedColon
  __ Colon
  "" ->
    return { $loc, token: ":" }

# https://262.ecma-international.org/#prod-TryStatement
TryStatement
  Try:t BracedBlock:b CatchClause?:c Finally?:f ->
    if (!c && !f) {
      return {
        type: "TryStatement",
        children: [t, b, " catch(e) {}"]
      }
    }

    return {
      type: "TryStatement",
      children: [t, b, c, f]
    }

# https://262.ecma-international.org/#prod-Catch
CatchClause
  __ Catch CatchBind? BracedBlock

# NOTE: Added optional parentheses to catch binding
CatchBind
  __ OpenParen __ CatchParameter __ CloseParen
  !EOS TrailingComment* InsertOpenParen CatchParameter InsertCloseParen

# https://262.ecma-international.org/#prod-Finally
Finally
  __ "finally" BracedBlock

# https://262.ecma-international.org/#prod-CatchParameter
CatchParameter
  BindingIdentifier
  BindingPattern

# An expression with explicit or implied parentheses, for use in if/while
Condition
  __ OpenParen Expression __ CloseParen
  !EOS __ InsertOpenParen ExpressionWithIndentedApplicationSuppressed InsertCloseParen

ExpressionWithIndentedApplicationSuppressed
  SuppressIndentedApplication AssignmentExpression?:exp ->
    module.suppressIndentedApplication = false

    if (exp) return exp
    return $skip

SuppressIndentedApplication
  "" ->
    module.suppressIndentedApplication = true

# https://262.ecma-international.org/#prod-ExpressionStatement
ExpressionStatement
  # NOTE: semi-colons are being handled elsewhere
  # NOTE: Shouldn't need negative lookahead if shadowed in the proper order
  Expression

KeywordStatement
  # https://262.ecma-international.org/#prod-BreakStatement
  # NOTE: no label
  "break" NonIdContinue -> {
    type: "BreakStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ContinueStatement
  # NOTE: no label
  "continue" NonIdContinue -> {
    type: "ContinueStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#sec-debugger-statement
  "debugger" NonIdContinue -> {
    type: "DebuggerStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ReturnStatement
  Return MaybeNestedExpression? -> {
    type: "ReturnStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ThrowStatement
  Throw Expression -> {
    type: "ThrowStatement",
    children: $0,
  }

MaybeNestedExpression
  !EOS TrailingComment* Expression
  &EOS ObjectLiteral

# https://262.ecma-international.org/#prod-ImportDeclaration
ImportDeclaration
  "import type" NonIdContinue __ ImportClause __ FromClause -> { ts: true, children: $0 }
  Import __ ImportClause __ FromClause
  Import __ ModuleSpecifier
  # NOTE: Added import shorthand
  # NOTE: Not adding $loc to source map here yet because it will point to the start of the identifier
  # the proper place may be to use the From location
  ImpliedImport:i ImportClause:c __:w FromClause:f ->
    // Map implied import location to `from`
    // The pos and length adjustment better match how tsc outputs to include the space before `from` with the `from` token
    i.$loc = {
      pos: f[0].$loc.pos-1,
      length: f[0].$loc.length+1,
    }
    return [i, c, w, f]

ImpliedImport
  "" ->
    return { $loc, token: "import " }

# https://262.ecma-international.org/#prod-ImportClause
ImportClause
  ImportedBinding ( __ Comma __ ( NameSpaceImport / NamedImports ) )?
  NameSpaceImport
  NamedImports

# https://262.ecma-international.org/#prod-NameSpaceImport
NameSpaceImport
  Star __ As NonIdContinue __ ImportedBinding

# https://262.ecma-international.org/#prod-NamedImports
NamedImports
  OpenBrace ImportSpecifier* ( __ Comma )? __ CloseBrace

# https://262.ecma-international.org/#prod-FromClause
FromClause
  From __ ModuleSpecifier

# https://262.ecma-international.org/#prod-ImportSpecifier
ImportSpecifier
  __ ModuleExportName __ As NonIdContinue __ ImportedBinding ObjectPropertyDelimiter
  __ ImportedBinding ObjectPropertyDelimiter

# https://262.ecma-international.org/#prod-ModuleExportName
ModuleExportName
  StringLiteral
  IdentifierName

# https://262.ecma-international.org/#prod-ModuleSpecifier
ModuleSpecifier
  UnprocessedModuleSpecifier ->
    // Workaround to fix:
    // https://github.com/microsoft/TypeScript/issues/42151
    // import t.ts
    // "An import path cannot end with a '.ts' extension. Consider importing './t.js' instead."
    const {token} = $1
    // convert .[mc]?ts to .[mc]?js
    return { $loc, token: token.replace(/\.([mc])?ts(['"])$/, ".$1js$2") }

UnprocessedModuleSpecifier
  BasicStringLiteral
  UnquotedSpecifier

UnquotedSpecifier
  # Currently allowing all characters except for whitespace, double quotes, and semi-colon
  # It may make sense to restrict this to only allow characters that are valid in a module specifier
  # Also consider URLs
  /[^;"\s]+/:spec ->
    return { $loc, token: `"${spec}"` }

# https://262.ecma-international.org/#prod-ImportedBinding
ImportedBinding
  BindingIdentifier

# https://262.ecma-international.org/#prod-ExportDeclaration
ExportDeclaration
  Export __ "default" NonIdContinue __ ( HoistableDeclaration / ClassDeclaration / AssignmentExpression )
  Export __ ExportFromClause __ FromClause
  Export __ ( NamedExports / VariableStatement / Declaration )

# https://262.ecma-international.org/#prod-ExportFromClause
ExportFromClause
  Star ( __ As NonIdContinue __ ModuleExportName )?
  NamedExports

# https://262.ecma-international.org/#prod-NamedExports
NamedExports
  OpenBrace ExportSpecifier* (__ Comma )? __ CloseBrace

# https://262.ecma-international.org/#prod-ExportSpecifier
ExportSpecifier
  __ ModuleExportName ( __ As __ ModuleExportName )? ObjectPropertyDelimiter

# https://262.ecma-international.org/#prod-Declaration
Declaration
  HoistableDeclaration
  ClassDeclaration
  LexicalDeclaration
  TypeDeclaration

# https://262.ecma-international.org/#prod-HoistableDeclaration
HoistableDeclaration
  FunctionDeclaration

# https://262.ecma-international.org/#prod-LexicalDeclaration
LexicalDeclaration
  # NOTE: Eliminated left recursion
  LetOrConst __ LexicalBinding ( __ Comma __ LexicalBinding )* -> {
    type: "VariableDeclaration",
    children: $0,
  }
  # NOTE: Added const shorthand
  InsertConst:c ( BindingPattern / BindingIdentifier ) TypeSuffix? __ ConstAssignment:ca AssignmentExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    c.$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return {
      type: "VariableDeclaration",
      children: $0
    }

ConstAssignment
  ":=" ->
    return { $loc, token: "=" }

# https://262.ecma-international.org/#prod-LexicalBinding
LexicalBinding
  BindingPattern TypeSuffix? Initializer
  BindingIdentifier TypeSuffix? Initializer?

# https://262.ecma-international.org/#prod-Initializer
Initializer
  # TODO: Simplify whitespace prefixing (may need to push it down into the literals)
  # Nested blocks will get shadowed if __ is consumed before them because it consumes the indent
  __ Equals AssignmentExpression

# https://262.ecma-international.org/#prod-VariableStatement
VariableStatement
  Var __ VariableDeclarationList -> {
    type: "VariableDeclaration",
    children: $0,
  }

# https://262.ecma-international.org/#prod-VariableDeclarationList
VariableDeclarationList
  VariableDeclaration ( __ Comma __ VariableDeclaration )*

# https://262.ecma-international.org/#prod-VariableDeclaration
VariableDeclaration
  BindingPattern Initializer
  BindingIdentifier Initializer?

# https://262.ecma-international.org/#prod-NumericLiteral
NumericLiteral
  NumericLiteralKind ->
    return { $loc, token: $1 }

NumericLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexLiteral
  DecimalLiteral

# https://262.ecma-international.org/#prod-DecimalBigIntegerLiteral
DecimalBigIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)n/
  # /[_0-9]*n/

DecimalLiteral
  /\d+(?:\.\d*)?/

# https://262.ecma-international.org/#prod-BinaryIntegerLiteral
BinaryIntegerLiteral
  /0[bB][01](?:[01]|_[01])*/

# https://262.ecma-international.org/#prod-OctalIntegerLiteral
OctalIntegerLiteral
  /0[oO][0-7](?:[0-7]|_[0-7])*/

# https://262.ecma-international.org/#prod-HexIntegerLiteral
HexLiteral
  /0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_[0-9a-fA-F])*/

# https://262.ecma-international.org/#prod-StringLiteral
StringLiteral
  # NOTE: actual CoffeeScript """ string behaviors are pretty weird, this is simplifed
  TripleDoubleQuote ( TripleDoubleStringCharacters / CoffeeStringSubstitution )* TripleDoubleQuote ->
    return module.dedentBlockSubstitutions($0)

  TripleSingleQuote:s TripleSingleStringCharacters:str TripleSingleQuote:e ->
    return [s, module.dedentBlockString(str), e]

  # CoffeeScript Interpolation is enabled when "use coffee-compat" directive is present
  CoffeeCompatDoubleQuotedString
  BasicStringLiteral

BasicStringLiteral
  DoubleQuote DoubleStringCharacters:str DoubleQuote ->
    return {
      token: `"${module.modifyString(str.token)}"`,
      $loc,
    }

  SingleQuote SingleStringCharacters:str SingleQuote ->
    return {
      token: `'${module.modifyString(str.token)}'`,
      $loc,
    }

DoubleStringCharacters
  /(?:\\.|[^"])*/ ->
    return { $loc, token: $0 }

SingleStringCharacters
  /(?:\\.|[^'])*/ ->
    return { $loc, token: $0 }

TripleDoubleStringCharacters
  /(?:"(?!"")|#(?!\{)|\\.|[^#"])+/ ->
    return { $loc, token: $0 }

TripleSingleStringCharacters
  /(?:'(?!'')|\\.|[^'])*/ ->
    return { $loc, token: $0 }

CoffeeStringSubstitution
  CoffeeSubstitutionStart Expression __ CloseBrace

CoffeeCompat
  "" ->
    if(module.coffeeCompat) return
    return $skip

CoffeeCompatDoubleQuotedString
  CoffeeCompat DoubleQuote:s ( CoffeeCompatDoubleQuotedStringCharacters / CoffeeStringSubstitution )*:parts DoubleQuote:e ->
    const noInterpolations = parts.length === 1 && parts[0].token != null
    if (noInterpolations) {
      return {
        token: `"${module.modifyString(parts[0].token)}"`,
        $loc,
      }
    }

    parts.forEach((part) => {
      // Is a string
      if(part.token) {
        // Escape '${' and '`'
        const str = part.token.replace(/(`|\$\{)/g, "\\$1")
        // Escape non-continuation newlines
        part.token = module.modifyString(str)
      }
    })

    // Convert to backtick enclosed string
    s.token = e.token = "`"

    return [s, parts, e]

CoffeeCompatDoubleQuotedStringCharacters
  /(?:\\.|#(?!\{)|[^"#])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#prod-RegularExpressionLiteral
RegularExpressionLiteral
  $("/" RegularExpressionBody "/" RegularExpressionFlags) ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-RegularExpressionBody
# NOTE: Simplified a little from the spec, ignoring <PS>, <LS>
RegularExpressionBody
  ![*\/\r\n] RegExpCharacter*

RegExpCharacter
  /(?:\\.|[^\/\r\n])+/

# https://262.ecma-international.org/#prod-RegularExpressionFlags
RegularExpressionFlags
  /(?:\p{ID_Continue}|[\u200C\u200D$])*/

# https://262.ecma-international.org/#prod-TemplateLiteral
# NOTE: Simplified template grammar
TemplateLiteral
  TripleTick ( TemplateBlockCharacters / TemplateSubstitution )* TripleTick ->
    return module.dedentBlockSubstitutions($0)

  "`" ( TemplateCharacters / TemplateSubstitution )* "`"

# NOTE: Simplified grammar
TemplateSubstitution
  SubstitutionStart Expression __ CloseBrace

# https://262.ecma-international.org/#prod-TemplateCharacter
TemplateCharacters
  /(?:\$(?!\{)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

TemplateBlockCharacters
  /(?:\$(?!\{)|`(?!``)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#sec-comments
ReservedWord
  /(?:and|as|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|import|in|instanceof|interface|is|new|null|or|return|static|super|switch|this|throw|true|try|typeof|unless|var|void|while|with|yield)(?!\p{ID_Continue})/

# https://262.ecma-international.org/#sec-comments
Comment
  MultiLineComment
  SingleLineComment

SingleLineComment
  /\/\/[^\r\n]*/ ->
    return { $loc, token: $0 }
  CoffeeCompat CoffeeSingleLineComment

# https://262.ecma-international.org/#prod-MultiLineComment
MultiLineComment
  JSMultiLineComment
  # NOTE: Added CoffeeScript style ### multiline comments
  CoffeeMultiLineComment

JSMultiLineComment
  $( "/*" (!"*/" . )* "*/" ) ->
    return { $loc, token: $1 }

CoffeeSingleLineComment
  # NOTE: CoffeeScript style single line comments
  /#([^\r\n]*)/ ->
    return { $loc, token: `//${$1}` }

CoffeeMultiLineComment
  "###" $( !("###" / "*/") . )* "###" ->
    return { $loc, token: `/*${$2}*/` }

# InlineComment is a multi-line comment with no line separators
InlineComment
  $( "/*" $(!"*/" [^\r\n] )* "*/" ) ->
    return { $loc, token: $1 }

RestOfLine
  (NonNewlineWhitespace / SingleLineComment / MultiLineComment)* EOL

TrailingComment
  (NonNewlineWhitespace / InlineComment / SingleLineComment)

# Non-newline "white space" (includes comments)
# TODO: JS counts line terminators that appear in multi-line comments. For example "return /*\n*/5" is different than "return /**/ 5" because of the newline within the comment
# NOTE: Maybe Comment should only be single line comments here?
_
  (NonNewlineWhitespace / Comment)+

NonNewlineWhitespace
  [ \t]+ ->
    return { $loc, token: $0 }

# Optional whitespace including newlines and comments
__
  (Whitespace / Comment)*

Whitespace
  [\s]+ ->
    return { $loc, token: $0 }

StatementDelimiter
  TrailingComment* Semicolon TrailingComment*
  # Implied semicolon
  "" &EOS ->
    return { $loc, token: ";" }

NonIdContinue
  /(?!\p{ID_Continue})/

Loc
  "" ->
    return { $loc, token: "" }

## Tokens

As
  "as" NonIdContinue ->
    return { $loc, token: $1 }

Async
  "async" ->
    return { $loc, token: $1 }

Await
  "await" NonIdContinue ->
    return { $loc, token: $1 }

Case
  "case" NonIdContinue ->
    return { $loc, token: $1 }

Catch
  "catch" ->
    return { $loc, token: $1 }

Class
  "class" ->
    return { $loc, token: $1 }

CloseBrace
  "}" ->
    return { $loc, token: $1 }

CloseBracket
  "]" ->
    return { $loc, token: $1 }

CloseParen
  ")" ->
    return { $loc, token: $1 }

CoffeeSubstitutionStart
  "#{" ->
    return { $loc, token: "${" }

Colon
  ":" ->
    return { $loc, token: $1 }

Comma
  "," ->
    return { $loc, token: $1 }

ConstructorShorthand
  "@" ->
    return { $loc, token: "constructor" }

Default
  "default" NonIdContinue ->
    return { $loc, token: $1 }

Dot
  "." ->
    return { $loc, token: $1 }

DoubleQuote
  "\"" ->
    return { $loc, token: $1 }

Else
  "else" ->
    return { $loc, token: $1 }

Equals
  "=" ->
    return { $loc, token: $1 }

Export
  "export" NonIdContinue ->
    return { $loc, token: $1 }

For
  "for" NonIdContinue ->
    return { $loc, token: $1 }

From
  "from" NonIdContinue ->
    return { $loc, token: $1 }

Function
  "function" ->
    return { $loc, token: $1 }

GetOrSet
  ( "get" / "set" ) NonIdContinue ->
    return { $loc, token: $1 }

If
  "if" ->
    return { $loc, token: $1 }

Import
  # NOTE: this is a hack so import.meta will parse correctly
  "import" &/\s/ ->
    return { $loc, token: $1 }

In
  "in" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-LetOrConst
LetOrConst
  "let" / "const" ->
    return { $loc, token: $1 }

Loop
  # NOTE: loop becomes while
  "loop" NonIdContinue ->
    return { $loc, token: "while(true)" }

New
  "new" ->
    return { $loc, token: $1 }

Of
  "of" ->
    return { $loc, token: $1 }

OpenBrace
  "{" ->
    return { $loc, token: $1 }

OpenBracket
  "[" ->
    return { $loc, token: $1 }

OpenParen
  "(" ->
    return { $loc, token: $1 }

QuestionMark
  "?" ->
    return { $loc, token: $1 }

Return
  "return" NonIdContinue ->
    return { $loc, token: $1 }

Semicolon
  ";" ->
    return { $loc, token: $1 }

SingleQuote
  "'" ->
    return { $loc, token: $1 }

Star
  "*" ->
    return { $loc, token: $1 }

Static
  "static" ->
    return { $loc, token: $1 }
  # NOTE: In ClassElements @ is a shorthand for 'static'
  # NOTE: added negative assertion to prevent overlapping constructor shorthand
  "@" !"(" ->
    return { $loc, token: "static " }

SubstitutionStart
  "${" ->
    return { $loc, token: $1 }

Switch
  "switch" NonIdContinue ->
    return { $loc, token: $1 }

Target
  "target" ->
    return { $loc, token: $1 }

Throw
  "throw" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: These become a single backtick
TripleDoubleQuote
  "\"\"\"" ->
    return { $loc, token: "`" }

# NOTE: These become a single backtick
TripleSingleQuote
  "'''" ->
    return { $loc, token: "`" }

TripleTick
  "```" ->
    return { $loc, token: "`" }

Try
  "try" ->
    return { $loc, token: $1 }

Unless
  "unless" ->
    return { $loc, token: $1 }

Var
  "var" ->
    return { $loc, token: $1 }

# NOTE: When maps to 'case'
When
  "when" NonIdContinue ->
    return { $loc, token: "case" }

Yield
  "yield" NonIdContinue ->
    return { $loc, token: $1 }

## JSX

# https://facebook.github.io/jsx/#prod-JSXElement
JSXElement
  JSXSelfClosingElement
  JSXOpeningElement JSXChildren* __ JSXClosingElement ->
    // Check that tags match
    if ($1[1] !== $4[2]) {
      throw new Error(`mismatched closing tags at ${JSON.stringify($loc)}`)
    }
    return $0

# https://facebook.github.io/jsx/#prod-JSXSelfClosingElement
JSXSelfClosingElement
  "<" $JSXElementName JSXAttributes? __ "/>"

# https://facebook.github.io/jsx/#prod-JSXOpeningElement
JSXOpeningElement
  "<" $JSXElementName JSXAttributes? __ ">"

# https://facebook.github.io/jsx/#prod-JSXClosingElement
JSXClosingElement
  "</" __ $JSXElementName __ ">"

# https://facebook.github.io/jsx/#prod-JSXFragment
JSXFragment
  "<>" JSXChildren? "</>"

# https://facebook.github.io/jsx/#prod-JSXElementName
JSXElementName
  # Merged in https://facebook.github.io/jsx/#prod-JSXNamespacedName
  # Merged in https://facebook.github.io/jsx/#prod-JSXMemberExpression
  JSXIdentifierName ( (Colon JSXIdentifierName) / ( Dot JSXIdentifierName )* )

# NOTE: Like IdentifierName but includes hyphens after start
# NOTE: Combined from recursive https://facebook.github.io/jsx/#prod-JSXIdentifier definition
JSXIdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$-])*/

# https://facebook.github.io/jsx/#prod-JSXAttributes
JSXAttributes
  ( __ JSXAttribute )*

# NOTE: Merged SpreadAttribute and Attribute
JSXAttribute
  # https://facebook.github.io/jsx/#prod-JSXSpreadAttribute
  OpenBrace __ "..." __ AssignmentExpression __ CloseBrace

  # https://facebook.github.io/jsx/#prod-JSXAttribute
  JSXAttributeName JSXAttributeInitializer?

# https://facebook.github.io/jsx/#prod-JSXAttributeName
JSXAttributeName
  # NOTE: Merged JSXIdentifier and JSXNamespacedName
  JSXIdentifierName ( Colon JSXIdentifierName )?

# https://facebook.github.io/jsx/#prod-JSXAttributeInitializer
JSXAttributeInitializer
  __ Equals __ JSXAttributeValue

# https://facebook.github.io/jsx/#prod-JSXAttributeValue
JSXAttributeValue
  # https://facebook.github.io/jsx/#prod-JSXDoubleStringCharacters
  /"[^"]*"/
  # https://facebook.github.io/jsx/#prod-JSXSingleStringCharacters
  /'[^']*'/
  OpenBrace __ AssignmentExpression __ CloseBrace
  JSXElement
  JSXFragment

# https://facebook.github.io/jsx/#prod-JSXChildren
JSXChildren
  ( __ JSXChild )*

# https://facebook.github.io/jsx/#prod-JSXChild
JSXChild
  JSXText
  JSXElement
  JSXFragment
  OpenBrace JSXChildExpression? __ CloseBrace

# https://facebook.github.io/jsx/#prod-JSXText
JSXText
  # NOTE: not currently excluding https://facebook.github.io/jsx/#prod-HTMLCharacterReference
  [^{}<>]+

# https://facebook.github.io/jsx/#prod-JSXChildExpression
JSXChildExpression
  __ ( "..." __ )? AssignmentExpression

## Type Stuff

TypeDeclaration
  (TypeDeclarationModifier TrailingComment*)* TypeDeclarationRest -> { ts: true, children: $0 }

TypeDeclarationModifier
  "declare" NonIdContinue
  Export

TypeDeclarationRest
  TypeKeyword TrailingComment* IdentifierName TypeParameters? __ Equals __ Type
  Interface   TrailingComment* IdentifierName InterfaceBlock
  Namespace   TrailingComment* IdentifierName NamespaceBlock

TypeKeyword
  "type" NonIdContinue

Interface
  "interface" NonIdContinue

Namespace
  "namespace" NonIdContinue

InterfaceBlock
  __ OpenBrace EOS NestedInterfaceProperties __ CloseBrace
  __ OpenBrace ( __ InterfaceProperty )* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedInterfaceProperties InsertNewline InsertIndent InsertCloseBrace

NestedInterfaceProperties
  PushIndent NestedInterfaceProperty*:props PopIndent ->
    if (props.length) return props
    return $skip

NestedInterfaceProperty
  Nested InterfaceProperty

InterfaceProperty
  ( TypeIndexSignature / PropertyName ) TypeSuffix InterfacePropertyDelimiter
  MethodSignature TypeSuffix?

InterfacePropertyDelimiter
  _* Semicolon
  &( _* CloseBrace ) # NOTE: Don't insert semi-colon before inline closing brace
  &( __ CloseBrace ) ->
    return { $loc, token: ";" }
  &EOS ->
    return { $loc, token: ";" }

NamespaceBlock
  __ OpenBrace EOS NestedTypeDeclarations __ CloseBrace
  __ OpenBrace ( __ TypeDeclaration InterfacePropertyDelimiter)* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedTypeDeclarations InsertNewline InsertIndent InsertCloseBrace

NestedTypeDeclarations
  PushIndent NestedTypeDeclaration*:decs PopIndent ->
    if (decs.length) return decs
    return $skip

NestedTypeDeclaration
  Nested TypeDeclaration InterfacePropertyDelimiter

TypeIndexSignature
  ( [+-]? "readonly" __ )? OpenBracket TypeIndex CloseBracket ( __ [+-] QuestionMark )?

TypeIndex
  __ Identifier TypeSuffix
  __ PropertyName __ In Type ( __ As Type )?

TypeSuffix
  QuestionMark? __ Colon Type -> { ts: true, children: $0 }

ReturnTypeSuffix
  __ Colon ( __ "asserts" NonIdContinue )? TypePredicate -> { ts: true, children: $0 }

TypePredicate
  Type ( __ "is" NonIdContinue Type )?

Type
  TypeConditional

TypeBinary
  TypeUnary (__ TypeBinaryOp __ TypeUnary)*

TypeUnary
  ( __ TypeUnaryOp NonIdContinue )* TypePrimary TypeUnarySuffix*

TypeUnarySuffix
  TypeIndexedAccess

TypeUnaryOp
  "keyof"
  "typeof"
  "infer"

TypeIndexedAccess
  __ OpenBracket Type? __ CloseBracket

TypePrimary
  InterfaceBlock
  __ OpenParen Type __ CloseParen
  _* FunctionType
  _* IdentifierName (Dot IdentifierName)* TypeArguments?
  _* TypeLiteral

TypeConditional
  TypeBinary ( __ "extends" Type ( __ QuestionMark Type __ Colon Type )? )?

TypeLiteral
  Literal
  "void"
  "[]"

TypeBinaryOp
  "|"
  "&"

FunctionType
  Parameters __ "=>" Type

TypeArguments
  __ "<" __ Type (__ Comma __ Type)* (__ Comma)? __ ">"

TypeParameters
  __ "<" __ Type (__ Comma __ Type)* (__ Comma)? __ ">" ->
    return { ts: true, children: $0 }

TypeParameter
  __ Identifier TypeConstraint? TypeParameterDelimiter

TypeConstraint
  __ "extends" Type

TypeParameterDelimiter
  _* Comma
   # NOTE: Don't insert comma before inline closing angle bracket
  &( _* ">" )
  # NOTE: Do insert comma before closing angle bracket on following line
  &( __ ">" ) ->
    return { $loc, token: "," }
  &EOS ->
    return { $loc, token: "," }

## Utility

Shebang
  /#![^\r\n]*/ EOL

DirectivePrologue
  # NOTE: $ is to keep source verbatim and not insert a semicolon if one was omitted
  # Can't use $EOS because it will prevent re-writing of coffee style comments
  ([\t ]* StringLiteral $StatementDelimiter EOS)*

EOS
  RestOfLine+

# End of line
EOL
  /\r\n|\n|\r|$/

# End of file
EOF
  /$/

Debugger
  "" ->
    debugger

# Insertions

InsertOpenParen
  "" ->
    return { $loc, token: "(" }

InsertCloseParen
  "" ->
    return { $loc, token: ")" }

InsertOpenBrace
  # NOTE: Includes a preceding space
  "" ->
    return [{ $loc, token: " " }, { $loc, token: "{" } ]

InsertCloseBrace
  "" ->
    return { $loc, token: "}" }

InsertConst
  # NOTE: Includes a trailing space
  "" ->
    return { $loc, token: "const " }

InsertReadonly
  # NOTE: Includes a trailing space
  "" ->
    return { ts: true, children: [ { $loc, token: "readonly " } ] }

InsertNewline
  "" ->
    return "\n"

InsertIndent
  "" ->
    return "".padStart(module.currentIndent * 2)

InsertSpace
  "" ->
    return { $loc, token: " " }

InsertDot
  "" ->
    return { $loc, token: "." }

InsertBreak
  "" ->
    return { $loc, token: "break;" }

# Indentation

# Reset module level data
Reset
  "" ->
    // Storage for PushIndent/PopIndent
    module.currentIndent = 0
    module.indentLevels = [0]
    module.verbose = false
    module.coffeeCompat = false
    module.implicitReturns = true

Init
  Shebang? DirectivePrologue:directives "" ->
    if(directives) {
      const compatRe = /use coffee-compat/
      module.coffeeCompat = directives.some(d => d[1].token?.match(compatRe))
    }

    function hasReturnStatement(node) {
      if (!node) return false
      if (Array.isArray(node)) return node.some(hasReturnStatement)
      if (node.type === "ReturnStatement") return true
      // Don't recurse into nested functions
      if (node.type === "FunctionExpression") return false
      if (node.children) return hasReturnStatement(node.children)

      return false
    }

    // [indent, statement, semicolon]
    function insertReturn(node) {
      if (!node) return
      // TODO: unify this with the `exp` switch
      switch (node.type) {
        case "AssignmentExpression":
          node.children.unshift("return ")
          return
        case "BlockStatement":
          insertReturn(node.expressions[node.expressions.length - 1])
          return
        case "CaseBlock":
          node.clauses.forEach((clause) => {
            insertReturn(clause)
          })
          return
        case "CaseClause":
          // Don't adjust case clauses
          return
        case "WhenClause":
          // Remove inserted `break;`
          node.children.pop()
          insertReturn(node.expressions[node.expressions.length - 1])
          return
        case "DefaultClause":
          insertReturn(node.expressions[node.expressions.length - 1])
          return
      }
      if (!Array.isArray(node)) return

      const [, exp] = node

      debugger

      if (!exp) return

      switch (exp.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "EmptyStatement":
        case "IterationStatement":
        case "ThrowStatement":
        case "VariableDeclaration":
          return
        case "IfStatement":
          debugger
          // if block
          insertReturn(exp.children[2])
          // else block
          if (exp.children[3]) insertReturn(exp.children[3][2])
          return
        case "SwitchStatement":
          // insert a return in each case block
          insertReturn(exp.children[2])
          return
        case "TryStatement":
          // try block
          insertReturn(exp.children[1])
          // catch block
          insertReturn(exp.children[2][3])
          // NOTE: do not insert a return in the finally block
          return
      }

      // for/while
      // TODO: don't insert a return unless coffee compat

      // do while
      // TODO: don't insert a return

      // Insert return before expression
      node.splice(1, 0, "return ")
    }

    module.addImplicitReturns = function(block) {
      // don't add implicit returns if the block has any explicit returns
      if (hasReturnStatement(block)) return block

      insertReturn(block)

      return block
    }

    // Return an array of Rule names that correspond to the current call stack
    module.parsePosition = function() {
      let s = Error().stack.split(/\n    at /)
      s.shift()
      s = s.filter((e) => !e.match(/^eval/)).map((e) => e.split(' ')[0])
      s = s.slice(1, s.indexOf('Program') + 1)

      return s
    }

    module.prune = function(node) {
      if(node === null || node === undefined) return
      if(node.length === 0) return

      if (Array.isArray(node)) {
        const a = node
        .map((n) => module.prune(n))
        .filter((n) => !!n)

        if(a.length > 1)  return a
        if(a.length === 1) return a[0]
        return
      }

      if(node.children != null) {
        node.children = module.prune(node.children)
        return node
      }

      return node
    }

    // Trims the first single space from the spacing array if present
    // maintains $loc for source maps
    module.insertTrimmingSpace = function(spacing, c) {
      let target = spacing

      while(Array.isArray(target)) {
        target = target[0]
      }

      if (target.token) {
        target.token = target.token.replace(/^ ?/, c)
      }

      return spacing
    }

    // Adjust a parsed string by escaping newlines
    module.modifyString = function(str) {
      // Replace non-escaped newlines with escaped newlines
      // taking into account the possibility of a preceding escaped backslash
      return str.replace(/(?<!\\)(\\\\)*\n/g, '$1\\n')
    }

    module.dedentBlockSubstitutions = function($0) {
      const [s, strWithSubstitutions, e] = $0

      if (strWithSubstitutions.length === 0) {
        return $0
      }

      let initialSpacing, i=0, l=strWithSubstitutions.length, results=[s]
      // Get initial spacing from the first string token if it is not a substitution
      const {token} = strWithSubstitutions[0]

      if (token) {
        initialSpacing = token.match(/^(\r?\n|\n)\s+/)
      } else {
        initialSpacing = false
      }

      while (i < l) {
        let segment = strWithSubstitutions[i]

        if (segment.token) {
          segment = module.dedentBlockString(segment, initialSpacing, false)
          if (i === 0) {
            // Trim leading newline
            segment.token = segment.token.replace(/^(\r?\n|\n)/, "")
          }
          if (i === l - 1) {
            // Trim trailing newline
            segment.token = segment.token.replace(/(\r?\n|\n)[ \t]*$/, "")
          }
          results.push(segment)
        } else {
          results.push(segment)
        }

        i++
      }

      results.push(e)
      return results
    }

    module.dedentBlockString = function({$loc, token: str}, spacing, trim=true) {
      // If string begins with a newline then indentation assume that it should be removed for all lines
      if (spacing == null) spacing = str.match(/^(\r?\n|\n)[ \t]+/)

      if (spacing) {
        str = str.replaceAll(spacing[0], "\n")
        const l = spacing.length
        $loc.pos += l
        $loc.length -= l
      }

      if (trim) {
        // Remove leading newline
        str = str.replace(/^(\r?\n|\n)/, "")
        // Remove trailing newline
        .replace(/(\r?\n|\n)[ \t]*$/, "")
      }

      // escape backtick, $
      str = str.replace(/(`|\$\{)/g, "\\$1")

      return {
        $loc,
        token: str,
      }
    }

    return $0

# Holds the last indent level in `module.lastIndent`
# Can get weird with backtracking but should work out as long as
# EOS/Nested rules are used carefully and if we only compare to the
# pushed value.
Indent
  ( "  " / "\t" )* ->
    const level = $1.length

    return {
      $loc,
      token: "".padStart(level * 2),
      level
    }

# Tracks current indentation without assuming that it should nest deeper
# Must be matched with PopIndent
TrackIndent
  "" ->
    module.indentLevels.push(module.currentIndent)

Samedent
  EOS? Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (level === currentIndent) {
      return $0
    }
    return $skip

IndentedFurther
  EOS? Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (level > currentIndent) {
      return $0
    }
    return $skip

# Indents one level deeper
# Must be matched with PopIndent
PushIndent
  "" ->
    module.currentIndent++
    if (module.verbose) {
      console.log("pushing indent", module.currentIndent)
    }
    module.indentLevels.push(module.currentIndent)

PopIndent
  "" ->
    if (module.verbose) {
      console.log("popping indent", module.indentLevels[module.indentLevels.length-1], "->", module.indentLevels[module.indentLevels.length-2])
    }
    module.indentLevels.pop()
    module.currentIndent = module.indentLevels[module.indentLevels.length-1]

Nested
  EOS?:eos Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (module.verbose) {
      console.log("global indent", module.currentIndent)
      console.log("Indented", level, currentIndent)
    }
    if (level !== currentIndent) {
      if (module.verbose) {
        console.log("skipped nested")
      }
      return $skip
    }
    return $0
