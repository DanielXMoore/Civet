import { parse } from "./parser.hera"
import generate, { prune } from "./generate.civet"
import * as lib from "./parser/lib.civet"
import * as util from "./util.civet"
{ SourceMap } := util
export { parse, generate, prune, lib, util }

import StateCache from "./state-cache.civet"

// Need to no-cache any rule that directly modifies parser state
// indentation stack, jsx stack, etc.

uncacheable := new Set [
  // Meta
  "DebugHere"
  "Init"
  "Program"
  "Reset"

  // Indentation
  // We need to no-cache the state modifying rules up to the point where they
  // balance within a parent so PushIndent needs to be marked no-cache even
  // though it only calls TrackIndented which does the actual work.
  "PushIndent"
  "PopIndent"
  "TrackIndented"

  // JSX
  "PushJSXOpeningElement"
  "PushJSXOpeningFragment"
  "PopJSXStack"

  // State
  "AllowAll"
  "AllowClassImplicitCall"
  "AllowBracedApplication"
  "AllowIndentedApplication"
  "AllowMultiLineImplicitObjectLiteral"
  "AllowNewlineBinaryOp"
  "AllowTrailingMemberProperty"

  "ForbidClassImplicitCall"
  "ForbidBracedApplication"
  "ForbidIndentedApplication"
  "ForbidMultiLineImplicitObjectLiteral"
  "ForbidNewlineBinaryOp"
  "ForbidTrailingMemberProperty"

  "RestoreAll"
  "RestoreClassImplicitCall"
  "RestoreMultiLineImplicitObjectLiteral"
  "RestoreBracedApplication"
  "RestoreIndentedApplication"
  "RestoreTrailingMemberProperty"
  "RestoreNewlineBinaryOp"

]

export type CompilerOptions
  filename?: string
  sourceMap?: boolean
  inlineMap?: boolean
  ast?: boolean | "raw"
  js?: boolean
  noCache?: boolean
  hits?: string
  trace?: string
  parseOptions?:
    coffeeCompat?: boolean
  updateSourceMap?: (output: string, inputPos?: number) => void
  errors?: unknown[]

export compile := (src: string, options?: CompilerOptions) ->
  if (!options)
    options = {}
  else
    options = {...options}

  // Handle undefined parseOptions, and avoid mutating the original object
  options.parseOptions = {...options.parseOptions}

  filename := options.filename or "unknown"

  if filename.endsWith('.coffee') and not /^(#![^\r\n]*(\r\n|\n|\r))?\s*['"]civet/.test src
    options.parseOptions.coffeeCompat = true

  {hits, trace, noCache} := options

  let events: CacheEvents | undefined
  unless noCache
    events = makeCache {
      hits: !!hits
      trace: !!trace
    }

  let ast

  try
    //@ts-ignore
    parse.config = options.parseOptions or {}
    ast = parse(src, {
      filename
      events
    })
    ast = prune ast unless options.ast is "raw"
  finally
    if hits or trace
      import('fs').then ({ writeFileSync }) ->
        if { logs } := events?.meta
          if trace
            writeFileSync trace, logs.join "\n"

        if hits
          if hitData := events?.meta.hits
            total .= 0
            data := [...hitData.entries()]

            // sort hit count and write to hits.out
            counts := data
            .sort ([, a], [, b]) => b - a
            .map ([k, v]) =>
              total+=v
              `${k}: ${v}`
            .join "\n"

            hitSummary := ```
              Total: ${total}

              ${counts}
            ```

            writeFileSync hits, hitSummary

  if options.ast
    return ast

  if options.sourceMap or options.inlineMap
    sm := SourceMap(src)
    options.updateSourceMap = sm.updateSourceMap
    code := generate ast, options

    if options.inlineMap
      //@ts-ignore
      return SourceMap.remap code, sm, filename, filename + '.tsx'
    else
      return {
        code,
        sourceMap: sm
      }

  result := generate ast, options

  if options.errors?.length
    // TODO: Better error display
    //@ts-ignore
    throw new Error `Parse errors: ${options.errors.map(.message).join("\n")} `

  return result

type CacheKey = [string, number, number, string]

type ParseState =
  input: string
  pos: number

type ParseResult = {
  pos: number
  value: unknown
} | undefined

type MetaData
  hits?: Map<string, number>
  logs?: string[]

type CacheOptions
  hits?: boolean | undefined
  trace?: boolean | undefined

type CacheEvents
  meta: MetaData
  enter: (ruleName: string, state: ParseState) => { cache: ParseResult } | undefined
  exit: (ruleName: string, state: ParseState, result: ParseResult) => void

makeCache := ({hits, trace}: CacheOptions = {}): CacheEvents ->
  meta: MetaData := {}
  let hitCount: Map<string, number>
  if hits
    hitCount = new Map
    meta.hits = hitCount

  let logs: string[]
  if trace
    logs = []
    meta.logs = logs

  stateCache := new StateCache<ParseResult>
  getStateKey: () => [number, string] .= null!

  stack: string[] := []

  events := {
    meta
    enter: (ruleName: string, state: ParseState) ->
      hitCount.set ruleName, (hitCount.get(ruleName) or 0) + 1 if hits

      return if uncacheable.has(ruleName)

      [stateKey, tagKey] := getStateKey()
      key: CacheKey := [tagKey, stateKey, state.pos, ruleName ]

      // We cache `undefined` when a rule fails to match so we need to use `has` here.
      if stateCache.has(key)
        if trace
          logs.push "".padStart(stack.length * 2, " ") + ruleName + ":" + state.pos + "💰"
        result := stateCache.get(key)
        return {
          cache: if result then { ...result }
        }

      if trace
        logs.push "".padStart(stack.length * 2, " ") + ruleName + ":" + state.pos + "\u2192"
        stack.push ruleName

      return

    exit: (ruleName: string, state: ParseState, result: ParseResult) ->
      // special hack to get access to parser state
      if ruleName is "Reset"
        //@ts-ignore
        { getStateKey } = result.value

      if !uncacheable.has(ruleName)
        [stateKey, tagKey] := getStateKey()
        key: CacheKey := [tagKey, stateKey, state.pos, ruleName ]
        stateCache.set(key, result)

      //@ts-ignore
      if parse.config.verbose and result
        console.log `Parsed ${JSON.stringify state.input[state.pos...result.pos]} [pos ${state.pos}-${result.pos}] as ${ruleName}`//, JSON.stringify(result.value)

      if trace
        stack.pop()
        logs.push "".padStart(stack.length * 2, " ") + ruleName + ":" + state.pos + " " + (if result then "✅" else "❌")

      return
  }

  return events

// TODO: Import ParseError class from Hera
export isCompileError = (err: unknown) ->
  err <? Error and
  //@ts-ignore
  [err.message, err.name, err.filename, err.line, err.column, err.offset].every & !== undefined

export default { parse, generate, util, compile, isCompileError }
