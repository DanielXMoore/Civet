/**
 * lib.civet holds functions that are used inside parser.hera
 *
 * The rules inside parser.hera should be simple and short.
 * Most of the helpers/transforms should make their way into
 * here eventually.
 */

type ASTNode = ASTNodeBase | ASTError | ASTRef | ASTLeaf | ASTNode[] | string | undefined
type ASTNodeBase =
  type: string
  children: ASTNode[]
  blockPrefix?: unknown
  names?: string[]
  parent?: ASTNodeBase | undefined

type ASTError =
  type: "Error"
  message: string

type Loc =
  pos: number
  length: number

type ASTLeaf =
  $loc: Loc
  token: string

type Children = ASTNode[]

type StatementDelimiter = ASTNode
type IndentNode = ASTNode

type StatementTuple = [IndentNode, ASTNode, StatementDelimiter?]

type Condition = ParenthesizedExpression

type ParenthesizedExpression
  type: "ParenthesizedExpression"
  children: Children
  parent: ASTNodeBase
  expression: ASTNode
  implicit?: boolean

type IfStatement
  type: "IfStatement"
  children: Children
  condition: Condition
  then: BlockStatement
  else: [ ASTNode, ElseToken, BlockStatement ] | undefined

type IterationStatement
  type: "IterationStatement"
  children: Children
  parent: ASTNodeBase | undefined
  block: BlockStatement

type SwitchStatement
  type: "SwitchStatement"
  children: Children
  parent: ASTNodeBase | undefined
  condition: Condition
  caseBlock: unknown

type ElseToken = { $loc: Loc, token: "else" }

type ASTRef =
  type: "Ref"
  base: string
  id: string

type AtBinding =
  type: "AtBinding"
  ref: ASTRef

type BlockStatement =
  type: "BlockStatement"
  children: ASTNode[]
  expressions: StatementTuple[]
  bare: boolean
  root: boolean
  parent: ASTNodeBase | undefined

type MethodDefinition =
  type: "MethodDefinition"
  children: ASTNode[]
  name: string
  signature: FunctionSignature
  block: BlockStatement
  parameters: ParametersNode
  parent: ASTNodeBase | undefined

type FunctionSignature =
  type: "MethodSignature" | "FunctionSignature"
  children: ASTNode[]
  name: string
  optional: unknown
  modifier: MethodModifier
  returnType: ReturnTypeAnnotation | undefined
  parameters: ParametersNode
  parent: ASTNodeBase | undefined

type ReturnTypeAnnotation =
  t:
    type: string
    t:
      type: string

type MethodModifier =
  get?: boolean
  set?: boolean
  async?: boolean

type ParametersNode =
  type: "Parameters"
  children: ASTNode[]
  names: string[]
  parent: ASTNode | undefined
  tp: TypeParameters | undefined

type TypeParameters = unknown

type FunctionNode = FunctionExpression | ArrowFunction | MethodDefinition

type Predicate = (node: Exclude<ASTNode, undefined>) => boolean

type TabConfig = number | undefined

/**
 * Adds parent pointers to all nodes in the AST. Elements within
 * arrays of nodes receive the closest non-array object parent.
 */
function addParentPointers(node: ASTNode, parent?: ASTNodeBase): void
  if (not node?) return
  if (typeof node !== "object") return

  // NOTE: Arrays are transparent and skipped when traversing via parent
  if Array.isArray(node)
    for child of node
      addParentPointers(child, parent)
    return

  node = node as ASTNodeBase
  node.parent = parent
  if node.children
    for child of node.children
      addParentPointers(child, node)

/**
 * Just update parent pointers for the children of a node,
 * recursing into arrays but not objects.  More efficient version of
 * `addParentPointers` when just injecting one new node.
 */
function updateParentPointers(node: ASTNode, parent?: ASTNodeBase, depth = 1): void
  if (not node?) return
  if (typeof node !== "object") return

  // NOTE: Arrays are transparent and skipped when traversing via parent
  if Array.isArray(node)
    for child of node
      updateParentPointers(child, parent, depth)
    return

  node = node as ASTNodeBase
  if (parent?) node.parent = parent
  if depth and node.children
    for child of node.children
      updateParentPointers(child, node, depth-1)

function makeNode(node: ASTNode): ASTNode
  updateParentPointers node
  node

function addPostfixStatement(statement: StatementTuple, ws: ASTNode, post)
  expressions := [
    ...post.blockPrefix or []
    ["", statement]
  ]

  block := makeNode {
    type: "BlockStatement"
    children: [" { ", expressions, " }"]
    expressions
  }

  children := [...post.children, block]

  // This removes trailing whitespace for easier testing
  if (!isWhitespaceOrEmpty(ws)) children.push(ws)

  post = makeNode { ...post, children, block }
  if post.type === "IfStatement"
    post.then = block
  return post

/**
 * Adjusts `@binding` inside object properties that need to be aliased
 * see test/function.civet binding pattern
 */
function adjustAtBindings(statements: ASTNode, asThis = false): void {
  gatherRecursiveAll(statements, (n) => n.type === "AtBindingProperty")
    .forEach((binding) => {
      const { ref } = binding

      if (asThis) {
        // Convert from @x to x: this.x keeping any whitespace or initializer to the right
        const atBinding = binding.binding
        atBinding.children.pop()
        atBinding.type = undefined

        binding.children.unshift(ref.id, ": this.", ref.base)
        binding.type = "Property"
        binding.ref = undefined
        return
      }

      if (ref.names[0] !== ref.base) {
        binding.children.unshift(ref.base, ": ")
      }
    })
}

function adjustBindingElements(elements: ASTNodeBase[]) {
  const names = elements.flatMap((p) => p.names || []),
    { length } = elements

  let blockPrefix,
    restIndex = -1,
    restCount = 0

  elements.forEach(({ type }, i) => {
    if (type === "BindingRestElement") {
      if (restIndex < 0) restIndex = i
      restCount++
    }
  })

  if (restCount === 0) {
    return {
      children: elements,
      names,
      blockPrefix,
      length,
    }
  } else if (restCount === 1) {
    const rest = elements[restIndex]
    const after = elements.slice(restIndex + 1)

    const restIdentifier = rest.binding.ref || rest.binding
    names.push(...rest.names || [])

    let l = after.length

    if (l) {
      // increment l if trailing comma
      if (arrayElementHasTrailingComma(after[l - 1])) l++

      blockPrefix = {
        type: "PostRestBindingElements",
        children: ["[", insertTrimmingSpace(after, ""), "] = ", restIdentifier, ".splice(-", l.toString(), ")"],
        names: after.flatMap((p) => p.names),
      }
    }

    return {
      names,
      children: [...elements.slice(0, restIndex), {
        ...rest,
        children: rest.children.slice(0, -1) // remove trailing comma
      }],
      blockPrefix,
      length,
    }
  }

  const err = {
    type: "Error",
    children: ["Multiple rest elements in array pattern"],
  }

  return {
    names,
    children: [...elements, err],
    blockPrefix,
    length,
  }
}


/**
 * Adjust the alias of a binding property, adding an alias if one doesn't exist or
 * replacing an existing alias. This mutates the property in place.
 */
function aliasBinding(p, ref: ASTRef): void
  if p.type is "Identifier"
    // Array element binding
    // TODO: This ignores `name` and `names` properties of Identifier and
    // hackily converts it to a container for a Ref.
    p.children[0] = ref
  else if p.type is "BindingRestElement"
    aliasBinding p.binding, ref
  else if p.value?.type is "Identifier"
    // aliased property binding
    aliasBinding p.value, ref
  else
    // non-aliased property binding
    p.value = ref
    index := p.children.indexOf p.name
    p.children.splice index + 1, 0, ": ", ref

function arrayElementHasTrailingComma(elementNode) {
  const lastChild = elementNode.children.at(-1)
  return lastChild && lastChild[lastChild.length - 1]?.token === ","
}

assert := {
  equal(a, b, msg): void
    /* c8 ignore next */
    throw new Error(`Assertion failed [${msg}]: ${a} !== ${b}`) if a !== b
}

/**
 * Duplicate a block and attach statements prefixing the block.
 * Adds braces if the block is bare.
 *
 * @returns the duplicated block with prefix statements attached or the unchanged block.
 */
function blockWithPrefix(prefixStatements: StatementTuple[] | undefined, block: BlockStatement)
  if prefixStatements && prefixStatements.length
    const indent = getIndent(block.expressions[0])
    // Match prefix statements to block indent level
    if indent
      //@ts-ignore
      prefixStatements = prefixStatements.map (statement) =>
        [indent, ...statement.slice(1)]

    const expressions = [...prefixStatements, ...block.expressions]
    // blockPrefix wasn't previously a child, so now needs parent pointers
    addParentPointers prefixStatements, block

    block = {
      ...block,
      expressions,
      children: block.children === block.expressions ? expressions :
        block.children.map((c) => c === block.expressions ? expressions : c),
    }
    // Add braces if block lacked them
    if block.bare
      // Now copied, so mutation is OK
      block.children = [[" {"], ...block.children, "}"]
      block.bare = false

    updateParentPointers block

  return block

function closest(node: ASTNodeBase, types: string[]) {
  do {
    if (types.includes(node.type)) {
      return node
    }
  } while (node = node.parent!)
  return
}

/**
 * Clone an AST node including children (removing parent pointes)
 * This gives refs new identities which may not be what we want.
 *
 * TODO: preserve ref identities
 */
function clone(node: ASTNode) {
  removeParentPointers(node)
  return deepCopy(node)
}

function constructInvocation(fn, arg) {
  const fnArr = [fn.leadingComment, fn.expr, fn.trailingComment]

  // Unwrap ampersand blocks
  let expr = fn.expr
  while (expr.type === "ParenthesizedExpression") {
    expr = expr.expression
  }
  if (expr.ampersandBlock) {
    const { ref, body } = expr

    ref.type = "PipedExpression"
    ref.children = [makeLeftHandSideExpression(arg)]
    updateParentPointers ref

    return makeNode {
      type: "UnwrappedExpression",
      children: [skipIfOnlyWS(fn.leadingComment), body, skipIfOnlyWS(fn.trailingComment)],
    }
  }

  expr = fn.expr
  const lhs = makeLeftHandSideExpression(expr)

  // Attach comments
  let comment = skipIfOnlyWS(fn.trailingComment)
  if (comment) lhs.children.splice(2, 0, comment)
  comment = skipIfOnlyWS(fn.leadingComment)
  if (comment) lhs.children.splice(1, 0, comment)

  switch (arg.type) {
    case "CommaExpression":
      arg = makeLeftHandSideExpression(arg)
      break
  }

  return {
    type: "CallExpression",
    children: [lhs, "(", arg, ")"],
  }
}

function constructPipeStep(fn, arg, returning) {
  const children = [[fn.leadingComment, fn.expr, fn.trailingComment].map(skipIfOnlyWS), " ", arg]

  // Handle special non-function cases
  switch (fn.expr.token) {
    case "yield":
    case "await":
      if (returning) {
        return [
          children,
          returning
        ]
      }

      return [
        children,
        null
      ]

    case "return":
      // Return ignores ||> returning argument
      return [{
        type: "ReturnStatement",
        children,
      }, null]
  }

  if (returning) {
    return [
      constructInvocation(fn, arg),
      returning
    ]

  }

  return [constructInvocation(fn, arg), null]
}

// Given a string of spaces and tabs, and the current tab size
// (where `undefined` means "tabs are the same width as 1 space"),
// compute the indentation level counted as spaces.
// NOTE: Currently, tabs are treated as the specified number of spaces,
// no matter their location (no round-to-next-multiple behavior).
function getIndentLevel(str: string, tab: TabConfig)
  if tab? and tab != 1
    tabs := str.match /\t/g
    numTabs := tabs ? tabs.length : 0
    numTabs * tab + /*spaces*/ (str.length - numTabs)
  else
    str.length

// Given an indentation string (spaces and tabs), reduces the leading
// indentation by the specified amount of spaces. If removing a tab reduced
// the indentation too much, replaces it with the appropriate number of spaces.
function reduceIndentLevel(str: string, dedent: number, tab: TabConfig)
  if tab? and tab != 1
    for each char, i of str
      unless dedent  // finished removing indentation
        return str[i..]
      if char == '\t'
        dedent -= tab  // one tab removed
        if dedent < 0  // removed too much; add some spaces back
          return ''.padStart(-dedent, ' ') + str[i+1..]
      else
        dedent--  // one space removed
    ''  // removed all indentation (and maybe wanted to remove more)
  else
    str[dedent..]

indentRe := ///
  \n        // indent starts after newline (possibly preceded by \r)
  ([ \t]*)  // capture indentation as $1
  (?! [ \t] | \r?\n | $ )  // ignore blank lines
///g

// Gets the indentation level (number of spaces) shared by all indentations
// after the first newline.
function getIndentOfBlockString(str: string, tab: TabConfig)
  minLevel .= Infinity
  while match := indentRe.exec str
    level := getIndentLevel match[1], tab
    minLevel = level if level < minLevel
  minLevel = 0 if minLevel == Infinity
  minLevel

function dedentBlockString({ $loc, token: str }: ASTLeaf, tab: TabConfig, dedent: number | undefined, trimStart = true, trimEnd = true)
  // If string begins with a newline then indentation assume that it should be removed for all lines
  if not dedent? and /^[ \t]*\r?\n/.test str
    // Remove remaining shared indentation
    dedent = getIndentOfBlockString str, tab
  if dedent
    str = str.replace /(\n)([ \t]*)/g, (_, newline, indent) =>
      newline + reduceIndentLevel indent, dedent as number, tab

  // Remove leading newline
  str = str.replace /^[ \t]*\r?\n/, "" if trimStart
  // Remove trailing newline
  str = str.replace /(\r?\n|\n)[ \t]*$/, "" if trimEnd

  // escape unescaped backticks and `${`
  str = str.replace /(\\.|`|\$\{)/g, (s) =>
    if s[0] === "\\"
      s
    else
      `\\${s}`

  { $loc, token: str }

function dedentBlockSubstitutions($0: [ASTLeaf, (ASTLeaf | (ASTNode[] & {token: never}))[], ASTLeaf], tab: TabConfig)
  [s, strWithSubstitutions, e] := $0

  return $0 unless strWithSubstitutions.length

  // Compute shared indentation of all string parts, concatenated
  stringPart :=
    for each part of strWithSubstitutions
      part.token ?? "s"  // put "s" in place of substitutions
  .join ''
  dedent :=
    if /^[ \t]*\r?\n/.test stringPart
      getIndentOfBlockString stringPart, tab
    else
      false

  // Dedent the string parts
  results: ASTNode[] .= [s]
  for each let part, i of strWithSubstitutions
    if part.token?
      part = dedentBlockString part as ASTLeaf, tab, dedent,
        i === 0, i === strWithSubstitutions.length - 1
    results.push part
  results.push e

  type: "TemplateLiteral"
  children: results

function deepCopy(node: ASTNode): ASTNode {
  if (node == null) return node
  if (typeof node !== "object") return node

  if (Array.isArray(node)) {
    return node.map(deepCopy)
  }

  // Use from entries to clone objects
  // map the values to clone the children
  return Object.fromEntries(
    Object.entries(node).map(([key, value]) => {
      return [key, deepCopy(value)]
    })
  ) as any
}

// Negate expression inside condition
function negateCondition(condition)
  { expression } .= condition
  children := condition.children.slice()
  i := children.indexOf(expression)
  if i < 0
    throw new Error `Could not find expression in condition`
  children[i] = expression =
    type: "UnaryExpression"
    children: [
      "!"
      makeLeftHandSideExpression expression
    ]
  { ...condition, expression, children }

function expressionizeIfClause(clause, b, e)
  { condition } := clause  // remove 'if'
  [ ...condRest, closeParen ] := condition.children  // separate ')'
  children := [
    ...condRest
    "?"
    b
  ]
  if e
    // Replace 'else' in e[1] with ':'. (e[0] is space before 'else')
    children.push e[0], ":", ...e[2..]
  else
    children.push ":void 0"
  children.push closeParen

  {
    type: "IfExpression",
    children,
  }

function expressionizeIteration(exp): void
  const { async, subtype, block, children, statement } = exp
  const i = children.indexOf(statement)
  if i < 0
    throw new Error("Could not find iteration statement in iteration expression")

  if subtype === "DoStatement"
    // Just wrap with IIFE
    insertReturn(block)
    children.splice(i, 1, ...wrapIIFE(["", statement, undefined], async))
    updateParentPointers exp
    return

  const resultsRef = makeRef("results")

  // insert `results.push` to gather results array
  insertPush(block, resultsRef)
  braceBlock(block)

  // Wrap with IIFE
  children.splice(i,
    1,
    ...wrapIIFE([
      ["", ["const ", resultsRef, "=[]"], ";"],
      ...children.map((c) => ["", c, undefined]),
      ["", wrapWithReturn(resultsRef)],
    ], async)
  )
  updateParentPointers exp

function processBinaryOpExpression($0)
  expandedOps := expandChainedComparisons($0)

  // Expanded ops is [a, __, op1, __, b, __, op2, __, c, __, op3, __, d], etc.
  // NOTE: all operators of higher precedence than relational have been merged into the operand expressions
  let i = 2
  while (i < expandedOps.length) {
    const op = expandedOps[i]
    // a in b -> indexOf.call(b, a) >= 0
    // a is in b -> indexOf.call(b, a) >= 0
    // a not in b -> indexOf.call(b, a) < 0
    // a is not in b -> indexOf.call(b, a) < 0
    // a not instanceof b -> !(a instanceof b)
    if (op.special) {
      let [a, wsOp, op, wsB, b] = expandedOps.slice(i - 2, i + 3)

      // typeof shorthand: x instanceof "String" -> typeof x === "string"
      if (op.token === "instanceof" && b.type === "Literal" &&
        b.children?.[0]?.type === "StringLiteral") {
        a = ["typeof ", makeLeftHandSideExpression(a)]
        if (op.negated) {
          op = { ...op, token: "!==", negated: false }
        } else {
          op = { ...op, token: "===" }
        }
      }

      if (op.asConst) {
        a = makeAsConst(a)
        b = makeAsConst(b)
      }

      let children
      if (op.call) {
        wsOp = insertTrimmingSpace(wsOp, "")

        if (op.reversed) {
          wsB = insertTrimmingSpace(wsB, "")
          children = [wsOp, op.call, "(", wsB, b, ", ", a, ")", op.suffix]
        } else {
          children = [wsOp, op.call, "(", a, ",", wsB, b, ")", op.suffix]
        }
      } else if (op.method) {
        wsOp = insertTrimmingSpace(wsOp, "")
        wsB = insertTrimmingSpace(wsB, "")
        if (op.reversed) {
          children = [wsB, b, wsOp, ".", op.method, "(", a, ")"]
        } else {
          children = [a, wsOp, ".", op.method, "(", wsB, b, ")"]
        }
      } else if (op.token) {
        children = [a, wsOp, op, wsB, b]
        if (op.negated) children = ["(", ...children, ")"]
      } else {
        throw new Error("Unknown operator: " + JSON.stringify(op))
      }
      if (op.negated) children.unshift("!")

      expandedOps.splice(i - 2, 5, {
        children
      })
    } else {
      i += 4
    }
  }

  return expandedOps

/**
 * This adjusts #x.y().z and @x.y().z when used inside Object glob expressions
 * to remove `this.` where necessary.
 *
 * [See More](../test/object.civet)
 */
function handleThisPrivateShorthands(value)
  if value.privateShorthand
    value = value.children[1].children[1]

    return [value, false]

  if value.type is "MemberExpression" or value.type is "CallExpression"
    suppressPrefix .= value.thisShorthand
    value = {
      ...value,
      children: value.children.map (c, i) =>
        if i is 0
          let s
          [c, s] = handleThisPrivateShorthands c
          suppressPrefix ||= s

        c
    }

    return [value, suppressPrefix]

  return [value, value.thisShorthand]

/**
 * Process globs and bind shorthand in Call/MemberExpression
 */
function processCallMemberExpression(node)
  const { children } = node
  for (let i = 0; i < children.length; i++) {
    const glob = children[i]
    if (glob?.type === "PropertyGlob") {
      let prefix = children.slice(0, i)
      const parts = []
      let hoistDec, refAssignment
      // add ref to ensure object base evaluated only once
      if (prefix.length > 1) {
        const ref = makeRef()
        hoistDec = {
          type: "Declaration",
          children: ["let ", ref],
          names: [],
        }
        refAssignment = [{
          type: "AssignmentExpression",
          children: [ref, " = ", prefix],
        }, ","]
        prefix = [ref]
      }
      prefix = prefix.concat(glob.dot)

      for (const part of glob.object.properties) {
        if part.type is "MethodDefinition"
          throw new Error("Glob pattern cannot have method definition")
        if part.value and !["CallExpression", "MemberExpression", "Identifier"].includes(part.value.type)
          throw new Error(`Glob pattern must have call or member expression value, found ${JSON.stringify(part.value)}`)

        suppressPrefix .= false
        value .= part.value ?? part.name
        wValue := getTrimmingSpace part.value

        [value, suppressPrefix] = handleThisPrivateShorthands value

        if !suppressPrefix // Don't prefix @ shorthand
          value = prefix.concat(insertTrimmingSpace(value, ""))
        if (wValue) value.unshift(wValue)
        if (part.type === "SpreadProperty") {
          parts.push({
            type: part.type,
            value,
            dots: part.dots,
            delim: part.delim,
            names: part.names,
            children: part.children.slice(0, 2) // whitespace, ...
              .concat(value, part.delim)
          })
        } else {
          parts.push({
            type: part.type === "Identifier" ? "Property" : part.type,
            name: part.name,
            value,
            delim: part.delim,
            names: part.names,
            children: [
              isWhitespaceOrEmpty(part.children[0]) && part.children[0],
              part.name,
              isWhitespaceOrEmpty(part.children[2]) && part.children[2],
              part.children[3]?.token === ":" ? part.children[3] : ":",
              value,
              part.delim, // comma delimiter
            ]
          })
        }
      }
      let object = {
        type: "ObjectExpression",
        children: [
          glob.object.children[0], // {
          ...parts,
          glob.object.children.at(-1), // whitespace and }
        ],
        properties: parts,
        hoistDec,
      }
      if (refAssignment) {
        object = {
          type: "ParenthesizedExpression",
          children: ["(", ...refAssignment, object, ")"],
          expression: object,
        }
      }
      if (i === children.length - 1) return object
      return processCallMemberExpression({  // in case there are more
        ...node,
        children: [object, ...children.slice(i + 1)]
      })
    } else if (glob?.type === "PropertyBind") {
      // TODO: add ref to ensure object base evaluated only once
      const prefix = children.slice(0, i)
      return processCallMemberExpression({  // in case there are more
        ...node,
        children: [
          prefix,
          {
            ...glob,
            type: "PropertyAccess",
            children: [...glob.children, ".bind(", prefix, ")"]
          },
          ...children.slice(i + 1)
        ]
      })
    }
  }
  return node

function wrapIterationReturningResults(statement, outerRef): void {
  if (statement.type === "DoStatement") {
    if (outerRef) {
      insertPush(statement.block, outerRef)
    } else {
      insertReturn(statement.block)
    }
    return
  }

  const resultsRef = makeRef("results")

  const declaration = {
    type: "Declaration",
    children: ["const ", resultsRef, "=[];"],
  }

  insertPush(statement.block, resultsRef)

  statement.children.unshift(declaration)
  if (outerRef) {
    statement.children.push(";", outerRef, ".push(", resultsRef, ");")
  } else {
    statement.children.push(";return ", resultsRef, ";")
  }
}

// NOTE: this is almost the same as insertReturn but doesn't remove `breaks` in `when` and
// does construct an else clause pushing undefined in if statements that lack them
// and adds to the beginning and the end of the expression's children.
// Maybe these insertion modifications can be refactored to be more DRY eventually.
function insertPush(node, ref): void {
  if (!node) return
  // TODO: unify this with the `exp` switch
  switch (node.type) {
    case "BlockStatement":
      if (node.expressions.length) {
        const last = node.expressions[node.expressions.length - 1]
        insertPush(last, ref)
      } else {
        node.expressions.push([ref, ".push(void 0);"])
      }
      return
    case "CaseBlock":
      node.clauses.forEach((clause) => {
        insertPush(clause, ref)
      })
      return
    // NOTE: "CaseClause"s don't push
    case "WhenClause":
      insertPush(node.block, ref)
      return
    case "DefaultClause":
      insertPush(node.block, ref)
      return
  }
  if (!Array.isArray(node)) return

  const [, exp] = node
  if (!exp) return
  const indent = getIndent(node)

  switch (exp.type) {
    case "BreakStatement":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "EmptyStatement":
    case "ReturnStatement":
    case "ThrowStatement":
      return
    case "Declaration":
      exp.children.push(["", [";", ref, ".push(",
        patternAsValue(exp.bindings.at(-1).pattern), ")"]])
      return
    case "ForStatement":
    case "IterationStatement":
    case "DoStatement":
      wrapIterationReturningResults(exp, ref)
      return
    case "BlockStatement":
      insertPush(exp.expressions[exp.expressions.length - 1], ref)
      return
    case "IfStatement":
      // if block
      insertPush(exp.then, ref)
      if (exp.then.bare)
        exp.then.children.push(";")
      // else block
      if (exp.else) insertPush(exp.else[2], ref)
      // Add else block pushing undefined if no else block
      else exp.children.push([" else {\n", indent, ref, ".push(undefined)\n", indent, "}"])
      return
    case "PatternMatchingStatement":
      insertPush(exp.children[0][0], ref)
      return
    case "SwitchStatement":
      // insert a results.push in each case block
      insertPush(exp.children[2], ref)
      return
    case "TryStatement":
      // NOTE: CoffeeScript doesn't add a push to an empty catch block but does add if there is any statement in the catch block
      // we always add a push to the catch block
      // NOTE: does not insert a push in the finally block
      exp.blocks.forEach((block) => insertPush(block, ref))
      return
  }

  // Don't push if there's a trailing semicolon
  if (node[node.length - 1]?.type === "SemicolonDelimiter") return

  // Insert push wrapping expression
  node.splice(1, 0, ref, ".push(")
  node.push(")")
}

function wrapWithReturn(expression?: ASTNode): ASTNode
  const children = expression ? ["return ", expression] : ["return"]

  return makeNode {
    type: "ReturnStatement",
    children,
  }

function isExistence(exp) {
  if (exp.type === "ParenthesizedExpression" && exp.implicit) {
    exp = exp.expression
  }
  if (exp.type === "Existence") {
    return exp
  }
}

// all relational operators could be chained in theory, including in and instanceof
relationalOps := ["==", "===", "!=", "!==", "<", "<=", ">", ">=", "in"]

function isRelationalOp(op)
  relationalOps.includes(op.token) or op.relational

/**
* binops is an array of [__, op, __, exp] tuples
* first is an expression
*/
function expandChainedComparisons([first, binops]: [unknown, [unknown, ASTLeaf, unknown, unknown][]])
  // TODO: add refs to ensure middle expressions are evaluated only once

  // short circuit/bitwise ops have lower precedence than comparison ops
  // so we only need to look for chains in the sections between them
  lowerPrecedenceOps := ["??", "&&", "||", "&", "|", "^"]

  // shift/arithmetic ops have higher precedence, they will bind to expressions inside the chains
  // const higherPrecedenceOps = ["<<", ">>", ">>>", "+", "-", "*", "**", "/", "%"]

  results := []

  i .= 0
  l := binops.length

  start .= 0
  // indexes of chainable ops
  chains .= []
  let op

  while i < l
    ([, op] = binops[i])

    // NOTE: Treat Coffee `in` and `not in` ops as relational.
    if isRelationalOp op
      chains.push i
    else if lowerPrecedenceOps.includes op.token
      // end of the chain
      processChains op
      first = undefined

    i++

  processChains op

  return results

  function processChains(op): void
    if first and isRelationalOp op
      first = expandExistence first

    if chains.length > 1
      chains.forEach (index, k) =>
        if (k > 0) {
          // NOTE: Inserting ws tokens to keep even operator spacing in the resulting array
          results.push(" ", "&&", " ")
        }

        binop := binops[index]
        [ , , , exp] .= binop
        exp = binop[3] = expandExistence(exp)

        let endIndex
        if (k < chains.length - 1) {
          endIndex = chains[k + 1]
        } else {
          endIndex = i + 1
        }

        results.push(first, ...binops.slice(start, endIndex).flat())
        first = [exp].concat(binops.slice(index + 1, endIndex))
        start = endIndex
    else
      // Advance start if there was no chain
      results.push first if first
      results.push ...binops[start...i + 1].flat()
      start = i + 1

    chains.length = 0

  function expandExistence(exp)
    // Expand existence operator like x?
    const existence = isExistence(exp)
    if existence
      results.push(existence, " ", "&&", " ")
      return existence.expression

    return exp
  ;

function processParams(f): void {
  const { type, parameters, block } = f
  const isConstructor = f.name === 'constructor'

  // Check for singleton TypeParameters <Foo> before arrow function,
  // which TypeScript (in tsx mode) treats like JSX; replace with <Foo,>
  if (type === "ArrowFunction" && parameters && parameters.tp && parameters.tp.parameters.length === 1) {
    parameters.tp.parameters.push(",")
  }

  if (!block) return
  const { expressions } = block
  if (!expressions) return
  const { blockPrefix } = parameters

  let indent: string
  if (!expressions.length) {
    indent = ""
  } else {
    indent = expressions[0][0]
  }

  const [splices, thisAssignments] = gatherBindingCode(parameters, {
    injectParamProps: isConstructor
  })

  const delimiter = {
    type: "SemicolonDelimiter",
    children: [";"],
  }

  const prefix = splices
    .map (s) => ["let ", s]
    .concat(thisAssignments)
    .map((s) => s.type
      ? {
        // TODO: figure out how to get JS only statement tuples
        ...s,
        children: [indent, ...s.children, delimiter]
      }
      : [indent, s, delimiter]
    )

  if (!prefix.length) return
  // In constructor definition, insert prefix after first super() call
  if (isConstructor) {
    const superCalls = gatherNodes expressions, (exp) =>
      exp.type === "CallExpression" && exp.children[0]?.token === "super"
    if (superCalls.length) {
      const {child} = findAncestor(superCalls[0],
        (ancestor) => ancestor === block)
      const index = findChildIndex(expressions, child)
      if (index < 0) {
        throw new Error("Could not find super call within top-level expressions")
      }
      expressions.splice(index + 1, 0, ...prefix)
      return
    }
  }
  expressions.unshift(...prefix)
}

function removeParentPointers(node): void {
  if (node == null) return
  if (typeof node !== "object") return

  // NOTE: Arrays are transparent and skipped when traversing via parent
  if (Array.isArray(node)) {
    for (const child of node) {
      removeParentPointers(child)
    }
    return
  }

  node.parent = null
  if (node.children) {
    for (const child of node.children) {
      removeParentPointers(child)
    }
  }
}

/**
 * Replace `child` with `replacement` inside the `block`.
 * Assumes a `StatementTuple[]` for `block.expressions`
 */
function replaceBlockExpression(node: BlockStatement, child: ASTNodeBase, replacement: ASTNodeBase): void
  found .= false

  { expressions } := node

  for (let i = 0, l = expressions.length; i < l; i++)
    statement := expressions[i]
    [, s,] := statement

    if s is child
      statement[1] = replacement
      replacement.parent = node
      found = true
      break

  throw new Error("Could not find child to replace") unless found

/**
 * If `child.parent === parent`, then this should find the index `i` such that
 * `parent.children[i]` contains `child`.  This requires looking in
 * `parent.children` while descending into any arrays.
 * Also works if you pass an array (such as `parent.children`) as the `parent`,
 * which is useful for working with e.g. the `expressions` property.
 * Returns -1 if `child` cannot be found.
 */
function findChildIndex(parent, child) {
  const children = Array.isArray(parent) ? parent : parent.children
  const len = children.length
  for (let i = 0; i < len; i++) {
    const c = children[i]
    if (c === child || (Array.isArray(c) && arrayRecurse(c)))
      return i
  }
  function arrayRecurse(array) {
    const len = array.length
    for (let i = 0; i < len; i++) {
      const c = array[i]
      if (c === child || (Array.isArray(c) && arrayRecurse(c)))
        return true
    }
  }
  return -1
}

/**
 * Find nearest strict `ancestor` that satisfies predicate,
 * aborting (and returning `ancestor: undefined`) if stopPredicate returns true.
 * Also returns the `child` that we came from (possibly `node`), in an
 * `{ancestor, child}` object.  If none are found, `ancestor` will be null.
 */
function findAncestor(
  node: ASTNodeBase,
  predicate: (parent: ASTNode, child: ASTNode) => boolean,
  stopPredicate?: (parent: ASTNode, child: ASTNode) => boolean
): { ancestor: ASTNodeBase | undefined, child: ASTNodeBase } {
  let { parent } = node
  while (parent && !stopPredicate?.(parent, node)) {
    if (predicate(parent, node)) {
      return { ancestor: parent, child: node }
    }
    node = parent
    parent = node.parent
  }
  return { ancestor: undefined, child: node }
}

// Gather child nodes that match a predicate
// while recursing into nested expressions
// without recursing into nested blocks/for loops
function gatherNodes(node: ASTNode, predicate: Predicate): ASTNode[] {
  if (node == null) return []

  if (Array.isArray(node)) {
    return node.flatMap((n) => gatherNodes(n, predicate))
  }

  if (predicate(node)) {
    return [node]
  }

  switch (node.type) {
    case "BlockStatement":
      return []
    case "ForStatement":
      // Descend into expressions but not into declarations or the body of the for loop
      const isDec = node.declaration?.type === "Declaration"
      return node.children.flatMap((n) => {
        if (isDec && n === node.declaration) return []
        return gatherNodes(n, predicate)
      })
    default:
      return gatherNodes(node.children, predicate)
  }
}

// Gather nodes that match a predicate recursing into all unmatched children
// i.e. if the predicate matches a node it is not recursed into further
function gatherRecursive(node: ASTNode, predicate: Predicate, skipPredicate?: Predicate): ASTNode[] {
  if (node == null) return []

  if (Array.isArray(node)) {
    return node.flatMap((n) => gatherRecursive(n, predicate, skipPredicate))
  }

  if (skipPredicate?.(node)) return []

  if (predicate(node)) {
    return [node]
  }

  return gatherRecursive(node.children, predicate, skipPredicate)
}

function gatherRecursiveAll(node: ASTNode, predicate: Predicate): Exclude<ASTNode, undefined | ASTNode[]>[] {
  if (node == null) return []

  if (Array.isArray(node)) {
    return node.flatMap((n) => gatherRecursiveAll(n, predicate))
  }

  const nodes = gatherRecursiveAll(node.children, predicate)
  if (predicate(node)) {
    nodes.push(node)
  }

  return nodes
}

/**
 * Gets the indentation node from a statement. Includes newline,
 * excludes comments, strips location info.
 */
function getIndent(statement: StatementTuple) {
  let indent = statement?.[0]
  if (Array.isArray(indent)) {
    indent = indent.flat(Infinity)

    return indent.filter((n) => n && !(n.type === "Comment")).map((n) => {
      if (typeof n === "string") return n
      if (n.token != null) return n.token
      return ""
    })
  }
  return indent
}

/**
 * Does this expression have an `await` in it and thus needs to be `async`?
 */
function hasAwait(exp) {
  return gatherRecursiveWithinFunction(exp, ({ type }) => type === "Await").length > 0
}

function hasYield(exp) {
  return gatherRecursiveWithinFunction(exp, ({ type }) => type === "Yield").length > 0
}

function hoistRefDecs(statements: StatementTuple[]): void {
  gatherRecursiveAll(statements, (s) => s.hoistDec)
    .forEach((node) => {
      let { hoistDec } = node
      node.hoistDec = null

      const { ancestor, child } = findAncestor node, (ancestor) =>
        ancestor.type === "BlockStatement" && (!ancestor.bare || ancestor.root)

      if (ancestor) {
        insertHoistDec(ancestor, child, hoistDec)
      } else {
        throw new Error("Couldn't find block to hoist declaration into.")
      }

      return
    })
}

function insertHoistDec(block, node, dec): void {
  // NOTE: This is more accurately 'statements'
  const { expressions } = block
  const index = expressions.findIndex((exp) => exp === node ||
    (Array.isArray(exp) && exp[1] === node))
  if (index < 0) throw new Error("Couldn't find expression in block for hoistable declaration.")
  if (expressions[index] === node) {
    expressions.splice(index, 0, ["", dec, ";"])
  } else { // [ws, exp, delim] statement
    const indent = expressions[index][0]
    expressions.splice(index, 0, [indent, dec, ";"])
  }
  // hoistDec wasn't previously a child, so now needs parent pointers
  addParentPointers dec, block
}

function patternAsValue(pattern) {
  switch (pattern.type) {
    case "ArrayBindingPattern": {
      const children = [...pattern.children]
      const index = children.indexOf(pattern.elements)
      if (index < 0) throw new Error("failed to find elements in ArrayBindingPattern")
      children[index] = pattern.elements.map((el) => {
        const [ws, e, delim] = el.children
        return { ...el, children: [ws, patternAsValue(e), delim] }
      })
      return { ...pattern, children }
    }
    case "ObjectBindingPattern": {
      const children = [...pattern.children]
      const index = children.indexOf(pattern.properties)
      if (index < 0) throw new Error("failed to find properties in ArrayBindingPattern")
      children[index] = pattern.properties.map(patternAsValue)
      return { ...pattern, children }
    }
    case "Identifier":
    case "BindingProperty": {
      const children = [pattern.name, pattern.delim]
      // Check for leading whitespace
      if (isWhitespaceOrEmpty(pattern.children[0])) {
        children.unshift(pattern.children[0])
      }
      return { ...pattern, children }
    }
    default:
      return pattern
  }
}

// [indent, statement, semicolon]
function insertReturn(node: ASTNode): void
  if (!node) return
  // TODO: unify this with the `exp` switch
  switch node.type
    case "BlockStatement":
      if node.expressions.length
        const last = node.expressions[node.expressions.length - 1]
        insertReturn(last)
      else
        // NOTE: Kind of hacky but I'm too much of a coward to make `->` add an implicit return
        if node.parent.type is "CatchClause"
          node.expressions.push(["return"])
      return
    // NOTE: "CaseClause"s don't get a return statements inserted
    case "WhenClause":
      // Remove inserted `break;`
      node.children.splice(node.children.indexOf(node.break), 1)
      if node.block.expressions.length
        insertReturn(node.block)
      else
        node.block.expressions.push(wrapWithReturn())
      return
    case "DefaultClause":
      insertReturn(node.block)
      return
  if (!Array.isArray(node)) return

  const [, exp, semi] = node
  if (semi?.type is "SemicolonDelimiter") return
  if (!exp) return

  switch (exp.type)
    case "BreakStatement":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "EmptyStatement":
    case "ReturnStatement":
    case "ThrowStatement":
      return
    case "Declaration":
      exp.children.push ["", {
        type: "ReturnStatement",
        children: [";return ", patternAsValue(exp.bindings.at(-1).pattern)],
        parent: exp
      }]
      return
    case "FunctionExpression":
      // Add return after function declaration if it has an id to not interfere with hoisting
      if (exp.id)
        exp.children.push ["",
          type: "ReturnStatement"
          children: [";return ", exp.id]
          parent: exp
        ]
        return
      /* c8 ignore next 3 */
      // This is currently never hit because anonymous FunctionExpressions are already wrapped in parens by this point
      // Add return in normal way for functions without ids
      break
    case "ForStatement":
    case "IterationStatement":
    case "DoStatement":
      wrapIterationReturningResults(exp)
      return
    case "BlockStatement":
      insertReturn(exp.expressions[exp.expressions.length - 1])
      return
    case "IfStatement":
      // if block
      insertReturn(exp.then)
      // else block
      if (exp.else) insertReturn(exp.else[2])
      // Add explicit return after if block if no else block
      else exp.children.push ["", {
        type: "ReturnStatement"
        // NOTE: add a prefixed semi-colon because the if block may not be braced
        children: [";return"]
        parent: exp
      }]
      return
    case "PatternMatchingStatement":
      insertReturn(exp.children[0][0])
      return
    case "SwitchStatement":
      insertSwitchReturns(exp)
      return
    case "TryStatement":
      exp.blocks.forEach((block) => insertReturn(block))
      // NOTE: do not insert a return in the finally block
      return

  // Don't add return if there's a trailing semicolon
  if (node[node.length - 1]?.type === "SemicolonDelimiter") return

  // Insert return after indentation and before expression
  const returnStatement = wrapWithReturn(node[1])
  node.splice(1, 1, returnStatement)

// insert a return in each when/else/default block
// case blocks don't get implicit returns
// maybe default blocks shouldn't either?
function insertSwitchReturns(exp): void
  exp.caseBlock.clauses.forEach (clause) =>
    insertReturn clause

function isEmptyBareBlock(node) {
  if (node?.type !== "BlockStatement") return false
  const { bare, expressions } = node
  return bare &&
    (expressions.length === 0 ||
      (expressions.length === 1 &&
        expressions[0][1]?.type === "EmptyStatement"))
}

function isFunction(node) {
  const { type } = node
  return type === "FunctionExpression" || type === "ArrowFunction" ||
    type === "MethodDefinition" || node.async
  // do blocks can be marked async to prevent automatic await
}

/**
 * Returns true if the StringLiteral node is a template literal.
 */
function isTemplateLiteral(node) {
  let s = node
  while (s && s[0] && !s.token) s = s[0]
  return s.token?.startsWith?.('`')
}

function isVoidType(t?: ReturnTypeAnnotation) {
  return t?.type === "LiteralType" && t.t.type === "VoidType"
}

function isPromiseVoidType(t) {
  return t?.type === "IdentifierType" && t.raw === "Promise" &&
    t.args?.types?.length === 1 && isVoidType(t.args.types[0])
}

function isWhitespaceOrEmpty(node) {
  if (!node) return true
  if (node.type === "Ref") return false
  if (node.token) return node.token.match(/^\s*$/)
  if (node.children) node = node.children
  if (!node.length) return true
  if (typeof node === "string") return node.match(/^\s*$/)
  if (Array.isArray(node)) return node.every(isWhitespaceOrEmpty)
}

function gatherRecursiveWithinFunction(node, predicate) {
  return gatherRecursive(node, predicate, isFunction)
}

/**
 * Trims the first single space from the spacing array or node's children if present
 * Inserts string `c` in the first position.
 * maintains $loc for source maps
 */
function insertTrimmingSpace(target: ASTNode, c: string): ASTNode
  return target unless target

  if Array.isArray target
    return c if target.length is 0

    return target.map (e, i) =>
      return insertTrimmingSpace(e, c) if i is 0
      return e

  if target.children
    return {
      ...target
      children: insertTrimmingSpace(target.children, c)
    }

  if target.token
    return {
      ...target
      token: target.token.replace(/^ ?/, c)
    }

  return target

// Returns leading space as a string, or undefined if none
function getTrimmingSpace(target: ASTNodeBase) {
  if (!target) return
  if (Array.isArray(target)) return getTrimmingSpace(target[0])
  if (target.children) return getTrimmingSpace(target.children[0])
  if (target.token) return target.token.match(/^ ?/)[0]
}

function startsWith(target: ASTNodeBase, value: RegExp)
  if (!target) return
  if Array.isArray target
    let i = 0
    let l = target.length
    while i < l
      const t = target[i]
      break if t && (t.length || t.token || t.children)
      i++
    if i < l
      return startsWith target[i], value
  if (target.children) return startsWith target.children, value
  if (target.token) return value.test target.token
  if (typeof target === "string") return value.test target

function processForInOf($0: [
  awaits: ASTNode,
  eachOwn: undefined | [ASTLeaf, ASTNode],
  open: ASTNode,
  declaration: ASTNode,
  declaration2: [ws1: ASTNode, comma: ASTLeaf, ws2: ASTNode, decl2: ASTNode],
  ws: ASTNode,
  inOf: ASTLeaf,
  exp: ASTNodeBase,
  step: ASTNode,
  close: ASTNode
], getRef) {
  let [awaits, eachOwn, open, declaration, declaration2, ws, inOf, exp, step, close] = $0

  if (exp.type === "RangeExpression" && inOf.token === "of" && !declaration2) {
    // TODO: add support for `declaration2` to efficient `forRange`
    return forRange(open, declaration, exp, step, close)
  } else if (step) {
    throw new Error("for..of/in cannot use 'by' except with range literals")
  }

  let eachOwnError: ASTError | undefined
  let hoistDec, blockPrefix: ASTNode[] = []

  // for each item[, index] of array
  if (eachOwn && eachOwn[0].token === "each") {
    if (inOf.token === "of") {
      const counterRef = makeRef("i")
      const lenRef = makeRef("len")
      const expRef = maybeRef(exp)

      const increment = "++"
      let assignmentNames = [...declaration.names]

      if (declaration2) {
        const [, , ws2, decl2] = declaration2  // strip __ Comma __
        blockPrefix.push(["", [
          insertTrimmingSpace(ws2, ""), decl2, " = ", counterRef
        ], ";"])
        assignmentNames.push(...decl2.names)
      }

      const expRefDec = (expRef !== exp)
        // Trim a single leading space if present
        ? [insertTrimmingSpace(expRef, " "), " = ", insertTrimmingSpace(exp, ""), ", "]
        : []

      blockPrefix.push(["", {
        type: "AssignmentExpression",
        children: [declaration, " = ", insertTrimmingSpace(expRef, ""), "[", counterRef, "]"],
        names: assignmentNames,
      }, ";"])

      declaration = {
        type: "Declaration",
        children: ["let ", ...expRefDec, counterRef, " = 0, ", lenRef, " = ", insertTrimmingSpace(expRef, ""), ".length"],
        names: []
      }

      const condition = [counterRef, " < ", lenRef, "; "]
      const children = [open, declaration, "; ", condition, counterRef, increment, close]
      return { declaration, children, blockPrefix }
    } else {
      eachOwnError = {
        type: "Error",
        message: "'each' is only meaningful in for..of loops",
      }
    }
  }

  // for own..in
  let own = eachOwn && eachOwn[0].token === "own";
  let expRef: ASTNode | undefined
  if (own && inOf.token !== "in") {
    own = false
    eachOwnError = {
      type: "Error",
      message: "'own' is only meaningful in for..in loops",
    }
  }

  if (!declaration2 && !own) {
    return {
      declaration,
      blockPrefix,
      children: [awaits, eachOwnError, open, declaration, ws, inOf, expRef ?? exp, step, close], // omit declaration2, replace eachOwn with eachOwnError, replace exp with expRef
    }
  }

  let ws2: ASTNode | undefined, decl2: ASTNode | undefined
  if (declaration2) [, , ws2, decl2] = declaration2  // strip __ Comma __

  switch (inOf.token) {
    case "of": { // for item, index of iter
      const counterRef = makeRef("i")
      hoistDec = {
        type: "Declaration",
        children: ["let ", counterRef, " = 0"],
        names: [],
      }
      blockPrefix.push(["", {
        type: "Declaration",
        children: [insertTrimmingSpace(ws2, ""), decl2, " = ", counterRef, "++"],
        names: decl2.names,
      }, ";"])
      break
    }

    case "in": { // for key, value of object
      // First, wrap object in ref if complex expression
      const expRef = maybeRef(exp)
      if (expRef !== exp) {
        hoistDec = {
          type: "Declaration",
          children: ["let ", expRef],
          names: [],
        }
        exp = {
          type: "AssignmentExpression",
          children: [" ", expRef, " =", exp],
        }
      }
      // Replace key with single identifier if it's a pattern,
      // so that we can use it to dereference value.
      let { binding } = declaration
      if (binding?.type !== "Identifier") {
        const keyRef = makeRef("key")
        blockPrefix.push(["", [
          declaration, " = ", keyRef
        ], ";"])
        declaration = {
          type: "ForDeclaration",
          binding: binding = keyRef,
          children: ["const ", keyRef],
          names: [],
        }
      }
      // for own..in
      if (own) {
        const hasPropRef = getRef("hasProp")
        blockPrefix.push(["", ["if (!", hasPropRef, "(", insertTrimmingSpace(expRef, ""), ", ", insertTrimmingSpace(binding, ""), ")) continue"], ";"])
      }
      if (decl2) {
        blockPrefix.push(["", {
          type: "Declaration",
          children: [insertTrimmingSpace(ws2, ""), decl2, " = ", insertTrimmingSpace(expRef, ""), "[", insertTrimmingSpace(binding, ""), "]"],
          names: decl2.names,
        }, ";"])
      }
      break
    }

    default:
      throw new Error(`for item, index must use 'of' or 'in' instead of '${inOf.token}'`)
  }

  return {
    declaration,
    children: [awaits, eachOwnError, open, declaration, ws, inOf, exp, step, close], // omit declaration2, replace each with eachOwnError
    blockPrefix,
    hoistDec,
  }
}

// Construct for loop from RangeLiteral
function forRange(open, forDeclaration, range, stepExp, close) {
  const { start, end, inclusive } = range

  const counterRef = makeRef("i")

  let stepRef
  if (stepExp) {
    stepExp = insertTrimmingSpace(stepExp, "")
    stepRef = maybeRef(stepExp, "step")
  }

  const startRef = maybeRef(start, "start")
  const endRef = maybeRef(end, "end")

  const startRefDec = (startRef !== start) ? [startRef, " = ", start, ", "] : []
  const endRefDec = (endRef !== end) ? [endRef, " = ", end, ", "] : []

  let ascDec = [], ascRef, asc
  if (stepRef) {
    if (stepRef !== stepExp) {
      ascDec = [", ", stepRef, " = ", stepExp]
    }
  } else if (start.type === "Literal" && end.type === "Literal") {
    asc = literalValue(start) <= literalValue(end)
  } else {
    ascRef = makeRef("asc")
    ascDec = [", ", ascRef, " = ", startRef, " <= ", endRef]
  }

  let varAssign = [], varLetAssign = varAssign, varLet = varAssign, blockPrefix
  if (forDeclaration?.declare) { // var/let/const declaration of variable
    if (forDeclaration.declare.token === "let") {
      const varName = forDeclaration.children.splice(1)  // strip let
      varAssign = [...insertTrimmingSpace(varName, ""), " = "]
      varLet = [",", ...varName, " = ", counterRef]
    } else { // const or var: put inside loop
      // TODO: missing indentation
      blockPrefix = [
        ["", forDeclaration, " = ", counterRef, ";"]
      ]
    }
  } else if (forDeclaration) { // Coffee-style for loop
    varAssign = varLetAssign = [forDeclaration, " = "]
  }

  const declaration = {
    type: "Declaration",
    children: ["let ", ...startRefDec, ...endRefDec, counterRef, " = ", ...varLetAssign, startRef, ...varLet, ...ascDec],
    names: forDeclaration?.names,
  }

  const counterPart = inclusive
    ? [counterRef, " <= ", endRef, " : ", counterRef, " >= ", endRef]
    : [counterRef, " < ", endRef, " : ", counterRef, " > ", endRef]

  const condition = stepRef
    ? [stepRef, " !== 0 && (", stepRef, " > 0 ? ", ...counterPart, ")"]
    : ascRef
      ? [ascRef, " ? ", ...counterPart]
      : asc ? counterPart.slice(0, 3) : counterPart.slice(4)

  const increment = stepRef
    ? [...varAssign, counterRef, " += ", stepRef]
    : ascRef
      ? [...varAssign, ascRef, " ? ++", counterRef, " : --", counterRef]
      : [...varAssign, asc ? "++" : "--", counterRef]

  return {
    declaration,
    children: [open, declaration, "; ", ...condition, "; ", ...increment, close],
    blockPrefix,
  }
}

type ThisAssignments = [string, ASTRef][]

function gatherBindingCode(statements: ASTNode, opts?: { injectParamProps?: boolean }) {
  const thisAssignments: ThisAssignments = []
  const splices: unknown[] = []

  function insertRestSplices(s, p: unknown[], thisAssignments: ThisAssignments) {
    gatherRecursiveAll(s, (n) => n.blockPrefix || (opts?.injectParamProps && n.accessModifier) || n.type === "AtBinding")
      .forEach((n) => {
        // Insert `this` assignments
        if (n.type === "AtBinding") {
          const { ref } = n, { id } = ref
          thisAssignments.push([`this.${id} = `, ref])
          return
        }

        if (opts?.injectParamProps && n.type === "Parameter" && n.accessModifier) {
          n.names.forEach((id) => {
            thisAssignments.push({
              type: "AssignmentExpression",
              children: [`this.${id} = `, id],
              js: true
            })
          })
          return
        }

        const { blockPrefix } = n
        p.push(blockPrefix)

        // Search for any further nested splices, and at bindings
        insertRestSplices(blockPrefix, p, thisAssignments)
      })
  }

  insertRestSplices(statements, splices, thisAssignments)

  return [splices, thisAssignments] as const
}

// Convert (non-Template) Literal to actual JavaScript value
function literalValue(literal) {
  let { raw } = literal
  switch (raw) {
    case "null": return null
    case "true": return true
    case "false": return false
  }
  if (
    (raw.startsWith('"') && raw.endsWith('"')) ||
    (raw.startsWith("'") && raw.endsWith("'"))
  ) {
    return raw.slice(1, -1)
  }
  const numeric = literal.children.find(
    (child) => child.type === "NumericLiteral"
  )
  if (numeric) {
    raw = raw.replace(/_/g, "")
    const { token } = numeric
    if (token.endsWith("n")) {
      return BigInt(raw.slice(0, -1))
    } else if (token.match(/[\.eE]/)) {
      return parseFloat(raw)
    } else if (token.startsWith("0")) {
      switch (token.charAt(1).toLowerCase()) {
        case "x": return parseInt(raw.replace(/0[xX]/, ""), 16)
        case "b": return parseInt(raw.replace(/0[bB]/, ""), 2)
        case "o": return parseInt(raw.replace(/0[oO]/, ""), 8)
      }
    }
    return parseInt(raw, 10)
  }
  throw new Error("Unrecognized literal " + JSON.stringify(literal))
}

const asConst = {
  ts: true,
  children: [" as const"]
}

function makeAsConst(node) {
  // TS allows "as const" assertions for string, number, boolean, array,
  // and object literals (and enum members), but not for null/undefined.
  if ((node.type === "Literal" && node.raw !== "null") ||
    node.type === "ArrayExpression" ||
    node.type === "ObjectExpression") {
    return { ...node, children: [...node.children, asConst] }
  }
  return node
}

function makeEmptyBlock(): BlockStatement {
  const expressions = []
  return {
    type: "BlockStatement",
    expressions,
    children: ["{", expressions, "}"],
    bare: false,
    empty: true,
  }
}

function braceBlock(block: BlockStatement)
  if block.bare
    block.children.unshift(" {")
    block.children.push("}")
    block.bare = false

/**
 * Convert general ExtendedExpression into LeftHandSideExpression.
 * More generally wrap in parentheses if necessary.
 * (Consider renaming and making parentheses depend on context.)
 */
function makeLeftHandSideExpression(expression)
  switch (expression.type)
    case "Ref":
    case "AmpersandRef":
    case "Identifier":
    case "Literal":
    case "IterationExpression": // already a CallExpression
    case "CallExpression":
    case "MemberExpression":
    case "ParenthesizedExpression":
    case "IfExpression": // already wrapped in parens
    case "DebuggerExpression": // wrapIIFE
    case "SwitchExpression": // wrapIIFE
    case "ThrowExpression": // wrapIIFE
    case "TryExpression": // wrapIIFE
      return expression

  makeNode {
    type: "ParenthesizedExpression"
    children: ["(", expression, ")"]
    expression
    implicit: true
  }

// Wrap expression in parentheses to make into a statement when:
// * object literal expression
// * anonymous function expression
// * comma operators applied to above
function makeExpressionStatement(expression: ASTNode): ASTNode
  if Array.isArray(expression) and expression[1]?[0]?[0]?[1]?.token is "," // CommaExpression
    [
      makeExpressionStatement expression[0]
      expression[1].map ([comma, exp]) => // CommaDelimiter AssignmentExpression
        [comma, makeExpressionStatement exp]
    ]
  else if expression?.type === "ObjectExpression" or
          (expression?.type === "FunctionExpression" and not expression.id)
    makeLeftHandSideExpression expression
  else
    expression

// Adjust a parsed string by escaping newlines
function modifyString(str) {
  // Replace non-escaped newlines with escaped newlines
  // taking into account the possibility of a preceding escaped backslash
  return str.replace(/(^.?|[^\\]{2})(\\\\)*\n/g, '$1$2\\n')
}

// Add quotes around a string to make it a valid JavaScript string,
// escaping any \s
function quoteString(str) {
  str = str.replace(/\\/g, '\\\\')
  if (str.includes('"') && !str.includes("'")) {
    return "'" + str.replace(/'/g, "\\'") + "'"
  } else {
    return '"' + str.replace(/"/g, '\\"') + '"'
  }
}

// Look for last property access like `.foo` or `[computed]` or root Identifier,
// before any calls like `(args)`, non-null assertions `!`, and optionals `?`.
// The return value should have a `name` property (for "Identifier" and
// "Index"), or have `type` of "Index" (for `[computed]`), or be undefined.
function lastAccessInCallExpression(exp) {
  let children, i
  do {
    ({ children } = exp)
    i = children.length - 1
    while (i >= 0 && (
      children[i].type === "Call" ||
      children[i].type === "NonNullAssertion" ||
      children[i].type === "Optional"
    )) i--
    if (i < 0) return
    // Recurse into nested MemberExpression, e.g. from `x.y()`
  } while (children[i].type === "MemberExpression" && (exp = children[i]))
  return children[i]
}

// Given a MethodDefinition, convert into a FunctionExpression.
// Returns undefined if the method is a getter or setter.
function convertMethodToFunction(method) {
  const { signature, block } = method
  let { modifier, optional } = signature
  if (optional) return
  if (modifier) {
    if (modifier.get || modifier.set) {
      return
    } else if (modifier.async) {
      // put function after async
      modifier = [modifier.children[0][0], " function ", ...modifier.children.slice(1)]
    } else {
      modifier = ["function ", ...(modifier.children || [])]
    }
  } else {
    modifier = "function ";
  }
  return {
    ...signature,
    id: signature.name,
    signature,
    type: "FunctionExpression",
    children: [
      [modifier, ...signature.children.slice(1)],
      block,
    ],
    block,
  }
}

// Convert an ObjectExpression (with `properties`)
// into a set of JSX attributes.
// {foo} is equivalent to foo={foo}, and
// {foo, bar: baz} is equivalent to foo={foo} and bar={baz}.
// {...foo} is a special case.
function convertObjectToJSXAttributes(obj) {
  const { properties } = obj
  const parts = [] // JSX attributes
  const rest = []  // parts that need to be in {...rest} form
  for (let i = 0; i < properties.length; i++) {
    if (i > 0) parts.push(' ')
    const part = properties[i]
    switch (part.type) {
      case 'Identifier':
        parts.push([part.name, '={', part.name, '}'])
        break
      case 'Property':
        if (part.name.type === 'ComputedPropertyName') {
          rest.push(part)
        } else {
          parts.push([part.name, '={', insertTrimmingSpace(part.value, ''), '}'])
        }
        break
      case 'SpreadProperty':
        parts.push(['{', part.dots, part.value, '}'])
        break
      case 'MethodDefinition':
        const func = convertMethodToFunction(part)
        if (func) {
          parts.push([part.name, '={', convertMethodToFunction(part), '}'])
        } else {
          rest.push(part)
        }
        break
      default:
        throw new Error(`invalid object literal type in JSX attribute: ${part.type}`)
    }
  }
  if (rest.length) {
    parts.push(['{...{', ...rest, '}}'])
  }
  return parts
}

function duplicateBlock(block: BlockStatement): BlockStatement
  expressions := [...block.expressions]
  children := [...block.children]
  children.splice(children.indexOf(block.expressions), 1, expressions)
  return {
    ...block,
    expressions,
    children,
  }

/**
 * Returns a new MethodDefinition node.
 */
function makeGetterMethod(name, ws, value, block?: BlockStatement, kind: { token: "get" | "set" } = { token: "get" }, autoReturn: boolean = true): MethodDefinition
  { token } := kind
  ws = insertTrimmingSpace(ws, "")
  let setVal
  parameters := token is "get" ?
    type: "Parameters"
    children: ["()"]
    names: []
    implicit: true
  :
    type: "Parameters"
    children: ["(", setVal = makeRef("value"), ")"]
    names: []
    implicit: false

  let expressions: StatementTuple[]
  if block
    // Duplicate block to avoid mutating original
    block = duplicateBlock(block)
    expressions = block.expressions
  else
    expressions = []
    block = {
      type: "BlockStatement"
      expressions
      children: ["{ ", expressions, " }"]
    }

  if autoReturn
    finalStatement: StatementTuple := token is "get" ?
      [ [expressions[0]?.[0] || "", ws], wrapWithReturn(value) ]
    :
      [ [expressions[0]?.[0] || "", ws], [ value, " = ", setVal ] ]

    expressions.push finalStatement

  children := [kind, " ", name, parameters, block]

  return {
    type: "MethodDefinition",
    children,
    name,
    signature: {
      type: "MethodSignature"
      modifier: {
        get: token is "get"
        set: token is "set"
        async: false
      },
      name,
      returnType: undefined,
    },
    block,
    parameters,
  }

/**
 * Returns a new ref if the expression needs a ref (not a simple value).
 * Otherwise returns undefined.
 */
function needsRef(expression, base = "ref") {
  switch (expression.type) {
    case "Ref":
    case "Identifier":
    case "Literal":
      return
  }
  return makeRef(base)
}

function makeRef(base = "ref", id = base): ASTRef {
  return {
    type: "Ref",
    base,
    id,
  }
}

// Transform into a ref if needed
function maybeRef(exp: ASTNode, base: string = "ref"): ASTNode {
  if (!needsRef(exp)) return exp
  return makeRef(base)
}

// Return an array of Rule names that correspond to the current call stack
function parsePosition() {
  let s = Error().stack.split(/\n    at /)
  s.shift()
  s = s.filter((e) => !e.match(/^eval/)).map((e) => e.split(' ')[0])
  s = s.slice(1, s.indexOf('Program') + 1)

  return s
}

function processCoffeeInterpolation(s, parts, e, $loc) {
  // Check for no interpolations
  if (parts.length === 0 || (parts.length === 1 && parts[0].token != null)) {
    return {
      type: "StringLiteral",
      token: parts.length ? `"${modifyString(parts[0].token)}"` : '""',
      $loc,
    }
  }

  parts.forEach((part) => {
    // Is a string
    if (part.token) {
      // Escape '${' and '`'
      const str = part.token.replace(/(`|\$\{)/g, "\\$1")
      // Escape non-continuation newlines
      part.token = modifyString(str)
    }
  })

  // Convert to backtick enclosed string
  s.token = e.token = "`"

  return {
    type: "TemplateLiteral",
    children: [s, parts, e],
  }
}

function processAssignmentDeclaration(decl, id, suffix, ws, assign, e)
  // Adjust position to space before assignment to make TypeScript remapping happier
  decl = {
    ...decl,
    $loc: {
      pos: assign.$loc.pos - 1,
      length: assign.$loc.length + 1,
    }
  }

  [splices, thisAssignments] .= gatherBindingCode(id)

  splices = splices.map((s) => [", ", s])
  thisAssignments = thisAssignments.map((a) => ["", a, ";"])

  const initializer = [ws, assign, e]
  const binding = makeNode {
    type: "Binding",
    pattern: id,
    initializer,
    splices,
    suffix,
    thisAssignments,
    children: [id, suffix, initializer]
  }

  const children = [decl, binding]

  makeNode {
    type: "Declaration",
    names: id.names,
    decl,
    bindings: [binding],
    splices,
    thisAssignments,
    children,
  }

function processDeclarationCondition(condition, rootCondition, parent): void
  return unless condition.type is "DeclarationCondition"
  ref := makeRef()

  { decl, bindings } := condition.declaration
  // TODO: Add support for `let` and `const` declarations with multiple bindings in conditions
  binding := bindings[0]
  { pattern, suffix, initializer, splices, thisAssignments } := binding

  Object.assign condition,
    type: "AssignmentExpression"
    children: [ref, initializer]
    hoistDec:
      type: "Declaration"
      children: ["let ", ref, suffix]
      names: []
    pattern: pattern
    ref: ref
  // condition wasn't previously a child, so now needs parent pointers
  addParentPointers condition, parent

  Object.assign rootCondition,
    blockPrefix: [
      ["", [ decl, pattern, suffix, " = ", ref, ...splices ], ";"],
      ...thisAssignments
    ]

function processDeclarationConditions(node: ASTNode): void
  gatherRecursiveAll node, (n) =>
    n.type is "IfStatement" or n.type is "IterationStatement" or n.type is "SwitchStatement"
  .forEach processDeclarationConditionStatement

/**
 * Processes adding additional conditions when declarations are used as a condition in IfStatements, WhileStatements, and SwitchStatements.
 * Also does additional processing for IfStatements that used to be in the parser (inserting semi-colon on bare-block consequent with else).
 */
function processDeclarationConditionStatement(s: IfStatement | IterationStatement | SwitchStatement): void
  { condition } := s
  return unless condition?.expression
  { expression } .= condition
  // Support for negated conditions built by unless/until
  switch expression
    {type: 'UnaryExpression', children: ['!', {type: 'ParenthesizedExpression', expression: expression2}]}
      expression = expression2
  processDeclarationCondition expression, condition.expression, s

  { ref, pattern } := expression

  if pattern
    conditions .= []
    getPatternConditions(pattern, ref, conditions)

    conditions = conditions.filter (c) =>
      !(c.length is 3 and c[0] is "typeof " and c[1] is ref and c[2] is " === 'object'") and
      !(c.length is 2 and c[0] is ref and c[1] is " != null")

    if conditions.length
      condition.children.unshift "("
      conditions.forEach (c) ->
        condition.children.push " && ", c
      condition.children.push ")"

  switch s.type
    when "IfStatement"
      { else: e} := s
      block := blockWithPrefix(condition.expression.blockPrefix, s.then)
      s.then = block

      toAdd := [block]

      if block.bare and e
        toAdd.push ";"

      s.children.splice(2, 1, ...toAdd)

      // Update parent pointers since declaration conditions have expanded
      updateParentPointers(block, s)

    when "IterationStatement"
      { children, block } := s
      newBlock := blockWithPrefix(condition.expression.blockPrefix, block)
      s.children = children.map (c) -> c.type is "BlockStatement" ? newBlock : c

      // Update parent pointers since declaration conditions have expanded
      updateParentPointers(newBlock, s)

    when "SwitchStatement"
      { blockPrefix, ref } := condition.expression
      return unless blockPrefix

      s.condition =
        type: "ParenthesizedExpression"
        children: ["(", ref, ")"]
        expression: ref
        parent: s
      s.children[1] = s.condition
      updateParentPointers s

      // wraps the entire switch statement
      block := blockWithPrefix [["", [{
        type: "Declaration",
        children: ["let ", ...condition.expression.children],
      }], ";"], ...blockPrefix], makeEmptyBlock()
      updateParentPointers block, s.parent

      replaceBlockExpression(s.parent as BlockStatement, s, block)
      block.expressions.push ["", s]
      s.parent = block

// Add implicit block unless followed by a method/function of the same name,
// or block is within an ExportDeclaration.
function implicitFunctionBlock(f): void {
  if (f.abstract || f.block || f.signature?.optional) return

  const { name, parent } = f
  if (parent?.type === "ExportDeclaration") return
  const expressions = parent?.expressions ?? parent?.elements
  const currentIndex = expressions?.findIndex(([, def]) => def === f)
  const following = currentIndex >= 0 && expressions[currentIndex + 1]?.[1]

  if (f.type === following?.type && name && name === following.name) {
    f.ts = true
  } else {
    const block = makeEmptyBlock()
    block.parent = f
    f.block = block
    f.children.push(block)
    f.ts = false
  }
}

function processReturn(f: FunctionNode, implicitReturns: boolean): void
  if (!processReturnValue(f) and implicitReturns)
    { signature, block } := f
    { modifier, name, returnType } := signature
    { async, set } := modifier
    isMethod := f.type is "MethodDefinition"
    isConstructor := isMethod and name is "constructor"
    isVoid := isVoidType(returnType?.t) or
      (async && isPromiseVoidType(returnType?.t))
    isBlock := block?.type === "BlockStatement"
    if !isVoid and !set and !isConstructor and isBlock
      insertReturn(block)

function processFunctions(statements, config): void
  gatherRecursiveAll(statements, ({ type }) => type === "FunctionExpression" || type === "ArrowFunction")
  .forEach (f) =>
    if (f.type === "FunctionExpression") implicitFunctionBlock(f)
    processParams(f)
    processReturn(f, config.implicitReturns)

  gatherRecursiveAll(statements, ({ type }) => type === "MethodDefinition")
  .forEach (f) =>
    implicitFunctionBlock(f)
    processParams(f)
    processReturn(f, config.implicitReturns)


function processBindingPatternLHS(lhs, tail): void {
  // Expand AtBindings first before gathering splices
  adjustAtBindings(lhs, true)
  const [splices, thisAssignments] = gatherBindingCode(lhs)
  // TODO: This isn't quite right for compound assignments, may need to wrap with parens and use comma to return the complete value
  tail.push(...splices.map((s) => [", ", s]), ...thisAssignments.map((a) => [", ", a]))
}

function processAssignments(statements): void {
  // Move assignments/updates within LHS of assignments/updates
  // to run earlier via comma operator
  gatherRecursiveAll(statements, (n) => n.type === "AssignmentExpression" || n.type === "UpdateExpression")
    .forEach((exp) => {
      function extractAssignment(lhs) {
        let expr = lhs
        while expr.type === "ParenthesizedExpression"
          expr = expr.expression
        if (expr.type === "AssignmentExpression" ||
          expr.type === "UpdateExpression") {
          if (expr.type === "UpdateExpression" &&
            expr.children[0] === expr.assigned) {  // postfix update
            pre.push("(")
            post.push([", ", lhs, ")"])
          } else {
            pre.push(["(", lhs, ", "])
            post.push(")")
          }
          // TODO: use ref to avoid duplicating function calls
          return expr.assigned
        }
      }
      const pre = [], post = []
      switch (exp.type) {
        case "AssignmentExpression":
          if (!exp.lhs) return
          exp.lhs.forEach((lhsPart, i) => {
            let newLhs = extractAssignment(lhsPart[1])
            if (newLhs) {
              lhsPart[1] = newLhs
            }
          })
          break
        case "UpdateExpression":
          let newLhs = extractAssignment(exp.assigned)
          if (newLhs) {
            const i = exp.children.indexOf(exp.assigned)
            exp.assigned = exp.children[i] = newLhs
          }
          break
      }
      if (pre.length) exp.children.unshift(...pre)
      if (post.length) exp.children.push(...post)
      // TODO: need to make this a parenthesized expression when when we add parens
    })

  gatherRecursiveAll(statements, (n) => n.type === "AssignmentExpression" && n.names === null)
    .forEach((exp) => {
      let { lhs: $1, exp: $2 } = exp, tail = [], i = 0, len = $1.length

      // identifier=
      if ($1.some((left) => left[left.length - 1].special)) {
        if ($1.length !== 1) {
          throw new Error("Only one assignment with id= is allowed")
        }
        const [, lhs, , op] = $1[0]
        const { call } = op
        // Replace id= with =
        op[op.length - 1] = "="
        // Wrap right-hand side with call
        const index = exp.children.indexOf($2)
        if (index < 0) throw new Error("Assertion error: exp not in AssignmentExpression")
        exp.children.splice(index, 1,
          exp.exp = $2 = [call, "(", lhs, ", ", $2, ")"])
      }

      // Force parens around destructuring object assignments
      // Walk from left to right the minimal number of parens are added and enclose all destructured assignments
      // TODO: Could validate some lhs ecmascript rules here if we wanted to
      let wrapped = false
      while (i < len) {
        const lastAssignment = $1[i++]
        const [, lhs, , op] = lastAssignment
        if (op.token !== "=") continue

        if (lhs.type === "ObjectExpression" || lhs.type === "ObjectBindingPattern") {
          // Wrap with parens to distinguish from braced blocks
          if (!wrapped) {
            wrapped = true
            lhs.children.splice(0, 0, "(")
            tail.push(")")
          }
        }
      }

      // TODO: Handle optional assignment refs

      // Walk from right to left to handle splices
      i = len - 1
      while (i >= 0) {
        const lastAssignment = $1[i]

        if (lastAssignment[3].token === "=") {
          const lhs = lastAssignment[1]

          // Splice assignment
          if (lhs.type === "MemberExpression") {
            const members = lhs.children
            const lastMember = members[members.length - 1]

            // TODO: this is kind of bonkers
            if (lastMember.type === "SliceExpression") {
              const { start, end, children: c } = lastMember
              // TODO: don't lose as many source mappings
              c[0].token = ".splice("
              c[1] = start
              c[2] = ", "
              if (end)
                c[3] = [end, " - ", start]
              else
                c[3] = ["1/0"]
              c[4] = [", ...", $2]
              c[5] = ")"

              // Remove assignment token
              lastAssignment.pop()
              if (isWhitespaceOrEmpty(lastAssignment[2])) lastAssignment.pop()
              // TODO: this only works for the last assignment, not multiple splice assignments, or splice assignments earlier in the chain
              if ($1.length > 1) {
                throw new Error("Not implemented yet! TODO: Handle multiple splice assignments")
              }

              exp.children = [$1]
              exp.names = []
              return
            }
          } else if (lhs.type === "ObjectBindingPattern" || lhs.type === "ArrayBindingPattern") {
            processBindingPatternLHS(lhs, tail)
          }
          // NOTE: currently not processing any non-binding pattern ObjectExpression or ArrayExpressions
          // This might not be correct in all situations, esp BindingPatterns nested inside ObjectExpressions
        }
        i--
      }

      // Gather all identifier names from the lhs array
      exp.names = $1.flatMap(([, l]) => l.names || [])
      const index = exp.children.indexOf($2)
      if (index < 0) throw new Error("Assertion error: exp not in AssignmentExpression")
      exp.children.splice(index + 1, 0, ...tail)
    })
}

function processBlocks(statements): void
  insertSemicolon(statements)
  gatherRecursive statements, .type is "BlockStatement"
  .forEach ({ expressions }) ->
    processBlocks expressions

/**
* Avoid automatic continuation onto lines that start with
* certain characters by adding an explicit semicolon. See
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion
*/
function insertSemicolon(statements: StatementTuple[]): void
  l := statements.length
  statements.forEach (s, i) ->
    if i < l - 1
      if needsPrecedingSemicolon(statements[i + 1])
        delim := s[2]
        if !delim
          s[2] = ";"
        // If delim is an object assume it already has a semicolon
        // TODO: trailing comments might violate this assumption
        else if typeof delim is "string" and !delim.match(/;/)
          s[2] = `;${delim}`

function needsPrecedingSemicolon(exp)
  let following: ASTNode
  if Array.isArray exp
    [,following] = exp
  else
    // Ideally this would be a StatementTuple but js only public/protected param items don't quite fit into that yet
    // since the js: true is on the AST node the semicolon delimiters will stack up with empty nodes in between
    following = exp

  return false unless following

  if Array.isArray following // for chained conditionals
    return needsPrecedingSemicolon following[0]

  switch following.type
    when "ParenthesizedExpression", "ArrayExpression", "ArrowFunction", "TemplateLiteral", "RegularExpressionLiteral"
      true
    when "AssignmentExpression"
      startsWith(following, /^(\[|\()/)
    when "Literal"
      following.raw?.startsWith('-') || following.raw?.startsWith('+')
    else
      // descend into first child for things like:
      // IterationExpression
      //   CallExpression
      //     ParenthesizedExpression
      if following.children
        return needsPrecedingSemicolon following.children[0]

function attachPostfixStatementAsExpression(exp, post): void {
  switch (post[1].type) {
    case "ForStatement":
    case "IterationStatement":
    case "DoStatement": {
      const statement = addPostfixStatement(exp, ...post)
      return {
        type: "IterationExpression",
        children: [statement],
        block: statement.block,
        statement,
      }
    }
    case "IfStatement":
      return expressionizeIfClause(post[1], exp)
    default:
      throw new Error("Unknown postfix statement")
  }
}

function getPatternConditions(pattern, ref, conditions): void {
  if (pattern.rest) return // No conditions for rest elements

  switch (pattern.type) {
    case "ArrayBindingPattern": {
      const { elements, length } = pattern,
        hasRest = elements.some((e) => e.rest),
        comparator = hasRest ? " >= " : " === ",
        l = [comparator, (length - hasRest).toString()]

      conditions.push(
        ["Array.isArray(", ref, ")"],
        [ref, ".length", l],
      )

      // recursively collect nested conditions
      elements.forEach(({ children: [, e] }, i) => {
        const subRef = [ref, "[", i.toString(), "]"]
        getPatternConditions(e, subRef, conditions)
      })

      // collect post rest conditions
      const { blockPrefix } = pattern
      if (blockPrefix) {
        const postElements = blockPrefix.children[1],
          { length: postLength } = postElements

        postElements.forEach(({ children: [, e] }, i) => {
          const subRef = [ref, "[", ref, ".length - ", (postLength + i).toString(), "]"]
          getPatternConditions(e, subRef, conditions)
        })
      }

      break
    }
    case "ObjectBindingPattern": {
      conditions.push(
        ["typeof ", ref, " === 'object'"],
        [ref, " != null"],
      )

      pattern.properties.forEach((p) => {
        switch (p.type) {
          case "PinProperty":
          case "BindingProperty": {
            const { name, value } = p
            let subRef
            switch (name.type) {
              case "ComputedPropertyName":
                conditions.push([name.expression, " in ", ref])
                subRef = [ref, name]
                break
              case "Literal":
              case "StringLiteral":
              case "NumericLiteral":
                conditions.push([name, " in ", ref])
                subRef = [ref, "[", name, "]"]
                break
              default:
                conditions.push(["'", name, "' in ", ref])
                subRef = [ref, ".", name]
            }

            if (value) {
              getPatternConditions(value, subRef, conditions)
            }

            break
          }
        }
      })

      break
    }
    case "ConditionFragment": {
      let { children } = pattern
      // Add leading space to first binary operation
      if (children.length) {
        let [ first, ...rest ] = children
        let [ ws, ...op ] = first
        ws = [" "].concat(ws)
        first = [ ws, ...op ]
        children = [ first, ...rest ]
      }
      conditions.push(
        processBinaryOpExpression([ref, children])
      )
      break
    }
    case "RegularExpressionLiteral": {
      conditions.push(
        ["typeof ", ref, " === 'string'"],
        [pattern, ".test(", ref, ")"],
      )

      break
    }
    case "PinPattern":
      conditions.push([
        ref,
        " === ",
        pattern.expression,
      ])
      break
    case "Literal":
      conditions.push([
        ref,
        " === ",
        pattern,
      ])
      break
    default:
      break
  }
}

function elideMatchersFromArrayBindings(elements) {
  return elements.map((el) => {
    // TODO: this isn't unified with the element [ws, e, sep] tuple yet
    if (el.type === "BindingRestElement") {
      return ["", el, undefined]
    }
    const { children: [ws, e, delim] } = el
    switch (e.type) {
      case "Literal":
      case "RegularExpressionLiteral":
      case "StringLiteral":
      case "PinPattern":
        return delim
      default:
        return [ws, nonMatcherBindings(e), delim]
    }
  })
}

function elideMatchersFromPropertyBindings(properties) {
  return properties.map((p) => {
    switch (p.type) {
      case "BindingProperty": {
        const { children, name, value } = p
        const [ws] = children

        switch (value && value.type) {
          case "ArrayBindingPattern":
          case "ObjectBindingPattern":
            return {
              ...p,
              children: [ws, name, ": ", nonMatcherBindings(value), p.delim],
            }
          case "Identifier":
            return p
          case "Literal":
          case "RegularExpressionLiteral":
          case "StringLiteral":
          default:
            return {
              ...p,
              children: [ws, name, p.delim],
            }
        }
      }
      case "PinProperty":
      case "BindingRestProperty":
      default:
        return p
    }
  })
}

function nonMatcherBindings(pattern) {
  switch (pattern.type) {
    case "ArrayBindingPattern": {
      const elements = elideMatchersFromArrayBindings(pattern.elements)
      const children = ["[", elements, "]"]
      return {
        ...pattern,
        children,
        elements,
      }
    }
    case "PostRestBindingElements": {
      const els = elideMatchersFromArrayBindings(pattern.children[1])

      return {
        ...pattern,
        children: [
          pattern.children[0],
          els,
          ...pattern.children.slice(2),
        ],
      }
    }
    case "ObjectBindingPattern":
      return ["{", elideMatchersFromPropertyBindings(pattern.properties), "}"]

    default:
      return pattern
  }
}

function aggregateDuplicateBindings(bindings, ReservedWord) {
  const props = gatherRecursiveAll(bindings, (n) => n.type === "BindingProperty")
  const arrayBindings = gatherRecursiveAll(bindings, (n) => n.type === "ArrayBindingPattern")

  arrayBindings.forEach((a) => {
    const { elements } = a
    elements.forEach((element) => {
      if (Array.isArray(element)) {
        const [, e] = element
        if (e.type === "Identifier") {
          props.push(e)
        } else if (e.type === "BindingRestElement") {
          props.push(e)
        }
      }
    })
  })

  const declarations = []

  const propsGroupedByName = new Map

  for (const p of props) {
    const { name, value } = p

    // This is to handle aliased props, non-aliased props, and binding identifiers in arrays
    const key = value?.name || name?.name || name
    if (propsGroupedByName.has(key)) {
      propsGroupedByName.get(key).push(p)
    } else {
      propsGroupedByName.set(key, [p])
    }
  }

  propsGroupedByName.forEach((shared, key) => {
    if (!key) return
    // NOTE: Allows pattern matching reserved word keys by binding to inaccessible refs
    // HACK: using the parser's ReservedWord rule here
    if (ReservedWord({ fail() { } }, {
      pos: 0,
      input: key,
    })) {
      shared.forEach((p) => {
        aliasBinding(p, makeRef(`_${key}`, key))
      });
      // Don't push declarations for reserved words
      return
    }

    if (shared.length === 1) return

    // Create a ref alias for each duplicate binding
    const refs = shared.map((p) => {
      const ref = makeRef(key)

      aliasBinding(p, ref)

      return ref
    })

    // Gather duplicates in an array
    declarations.push(["const ", key, " = [", ...refs.map((r, i) => {
      return i === 0 ? r : [", ", r]
    }), "]"])
  })

  return declarations
}

function processPatternMatching(statements, ReservedWord): void {
  gatherRecursiveAll(statements, (n) => n.type === "SwitchStatement")
    .forEach((s: SwitchStatement) => {
      const { caseBlock } = s
      const { clauses } = caseBlock

      let errors = false
      let isPattern = false
      if (clauses.some((c) => c.type === "PatternClause")) {
        isPattern = true
        clauses.forEach((c) => {
          // else/default clause is ok
          if (!(c.type === "PatternClause" || c.type === "DefaultClause")) {
            errors = true
            c.children.push({
              type: "Error",
              message: "Can't mix pattern matching and non-pattern matching clauses",
            })
          }
        })
      }

      if (errors || !isPattern) return

      let { condition } = s
      if (condition.type === "ParenthesizedExpression") {
        // Unwrap parenthesized expression
        condition = condition.expression
      }

      let hoistDec, refAssignment = [], ref = maybeRef(condition, "m");
      if (ref !== condition) {
        hoistDec = {
          type: "Declaration",
          children: ["let ", ref],
          names: [],
        }
        refAssignment = [{
          type: "AssignmentExpression",
          children: [ref, " = ", condition],
        }, ","]
      }
      let prev = [],
        root = prev

      const l = clauses.length
      clauses.forEach((c, i) => {
        if (c.type === "DefaultClause") {
          prev.push(c.block)
          return
        }

        let { patterns, block } = c
        let pattern = patterns[0]

        const indent = block.expressions?.[0]?.[0] || ""

        // TODO: multiple binding patterns

        const alternativeConditions = patterns.map((pattern, i) => {
          const conditions = []
          getPatternConditions(pattern, ref, conditions)
          return conditions
        })

        const conditionExpression = alternativeConditions.map((conditions, i) => {
          const conditionArray = conditions.map((c, i) => {
            if (i === 0) return c
            return [" && ", ...c]
          })

          if (i === 0) return conditionArray
          return [" || ", ...conditionArray]
        })

        const condition = {
          type: "ParenthesizedExpression",
          children: ["(", ...refAssignment, conditionExpression, ")"],
          expression: conditionExpression,
        }

        const prefix = []

        switch (pattern.type) {
          case "ArrayBindingPattern":
            if (pattern.length === 0) break
          case "ObjectBindingPattern": {
            // NOTE: Array matching pattern falls through so we use the null check
            if (pattern.properties?.length === 0) break

            // Gather bindings
            let [splices, thisAssignments] = gatherBindingCode(pattern)
            const patternBindings = nonMatcherBindings(pattern)

            splices = splices.map((s) => [", ", nonMatcherBindings(s)])
            thisAssignments = thisAssignments.map((a) => [indent, a, ";"])

            const duplicateDeclarations = aggregateDuplicateBindings([patternBindings, splices], ReservedWord)

            prefix.push([indent, "const ", patternBindings, " = ", ref, splices, ";"])
            prefix.push(...thisAssignments)
            prefix.push(...duplicateDeclarations.map((d) => [indent, d, ";"]))

            break
          }
        }

        block.expressions.unshift(...prefix)

        const next = []

        // Add braces if necessary
        braceBlock(block)

        // Insert else if there are more branches
        if (i < l - 1) next.push("\n", "else ")

        prev.push(["", {
          type: "IfStatement",
          children: ["if", condition, block, next],
          then: block,
          else: next,
          hoistDec,
        }])
        hoistDec = undefined
        refAssignment = []
        prev = next
      })

      s.type = "PatternMatchingStatement"
      s.children = [root]
      // Update parent pointers
      addParentPointers(s, s.parent)
    })
}

// head: expr
// body: [ws, pipe, ws, expr][]

function processPipelineExpressions(statements): void {
  gatherRecursiveAll(statements, (n) => n.type === "PipelineExpression")
    .forEach((s) => {
      const [ws, , body] = s.children
      let [, arg] = s.children

      let i = 0, l = body.length

      const children = [ws]

      let usingRef = null

      for (i = 0; i < l; i++) {
        const step = body[i]
        const [leadingComment, pipe, trailingComment, expr] = step
        const returns = pipe.token === "||>"
        let ref, result,
          returning = returns ? arg : null

        if (pipe.token === "|>=") {
          let initRef
          if (i === 0) {
            :outer switch (arg.type) {
              case "MemberExpression":
                // If there is only a single access then we don't need a ref
                if (arg.children.length <= 2) break
              case "CallExpression":
                const access = arg.children.pop()

                switch (access.type) {
                  case "PropertyAccess":
                  case "SliceExpression":
                    break
                  default:
                    children.unshift({
                      type: "Error",
                      $loc: pipe.token.$loc,
                      message: `Can't assign to ${access.type}`,
                    })
                    arg.children.push(access)
                    break outer
                }

                usingRef = makeRef()
                initRef = {
                  type: "AssignmentExpression",
                  children: [usingRef, " = ", arg, ","],
                }

                arg = {
                  type: "MemberExpression",
                  children: [usingRef, access]
                }

                break;
            }

            // assignment node
            const lhs = [[
              [initRef],
              arg,
              [],
              { token: "=", children: [" = "] }
            ]];

            Object.assign(s, {
              type: "AssignmentExpression",
              children: [lhs, children],
              names: null,
              lhs,
              assigned: arg,
              exp: children,
            })

            // Clone so that the same node isn't on the left and right because splice manipulation
            // moves things around and can cause a loop in the graph
            arg = clone(arg)

            // except keep the ref the same
            if (arg.children[0].type === "Ref") {
              arg.children[0] = usingRef
            }

          } else {
            children.unshift({
              type: "Error",
              $loc: pipe.token.$loc,
              message: "Can't use |>= in the middle of a pipeline",
            })
          }
        } else {
          if (i === 0) s.children = children
        }

        if (returns && (ref = needsRef(arg))) {
          // Use the existing ref if present
          usingRef = usingRef || ref
          arg = {
            type: "ParenthesizedExpression",
            children: ["(", {
              type: "AssignmentExpression",
              children: [usingRef, " = ", arg],
            }, ")"],
          }
          returning = usingRef
        }

        [result, returning] = constructPipeStep(
          {
            leadingComment: skipIfOnlyWS(leadingComment),
            trailingComment: skipIfOnlyWS(trailingComment),
            expr
          },
          arg,
          returning,
        )

        if (result.type === "ReturnStatement") {
          // Attach errors/warnings if there are more steps
          if (i < l - 1) {
            result.children.push({
              type: "Error",
              message: "Can't continue a pipeline after returning",
            })
          }
          arg = result
          if (children[children.length - 1] === ",") {
            children.pop()
            children.push(";")
          }
          break
        }

        if (returning) {
          arg = returning
          children.push(result, ",")
        } else {
          arg = result
        }
      }

      if (usingRef) {
        s.hoistDec = {
          type: "Declaration",
          children: ["let ", usingRef],
          names: [],
        }
      }

      children.push(arg)
      // Update parent pointers
      addParentPointers(s, s.parent)
    })
}

function processProgram(root: BlockStatement, config, m, ReservedWord): void {
  // invariants
  assert.equal(m.forbidBracedApplication.length, 1, "forbidBracedApplication")
  assert.equal(m.forbidClassImplicitCall.length, 1, "forbidClassImplicitCall")
  assert.equal(m.forbidIndentedApplication.length, 1, "forbidIndentedApplication")
  assert.equal(m.forbidNewlineBinaryOp.length, 1, "forbidNewlineBinaryOp")
  assert.equal(m.forbidTrailingMemberProperty.length, 1, "forbidTrailingMemberProperty")
  assert.equal(m.JSXTagStack.length, 1, "JSXTagStack")

  addParentPointers(root)

  const { expressions: statements } = root

  processDeclarationConditions(statements)
  processPipelineExpressions(statements)
  processAssignments(statements)
  processPatternMatching(statements, ReservedWord)

  // Modify iteration expressions
  gatherRecursiveAll(statements, (n) => n.type === "IterationExpression")
    .forEach((e) => expressionizeIteration(e))

  // Hoist hoistDec attributes to actual declarations.
  // NOTE: This should come after iteration expressions get processed
  // into IIFEs.
  hoistRefDecs(statements)

  // Adding implicit returns should happen after hoisting any ref declarations
  // so their target node can be found in the block without being inside a return
  processFunctions(statements, config)

  // Insert prelude
  statements.unshift(...m.prelude)

  if (config.autoLet) {
    createConstLetDecs(statements, [], "let")
  } else if(config.autoConst) {
    createConstLetDecs(statements, [], "const")
  } else if (config.autoVar) {
    createVarDecs(statements, [])
  }

  processBlocks(statements)

  populateRefs(statements)
  adjustAtBindings(statements)
}

function findDecs(statements) {
  const declarationNames = gatherNodes(statements, ({ type }) => type === "Declaration")
    .flatMap((d) => d.names)

  return new Set(declarationNames)
}

function populateRefs(statements: ASTNode): void {
  const refNodes = gatherRecursive(statements, ({ type }) => type === "Ref")

  if (refNodes.length) {
    // Find all ids within nested scopes
    const ids = gatherRecursive(statements, (s) => s.type === "Identifier")
    const names = new Set(ids.flatMap(({ names }) => names || []))

    // Populate each ref
    refNodes.forEach((ref) => {
      const { type, base } = ref
      if (type !== "Ref") return

      ref.type = "Identifier"

      let n = 0
      let name = base

      // check for name collisions and increment name suffix
      while (names.has(name)) {
        n++
        name = `${base}${n}`
      }

      names.add(name)
      ref.children = ref.names = [name]
    })
  }
}

// CoffeeScript compatible automatic var insertion
function createVarDecs(statements, scopes, pushVar) {
  // NOTE: var and let/const have different scoping rules
  // need to keep var scopes when entering functions and within a var scope keep
  // track of lexical scopes within blocks
  function hasDec(name) {
    return scopes.some((s) => s.has(name))
  }

  function findAssignments(statements, decs) {
    let assignmentStatements = gatherNodes(statements, (node) => {
      return node.type === "AssignmentExpression"
    })

    if (assignmentStatements.length) {
      // Get nested assignments that could be in expressions
      assignmentStatements = assignmentStatements
        .concat(findAssignments(assignmentStatements.map((s) => s.children), decs))
    }

    return assignmentStatements
  }

  // Let descendent blocks add the var at the outer enclosing function scope
  if (!pushVar) {
    pushVar = function (name) {
      varIds.push(name)
      decs.add(name)
    }
  }

  const decs = findDecs(statements)
  scopes.push(decs)
  const varIds = []
  const assignmentStatements = findAssignments(statements, scopes)
  const undeclaredIdentifiers = assignmentStatements.flatMap((a) => a.names)

  // Unique, undeclared identifiers in this scope
  undeclaredIdentifiers.filter((x, i, a) => {
    if (!hasDec(x)) return a.indexOf(x) === i
  }).forEach(pushVar)

  const fnNodes = gatherNodes(statements, isFunction)
  const forNodes = gatherNodes(statements, (s) => s.type === "ForStatement")

  const blockNodes = new Set(gatherNodes(statements, (s) => s.type === "BlockStatement"))
  // Remove function blocks and for statements, they get handled separately because they have additional parameter scopes and lexical scopes to add
  fnNodes.forEach(({ block }) => blockNodes.delete(block))
  forNodes.forEach(({ block }) => blockNodes.delete(block))

  // recurse into nested blocks
  blockNodes.forEach (block) =>
    createVarDecs(block.expressions, scopes, pushVar)

  // recurse into for loops
  forNodes.forEach ({ block, declaration }) =>
    scopes.push(new Set(declaration.names))
    createVarDecs(block.expressions, scopes, pushVar)
    scopes.pop()

  // recurse into nested functions
  fnNodes.forEach ({ block, parameters }) =>
    scopes.push(new Set(parameters.names))
    createVarDecs(block.expressions, scopes)
    scopes.pop()

  if (varIds.length) {
    // get indent from first statement
    const indent = getIndent(statements[0])
    let delimiter = ";"
    if (statements[0][1]?.parent?.root) {
      delimiter = ";\n"
    }
    // TODO: Declaration ast node
    statements.unshift([indent, {
      type: "Declaration"
      children: ["var ", varIds.join(", ")]
    }, delimiter])
  }

  scopes.pop()
}

function createConstLetDecs(statements, scopes, letOrConst: "let" | "const"): void {
  function findVarDecs(statements, decs) {
    const declarationNames = gatherRecursive statements, (node) =>
        node.type === "Declaration" &&
        node.children &&
        node.children.length > 0 &&
        node.children[0].token &&
        node.children[0].token.startsWith('var') ||
        node.type === "FunctionExpression"
      .filter((node) => node.type === "Declaration")
      .flatMap((node) => node.names)

    return new Set(declarationNames)
  }

  let declaredIdentifiers = findVarDecs(statements)

  function hasDec(name) {
    return declaredIdentifiers.has(name) || scopes.some((s) => s.has(name))
  }

  function gatherBlockOrOther(statement) {
    return gatherNodes(statement, (s) => s.type === "BlockStatement" || s.type === "AssignmentExpression" || s.type === "Declaration").flatMap((node) => {
      if (node.type == "BlockStatement")
        // bare blocks is not a safe position to insert let declaration
        return node.bare ? gatherBlockOrOther(node.expressions) : node
      else if (node.children && node.children.length)
        return [...gatherBlockOrOther(node.children), node]
      else
        return []
    })
  }

  let currentScope = new Set()
  scopes.push(currentScope)

  const fnNodes = gatherNodes(statements, isFunction)
  const forNodes = gatherNodes(statements, (s) => s.type === "ForStatement")

  let targetStatements: StatementTuple[] = []
  for (const statement of statements) {
    const nodes = gatherBlockOrOther(statement)
    let undeclaredIdentifiers = []
    for (const node of nodes) {
      if (node.type == "BlockStatement") {
        let block = node
        let fnNode = fnNodes.find((fnNode) => fnNode.block === block)
        let forNode = forNodes.find((forNode) => forNode.block === block)
        if (fnNode != null) {
          scopes.push(new Set(fnNode.parameters.names))
          createConstLetDecs(block.expressions, scopes, letOrConst)
          scopes.pop()
        }
        else if (forNode != null) {
          scopes.push(new Set(forNode.declaration.names))
          createConstLetDecs(block.expressions, scopes, letOrConst)
          scopes.pop()
        }
        else
          createConstLetDecs(block.expressions, scopes, letOrConst)
        continue
      }
      // Assignment and Declaration all use 'names'.
      if (node.names == null) continue
      let names = node.names.filter((name) => !hasDec(name))
      if (node.type == "AssignmentExpression")
        undeclaredIdentifiers.push(...names)
      names.forEach((name) => currentScope.add(name))
    }

    if (undeclaredIdentifiers.length > 0) {
      let indent = statement[0]
      // Is this statement a simple assingment like 'a = 1'?
      let firstIdentifier = gatherNodes(statement[1], (node) => node.type == "Identifier")[0]
      if (undeclaredIdentifiers.length == 1
        && statement[1].type == 'AssignmentExpression'
        && statement[1].names.length == 1
        && statement[1].names[0] == undeclaredIdentifiers[0]
        && firstIdentifier && firstIdentifier.names == undeclaredIdentifiers[0]
        && gatherNodes(statement[1], (node) => node.type === "ObjectBindingPattern").length == 0)
        statement[1].children.unshift([`${letOrConst} `])
      else {
        let tail = "\n"
        // Does this statement start with a newline?
        if (gatherNodes(indent, (node) => node.token && node.token.endsWith("\n")).length > 0)
          tail = undefined
        // Have to use 'let' instead of 'const' if the assignment is inside an expression
        targetStatements.push [indent, {
          type: "Declaration",
          children: ["let ", ...undeclaredIdentifiers.join(", ")],
          names: undeclaredIdentifiers,
        }, tail]
      }
    }
    targetStatements.push(statement)
  }

  scopes.pop()
  statements.splice(0, statements.length, ...targetStatements)
}


/**
 * Support for `return.value` and `return =`
 * for changing automatic return value of function.
 * Returns whether any present (so shouldn't do implicit return).
 */
function processReturnValue(func: FunctionNode)
  { block } := func
  values: ASTNodeBase[] := (gatherRecursiveWithinFunction block,
    ({ type }) => type === "ReturnValue") as ASTNodeBase[]
  return false unless values.length

  ref := makeRef "ret"

  let declaration
  values.forEach (value) =>
    value.children = [ref]

    // Check whether return.value already declared within this function
    { ancestor, child } := findAncestor(value,
      ({ type }) => type === "Declaration",
      isFunction)
    declaration ??= child if ancestor  // remember binding

  // Compute default return type
  returnType .= func.returnType ?? func.signature?.returnType
  if returnType
    { t } := returnType
    switch t.type
      "TypePredicate"
        returnType = ": boolean"
      "AssertsType"
        returnType = undefined

  // Modify existing declaration, or add declaration of return.value after {
  if declaration
    unless declaration.suffix?
      declaration.children[1] = declaration.suffix = returnType
  else
    block.expressions.unshift [
      getIndent block.expressions[0]
    ,
      type: "Declaration"
      children: ["let ", ref, returnType]
      names: []
    ,
      ";"
    ]

  // Transform existing `return` -> `return ret`
  gatherRecursiveWithinFunction block,
    (r) => r.type is "ReturnStatement" and not r.expression
  .forEach (r) =>
    r.expression = ref
    r.children.splice -1, 1, " ", ref

  // Implicit return before }
  unless block.children.at(-2)?.type is "ReturnStatement"
    block.expressions.push [
      [getIndent(block.expressions.at(-1))]
    ,
      type: "ReturnStatement",
      expression: ref,
      children: ["return ", ref]
    ]

  return true

function processUnaryExpression(pre, exp, post) {
  if (!(pre.length || post)) return exp
  // Handle "?" postfix
  if (post?.token === "?") {
    post = {
      $loc: post.$loc,
      token: " != null",
    }

    if (pre.length) {
      const lastPre = pre[pre.length - 1]
      // Check for `!a?`
      if (lastPre.token === "!") {
        post.token = " == null"
        pre = pre.slice(0, -1)
      // Chec for `not a?`
      } else if (lastPre.length is 2 && lastPre[0].token === "!") {
        post.token = " == null"
        pre = pre.slice(0, -1)
      }
    }
    const existence = {
      type: "Existence",
      expression: exp,
      children: [exp, post],
    }
    exp = makeLeftHandSideExpression(existence)
    if (pre.length) {
      return {
        type: "UnaryExpression",
        children: [...pre, exp],
      }
    }
    return exp
  }

  // Combine unary -/+ to become numeric literals
  if exp.type is "Literal"
    if pre.length is 1
      {token} := pre[0]
      if token is "-" or token is "+"
        children := [pre[0], ...exp.children]
        if (post) exp.children.push(post)

        return {
          type: "Literal",
          children,
          raw: `${token}${exp.raw}`
        }

  // Await ops
  const l = pre.length
  if (l) {
    const last = pre[l - 1]
    if (last.type === "Await" && last.op) {
      if (exp.type !== "ParenthesizedExpression") {
        exp = ["(", exp, ")"]
      }
      exp = {
        type: "CallExpression",
        children: [" Promise", last.op, exp]
      }
    }
  }

  return {
    type: "UnaryExpression",
    children: [...pre, exp, post]
  }
}

function prune(node: ASTNode): ASTNode {
  if (node === null || node === undefined) return
  if (node.length === 0) return

  if (Array.isArray(node)) {
    const a = node
      .map((n) => prune(n))
      .filter((n) => !!n)

    if (a.length > 1) return a
    if (a.length === 1) return a[0]
    return
  }

  if (node.children != null) {
    node.children = prune(node.children)
    return node
  }

  return node
}

function reorderBindingRestProperty(props) {
  const names = props.flatMap((p) => p.names)

  let restIndex = -1
  let restCount = 0
  props.forEach(({ type }, i) => {
    if (type === "BindingRestProperty") {
      if (restIndex < 0) restIndex = i
      restCount++
    }
  })

  if (restCount === 0) {
    return {
      children: props,
      names,
    }
  } else if (restCount === 1) {
    let after = props.slice(restIndex + 1)
    let rest = props[restIndex]

    props = props.slice(0, restIndex);

    // Swap delimiters of last property and rest so that an omitted trailing comma doesn't end up in the middle
    if (after.length) {
      const {delim: restDelim} = rest,
        lastAfterProp = after[after.length - 1],
        {delim: lastDelim, children: lastAfterChildren} = lastAfterProp

      rest = {
        ...rest,
        delim: lastDelim,
        children: [...rest.children.slice(0, -1), lastDelim]
      }
      after = [
        ...after.slice(0, -1),
        {
          ...lastAfterProp,
          delim: restDelim,
          children: [...lastAfterChildren.slice(0, -1), restDelim]
        }
      ]
    }

    const children = [...props, ...after, rest]

    return {
      children,
      names,
    }
  }

  return {
    children: [{
      type: "Error",
      message: "Multiple rest properties in object pattern",
    }, props]
  }
}

/**
 * Replace all nodes that match predicate with replacer(node)
 */
function replaceNodes(root, predicate, replacer) {
  if (root == null) return root
  const array = Array.isArray(root) ? root : root.children
  if (!array) return root
  array.forEach((node, i) => {
    if (node == null) return
    if (predicate(node)) {
      array[i] = replacer(node, root)
    } else {
      replaceNodes(node, predicate, replacer)
    }
  })
  return root
}

/**
 * Used to ignore the result of __ if it is only whitespace
 * Useful to preserve spacing around comments
 */
function skipIfOnlyWS(target) {
  if (!target) return target
  if (Array.isArray(target)) {
    if (target.length === 1) {
      return skipIfOnlyWS(target[0])
    } else if (target.every((e) => (skipIfOnlyWS(e) === undefined))) {
      return undefined
    }
    return target
  }
  if (target.token != null && target.token.trim() === '') {
    return undefined
  }
  return target
}

function typeOfJSX(node, config, getRef) {
  switch (node.type) {
    case "JSXElement":
      return typeOfJSXElement(node, config, getRef)
    case "JSXFragment":
      return typeOfJSXFragment(node, config, getRef)
  }
}

function typeOfJSXElement(node, config, getRef) {
  if (config.solid) {
    if (config.server && !config.client) {  // server only
      return ["string"]
    }
    let { tag } = node
    // "An intrinsic element always begins with a lowercase letter,
    // and a value-based element always begins with an uppercase letter."
    // [https://www.typescriptlang.org/docs/handbook/jsx.html]
    const clientType =
      tag[0] === tag[0].toLowerCase() ?
        [getRef("IntrinsicElements"), '<"', tag, '">'] :
        ['ReturnType<typeof ', tag, '>']
    if (config.server) {  // isomorphic code for client + server
      return ["string", " | ", clientType]
    } else {  // client only (default)
      return clientType
    }
  }
}

function typeOfJSXFragment(node, config, getRef) {
  if (config.solid) {
    let type = []
    let lastType
    for (let child of node.jsxChildren) {
      switch (child.type) {
        case "JSXText":
          // Solid combines multiple consecutive texts into one string
          if (lastType !== "JSXText") {
            type.push("string")
          }
          break
        case "JSXElement":
          type.push(typeOfJSXElement(child, config, getRef))
          break
        case "JSXFragment":
          // Solid flattens fragments of fragments into one array.
          type.push(...typeOfJSXFragment(child, config, getRef))
          break
        case "JSXChildExpression":
          // Solid discards empty expressions
          if (child.expression) {
            type.push(["typeof ", child.expression])
          }
          break
        default:
          throw new Error(`unknown child in JSXFragment: ${JSON.stringify(child)}`)
      }
      lastType = child.type
    }
    // Solid doesn't wrap single fragment child in an array
    if (type.length === 1) {
      return type[0]
    } else {
      type = type.flatMap((t) => [t, ", "])
      type.pop() // remove trailing comma
      return ["[", type, "]"]
    }
  }
}

/**
 * Wrap an expression in an IIFE, adding async/await if expression
 * uses await, or just adding async if specified.
 * Returns an Array suitable for `children`.
 */
function wrapIIFE(expressions: StatementTuple[], async): ASTNode[] {
  let prefix

  if async
    async = "async "
  else if hasAwait expressions
    async = "async "
    prefix =
      type: "Await"
      children: ["await "]

  block := makeNode {
    type: "BlockStatement",
    expressions,
    children: ["{", expressions, "}"],
    bare: false,
  }

  parameters :=
    type: "Parameters"
    children: ["()"]
    names: []

  signature :=
    modifier:
      async: !!async
    returnType: undefined

  fn := makeNode {
    type: "ArrowFunction",
    signature
    parameters
    returnType: undefined
    ts: false
    async
    block
    children: [async, parameters, "=>", block]
  }

  exp := makeNode
    type: "CallExpression"
    children: [ makeLeftHandSideExpression(fn), "()" ]

  if prefix
    return [ makeLeftHandSideExpression [prefix, exp] ]

  return [ exp ]
}

module.exports = {
  addParentPointers,
  addPostfixStatement,
  adjustAtBindings,
  adjustBindingElements,
  aliasBinding,
  arrayElementHasTrailingComma,
  attachPostfixStatementAsExpression,
  blockWithPrefix,
  clone,
  constructInvocation,
  constructPipeStep,
  convertMethodToFunction,
  convertObjectToJSXAttributes,
  dedentBlockString,
  dedentBlockSubstitutions,
  deepCopy,
  expressionizeIfClause,
  findAncestor,
  forRange,
  gatherBindingCode,
  gatherNodes,
  gatherRecursive,
  gatherRecursiveAll,
  gatherRecursiveWithinFunction,
  getIndentLevel,
  getTrimmingSpace,
  hasAwait,
  hasYield,
  hoistRefDecs,
  insertReturn,
  insertSwitchReturns,
  insertTrimmingSpace,
  isEmptyBareBlock,
  isFunction,
  isVoidType,
  isWhitespaceOrEmpty,
  lastAccessInCallExpression,
  literalValue,
  makeAsConst,
  makeEmptyBlock,
  makeExpressionStatement,
  makeGetterMethod,
  makeLeftHandSideExpression,
  makeRef,
  maybeRef,
  modifyString,
  needsRef,
  negateCondition,
  processAssignmentDeclaration,
  processBinaryOpExpression,
  processCallMemberExpression,
  processCoffeeInterpolation,
  processForInOf,
  processParams,
  processProgram,
  processReturnValue,
  processUnaryExpression,
  prune,
  quoteString,
  removeParentPointers,
  reorderBindingRestProperty,
  replaceNodes,
  skipIfOnlyWS,
  typeOfJSX,
  wrapIIFE,
}
