* as vscode from 'vscode'
* as path from 'node:path'
{ promises as fsPromises } from 'node:fs'

{ findConfig, loadConfig as loadCivetConfig } from '@danielx/civet/config'
{ features } from './grammarList.civet'

let output: vscode.OutputChannel | undefined

// Entry point for VS Code command
export async function regenerateTextmate(showOutput = false)
  if not output
    output = vscode.window.createOutputChannel("Civet Textmate Grammar")
  else
    output!.clear()
  out := output!
  if showOutput
    out.show()
  out.appendLine("Starting Civet grammar regeneration...")

  civetParseOpts .= {}
  optionsModified .= false

  try
    workspaceFolder := vscode.workspace.workspaceFolders?.[0]
    if not workspaceFolder
      msg := 'Civet: No workspace folder – cannot regenerate grammar'
      out.appendLine(`ERROR: ${msg}`)
      vscode.window.showErrorMessage(msg)
      return { modified: false, parseOptions: {} }

    // 1 Load Civet config (may return undefined)
    configPath := workspaceFolder.uri.fsPath
    out.appendLine(`Searching for Civet config in: ${configPath}`)
    cfgFile := await findConfig(configPath).catch((err) => {
      out.appendLine(`ERROR while searching for config: ${err?.message ?? err}`)
      return undefined
    })

    if cfgFile
      out.appendLine(`Found Civet config: ${cfgFile}`)
    else
      out.appendLine('No Civet config file found – using defaults')

    cfg := cfgFile ? await loadCivetConfig(cfgFile).catch((err) => {
      out.appendLine(`ERROR loading config: ${err?.message ?? err}`)
      return undefined
    }) : undefined
    civetParseOpts = cfg?.parseOptions ?? {}
    out.appendLine(`Loaded parseOptions: ${JSON.stringify(civetParseOpts, null, 2)}`)

    // If parse options are empty, skip writing cache/grammar
    if Object.keys(civetParseOpts).length is 0
      out.appendLine('Warning: civetParseOpts is empty, skipping grammar/cache update.')
      return { modified: false, parseOptions: civetParseOpts }
    
    // 2 Locate grammar file within the extension bundle
    ext := vscode.extensions.getExtension 'DanielX.civet'
    if !ext
      msg := 'Civet: Unable to locate extension path'
      out.appendLine(`ERROR: ${msg}`)
      vscode.window.showErrorMessage(msg)
      return { modified: false, parseOptions: civetParseOpts }
    
    grammarFile := path.join ext.extensionPath, 'syntaxes', 'civet.json'
    cacheFile := path.join ext.extensionPath, 'syntaxes', '.civet-grammar-cache.json'
    out.appendLine(`Found grammar file at: ${grammarFile}`)

    // Check if options have changed by comparing with cache (async)
    cachedOpts .= {}
    try
      await fsPromises.access cacheFile
      const cachedContent = await fsPromises.readFile(cacheFile, 'utf8')
      cachedOpts = JSON.parse(cachedContent)
      out.appendLine('Found cached parse options')
    catch err
      // ENOENT = file not found -> treat as "no cache"; otherwise warn
      if (err as any)?.code is not 'ENOENT'
        out.appendLine(`Warning: Could not read cache file: ${err}`)

    // Compare current options with cache
    currentOptsStr := JSON.stringify(civetParseOpts)
    cachedOptsStr := JSON.stringify(cachedOpts)
    
    if currentOptsStr is cachedOptsStr
      out.appendLine('\nParse options unchanged from cache.')
      return { modified: false, parseOptions: civetParseOpts }
    
    out.appendLine('\nParse options changed from cache - updating grammar...')

    // 3 Read and parse grammar (async)
    rawGrammar := await fsPromises.readFile(grammarFile, 'utf8')
    grammar := JSON.parse(rawGrammar)
    grammar.repository ?= {}
    out.appendLine(`Successfully read and parsed grammar file.`)

    // 4 Iterate over feature table
    for feature of features
      out.appendLine(`\nProcessing feature: '${feature.key}'`)
      includeRule := { include: `#${feature.marker}` }
      hasRuleInPatterns := grammar.patterns.some((rule: any) => rule.include === includeRule.include)
      hasRuleInRepo := grammar.repository.hasOwnProperty(feature.marker)
      shouldHaveRule := (civetParseOpts as any)[feature.key]

      out.appendLine(`- Should have rule? ${shouldHaveRule ? 'Yes' : 'No'} (from config)`)
      out.appendLine(`- Rule in patterns? ${hasRuleInPatterns ? 'Yes' : 'No'}`)
      out.appendLine(`- Rule in repository? ${hasRuleInRepo ? 'Yes' : 'No'}`)

      if shouldHaveRule
        if not hasRuleInRepo
          out.appendLine(`- ADDING rule to repository: '${feature.marker}'`)
          grammar.repository[feature.marker] = JSON.parse(feature.snippet)
          optionsModified = true
        if not hasRuleInPatterns
          out.appendLine(`- ADDING include to patterns: '${includeRule.include}'`)
          grammar.patterns.unshift(includeRule)
          optionsModified = true

      else  // should NOT have rule
        if hasRuleInRepo
          out.appendLine(`- REMOVING rule from repository: '${feature.marker}'`)
          delete grammar.repository[feature.marker]
          optionsModified = true
        if hasRuleInPatterns
          out.appendLine(`- REMOVING include from patterns: '${includeRule.include}'`)
          grammar.patterns = grammar.patterns.filter((rule: any) => rule.include !== includeRule.include)
          optionsModified = true

    if not optionsModified
      msg := 'Civet grammar is already up-to-date.'
      out.appendLine(`\n${msg}`)
      return { modified: false, parseOptions: civetParseOpts }

    out.appendLine('\nOptions changed – updating grammar.')
    const newContent = JSON.stringify(grammar, null, 2)
    
    // 5 Backup and write grammar
    try
      await fsPromises.copyFile(grammarFile, grammarFile + '.bak')
      out.appendLine(`Successfully created backup: ${grammarFile}.bak`)
    catch err
      out.appendLine(`Warning: Could not create backup file. ${err}`)
    
    // Write both the grammar and cache atomically
    await Promise.all([
      fsPromises.writeFile(grammarFile, newContent, 'utf8'),
      fsPromises.writeFile(cacheFile, currentOptsStr, 'utf8')
    ])

    // Optionally remove backup after successful write to avoid clutter
    try
      await fsPromises.unlink(grammarFile + '.bak')
      out.appendLine(`Deleted temporary backup: ${grammarFile}.bak`)
    catch err
      // If file does not exist, warn accordingly
      if (err as any)?.code is not 'ENOENT'
        out.appendLine(`Warning: Could not delete backup file: ${err}`)
    
    out.appendLine(`Successfully wrote updated grammar to: ${grammarFile}`)
    out.appendLine(`Successfully updated cache file: ${cacheFile}`)
    out.appendLine('Reload the VS Code window ("Developer: Reload Window" or click the popup) to apply the new syntax highlighting.')

    // 6 Prompt user to reload
    btn := await vscode.window.showInformationMessage 'Civet grammar updated – reload window to apply.', 'Reload Window'
    if btn is 'Reload Window'
      vscode.commands.executeCommand 'workbench.action.reloadWindow'
    return { modified: true, parseOptions: civetParseOpts }
  catch err
    out.show()
    message := err instanceof Error ? err.message : String(err)
    out.appendLine(`FATAL ERROR: ${message}`)
    vscode.window.showErrorMessage(`Civet: Failed to regenerate grammar – ${message}`)

  return { modified: optionsModified, parseOptions: civetParseOpts ?? {} }
