* as vscode from vscode
* as fs from node:fs/promises
* as path from node:path

{ findConfig, loadConfig as loadCivetConfig } from '@danielx/civet/config'
{ features } from './grammarList.civet'

let output: vscode.OutputChannel | undefined

// Entry point for VS Code command
export async function regenerateTextmate()
  if not output
    output = vscode.window.createOutputChannel("Civet Textmate Grammar")
  else
    output!.clear()
  out := output!
  out.show()
  out.appendLine("Starting Civet grammar regeneration...")

  try
    workspaceFolder := vscode.workspace.workspaceFolders?.[0]
    if not workspaceFolder
      msg := 'Civet: No workspace folder – cannot regenerate grammar'
      out.appendLine(`ERROR: ${msg}`)
      vscode.window.showErrorMessage(msg)
      return

    // 1 Load Civet config (may return undefined)
    configPath := workspaceFolder.uri.fsPath
    out.appendLine(`Searching for Civet config in: ${configPath}`)
    cfgFile := await findConfig(configPath).catch((err) => {
      out.appendLine(`ERROR while searching for config: ${err?.message ?? err}`)
      return undefined
    })

    if cfgFile
      out.appendLine(`Found Civet config: ${cfgFile}`)
    else
      out.appendLine('No Civet config file found – using defaults')

    cfg := cfgFile ? await loadCivetConfig(cfgFile).catch((err) => {
      out.appendLine(`ERROR loading config: ${err?.message ?? err}`)
      return undefined
    }) : undefined
    civetParseOpts := cfg?.parseOptions ?? {}
    out.appendLine(`Loaded parseOptions: ${JSON.stringify(civetParseOpts, null, 2)}`)


    // 2 Locate grammar file within the extension bundle
    ext := vscode.extensions.getExtension 'DanielX.civet'
    if !ext
      msg := 'Civet: Unable to locate extension path'
      out.appendLine(`ERROR: ${msg}`)
      vscode.window.showErrorMessage(msg)
      return
    grammarFile := path.join ext.extensionPath, 'syntaxes', 'civet.json'
    out.appendLine(`Found grammar file at: ${grammarFile}`)

    // 3 Read and parse grammar
    grammarUri := vscode.Uri.file(grammarFile)
    rawGrammar := await vscode.workspace.fs.readFile(grammarUri)
    grammar := JSON.parse(rawGrammar.toString())
    grammar.repository ?= {}
    out.appendLine(`Successfully read and parsed grammar file.`)

    // 4 Iterate over feature table
    modified .= false
    for feature of features
      out.appendLine(`\nProcessing feature: '${feature.key}'`)
      includeRule := { include: `#${feature.marker}` }
      hasRuleInPatterns := grammar.patterns.some((rule: any) => rule.include === includeRule.include)
      hasRuleInRepo := grammar.repository.hasOwnProperty(feature.marker)
      shouldHaveRule := (civetParseOpts as any)[feature.key]

      out.appendLine(`- Should have rule? ${shouldHaveRule ? 'Yes' : 'No'} (from config)`)
      out.appendLine(`- Rule in patterns? ${hasRuleInPatterns ? 'Yes' : 'No'}`)
      out.appendLine(`- Rule in repository? ${hasRuleInRepo ? 'Yes' : 'No'}`)

      if shouldHaveRule
        if not hasRuleInRepo
          out.appendLine(`- ADDING rule to repository: '${feature.marker}'`)
          grammar.repository[feature.marker] = JSON.parse(feature.snippet)
          modified = true
        if not hasRuleInPatterns
          out.appendLine(`- ADDING include to patterns: '${includeRule.include}'`)
          grammar.patterns.unshift(includeRule)
          modified = true

      else  // should NOT have rule
        if hasRuleInRepo
          out.appendLine(`- REMOVING rule from repository: '${feature.marker}'`)
          delete grammar.repository[feature.marker]
          modified = true
        if hasRuleInPatterns
          out.appendLine(`- REMOVING include from patterns: '${includeRule.include}'`)
          grammar.patterns = grammar.patterns.filter((rule: any) => rule.include !== includeRule.include)
          modified = true

    if not modified
      msg := 'Civet grammar is already up-to-date.'
      out.appendLine(`\n${msg}`)
      vscode.window.showInformationMessage(msg)
      return
    
    out.appendLine('\nGrammar has been modified.')
    // 5 Backup and write
    try
      await fs.copyFile grammarFile, grammarFile + '.bak'
      out.appendLine(`Successfully created backup: ${grammarFile}.bak`)
    catch err
      out.appendLine(`Warning: Could not create backup file. ${err}`)
    
    newContent := JSON.stringify(grammar, null, 2)
    await fs.writeFile grammarFile, newContent, 'utf8'
    out.appendLine(`Successfully wrote updated grammar to: ${grammarFile}`)
    out.appendLine('Reload the VS Code window ("Developer: Reload Window" or click the popup) to apply the new syntax highlighting.')

    // 6 Prompt user to reload
    btn := await vscode.window.showInformationMessage 'Civet grammar updated – reload window to apply.', 'Reload Window'
    if btn is 'Reload Window'
      vscode.commands.executeCommand 'workbench.action.reloadWindow'
  catch err
    const message = err instanceof Error ? err.message : String(err)
    out.appendLine(`FATAL ERROR: ${message}`)
    vscode.window.showErrorMessage(`Civet: Failed to regenerate grammar – ${message}`)
