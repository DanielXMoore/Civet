{testCase} from ./helper.civet

describe "examples (from real life)", ->
  testCase """
    lsp prototype
    ---
    "civet coffee-compat"
    # Experimenting with transpiling to TS

    import ts from "typescript"

    const DefaultCompilerOptions =
      allowNonTsExtensions: true
      allowJs: true
      target: ts.ScriptTarget.Latest
      moduleResolution: ts.ModuleResolutionKind.NodeJs
      module: ts.ModuleKind.CommonJS
      allowSyntheticDefaultImports: true
      experimentalDecorators: true

    const fileCache = {}

    const createCompilerHost = (options, moduleSearchLocations) ->
      fileExists = (fileName) ->
        fileCache[fileName]?

      readFile = (fileName) ->
        fileCache[fileName]

      getSourceFile = (fileName, languageVersion, onError) ->
        sourceText = ts.sys.readFile(fileName)

        if sourceText?
          return ts.createSourceFile(fileName, sourceText, languageVersion)

      resolveModuleNames = (moduleNames, containingFile) ->
        resolvedModules = []

        for moduleName of moduleNames
          # try to use standard resolution
          result = ts.resolveModuleName moduleName, containingFile, options, {
            fileExists,
            readFile
          }

          if result.resolvedModule
            resolvedModules.push(result.resolvedModule)
          else
            # check fallback locations, for simplicity assume that module at location
            # should be represented by '.d.ts' file
            for location of moduleSearchLocations
              modulePath = path.join(location, moduleName + ".d.ts")
              if fileExists(modulePath)
                resolvedModules.push({ resolvedFileName: modulePath })

        return resolvedModules

      // TODO: Return host
      return
    ---
    // Experimenting with transpiling to TS

    import ts from "typescript"

    const DefaultCompilerOptions = {
      allowNonTsExtensions: true,
      allowJs: true,
      target: ts.ScriptTarget.Latest,
      moduleResolution: ts.ModuleResolutionKind.NodeJs,
      module: ts.ModuleKind.CommonJS,
      allowSyntheticDefaultImports: true,
      experimentalDecorators: true,
    }

    const fileCache = {}

    const createCompilerHost = function(options, moduleSearchLocations) {
      var fileExists, readFile, getSourceFile, resolveModuleNames
      fileExists = function(fileName) {
        return ((fileCache[fileName]) != null)
      }

      readFile = function(fileName) {
        return fileCache[fileName]
      }

      getSourceFile = function(fileName, languageVersion, onError) {
        var sourceText
        sourceText = ts.sys.readFile(fileName)

        if (((sourceText) != null)) {
          return ts.createSourceFile(fileName, sourceText, languageVersion)
        }
        return
      }

      resolveModuleNames = function(moduleNames, containingFile) {
        var resolvedModules
        resolvedModules = []

        for (const moduleName of moduleNames) {
          // try to use standard resolution
          var result
          result = ts.resolveModuleName(moduleName, containingFile, options, {
            fileExists,
            readFile
          })

          if (result.resolvedModule) {
            resolvedModules.push(result.resolvedModule)
          }
          else {
            // check fallback locations, for simplicity assume that module at location
            // should be represented by '.d.ts' file
            for (const location of moduleSearchLocations) {
              var modulePath
              modulePath = path.join(location, moduleName + ".d.ts")
              if (fileExists(modulePath)) {
                resolvedModules.push({ resolvedFileName: modulePath })
              }
            }
          }
        }

        return resolvedModules
      }

      // TODO: Return host
      return
    }
  """

  testCase """
    hera compiler
    ---
    compileStructuralHandler := (mapping: StructuralHandling, source: any, single=false, offset=-1): string ->
      switch typeof mapping
        when "string"
          JSON.stringify(mapping)
        when "object"
          if Array.isArray mapping
            `[${mapping.map((m) => compileStructuralHandler(m, source, single, offset)).join(', ')}]`
          else if mapping is null
            "null"
          else if "l" in mapping
            String(mapping.l)
          else if "v" in mapping
            if single
              source
            else
              if typeof mapping.v is 'number'
                n := mapping.v+offset
                if n is -1 // Handle $0
                  source
                else // Handle $1, $2, etc.
                  `${source}[${n}]`
              else
                mapping.v
          else if "o" in mapping
            o := mapping.o
            "{" + Object.keys(o).map (key) ->
              `${JSON.stringify(key)}: ${compileStructuralHandler(o[key], source, single, offset)}`
            .join(", ") + "}"
          else
            throw new Error "unknown object mapping"
        default // number, boolean, undefined
          String(mapping)
    ---
    function compileStructuralHandler (mapping: StructuralHandling, source: any, single=false, offset=-1): string {
      switch (typeof mapping) {
        case "string":
          return JSON.stringify(mapping)
        case "object":
          if (Array.isArray(mapping)) {
            return `[${mapping.map((m) => compileStructuralHandler(m, source, single, offset)).join(', ')}]`
          }
          else if (mapping === null) {
            return "null"
          }
          else if ("l" in mapping) {
            return String(mapping.l)
          }
          else if ("v" in mapping) {
            if (single) {
              return source
            }
            else {
              if (typeof mapping.v === 'number') {
                const n = mapping.v+offset
                if (n === -1) { // Handle $0
                  return source
                }
                else { // Handle $1, $2, etc.
                  return `${source}[${n}]`
                }
              }
              else {
                return mapping.v
              }
            }
          }
          else if ("o" in mapping) {
            const o = mapping.o
            return "{" + Object.keys(o).map(function(key) {
              return `${JSON.stringify(key)}: ${compileStructuralHandler(o[key], source, single, offset)}`
            })
            .join(", ") + "}"
          }
          else {
            throw new Error("unknown object mapping")
          }
        default: // number, boolean, undefined
          return String(mapping)
      }
    }
  """

  testCase """
    shorthand key value notation
    ---
    return {
      getCompilationSettings: ->
        options
      getSourceFile
      getDefaultLibFileName: ->
        "lib.d.ts"
    }
    ---
    return {
      getCompilationSettings: function() {
        return options
      },
      getSourceFile,
      getDefaultLibFileName: function() {
        return "lib.d.ts"
      }
    }
  """

  testCase """
    react example
    ---
    import React from "react"

    data := [
        {
            key: 1,
            value: "Some label"

            },
            {
            key: 2,
            value: "Another label"
            },
    ]

    Component := () => <>{data.map (x) => <h1>{x.value}</h1> }</>
    ---
    import React from "react"

    const data = [
        {
            key: 1,
            value: "Some label"

            },
            {
            key: 2,
            value: "Another label"
            },
    ]

    const Component = () => <>{data.map((x) => <h1>{x.value}</h1>) }</>
  """

  testCase """
    variables that start with 'in' should not get confused with 'in' keyword
    ---
    outer := 1

    changeNumbers := ->
      inner := 1
      outer := 10

    inner = "1"
    ---
    const outer = 1

    function changeNumbers () {
      const inner = 1
      const outer = 10
    }

    inner = "1"
  """

  testCase """
    if else expression
    ---
    date := if x==1 then "a" else "b"
    ---
    const date = (x==1)? "a":  "b"
  """

  testCase """
    bare return statement
    ---
    getSourceFile := (fileName: string, languageVersion: ScriptTarget, onError: (message: string) => void ) ->
      sourceText := sys.readFile fileName

      if sourceText != undefined
        return createSourceFile fileName, sourceText, languageVersion
      return

    resolveModuleNames := (moduleNames: string[], containingFile: string) ->
      resolvedModules := []
    ---
    function getSourceFile (fileName: string, languageVersion: ScriptTarget, onError: (message: string) => void ) {
      const sourceText = sys.readFile(fileName)

      if (sourceText != undefined) {
        return createSourceFile(fileName, sourceText, languageVersion)
      }
      return
    }

    function resolveModuleNames (moduleNames: string[], containingFile: string) {
      const resolvedModules = []
    }
  """

  testCase """
    don't add extra trailing comma
    ---
    documentSelectors := [
      { scheme: 'file', language: 'civet' },
      { scheme: 'file', language: 'coffeescript' },
      { scheme: 'file', language: 'javascript' },
      { scheme: 'file', language: 'typescript' },
    ]
    ---
    const documentSelectors = [
      { scheme: 'file', language: 'civet' },
      { scheme: 'file', language: 'coffeescript' },
      { scheme: 'file', language: 'javascript' },
      { scheme: 'file', language: 'typescript' },
    ]
  """

  testCase """
    multi-line comment between declarations was breaking parse
    ---
    reDefs: string[] := []
    /** heyy
    */
    x := 3
    ---
    const reDefs: string[] = []
    /** heyy
    */
    const x = 3
  """

  testCase """
    indented multi-line comment between declarations
    ---
    ->
      reDefs: string[] := []
      /** heyy
      */
      x := 3
    ---
    function() {
      const reDefs: string[] = []
      /** heyy
      */
      const x = 3
    }
  """

  testCase """
    compiler
    ---
    if arg[0] is "S"
      namedParameters := arg[1].map (node, i) ->
        return getParameterDeclaration(node, i+1)
      .join("")
    ---
    if (arg[0] === "S") {
      const namedParameters = arg[1].map(function(node, i) {
        return getParameterDeclaration(node, i+1)
      })
      .join("")
    }
  """

  testCase """
    function with nested object as first parameter and trailing method call
    ---
    build
      entryPoints: ['source/extension.mts']
      tsconfig: "./tsconfig.json"
      bundle: true
      external: ['vscode']
      format: "cjs"
      sourcemap
      minify
      watch
      platform: 'node'
      outfile: 'dist/extension.js'
    .catch ->
      process.exit 1
    ---
    build( {
      entryPoints: ['source/extension.mts'],
      tsconfig: "./tsconfig.json",
      bundle: true,
      external: ['vscode'],
      format: "cjs",
      sourcemap,
      minify,
      watch,
      platform: 'node',
      outfile: 'dist/extension.js',
    })
    .catch(function() {
      return process.exit(1)
    })
  """

  describe.skip "TOMAYBE", ->
    testCase """
      nested function arguments
      ---
      client = new LanguageClient
        'civetLanguageServer'
        'Civet Language Server'
        serverOptions
        clientOptions
      ---
      const client = new LanguageClient(
        'civetLanguageServer',
        'Civet Language Server',
        serverOptions,
        clientOptions
      )
    """
