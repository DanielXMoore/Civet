{ testCase, throws } from ./helper.civet
{ compile } from ../source/main.civet
{ serialize } from ../source/parser/comptime.civet
assert from assert

declare global
  var outside: number

describe "comptime", ->
  options := parseOptions: comptime: true

  testCase """
    statement with indented block
    ---
    comptime
      x := 5
      x * x
    ---

  """, options

  testCase """
    one-line statement
    ---
    comptime x := 5
    ---

  """, options

  it "statement has side effect", =>
    global.outside = 0
    compile "comptime global.outside = 7", options
    assert.equal global.outside, 7

  testCase """
    one-line expression
    ---
    value := comptime 1+2
    ---
    const value = 3
  """, options

  testCase """
    expression with indented block
    ---
    value := comptime
      x := 5
      x * x
    ---
    const value = 25
  """, options

  describe "disabled", ->
    testCase """
      empty
      ---
      comptime
      ---
      {}
    """

    testCase """
      empty assigned
      ---
      x = comptime
      ---
      x = (()=>{})()
    """

    testCase """
      statement with indented block
      ---
      comptime
        x := 5
        x * x
      ---
      {
        const x = 5
        x * x
      }
    """

    testCase """
      expression with indented block
      ---
      value := comptime
        x := 5
        x * x
      ---
      const value = (()=>{
        const x = 5
        return x * x})()
    """

    testCase """
      attempt to override
      ---
      "civet comptime"
      x := comptime 1+2
      ---
      const x = (()=>{ return 1+2})()
    """

describe "serialize", ->
  it "numbers", =>
    assert.equal serialize(1), "1"
    assert.equal serialize(1.5), "1.5"
    assert.equal serialize(Infinity), "Infinity"
    assert.equal serialize(-Infinity), "-Infinity"
    assert.equal serialize(NaN), "NaN"
    assert.equal serialize(0), "0"
    assert.equal serialize(-0), "-0"
  it "big numbers", =>
    assert.equal serialize(1000000000000000n), "1000000000000000n"
  it "arrays and nulls", =>
    assert.equal serialize([1, undefined, 3, null]), "[1,undefined,3,null]"
  it "strings", =>
    assert.equal serialize('Hello, "world"!'), '"Hello, \\"world\\"!"'
  it "symbols", =>
    assert.equal serialize(Symbol.for 'MyKeyedSymbol'),
      'Symbol.for("MyKeyedSymbol")'
    assert.throws (=> serialize Symbol()), /cannot serialize unique symbol/
    assert.equal serialize(Symbol.iterator), "Symbol.iterator"
  it "regexps", =>
    assert.equal serialize(/a[b\s]c/), "/a[b\\s]c/"
    assert.equal serialize(/abc/gi), "/abc/gi"
  it "dates", =>
    assert.equal serialize(new Date(1659916697000)), 'new Date(1659916697000)'
  it "objects", =>
    assert.equal serialize(foo: true, bar: baz: false),
      '{"foo":true,"bar":{"baz":false}}'
  it "Sets", =>
    assert.equal serialize(new Set([1, 2, 3])), "new Set([1,2,3])"
  it "Maps", =>
    assert.equal serialize(new Map([["a", 1], ["b", 2], ["c", 3]])),
      'new Map([["a",1],["b",2],["c",3]])'
  it "custom classes", =>
    class Foo {}
    assert.throws (=> serialize new Foo()), /cannot serialize object with prototype/
  it "arrow functions", =>
    assert.equal serialize((x: ???) => x), "(x) => x"
    // Using match instead of equal so it's not sensitive to the rest of the file
    // @ts-ignore Adding a type annotation adds parens to the output, so it's intentionally not typed
    assert.match serialize(&), /^\$(\d*) => \$\1$/
  it "regular functions", =>
    assert.equal serialize((x: ???) -> x), "function (x) { return x; }"
  it "functions with properties", =>
    func: any := (x: ???) => x
    func.a = 1
    assert.throws (=> serialize func), /cannot serialize function with properties/
  it "native functions", =>
    assert.throws (=> serialize parseInt), /cannot serialize native function/
  it "circular", =>
    object: any := {}
    object.circular = object
    assert.throws (=> serialize object), /circular reference detected/
    array: any := []
    array.push array
    assert.throws (=> serialize array), /circular reference detected/
  it "aliasing", =>
    inner: never[] := []
    outer := [inner, inner]
    assert.equal serialize(outer), "[[],[]]"
  it "ES6 methods", =>
    assert.equal serialize({ functionF() { } }.functionF), "function functionF() { }"
    assert.equal serialize({ async bar() { } }.bar), "async function bar() { }"
    assert.throws (=> serialize { [Math.sqrt 5]() {} }), /cannot serialize method with computed name/
  it "typed arrays", =>
    assert.equal serialize(new Uint32Array [1, 2, 3]), "new Uint32Array([1,2,3])"
    assert.equal serialize(new Float64Array [1.0, 1.5, NaN]), "new Float64Array([1,1.5,NaN])"
    assert.equal serialize(new BigInt64Array [1n, 2n, 3n]), "new BigInt64Array([1n,2n,3n])"
    assert.equal serialize(Buffer.from [1, 2, 3]), "Buffer.from([1,2,3])"
    assert.equal serialize(new Uint8ClampedArray [-1, 0, 2, 256]), "new Uint8ClampedArray([0,0,2,255])"
