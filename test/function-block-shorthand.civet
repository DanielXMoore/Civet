{ testCase, throws } from ./helper.civet

describe "&. function block shorthand", ->
  testCase """
    accessor
    ---
    x.map &.name
    ---
    x.map($ => $.name)
  """

  testCase """
    optional access
    ---
    x.map &?.name
    ---
    x.map($ => $?.name)
  """

  testCase """
    omit &
    ---
    x.map .name
    ---
    x.map($ => $.name)
  """

  testCase """
    identity function
    ---
    x.map (&)
    ---
    x.map($ => $)
  """

  testCase """
    omit & with ?
    ---
    x.map ?.name
    ---
    x.map($ => $?.name)
  """

  testCase """
    omit & doesn't break numbers
    ---
    x.map .1
    ---
    x.map(.1)
  """

  testCase """
    index
    ---
    x.map &[0]
    ---
    x.map($ => $[0])
  """

  testCase """
    optional index
    ---
    x.map &?[0]
    ---
    x.map($ => $?.[0])
  """

  testCase """
    index with expression
    ---
    x.map &[b + 1]
    ---
    x.map($ => $[b + 1])
  """

  testCase """
    slice
    ---
    x.map &[0..2]
    ---
    x.map($ => $.slice(0, 1 + 2 || 1/0))
  """

  testCase """
    kitchen sink
    ---
    x.map &.profile?.name?[0..2]
    ---
    x.map($ => $.profile?.name?.slice(0, 1 + 2 || 1/0))
  """

  testCase """
    assignment
    ---
    x.map .name = "foo"
    ---
    x.map($ => $.name = "foo")
  """

  testCase """
    multiple assignment
    ---
    x.map .name = name += "foo"
    ---
    x.map($ => $.name = name += "foo")
  """

  testCase """
    addition
    ---
    x.map &+1
    ---
    x.map($ => $+1)
  """

  testCase """
    subtraction
    ---
    x.map &-1
    ---
    x.map($ => $-1)
  """

  testCase """
    bitwise and
    ---
    x.map & & 1
    ---
    x.map($ => $ & 1)
  """

  testCase """
    bitwise or
    ---
    x.map & | 1
    ---
    x.map($ => $ | 1)
  """

  testCase """
    logical and
    ---
    x.map & && 1
    ---
    x.map($ => $ && 1)
  """

  testCase """
    logical or
    ---
    x.map & || 1
    ---
    x.map($ => $ || 1)
  """

  testCase """
    chained comparisons
    ---
    x.map & > a < b
    ---
    x.map($ => $ > a && a < b)
  """

  testCase """
    access with chained comparisons
    ---
    x.map &.foo > a < b
    ---
    x.map($ => $.foo > a && a < b)
  """

  testCase """
    special operator
    ---
    x.map & is in a
    ---
    x.map($ => a.includes($))
  """

  testCase """
    access with special operator
    ---
    x.map &.foo is in a
    ---
    x.map($ => a.includes($.foo))
  """

  testCase """
    assignment and binary operator
    ---
    x.map &.name = 'name' + i++
    ---
    x.map($ => $.name = 'name' + i++)
  """

  testCase """
    $ as local value
    ---
    x.map & < 3 && $ > 1
    ---
    x.map($1 => $1 < 3 && $ > 1)
  """

  testCase """
    unary !
    ---
    x.map !&
    ---
    x.map($ => !$)
  """

  testCase """
    unary !!
    ---
    x.map !!&
    ---
    x.map($ => !!$)
  """

  testCase """
    unary not
    ---
    x.map not &
    ---
    x.map($ => !$)
  """

  testCase """
    unary not not
    ---
    x.map not not &
    ---
    x.map($ => !!$)
  """

  testCase """
    unary ~
    ---
    x.map ~&
    ---
    x.map($ => ~$)
  """

  testCase """
    unary -
    ---
    x.map -&
    ---
    x.map($ => -$)
  """

  testCase """
    unary +
    ---
    x.map +&
    ---
    x.map($ => +$)
  """

  testCase """
    unary typeof
    ---
    x.map typeof &
    ---
    x.map($ => typeof $)
  """

  testCase """
    unary delete
    ---
    x.forEach delete .old
    ---
    x.forEach($ => delete $.old)
  """

  testCase """
    unary await
    ---
    await.all x.map await .json()
    ---
    await Promise.all(x.map(async $ => await $.json()))
  """

  throws """
    not.prop
    ---
    x.map not.prop
  """

  throws """
    typeof.prop
    ---
    x.map typeof.prop
  """

  throws """
    delete.prop
    ---
    x.map delete.prop
  """

  testCase """
    call expression
    ---
    x.map &.foo()
    ---
    x.map($ => $.foo())
  """

  testCase """
    call expression with arguments
    ---
    x.map &.foo(1, 2, 3)
    ---
    x.map($ => $.foo(1, 2, 3))
  """

  testCase """
    call expression with arguments and splat
    ---
    x.map &.foo(b, ...rest)
    ---
    x.map($ => $.foo(b, ...rest))
  """

  testCase """
    call expression with implicit application
    ---
    x.map &.foo 1, 2
    ---
    x.map($ => $.foo(1, 2))
  """

  testCase """
    access, index, and call expression followed by index and safe access
    ---
    x.map &.foo[0].bar()[2]?.baz
    ---
    x.map($ => $.foo[0].bar()[2]?.baz)
  """

  testCase """
    template literal
    ---
    x.map &`foo`
    ---
    x.map($ => $`foo`)
  """

  testCase """
    it works with const assignment
    ---
    x := &.foo
    ---
    const x = $ => $.foo
  """

  testCase """
    await
    ---
    x.map & + await f()
    ---
    x.map(async $ => $ + await f())
  """

  testCase """
    non-null
    ---
    arr.filter &?
    ---
    arr.filter($ => ($ != null))
  """

  testCase """
    null
    ---
    arr.filter !&?
    ---
    arr.filter($ => !($ != null))
  """

  testCase """
    property non-null
    ---
    hasNull := arr.every .x?
    ---
    const hasNull = arr.every($ => ($.x != null))
  """

  testCase """
    property null
    ---
    hasNull := arr.every !.x?
    ---
    const hasNull = arr.every($ => !($.x != null))
  """

  testCase """
    & function block followed by pipe
    ---
    &.foo |> bar
    ---
    bar($ => $.foo)
  """

describe "(op) shorthand", ->
  testCase """
    binary op
    ---
    items.reduce (+), 0
    items.reduce (&&), true
    items.reduce (||), false
    ---
    items.reduce(((a,b) => a+b), 0)
    items.reduce(((a1,b1) => a1&&b1), true)
    items.reduce(((a2,b2) => a2||b2), false)
  """

  testCase """
    compose binary op
    ---
    compose (+), (*)
    ---
    compose(((a,b) => a+b), ((a1,b1) => a1*b1))
  """

  testCase """
    apply binary op
    ---
    (+) 1, 2
    ---
    ((1)+( 2))
  """

  testCase """
    apply binary op with many complex arguments
    ---
    (*) x+y, z+w, a**b
    ---
    ((x+y)*( z+w)*( a**b))
  """

  testCase """
    indented apply binary op
    ---
    (and)
      x
      y, yy
      z
    ---
    ((
      x)&&(
      y)&&( yy)&&(
      z))
  """

  testCase """
    apply binary op with trailing comma
    ---
    (+)(1, 2, )
    (+)(1, 2, /* comment */ )
    ---
    ((1)+( 2 ));
    ((1)+( 2 /* comment */ ))
  """

  testCase """
    parenthesized special op
    ---
    items.reduce (is in), false
    ---
    items.reduce(((a,b) => b.includes(a)), false)
  """

  testCase """
    parenthesized custom op
    ---
    operator foo
    items.reduce (foo), 0
    ---

    items.reduce(foo, 0)
  """

  testCase """
    parenthesized negated custom op
    ---
    operator foo
    items.reduce (not foo), false
    ---

    items.reduce(((a,b) => !foo(a,b)), false)
  """

  testCase """
    parenthesized ! custom op
    ---
    operator foo
    items.reduce (!foo), false
    ---

    items.reduce(((a,b) => !foo(a,b)), false)
  """

  testCase """
    applied parenthesized custom op
    ---
    operator foo
    (foo) 1, 2
    ---

    foo(1, 2)
  """

describe "operator sections", ->
  testCase """
    left section
    ---
    items.map (1+)
    ---
    items.map(((b) => 1+b))
  """

  testCase """
    left section with spaces
    ---
    items.map (1 + )
    ---
    items.map(((b) => 1 + b))
  """

  testCase """
    complex left section
    ---
    items.map (length * width + )
    ---
    items.map(((b) => length * width + b))
  """
