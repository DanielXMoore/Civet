{testCase, throws} from ./helper.civet

describe "function", ->
  testCase """
    basic
    ---
    f = (x) ->
      x
    ---
    f = function(x) {
      return x
    }
  """

  testCase """
    one liner
    ---
    (x) -> x
    ---
    (function(x) { return x })
  """

  testCase """
    fat tight one liner
    ---
    f=(x)=>x
    ---
    f=(x) =>x
  """

  testCase """
    one liner with multiple statements
    ---
    (x) -> hi; x
    ---
    (function(x) { hi; return x })
  """

  testCase """
    fat one liner with multiple statements
    ---
    (x) => hi; x
    ---
    (x) => { hi; return x }
  """

  testCase """
    no-op
    ---
    ->
    ---
    (function() {})
  """

  testCase """
    one liner keeps comments
    ---
    (/**/x) -> /**/x
    ---
    (function(/**/x) { /**/return x })
  """

  testCase """
    one liner doesn't consume comma operator
    ---
    count = array.reduce((x) -> x+1, 0)
    count = array.reduce (x) -> x+1, 0
    count = array.reduce((x) => x+1, 0)
    count = array.reduce (x) => x+1, 0
    ---
    count = array.reduce(function(x) { return x+1 }, 0)
    count = array.reduce(function(x) { return x+1 }, 0)
    count = array.reduce((x) => x+1, 0)
    count = array.reduce((x) => x+1, 0)
  """

  testCase """
    empty parameters
    ---
    ->
      x
    ---
    (function() {
      return x
    })
  """

  testCase """
    const declaration
    ---
    x :=-> a
    ---
    const x =function() { return a }
  """

  testCase """
    async const declaration
    ---
    defaultLoad := async ->
    ---
    const defaultLoad = async function() {}
  """

  testCase """
    const async longhand
    ---
    const defaultLoad = async function() {}
    ---
    const defaultLoad = async function() {}
  """

  testCase """
    Unicode ->
    ---
    (x) → x
    ---
    (function(x) { return x })
  """

  testCase """
    Unicode =>
    ---
    (x) ⇒ x
    ---
    (x) => x
  """

  describe "implicit async", ->
    testCase """
      basic
      ---
      function f
        await 5
      ---
      async function f() {
        return await 5
      }
    """

    testCase """
      arguments
      ---
      function f(x)
        await 5
      ---
      async function f(x) {
        return await 5
      }
    """

    testCase """
      nested function boundary
      ---
      function f
        function g
          await 5
      ---
      function f() {
        async function g() {
          return await 5
        };return g
      }
    """

    testCase """
      arrow
      ---
      f := ->
        await 5
      ---
      const f = async function() {
        return await 5
      }
    """

    testCase """
      explicit async doesn't get double added
      ---
      async ->
        await 5
      ---
      (async function() {
        return await 5
      })
    """

    testCase """
      implicit generator
      ---
      ->
        yield 5
      ---
      (function*() {
        yield 5
      })
    """

    testCase """
      assigned implicit generator
      ---
      f := ->
        yield 5
      g := <T>(x: T) ->
        yield x
      ---
      const f = function*() {
        yield 5
      }
      const g = function*<T>(x: T) {
        yield x
      }
    """

    testCase """
      implicit generator longhand
      ---
      function
        yield 5
      ---
      (function*() {
        yield 5
      })
    """

    testCase """
      explicit generator doesn't get double added
      ---
      function*
        yield 5
      ---
      (function*() {
        yield 5
      })
    """

    throws """
      yield forbidden within thick arrow
      ---
      => yield 5
      ---
      ParseErrors: unknown:1:9 yield invalid in => arrow function
    """

    throws """
      yield forbidden within thick arrow, inlineMap
      ---
      => yield 5
      ---
      ParseErrors: unknown:1:9 yield invalid in => arrow function
    """, inlineMap: true

    throws """
      multiple forbidden yield
      ---
      =>
        yield 1
        yield 2
      ---
      ParseErrors: unknown:2:8 yield invalid in => arrow function
      unknown:3:8 yield invalid in => arrow function
    """

    testCase """
      thick arrow
      ---
      f := =>
        await 5
      ---
      const f = async () => {
        return await 5
      }
    """

    testCase """
      inline thick arrow
      ---
      f := => await 5
      ---
      const f = async () => await 5
    """

  describe "argumentless without parens", ->
    testCase """
      inline
      ---
      function f 5
      ---
      function f()  {return 5 }
    """

    testCase """
      inline anonymous
      ---
      function 5
      ---
      (function()  {return 5 })
    """

    testCase """
      inline assigned
      ---
      f := function 5
      ---
      const f = function()  {return 5 }
    """

    testCase """
      braced
      ---
      function f { 5 }
      ---
      function f() { return 5 }
    """

    testCase """
      anonymous braced
      ---
      function { 5 }
      ---
      (function() { return 5 })
    """

    testCase """
      implicit block
      ---
      function f
        x := 5
        x*x
      ---
      function f() {
        const x = 5
        return x*x
      }
    """

    testCase """
      implicit block anonymous
      ---
      function
        x := 5
        x*x
      ---
      (function() {
        const x = 5
        return x*x
      })
    """

    testCase """
      separate lines assigned
      ---
      f := function
        x := 5
        x*x
      ---
      const f = function() {
        const x = 5
        return x*x
      }
    """

  describe "@params", ->
    testCase """
      empty function body
      ---
      (@a, @b) ->
      ---
      (function(a, b) {this.a = a;this.b = b;})
    """

    testCase """
      keyword @ params
      ---
      (@var) ->
      ---
      (function(_var) {this.var = _var;})
    """

    testCase """
      local reference
      ---
      (@a, @b) ->
        a++
      ---
      (function(a1, b) {
        this.a = a1;
        this.b = b;
        return a++
      })
    """

    testCase """
      object binding pattern with alias
      ---
      ({@a, @b}) ->
        a
      ---
      (function({a: a1, b}) {
        this.a = a1;
        this.b = b;
        return a
      })
    """

    testCase """
      array binding pattern with alias
      ---
      ([@a, @b]) ->
        a
      ---
      (function([a1, b]) {
        this.a = a1;
        this.b = b;
        return a
      })
    """

    testCase """
      short fat arrow
      ---
      (@a) => 1
      ---
      (a) => {this.a = a;return  1}
    """

  describe "^pin params", ->
    testCase """
      empty function body
      ---
      (^a, ^b) ->
      ---
      (function(a1, b1) {a = a1;b = b1;})
    """

    testCase """
      local reference
      ---
      (^a, ^b.c) ->
        a++
      ---
      (function(a1, pin) {
        a = a1;
        b.c = pin;
        return a++
      })
    """

    testCase """
      object binding pattern with alias
      ---
      ({^a, b: ^b}) ->
        a
      ---
      (function({a: a1, b: b1}) {
        a = a1;
        b = b1;
        return a
      })
    """

    testCase """
      array binding pattern with alias
      ---
      ([^a, ^b]) ->
        a
      ---
      (function([a1, b1]) {
        a = a1;
        b = b1;
        return a
      })
    """

    testCase """
      short fat arrow
      ---
      (^a) => 1
      ---
      (a1) => {a = a1;return  1}
    """

    testCase """
      typed
      ---
      function initialize(^options: Options)
      ---
      function initialize(options1: Options){options = options1;}
    """

  describe "named destructured parameters", ->
    testCase """
      named object
      ---
      function Comp(props^{x, y})
      ---
      function Comp(props){const {x, y} = props;}
    """

    testCase """
      named object with type
      ---
      function Comp(props^{x, y}: {x: number, y: number})
      ---
      function Comp(props: {x: number, y: number}){const {x, y} = props;}
    """

    testCase """
      named object with subtypes
      ---
      function Comp(props^{x:: number, y:: number})
      ---
      function Comp(props: {x: number, y: number}){const {x, y} = props;}
    """

    testCase """
      named array
      ---
      function f(array^[first, ...])
      ---
      function f(array){const [first, ...ref] = array;}
    """

    testCase """
      object inside array
      ---
      function f(array^[first^{x, y}, ...])
      ---
      function f(array){const [first, ...ref] = array, {x, y} = first;}
    """

    testCase """
      array inside object
      ---
      function Comp(props^{array: array^[first, ...]})
      ---
      function Comp(props){const {array: array} = props, [first, ...ref] = array;}
    """

    testCase """
      named properties of object
      ---
      function Comp1(props^{array^: [lead, ...], x^, name^: {first, last, suffix^: {jr}}})
      function Comp2({array^: [lead, ...], x^, name^: {first, last, suffix^: {jr}}})
      ---
      function Comp1(props){const {array, x, name} = props, [lead, ...ref] = array, {first, last, suffix} = name, {jr} = suffix;}
      function Comp2({array, x, name}){const [lead, ...ref1] = array, {first, last, suffix} = name, {jr} = suffix;}
    """

  testCase """
    longhand
    ---
    function()
      x
    ---
    (function() {
      return x
    })
  """

  testCase """
    longhand with braces
    ---
    function() {
      x
    }
    ---
    (function() {
      return x
    })
  """

  testCase """
    longhand with inline braces
    ---
    function() { x }
    ---
    (function() { return x })
  """

  testCase """
    anonymous single-line longhand
    ---
    function do console.log "Anonymous"
    ---
    (function()  {{ return console.log("Anonymous") } })
  """

  testCase """
    argumentless single-line longhand
    ---
    function f do console.log "Anonymous"
    ---
    function f()  {{ return console.log("Anonymous") } }
  """

  testCase """
    single-line longhand
    ---
    function f(x) do console.log x
    ---
    function f(x) { { return console.log(x) } }
  """

  testCase """
    return
    ---
    (x) ->
      return x
    ---
    (function(x) {
      return x
    })
  """

  testCase """
    fat arrow
    ---
    () => x
    (x) => x
    ---
    () => x;
    (x) => x
  """

  testCase """
    fat arrow nested body
    ---
    x = =>
      x x
    ---
    x = () => {
      return x(x)
    }
  """

  testCase """
    fat arrow with expressionizable statement body
    ---
    => throw new Error
    ---
    () => { throw new Error }
  """

  testCase """
    fat arrow nested body with same line closing parenthesis
    ---
    g( =>
      x)
    ---
    g( () => {
      return x
    })
  """

  testCase """
    fat arrow body with inline closing bracket
    ---
    [ =>
      1+2]
    ---
    [ () => {
      return 1+2
    }]
  """

  testCase """
    fat interprets single arg without parens as function application
    ---
    x => 5
    ---
    x(() => 5)
  """

  testCase """
    fat arrow nested body with multiple statements
    ---
    x = =>
      x x
      a
      b
    ---
    x = () => {
      x(x)
      a
      return b
    }
  """

  testCase """
    fat arrow empty block
    ---
    x = =>
    ---
    x = () => {}
  """

  testCase """
    fat arrow return
    ---
    x = =>
      return x
    ---
    x = () => {
      return x
    }
  """

  testCase """
    fat arrow return
    ---
    x = (a, b) =>
      c := a + b
      return c
    ---
    x = (a, b) => {
      const c = a + b
      return c
    }
  """

  testCase """
    decs inside function
    ---
    function f() {
      var x = 3
    }
    ---
    function f() {
      var x = 3;return x
    }
  """

  testCase """
    implicit return braceless object
    ---
    ->
      a: 1
    ---
    (function() {
      return ({a: 1})
    })
  """

  testCase """
    return nested braceless object
    ---
    config = ->
      return
        a: x
        b: y
    ---
    config = function() {
      return {
        a: x,
        b: y,
      }
    }
  """

  testCase """
    return nested braceless object with methods
    ---
    config = ->
      return
        a: getA()
        b: getB()
    ---
    config = function() {
      return {
        a: getA(),
        b: getB(),
      }
    }
  """

  testCase """
    rest parameter
    ---
    (a, b, ...c) ->
      c
    ---
    (function(a, b, ...c) {
      return c
    })
  """

  throws """
    double rest parameter
    ---
    (a, ...b, ...c) ->
      c
    ---
    ParseErrors: unknown:2:8 Only one rest parameter is allowed
  """

  testCase """
    non-end rest parameter
    ---
    (a, b, ...c, d) ->
      c
    ---
    (function(a, b, ...c) {
      let [d] = c.splice(-1);
      return c
    })
  """

  throws """
    non-end destructuring rest parameter
    ---
    (a, ...[b, c], d) ->
      d
    ---
    ParseErrors: unknown:1:4 Non-end rest parameter cannot be binding pattern
  """

  testCase """
    non-end @ rest parameter
    ---
    (a, b, ...@c, d) ->
      [@c, d]
    ---
    (function(a, b, ...c) {
      let [d] = c.splice(-1);
      this.c = c;
      return [this.c, d]
    })
  """

  testCase """
    empty rest parameter
    ---
    (a, ...) ->
      a
    ---
    (function(a, ...ref) {
      return a
    })
  """

  testCase """
    empty non-end rest parameter
    ---
    (a, ..., b) ->
      b
    ---
    (function(a, ...ref) {
      let [b] = ref.splice(-1);
      return b
    })
  """

  testCase """
    rest element in parameter
    ---
    ([a, b, ...c]) ->
      c
    ---
    (function([a, b, ...c]) {
      return c
    })
  """

  testCase """
    non-end rest element
    ---
    ([a, b, ...c, d]) ->
      c
    ---
    (function([a, b, ...c]) {
      let [d] = c.splice(-1);
      return c
    })
  """

  testCase """
    multiple nested rest elements
    ---
    ([a, b, ...c, [d, ...e, f]]) ->
      e
    ---
    (function([a, b, ...c]) {
      let [[d, ...e]] = c.splice(-1);
      let [f] = e.splice(-1);
      return e
    })
  """

  testCase """
    reorders non-end position binding rest property
    ---
    ({a, b, ...c, d}) ->
      c
    ---
    (function({a, b, d, ...c}) {
      return c
    })
  """

  testCase """
    allows trailing dots for binding rest property
    ---
    ({a, b, c..., d}) ->
      c
    ---
    (function({a, b, d, ...c}) {
      return c
    })
  """

  testCase """
    non-end rest element inside object
    ---
    ({a, b, c: [c, ...d, e]}) ->
      d
    ---
    (function({a, b, c: [c, ...d]}) {
      let [e] = d.splice(-1);
      return d
    })
  """

  testCase """
    non-end rest element inside object with non-end rest property
    ---
    ({a, b..., c: [d, ...e, f]}) ->
      x
    ---
    (function({a, c: [d, ...e], ...b}) {
      let [f] = e.splice(-1);
      return x
    })
  """

  testCase """
    non-end at identifier rest element inside object
    ---
    ({a, b, c: [c, ...@d, e]}) ->
      [@d, e]
    ---
    (function({a, b, c: [c, ...d]}) {
      let [e] = d.splice(-1);
      this.d = d;
      return [this.d, e]
    })
  """

  testCase """
    very nested non-end rest elements with at identifiers
    ---
    function ({x: [a, b, ...@c, [{d: {y: [@z1, @z2..., @z3]}}, ...@e, f]]})
      [@c, @e, f]
    ---
    (function ({x: [a, b, ...c]}) {
      let [[{d: {y: [z1, ...z2]}}, ...e]] = c.splice(-1);
      let [z3] = z2.splice(-1);
      let [f] = e.splice(-1);
      this.c = c;
      this.z1 = z1;
      this.z2 = z2;
      this.z3 = z3;
      this.e = e;
      return [this.c, this.e, f]
    })
  """

  testCase """
    nested property at binding
    ---
    ({@a, b: {c, @d}}) ->
      [@a, @d]
    ---
    (function({a, b: {c, d}}) {
      this.a = a;
      this.d = d;
      return [this.a, this.d]
    })
  """

  testCase """
    multiple binding properties on one line
    ---
    ({
      b, c
    }: d) =>
      e
    ---
    ({
      b, c
    }: d) => {
      return e
    }
  """

  testCase """
    braces on following line
    ---
    export function resolve(specifier: string, context: any, next: any)
      { parentURL = baseURL } := context
    ---
    export function resolve(specifier: string, context: any, next: any) {
      const { parentURL = baseURL } = context;return { parentURL }
    }
  """

  testCase """
    nested block returning arrow function
    ---
    function test(a)
      a = simplify a
      (x) => x+a
    ---
    function test(a) {
      a = simplify(a)
      return (x) => x+a
    }
  """

  testCase """
    nested block returning negated identifier
    ---
    function test(a)
      a = simplify a
      !a
    ---
    function test(a) {
      a = simplify(a)
      return !a
    }
  """

  describe "indented parameters", ->
    testCase """
      mixed
      ---
      (
        a, b
        c, d
      ) => null
      ---
      (
        a, b,
        c, d
      ) => null
    """

    testCase """
      ...rest
      ---
      foo := (
        x
        ...rest
      ) -> null
      ---
      const foo = function(
        x,
        ...rest
      ) { return null }
    """

    testCase """
      rest...
      ---
      foo := (
        x
        rest...
      ) -> null
      ---
      const foo = function(
        x,
        ...rest
      ) { return null }
    """

    testCase """
      indented with types
      ---
      function f<T>(
        t:
          item: T
        u:
          item: T
      )
      ---
      function f<T>(
        t: {
          item: T
        },
        u: {
          item: T
        }
      ){}
    """

    testCase """
      indented with assignments
      ---
      function f(
        x = 0
        y = 1
      )
      ---
      function f(
        x = 0,
        y = 1
      ){}
    """

    testCase """
      indented with assignments and types
      ---
      function f(
        x : number = 0
        y : number = 1
      )
      ---
      function f(
        x : number = 0,
        y : number = 1
      ){}
    """

  describe "implicit returns", ->
    testCase """
      basic
      ---
      (x) ->
        x
      ---
      (function(x) {
        return x
      })
    """

    testCase """
      one liner
      ---
      (x) -> x
      ---
      (function(x) { return x })
    """

    testCase """
      semicolon
      ---
      (x) ->
        x;
      ---
      (function(x) {
        x;
      })
    """

    testCase """
      declaration with semicolon
      ---
      (x) ->
        var x = 5;
      ---
      (function(x) {
        var x = 5;
      })
    """

    testCase """
      one liner with semicolon
      ---
      (x) -> x;
      ---
      (function(x) { x; })
    """

    testCase """
      fat one liner with semicolon
      ---
      (x) => x;
      ---
      (x) => { x; }
    """

    testCase """
      postfixed one liner with semicolon
      ---
      (x) -> x while y;
      ---
      (function(x) { while (y) { x }; })
    """

    testCase """
      fat postfixed one liner with semicolon
      ---
      (x) => x while y;
      ---
      (x) => { while (y) { x }; }
    """

    testCase """
      inline multi-statement
      ---
      -> $2.implicit = $1.generated; $2
      ---
      (function() { $2.implicit = $1.generated; return $2 })
    """

    testCase """
      inline multi-statement with semicolon
      ---
      -> $2.implicit = $1.generated; $2;
      ---
      (function() { $2.implicit = $1.generated; $2; })
    """

    testCase """
      const declaration
      ---
      ->
        fn2 := () ->
          x
      ---
      (function() {
        const fn2 = function() {
          return x
        };return fn2
      })
    """

    testCase """
      renamed declaration
      ---
      ->
        {x: y} := obj
      ---
      (function() {
        const {x: y} = obj;return {y}
      })
    """

    testCase """
      expanded property declaration
      ---
      ->
        {x: [y]} := obj
      ---
      (function() {
        const {x: [y]} = obj;return {x: [y]}
      })
    """

    testCase """
      initialized property declaration
      ---
      ->
        {x = 5, @y = 10, z: zz = 15} := obj
      ---
      (function() {
        const {x = 5, y = 10, z: zz = 15} = obj;this.y = y;;return {x, y, zz}
      })
    """

    testCase """
      complex declaration
      ---
      ->
        [ { x: other, y = init, ...r, }, z = 0, ...rest ] := list
      ---
      (function() {
        const [ { x: other, y = init, ...r }, z = 0, ...rest ] = list;return [ { other, y, ...r }, z, ...rest ]
      })
    """

    testCase """
      nested implicit return fat arrow
      ---
      function g() {
        function f() {
          y((node) =>
              x)
        }
      }
      ---
      function g() {
        function f() {
          return y((node) => {
              return x
          })
        };return f
      }
    """

    testCase """
      one-line function adds braces
      ---
      (x) => if (x) function f() { x }
      ---
      (x) => { if (x) { function f() { return x };return f};return }
    """

    testCase """
      inline multi-statement longhand
      ---
      function() { $2.implicit = $1.generated; $2 }
      ---
      (function() { $2.implicit = $1.generated; return $2 })
    """

    testCase """
      empty statement
      ---
      ->
        ;
      ---
      (function() {
        ;
      })
    """

    testCase """
      parens
      ---
      (x) ->
        (x)
      ---
      (function(x) {
        return (x)
      })
    """

    testCase """
      parens and multiple statements
      ---
      (x) ->
        (x)
        a
        b
      ---
      (function(x) {
        (x)
        a
        return b
      })
    """

    testCase """
      multiple statements with middle semicolon
      ---
      (x) ->
        a;
        b
      ---
      (function(x) {
        a;
        return b
      })
    """

    testCase """
      multiple statements with final semicolon
      ---
      (x) ->
        a
        b;
      ---
      (function(x) {
        a
        b;
      })
    """

    testCase """
      loop
      ---
      (x) ->
        loop
          x
      ---
      (function(x) {
        while(true) {
          x
        }
      })
    """

    testCase """
      loop with break
      ---
      (x) ->
        loop
          if cond()
            x
          else
            break
      ---
      (function(x) {
        const results=[];while(true) {
          if (cond()) {
            results.push(x)
          }
          else {
            break
          }
        };return results;
      })
    """

    testCase """
      loop with loop
      ---
      (x) ->
        loop
          break if done()
          if cond()
            x
          else
            loop
              x
      ---
      (function(x) {
        const results=[];while(true) {
          if (done()) { break }
          if (cond()) {
            results.push(x)
          }
          else {
            while(true) {
              x
            }
          }
        };return results;
      })
    """

    testCase """
      loop with assignment
      ---
      (x) ->
        loop
          break if cond()
          y := x
      ---
      (function(x) {
        const results=[];while(true) {
          if (cond()) { break }
          const y = x;results.push(y)
        };return results;
      })
    """

    testCase """
      while
      ---
      (x) ->
        while x
          x
      ---
      (function(x) {
        const results=[];while (x) {
          results.push(x)
        };return results;
      })
    """

    testCase """
      for in
      ---
      (x) ->
        for k in x
          k
      ---
      (function(x) {
        const results=[];for (const k in x) {
          results.push(k)
        };return results;
      })
    """

    testCase """
      nested for loops
      ---
      (x) ->
        for i = 0; i < x.length; i++
          for v of x[i]
            v + 1
      ---
      (function(x) {
        const results=[];for (i = 0; i < x.length; i++) {
          const results1=[];for (const v of x[i]) {
            results1.push(v + 1)
          }results.push(results1)
        };return results;
      })
    """

    testCase """
      nested for loops, inner postfix
      ---
      (x) ->
        for i = 0; i < x.length; i++
          v + 1 for v of x[i]
      ---
      (function(x) {
        const results=[];for (i = 0; i < x.length; i++) {
          const results1=[];for (const v of x[i]) { results1.push(v + 1) }results.push(results1)
        };return results;
      })
    """

    testCase """
      nested for loops with labels
      ---
      (x) ->
        :outer for i = 0; i < x.length; i++
          :inner for v of x[i]
            break outer unless v?
            v + 1
      ---
      (function(x) {
        const results=[];outer: for (i = 0; i < x.length; i++) {
          const results1=[];inner: for (const v of x[i]) {
            if (!(v != null)) { break outer }
            results1.push(v + 1)
          }results.push(results1)
        };return results;
      })
    """

    testCase """
      void
      ---
      (x): void ->
        console.log x
      ---
      (function(x): void {
        console.log(x)
      })
    """

    testCase """
      void longhand
      ---
      function(x): void
        console.log x
      ---
      (function(x): void {
        console.log(x)
      })
    """

    testCase """
      explicit async Promise<void>
      ---
      async (x): Promise<void> ->
        await fetch x
      ---
      (async function(x): Promise<void> {
        await fetch(x)
      })
    """

    testCase """
      implicit async Promise<void>
      ---
      (x): Promise<void> ->
        await fetch x
      ---
      (async function(x): Promise<void> {
        await fetch(x)
      })
    """

    testCase """
      implicit async Promise<void> longhand
      ---
      function(x): Promise<void>
        await fetch x
      ---
      (async function(x): Promise<void> {
        await fetch(x)
      })
    """

    testCase """
      implicit async Promise void longhand
      ---
      function(x): Promise void
        await fetch x
      ---
      (async function(x): Promise<void> {
        await fetch(x)
      })
    """

    testCase """
      no async Promise<void>
      ---
      (x): Promise<void> ->
        fetch x
      ---
      (function(x): Promise<void> {
        return fetch(x)
      })
    """

    testCase """
      no async Promise<void> fat
      ---
      (x): Promise<void> =>
        fetch x
      ---
      (x): Promise<void> => {
        return fetch(x)
      }
    """

    testCase """
      no async Promise<void> longhand
      ---
      function(x): Promise<void>
        fetch x
      ---
      (function(x): Promise<void> {
        return fetch(x)
      })
    """

    testCase """
      implicit * Iterator<*, void>
      ---
      (x): Iterator<any, void, any> ->
        yield x
      ---
      (function*(x): Iterator<any, void, any> {
        yield x
      })
    """

    testCase """
      implicit * Generator<*, void> longhand
      ---
      function(x): Generator<any, void>
        yield x
      ---
      (function*(x): Generator<any, void> {
        yield x
      })
    """

    testCase """
      no * Iterator<*, void>
      ---
      (x): Iterator<any, void> ->
        fetch x
      ---
      (function(x): Iterator<any, void> {
        return fetch(x)
      })
    """

    testCase """
      no * Generator<*, void> longhand
      ---
      function(x): Generator<any, void>
        fetch x
      ---
      (function(x): Generator<any, void> {
        return fetch(x)
      })
    """

    testCase """
      async generator implicit
      ---
      f1 := ->
        await Promise.resolve()
        yield 5
      ---
      const f1 = async function*() {
        await Promise.resolve()
        yield 5
      }
    """

    testCase """
      async generator implicit with void return type
      ---
      f1 := :AsyncGenerator<number, void> ->
        await Promise.resolve()
        yield 5
      ---
      const f1 = async function*():AsyncGenerator<number, void> {
        await Promise.resolve()
        yield 5
      }
    """

    testCase """
      async generator pass through
      ---
      function f(): AsyncGenerator<number, void>
        makeGenerator()
      ---
      function f(): AsyncGenerator<number, void> {
        return makeGenerator()
      }
    """

    testCase """
      async iterator
      ---
      f2 := :AsyncIterator<number, void> ->
        await Promise.resolve()
        yield 5
      ---
      const f2 = async function*():AsyncIterator<number, void> {
        await Promise.resolve()
        yield 5
      }
    """

    testCase """
      one-line fat arrow with void
      ---
      (x): void => console.log x
      ---
      (x): void => { console.log(x)}
    """

    testCase """
      nested anonymous function
      ---
      (x) ->
        (y) ->
          y
      ---
      (function(x) {
        return (function(y) {
          return y
        })
      })
    """

    testCase """
      fat arrow
      ---
      (x) =>
        x
      ---
      (x) => {
        return x
      }
    """

    testCase """
      arrow function with object literal
      ---
      () => a: b
      ---
      () =>( {a: b})
    """

    testCase """
      void fat arrow
      ---
      (x): void =>
        console.log x
      ---
      (x): void => {
        console.log(x)
      }
    """

    testCase """
      async Promise<void> fat arrow
      ---
      run := async (command: string): Promise<void> =>
        await exec command
      ---
      const run = async (command: string): Promise<void> => {
        await exec(command)
      }
    """

    testCase """
      binding object pattern params
      ---
      {a, b} ->
        a
      {a, b} =>
        a
      ---
      (function({a, b}) {
        return a
      });
      ({a, b}) => {
        return a
      }
    """

    testCase """
      binding array pattern params
      ---
      [a, b] ->
        a
      [a, b] =>
        a
      ---
      (function([a, b]) {
        return a
      });
      ([a, b]) => {
        return a
      }
    """

    testCase """
      add implicit return even if an explicit return is present
      ---
      (x) ->
        return x if c
        a
        b
      ---
      (function(x) {
        if (c) { return x }
        a
        return b
      })
    """

    testCase """
      return before hoisted function
      ---
      function find(x)
        return recurse x
        function recurse(y)
          return unless y?
          y.forEach recurse
      ---
      function find(x) {
        return recurse(x)
        function recurse(y) {
          if (!(y != null)) { return }
          return y.forEach(recurse)
        }
      }
    """

    testCase """
      function declaration in loop
      ---
      (x) =>
        for i of x
          function f()
            i
      ---
      (x) => {
        const results=[];for (const i of x) {
          function f() {
            return i
          };results.push(f)
        };return results;
      }
    """

    testCase """
      const shorthand
      ---
      (x) ->
        a := x
      ---
      (function(x) {
        const a = x;return a
      })
    """

    testCase """
      const declaration
      ---
      (x) ->
        const a = 3, b = 4
      ---
      (function(x) {
        const a = 3, b = 4;return b
      })
    """

    testCase """
      var declaration
      ---
      (x) ->
        var a = 3, b = 4
      ---
      (function(x) {
        var a = 3, b = 4;return b
      })
    """

    testCase """
      let declaration
      ---
      (x) ->
        let a = 3, b = 4
      ---
      (function(x) {
        let a = 3, b = 4;return b
      })
    """

    testCase """
      destructuring declaration
      ---
      (x) ->
        {a, b: c, d: [,e]} := x
      ---
      (function(x) {
        const {a, b: c, d: [,e]} = x;return {a, c, d: [,e]}
      })
    """

    testCase """
      number literal
      ---
      (x) ->
        5
      ---
      (function(x) {
        return 5
      })
    """

    testCase """
      expression
      ---
      (x) ->
        5 + 5
      ---
      (function(x) {
        return 5 + 5
      })
    """

    testCase """
      one-line postfix if
      ---
      (x) -> a if x
      ---
      (function(x) { if (x) { return a };return })
    """

    testCase """
      fat one-line postfix if
      ---
      (x) => a if x
      ---
      (x) => { if (x) { return a };return }
    """

    testCase """
      one-line if/else
      ---
      (x) -> if x then a else b
      ---
      (function(x) { if (x) { return a} else return b })
    """

    testCase """
      fat one-line if/else
      ---
      (x) => if x then a else b
      ---
      (x) => { if (x) { return a} else return b }
    """

    testCase """
      if/else
      ---
      (x) ->
        if x
          a
        else
          b
      ---
      (function(x) {
        if (x) {
          return a
        }
        else {
          return b
        }
      })
    """

    testCase """
      if without else
      ---
      (x) ->
        if x
          a
      ---
      (function(x) {
        if (x) {
          return a
        };return
      })
    """

    testCase """
      if with empty object literal
      ---
      (x) ->
        if x
          {}
      ---
      (function(x) {
        if (x) {
          return ({})
        };return
      })
    """

    testCase """
      nested if else
      ---
      (x) ->
        if x
          if y
            a
          else
            if z
              b
        else
          c
      ---
      (function(x) {
        if (x) {
          if (y) {
            return a
          }
          else {
            if (z) {
              return b
            };return
          }
        }
        else {
          return c
        }
      })
    """

    testCase """
      if else if
      ---
      (x) ->
        if x
          a
        else if y
          b
        else if z
          c
      ---
      (function(x) {
        if (x) {
          return a
        }
        else if (y) {
          return b
        }
        else if (z) {
          return c
        };return
      })
    """

    testCase """
      unless
      ---
      (x) ->
        unless x
          a
      ---
      (function(x) {
        if (!x) {
          return a
        };return
      })
    """

    testCase """
      switch
      ---
      (x) ->
        switch x
          when 1
            a
          when 2
            b
          default
            c()
            d
      ---
      (function(x) {
        switch(x) {
          case 1: {
            return a
          }
          case 2: {
            return b
          }
          default:
            c()
            return d
        }
      })
    """

    testCase """
      switch with empty when body
      ---
      (x) ->
        switch x
          when 1
            a
          when 2
          when 3
            b
      ---
      (function(x) {
        switch(x) {
          case 1: {
            return a
          }
          case 2: {return
          }
          case 3: {
            return b
          }
        }
      })
    """

    testCase """
      switch with blocks
      ---
      (x) ->
        switch x
          when 1
            {
              let a = 2
              a
            }
      ---
      (function(x) {
        switch(x) {
          case 1: {
            {
              let a = 2
              return a
            }
          }
        }
      })
    """

    testCase """
      switch with else
      ---
      (x) ->
        switch x
          when 1
            a
          when 2
            b
          else
            c
      ---
      (function(x) {
        switch(x) {
          case 1: {
            return a
          }
          case 2: {
            return b
          }
          default: {
            return c
          }
        }
      })
    """

    testCase """
      new
      ---
      (x) -> new Foo
      ---
      (function(x) { return new Foo })
    """

    testCase """
      throw statement
      ---
      (x) ->
        throw new Error('x')
      ---
      (function(x) {
        throw new Error('x')
      })
    """

    testCase """
      debugger statement
      ---
      (x) ->
        debugger
      ---
      (function(x) {
        debugger
      })
    """

    testCase """
      try/catch
      ---
      (x) ->
        try
          a
        catch e
          b
      ---
      (function(x) {
        try {
          return a
        }
        catch (e) {
          return b
        }
      })
    """

    testCase """
      try without catch
      ---
      (x) ->
        try
          a
      ---
      (function(x) {
        try {
          return a
        } catch(e) {return}
      })
    """

    testCase """
      try without catch with finally
      ---
      (x) ->
        try
          a
        finally
          b
      ---
      (function(x) {
        try {
          return a
        }
        finally {
          b
        }
      })
    """

    testCase """
      loop with nested if with inline return
      ---
      ->
        while x
          if a return true
      ---
      (function() {
        const results=[];while (x) {
          if (a) { return true} else {results.push(void 0)}
        };return results;
      })
    """

    testCase """
      class method with Promise<void> return type
      ---
      class App
        async run(): Promise<void>
          await exec command
      ---
      class App {
        async run(): Promise<void> {
          await exec(command)
        }
      }
    """

    testCase """
      disable via -implicitReturns
      ---
      "civet -implicitReturns"
      => "one line still returns"
      =>
        notReturned()
      -> notReturned()
      ->
        notReturned()
      function() notReturned()
      function()
        notReturned()
      function()
        if x
          notReturned()
        else
          notReturned()
      ---
      () => "one line still returns";
      () => {
        notReturned()
      };
      (function() { notReturned() });
      (function() {
        notReturned()
      });
      (function() { notReturned() });
      (function() {
        notReturned()
      });
      (function() {
        if (x) {
          notReturned()
        }
        else {
          notReturned()
        }
      })
    """

  describe "return.value", ->
    testCase """
      return =
      ---
      function f
        return = 5
      ---
      function f() {
        let ret;
        ret = 5
        return ret
      }
    """

    testCase """
      return +=
      ---
      function f
        return = 5
        return += 5
      ---
      function f() {
        let ret;
        ret = 5
        ret += 5
        return ret
      }
    """

    testCase """
      return++
      ---
      function f
        return = 5
        return++
      ---
      function f() {
        let ret;
        ret = 5
        ret++
        return ret
      }
    """

    testCase """
      return.value =
      ---
      function f
        return.value = 5
      ---
      function f() {
        let ret;
        ret = 5
        return ret
      }
    """

    testCase """
      bare return
      ---
      function f(arg)
        return = 'default'
        return unless arg
        return = arg
      ---
      function f(arg) {
        let ret;
        ret = 'default'
        if (!arg) { return ret }
        ret = arg
        return ret
      }
    """

    testCase """
      existing ret
      ---
      function f(arg)
        ret := arg
        return = ret
      ---
      function f(arg) {
        let ret1;
        const ret = arg
        ret1 = ret
        return ret1
      }
    """

    testCase """
      return .=
      ---
      function f
        return .= 0
      ---
      function f() {
        let ret = 0
        return ret
      }
    """

    testCase """
      return.value .=
      ---
      function f
        return.value .= 0
      ---
      function f() {
        let ret = 0
        return ret
      }
    """

    testCase """
      return .= with type
      ---
      function f: Number
        return: number .= 0
      ---
      function f(): Number {
        let ret: number = 0
        return ret
      }
    """

    testCase """
      let return
      ---
      function f
        let return: number
      ---
      function f() {
        let ret: number
        return ret
      }
    """

    testCase """
      let return.value
      ---
      function f
        let return.value: number
      ---
      function f() {
        let ret: number
        return ret
      }
    """

    testCase """
      return.value typed by function
      ---
      function f: number
        return = 5
      ---
      function f(): number {
        let ret: number;
        ret = 5
        return ret
      }
    """

    testCase """
      return.value typed by function with arguments
      ---
      function dupem(thing: Record<string, string>): Record<string, string>
        return := {}
        for key, value in thing
          return.value[key] = value + value
      ---
      function dupem(thing: Record<string, string>): Record<string, string> {
        const ret: Record<string, string> = {}
        for (const key in thing) {const value = thing[key];
          ret[key] = value + value
        }
        return ret
      }
    """

    testCase """
      return.value typed by arrow function
      ---
      (): number =>
        return = 5
      ---
      (): number => {
        let ret: number;
        ret = 5
        return ret
      }
    """

    testCase """
      return.value typed by method
      ---
      {
        f(): number
          return = 5
      }
      ---
      ({
        f(): number {
          let ret: number;
          ret = 5
          return ret
        }
      })
    """

    testCase """
      return.value not typed for asserts
      ---
      function f(x): asserts x is number
        return = false
      ---
      function f(x): asserts x is number {
        let ret;
        ret = false
        return ret
      }
    """

    testCase """
      return.value typed boolean for is
      ---
      function f(x): x is number
        return = false
      ---
      function f(x): x is number {
        let ret: boolean;
        ret = false
        return ret
      }
    """

    testCase """
      return.value typed async
      ---
      (): number =>
        return = await 5
      ---
      type AutoPromise<T> = Promise<Awaited<T>>;
      async (): AutoPromise<number> => {
        let ret:Awaited<AutoPromise<number>>;
        ret = await 5
        return ret
      }
    """

    testCase """
      callable return.value
      ---
      function f
        return.value := ->
          console.log 'hi'
        return.value()
      ---
      function f() {
        const ret = function() {
          return console.log('hi')
        }
        ret()
        return ret
      }
    """

    testCase.skip """
      return.value parameter
      ---
      function f(return.value)
        console.log 'hi'
      ---
      function f(ret)
        console.log('hi')
        return ret
    """

    testCase """
      with pipes
      ---
      =>
        return := document.createElement 'div'

        document.createElement 'input'
          ||> .type = 'color'
          |> return.value.appendChild
      ---
      () => {
        const ret = document.createElement('div')

        let ref;(ref = document.createElement('input')).type = 'color';ret.appendChild(ref);return ret
      }
    """

    testCase """
      big example
      ---
      function f(list)
        for item of list
          if match item
            return = item
            break
        if return.value
          return += 1
        list.destroy()
      ---
      function f(list) {
        let ret;
        for (const item of list) {
          if (match(item)) {
            ret = item
            break
          }
        }
        if (ret) {
          ret += 1
        }
        list.destroy()
        return ret
      }
    """
