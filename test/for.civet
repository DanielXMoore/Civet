{testCase, throws} from ./helper.civet

describe "for", ->
  testCase """
    basic
    ---
    for (var i = 0; i < 10; i++) console.log(i)
    ---
    for (var i = 0; i < 10; i++) console.log(i)
  """

  testCase """
    basic braced
    ---
    for (var i = 0; i < 10; i++) {
      console.log(i)
    }
    ---
    for (var i = 0; i < 10; i++) {
      console.log(i)
    }
  """

  testCase """
    of
    ---
    for (a of x) console.log(i)
    ---
    for (const a of x) console.log(i)
  """

  testCase """
    of braced
    ---
    for (a of x) {
      console.log(i)
    }
    ---
    for (const a of x) {
      console.log(i)
    }
  """

  testCase """
    optional parens
    ---
    for var i = 0; i < 10; i++
      console.log(i)
    ---
    for (var i = 0; i < 10; i++) {
      console.log(i)
    }
  """

  testCase """
    empty
    ---
    for (;;)
      console.log("hi")
    ---
    for (;;) {
      console.log("hi")
    }
  """

  testCase """
    empty no parens
    ---
    for ;;
      console.log("hi")
    ---
    for (;;) {
      console.log("hi")
    }
  """

  testCase """
    empty body
    ---
    for x of y
    ---
    for (const x of y);
  """

  testCase """
    no space after of
    ---
    for x of$
    ---
    for (const x of $);
  """

  // TODO: This is dubious
  testCase """
    optional parens inline
    ---
    for var i = 0; i < 10; i++ console.log(i)
    ---
    for (var i = 0; i < 10; i++) console.log(i)
  """

  testCase """
    in
    ---
    for (var i in x) console.log(i)
    ---
    for (var i in x) console.log(i)
  """

  testCase """
    const of range one-line
    ---
    for (i of [1..10]) console.log(i)
    ---
    for (let i1 = 1; i1 <= 10; ++i1) {const i = i1; console.log(i)}
  """

  testCase """
    const of range
    ---
    for i of [1..10]
      console.log(i)
    ---
    for (let i1 = 1; i1 <= 10; ++i1) {const i = i1;
      console.log(i)
    }
  """

  testCase """
    var of range
    ---
    for var i of [1..10]
      console.log(i)
    ---
    for (let i1 = 1; i1 <= 10; ++i1) {var i = i1;
      console.log(i)
    }
  """

  testCase """
    let of range
    ---
    for let i of [1..10]
      console.log(i)
    ---
    for (let i1 = 1, i = i1; i1 <= 10; i = ++i1) {
      console.log(i)
    }
  """

  testCase """
    range with parenthetical inside
    ---
    for i of [1..10]
      (i)
    ---
    for (let i1 = 1; i1 <= 10; ++i1) {const i = i1;
      (i)
    }
  """

  testCase """
    range with access assignment
    ---
    for chosen[i] of [0...10]
    ---
    for (let i1 = 0; i1 < 10; ++i1) {chosen[i] = i1;;}
  """

  testCase """
    infinite range
    ---
    for i of [1..]
      console.log(i)
    ---
    for (let i1 = 1; ; ++i1) {const i = i1;
      console.log(i)
    }
  """

  testCase """
    range without declaration
    ---
    for [1..10]
      console.log("hello")
    ---
    for (let i = 1; i <= 10; ++i) {
      console.log("hello")
    }
  """

  testCase """
    exclusive range without declaration
    ---
    for [1...10]
      console.log("hello")
    ---
    for (let i = 1; i < 10; ++i) {
      console.log("hello")
    }
  """

  testCase """
    spaced exclusive range without declaration
    ---
    for [1 ... 10]
      console.log("hello")
    ---
    for (let i = 1; i <  10; ++i) {
      console.log("hello")
    }
  """

  testCase """
    infinite range without declaration
    ---
    for [1..]
      console.log("hello")
    ---
    for (let i = 1; ; ++i) {
      console.log("hello")
    }
  """

  throws """
    infinite range without for
    ---
    [1..]
    ---
    ParseErrors: unknown:1:3 Infinite range [x..] is only valid in for loops
  """

  testCase """
    double range without declaration
    ---
    => for [1..10] for [1..10]
      '*'
    ---
    () => { const results=[];for (let i = 1; i <= 10; ++i) { const results1=[];for (let i1 = 1; i1 <= 10; ++i1) {
      results1.push('*')
    }results.push(results1)};return results; }
  """

  testCase """
    for of character range
    ---
    for letter of ['a'..'z']
      letter
    ---
    for (let i = 97; i <= 122; ++i) {const letter = String.fromCharCode(i);
      letter
    }
  """

  testCase """
    for of character range with inequality
    ---
    for letter of ['a'<..<'z']
      letter
    ---
    for (let i = 97 + 1; i < 122; ++i) {const letter = String.fromCharCode(i);
      letter
    }
  """

  testCase """
    for each of character range
    ---
    for each letter of ['a'..'z']
      letter
    ---
    for (let i = 97; i <= 122; ++i) {const letter = String.fromCharCode(i);
      letter
    }
  """

  testCase """
    for range expression without body
    ---
    digits := for i of [1..9]
    ---
    const results=[];for (let i1 = 1; i1 <= 9; ++i1) {const i = i1;results.push(i)};const digits =results
  """

  describe "inequalities on range", ->
    testCase """
      ..<
      ---
      for i of [a..<b]
        i
      ---
      for (let i1 = a; i1 < b; ++i1) {const i = i1;
        i
      }
    """

    testCase """
      <..
      ---
      for i of [a<..b]
        i
      ---
      for (let i1 = a + 1; i1 <= b; ++i1) {const i = i1;
        i
      }
    """

    testCase """
      <..<
      ---
      for i of [a<..<b]
        i
      ---
      for (let i1 = a + 1; i1 < b; ++i1) {const i = i1;
        i
      }
    """

    throws """
      <..>
      ---
      for i of [a<..>b]
        i
      ---
      ParseErrors: unknown:1:13 <..> uses inconsistent < vs. >
    """

    testCase """
      ..>
      ---
      for i of [a..>b]
        i
      ---
      for (let i1 = a; i1 > b; --i1) {const i = i1;
        i
      }
    """

    testCase """
      >..
      ---
      for i of [a>..b]
        i
      ---
      for (let i1 = a + -1; i1 >= b; --i1) {const i = i1;
        i
      }
    """

    testCase """
      >..>
      ---
      for i of [a>..>b]
        i
      ---
      for (let i1 = a + -1; i1 > b; --i1) {const i = i1;
        i
      }
    """

  describe "binding left-hand side", ->
    testCase """
      a.b
      ---
      for a.b of x
        console.log(a)
      ---
      for (a.b of x) {
        console.log(a)
      }
    """

    testCase """
      array
      ---
      for [a.b] of x
        console.log(a)
      ---
      for ([a.b] of x) {
        console.log(a)
      }
    """

    testCase """
      this
      ---
      for @a of x
        console.log @a
      for [@a] of x
        console.log @a
      ---
      for (const a of x) {this.a = a;
        console.log(this.a)
      }
      for (const [a1] of x) {this.a = a1;
        console.log(this.a)
      }
    """

    testCase """
      splice
      ---
      for [first, ...middle, last] of x
        console.log first, middle, last
      ---
      for (const [first, ...middle] of x) {const [last] = middle.splice(-1);
        console.log(first, middle, last)
      }
    """

    testCase """
      named properties
      ---
      for props^{array^: [lead^{item}, ...], x^, name^: {first, last}} of y
      for let {array^: [lead^{item}, ...], x^, name^: {first, last}} of y
      ---
      for (const props of y) {const {array, x, name} = props, [lead, ...ref] = array, {item} = lead, {first, last} = name;;}
      for (let {array, x, name} of y) {let [lead, ...ref1] = array, {item} = lead, {first, last} = name;;}
    """

    testCase """
      in named properties
      ---
      for key^{length}, props^{array^: [lead^{item}, ...], x^, name^: {first, last}} in y
      ---
      for (const key in y) {const {length} = key;const props = y[key], {array, x, name} = props, [lead, ...ref] = array, {item} = lead, {first, last} = name;;}
    """

  testCase """
    in optional parens
    ---
    for var i in x
      console.log(i)
    ---
    for (var i in x) {
      console.log(i)
    }
  """

  testCase """
    of
    ---
    for (var i of x) console.log(i)
    ---
    for (var i of x) console.log(i)
  """

  testCase """
    of optional parens
    ---
    for var i of x
      console.log(i)
    ---
    for (var i of x) {
      console.log(i)
    }
  """

  testCase """
    in implied declaration
    ---
    for i in x
      console.log(i)
    ---
    for (const i in x) {
      console.log(i)
    }
  """

  testCase """
    of implied declaration
    ---
    for i of x
      console.log(i)
    ---
    for (const i of x) {
      console.log(i)
    }
  """

  testCase """
    of implied declaration with binding pattern
    ---
    for [i, j] of x
      console.log(i)
    ---
    for (const [i, j] of x) {
      console.log(i)
    }
  """

  testCase """
    of optional parens await
    ---
    for await var i of x
      console.log(i)
    ---
    for await (var i of x) {
      console.log(i)
    }
  """

  testCase """
    of with two implicit declarations
    ---
    for item, index of array
      console.log `${index}. ${item}`
    ---
    let i = 0;for (const item of array) {const index = i++;
      console.log(`${index}. ${item}`)
    }
  """

  testCase """
    of with two explicit declarations
    ---
    for var item, let index of array
      console.log `${index}. ${item}`
    ---
    let i = 0;for (var item of array) {let index = i++;
      console.log(`${index}. ${item}`)
    }
  """

  testCase """
    in with two implicit declarations
    ---
    for key, value in array
      console.log `${key}: ${value}`
    ---
    for (const key in array) {const value = array[key];
      console.log(`${key}: ${value}`)
    }
  """

  testCase """
    in with two explicit declarations
    ---
    for var key, let value in object
      console.log `${key}: ${value}`
    ---
    for (var key in object) {let value = object[key];
      console.log(`${key}: ${value}`)
    }
  """

  testCase """
    in with pattern matching key and value
    ---
    for var [a, b], let [x, y] in object
      console.log `${a}, ${b}: ${x}, ${y}`
    ---
    for (const key in object) {var [a, b] = key;let [x, y] = object[key];
      console.log(`${a}, ${b}: ${x}, ${y}`)
    }
  """

  testCase """
    in with two explicit declarations and complex object
    ---
    for var key, let value in getObject()
      console.log `${key}: ${value}`
    ---
    let ref;for (var key in ref = getObject()) {let value = ref[key];
      console.log(`${key}: ${value}`)
    }
  """

  describe "each..of", ->
    testCase """
      each still works as variable
      ---
      for each of array
        console.log each
      for each in object
        console.log each
      ---
      for (const each of array) {
        console.log(each)
      }
      for (const each in object) {
        console.log(each)
      }
    """

    testCase """
      each..of
      ---
      for each item of array
        console.log item
      ---
      for (let i = 0, len = array.length; i < len; i++) {const item = array[i];
        console.log(item)
      }
    """

    throws """
      foreach doesn't work
      ---
      foreach item of getArray()
        console.log item
      ---
      ParseError
    """

    testCase """
      each of with autolet
      ---
      "civet autoLet"
      for each e of array
        console.log e
      ---
      for (let i = 0, len = array.length; i < len; i++) {const e = array[i];
        console.log(e)
      }
    """

    testCase """
      each..of with complex expression
      ---
      for each item of getArray()
        console.log item
      ---
      for (let ref = getArray(), i = 0, len = ref.length; i < len; i++) {const item = ref[i];
        console.log(item)
      }
    """

    testCase """
      each..of with two implicit declarations
      ---
      for each item, index of getArray()
        console.log item
      ---
      for (let ref = getArray(), i = 0, len = ref.length; i < len; i++) {const index = i;const item = ref[i];
        console.log(item)
      }
    """

    testCase """
      each..of with two explicit declarations
      ---
      for each var item, let index of array
        console.log item
      ---
      for (let i = 0, len = array.length; i < len; i++) {let index = i;var item = array[i];
        console.log(item)
      }
    """

    throws """
      each..in
      ---
      for each key in object
        console.log key
      ---
      ParseErrors: unknown:1:5 'each' is only meaningful in for..of loops
    """

    throws """
      each..in line numbers
      ---
      if x
        x()
      for each key in object
        console.log key
      ---
      ParseErrors: unknown:3:5 'each' is only meaningful in for..of loops
    """

  describe "own..in", ->
    testCase """
      own still works as variable
      ---
      for own of array
        console.log own
      for own in object
        console.log own
      ---
      for (const own of array) {
        console.log(own)
      }
      for (const own in object) {
        console.log(own)
      }
    """

    testCase """
      own..in
      ---
      for own key in object
        console.log key
      ---
      var hasProp: <T>(object: T, prop: PropertyKey) => boolean = ({}.constructor as any).hasOwn;
      for (const key in object) {if (!hasProp(object, key)) continue;
        console.log(key)
      }
    """

    testCase """
      own..in with complex expression
      ---
      for own key in getObject()
        console.log key
      ---
      var hasProp: <T>(object: T, prop: PropertyKey) => boolean = ({}.constructor as any).hasOwn;
      let ref;for (const key in ref = getObject()) {if (!hasProp(ref, key)) continue;
        console.log(key)
      }
    """

    testCase """
      own..in with two implicit declarations
      ---
      for own key, value in object
        console.log key, value
      ---
      var hasProp: <T>(object: T, prop: PropertyKey) => boolean = ({}.constructor as any).hasOwn;
      for (const key in object) {if (!hasProp(object, key)) continue;const value = object[key];
        console.log(key, value)
      }
    """

    testCase """
      own..in with two implicit declarations and complex expression
      ---
      for own key, value in getObject()
        console.log key, value
      ---
      var hasProp: <T>(object: T, prop: PropertyKey) => boolean = ({}.constructor as any).hasOwn;
      let ref;for (const key in ref = getObject()) {if (!hasProp(ref, key)) continue;const value = ref[key];
        console.log(key, value)
      }
    """

    testCase """
      own..in with two explicit declarations
      ---
      for own var key, let value in object
        console.log key, value
      ---
      var hasProp: <T>(object: T, prop: PropertyKey) => boolean = ({}.constructor as any).hasOwn;
      for (var key in object) {if (!hasProp(object, key)) continue;let value = object[key];
        console.log(key, value)
      }
    """

  testCase """
    postfix
    ---
    console.log(i) for let i = 0; i < 10; i++
    ---
    for (let i = 0; i < 10; i++) { console.log(i) }
  """

  testCase """
    postfix for in
    ---
    console.log(i) for i in x
    ---
    for (const i in x) { console.log(i) }
  """

  testCase """
    postfix for of
    ---
    console.log(i) for i of x
    ---
    for (const i of x) { console.log(i) }
  """

  testCase """
    postfix for of with unindented next line
    ---
    console.log(i) for i of x
    nextLine
    ---
    for (const i of x) { console.log(i) }
    nextLine
  """

  testCase """
    postfix for of with dedented next line
    ---
    for x of y
      console.log(i) for i of x
    nextLine
    ---
    for (const x of y) {
      for (const i of x) { console.log(i) }
    }
    nextLine
  """

  describe "expression", ->
    testCase """
      basic
      ---
      x = for (let i = 0; i < 10; i++)
        i
      ---
      const results=[];for (let i = 0; i < 10; i++) {
        results.push(i)
      };x = results
    """

    testCase """
      inline body
      ---
      x = for (let i = 0; i < 10; i++) i
      ---
      const results=[];for (let i = 0; i < 10; i++) results.push(i);x = results
    """

    testCase """
      assignment expression in last statement
      ---
      x := for i .= 0; i < x; i += 1
        i
      ---
      const results=[];for (let i = 0; i < x; i += 1) {
        results.push(i)
      };const x =results
    """

    testCase """
      with results in scope
      ---
      x = for (let i = 0; i < 10; i++)
        results.push(i)
      ---
      const results1=[];for (let i = 0; i < 10; i++) {
        results1.push(results.push(i))
      };x = results1
    """

    testCase """
      if then else
      ---
      check :=
        for i of [0..7]
          if true then 'yes' else 'no'
      ---
      const results=[];
        for (let i1 = 0; i1 <= 7; ++i1) {const i = i1;
          if (true) { results.push('yes')} else results.push('no')
        };const check =results
    """

    testCase """
      pushing switch results
      ---
      x = for (let i = 0; i < 10; i++)
        switch i
          when 0 then 1
          when 1 then 2
          else 3; 4
      ---
      const results=[];for (let i = 0; i < 10; i++) {
        switch(i) {
          case 0: { results.push(1);break;
          }
          case 1: { results.push(2);break;
          }
          default: { 3; results.push(4) }
        }
      };x = results
    """

    testCase """
      two for..of
      ---
      z = for x of y
        x*x
      z = for x of y
        x*x
      ---
      const results=[];for (const x of y) {
        results.push(x*x)
      };z = results
      const results1=[];for (const x of y) {
        results1.push(x*x)
      };z = results1
    """

    testCase """
      async for
      ---
      async for x of y
        await x
      ---
      (async ()=>{const results=[];for (const x of y) {
        results.push(await x)
      }return results})()
    """

    testCase """
      trailing method calls
      ---
      sorted :=
        for item of list
          item.toString()
        .sort()
        .reverse()
      ---
      const sorted =
        (()=>{const results=[];for (const item of list) {
          results.push(item.toString())
        }return results})()
        .sort()
        .reverse()
    """

    testCase """
      trailing method calls after dedent
      ---
      sorted :=
        for item of list
          item.toString()
      .sort()
      .reverse()
      ---
      const sorted =
        (()=>{const results=[];for (const item of list) {
          results.push(item.toString())
        }return results})()
      .sort()
      .reverse()
    """

    testCase """
      of with two implicit declarations
      ---
      strings :=
        for item, index of array
          `${index}. ${item}`
      ---
      const results=[];let i = 0;
        for (const item of array) {const index = i++;
          results.push(`${index}. ${item}`)
        };const strings =results
    """

    testCase """
      of with two implicit declarations inside function with parens
      ---
      function f
        (for item, index of array
          `${index}. ${item}`
        )
      ---
      function f() {
        const results=[];let i = 0;for (const item of array) {const index = i++;
          results.push(`${index}. ${item}`)
        }return results
      }
    """

    testCase """
      of with two implicit declarations inside function in expression
      ---
      function f
        ['head'] ++ (for item, index of array
          `${index}. ${item}`
        )
      ---
      function f() {
        return ['head'].concat((()=>{const results=[];let i = 0;for (const item of array) {const index = i++;
          results.push(`${index}. ${item}`)
        }return results})())
      }
    """

    testCase """
      splice assignment
      ---
      args[i..i] =
        for each char of arg[1..]
          `-${char}`
      ---
      const results=[];
        for (let ref = arg.slice(1), i1 = 0, len = ref.length; i1 < len; i1++) {const char = ref[i1];
          results.push(`-${char}`)
        };args.splice(i, i + 1 - i, ...results)
    """

    testCase """
      trailing call expression
      ---
      for x of y
        x ** 2
      .toString()
      ---
      (()=>{const results=[];for (const x of y) {
        results.push(x ** 2)
      }return results})()
      .toString()
    """

    testCase """
      trailing pipeline
      ---
      for x of y
        x ** 2
      |> f
      ---
      f((()=>{const results=[];for (const x of y) {
        results.push(x ** 2)
      }return results})())
    """

    testCase """
      trailing pipeline assignment
      ---
      result = for x of y
        x ** 2
      |> f
      ---
      result = f((()=>{const results=[];for (const x of y) {
        results.push(x ** 2)
      }return results})())
    """

    testCase """
      trailing as
      ---
      result = for x of y
        x ** 2
      as number[]
      ---
      result = (()=>{const results=[];for (const x of y) {
        results.push(x ** 2)
      }return results})() as number[]
    """

    testCase """
      trailing operator
      ---
      result = for x of y
        x ** 2
      ++ [16, 25]
      ---
      result = (()=>{const results=[];for (const x of y) {
        results.push(x ** 2)
      }return results})()
      .concat([16, 25])
    """

    testCase """
      empty body in function
      ---
      => for x of y
      => for [x] of y
      ---
      () => { const results=[];for (const x of y) {results.push(x)};return results; };
      () => { const results1=[];for (const [x] of y) {results1.push([x])};return results1; }
    """

    testCase """
      assigned empty body
      ---
      result = for x of y
      ---
      const results=[];for (const x of y) {results.push(x)};result = results
    """

    testCase """
      parenthesized empty body
      ---
      (for x of y)
      ---
      const results=[];for (const x of y) {results.push(x)}results
    """

    testCase """
      parenthesized empty body with trailing whitespace
      ---
      (for x of y
        )
      ---
      const results=[];for (const x of y) {results.push(x)}results
    """

  testCase """
    for generator range expression without body
    ---
    numbers := for* i of [0..]
    ---
    const numbers = (function*(){for (let i1 = 0; ; ++i1) {const i = i1;yield i}})()
  """

  testCase """
    for generator
    ---
    for* x of y
      1
    |> f
    ---
    f((function*(){for (const x of y) {
      yield 1
    }})())
  """

  testCase """
    multiple for generators
    ---
    function double()
      for* x of y
        x
      for* x of y
        x
    ---
    function* double() {
      for (const x of y) {
        yield x
      }
      for (const x of y) {
        yield x
      }
    }
  """

  testCase """
    for generator with this
    ---
    function double()
      [
        for* x of y
          this.x
        for* x of y
          @x
      ]
    ---
    function double() {
      return [
        (function*(){for (const x of y) {
          yield this.x
        }}).bind(this)(),
        (function*(){for (const x of y) {
          yield this.x
        }}).bind(this)()
      ]
    }
  """

  testCase """
    for generator with arguments
    ---
    function f()
      return for* i of x
        arguments[i]
    ---
    function f() {
      return (function*(arguments){for (const i of x) {
        yield arguments[i]
      }})(arguments)
    }
  """

  testCase """
    break/continue with
    ---
    values := for x of y
      continue with null unless x?
      if(isNaN x) break with
        . "NaN"
      x+1
    ---
    let results;results=[];for (const x of y) {
      if (!(x != null)) { results.push(null);continue }
      if(isNaN(x)) { results = [
          "NaN"];break}
      results.push(x+1)
    };const values =results
  """

  throws """
    break/continue with outside expression context
    ---
    for x of y
      continue with null unless x?
      break with x
    ---
    ParseErrors: unknown:2:11 'continue with' outside of loop that returns a value
    unknown:3:8 'break with' outside of loop that returns a value
  """

  throws """
    break with inside switch
    ---
    =>
      for x of y
        switch x
          when 1
            break with x
    ---
    ParseErrors: unknown:5:14 'break with' outside of loop that returns a value
  """

  testCase """
    continue with inside switch
    ---
    =>
      for x of y
        switch x
          when 1
            continue with 0
        x
    ---
    () => {
      const results=[];for (const x of y) {
        switch(x) {
          case 1: { {
            results.push(0);continue}
          }
        }
        results.push(x)
      };return results;
    }
  """

  testCase """
    labelled break/continue with
    ---
    function f(arrays)
      :outer for array of arrays
        :inner for item of array
          break :outer with [] if item is "ABORT"
          continue outer with [] if item is "SKIP"
          break inner with [] if item is "abort"
          continue :outer with [] if item is "skip"
          break with [] if item is "abort"
          continue with [] if item is "skip"
          item * item
    ---
    function f(arrays) {
      let results;results=[];outer: for (const array of arrays) {
        let results1;results1=[];inner: for (const item of array) {
          if (item === "ABORT") { results = [];break outer }
          if (item === "SKIP") { results.push([]);continue outer }
          if (item === "abort") { results1 = [];break inner }
          if (item === "skip") { results.push([]);continue outer }
          if (item === "abort") { results1 = [];break }
          if (item === "skip") { results1.push([]);continue }
          results1.push(item * item)
        }results.push(results1)
      };return results;
    }
  """

  testCase """
    break with followed by binary op
    ---
    for x of y
      break with 5
    + 1
    ---
    (()=>{let results;results=[];for (const x of y) {
      results = 5;break
    }return results})()
    + 1
  """

  testCase """
    when
    ---
    bigSquares = for x of y when x > 5
      x*x
    ---
    const results=[];for (const x of y) {if (!(x > 5)) continue;
      results.push(x*x)
    };bigSquares = results
  """

  testCase """
    suffix with when
    ---
    bigSquares = (x*x for x of y when x > 5)
    ---
    bigSquares = (()=>{const results=[];for (const x of y) { if (!(x > 5)) continue;results.push(x*x) }return results})()
  """

  testCase """
    generator suffix with when
    ---
    bigSquares = (x*x for* x of y when x > 5)
    ---
    bigSquares = (function*(){for (const x of y) { if (!(x > 5)) continue;yield x*x }})()
  """

  describe "by", ->
    testCase """
      for of in variable range with literal step
      ---
      for a of [x..y] by 2
        console.log a
      ---
      for (let i = x; i <= y; i += 2) {const a = i;
        console.log(a)
      }
    """

    testCase """
      by when
      ---
      as := a for a of [x..y] by 2 when good a
      ---
      const as =(()=>{const results=[];for (let i = x; i <= y; i += 2) { const a = i;if (!good(a)) continue;results.push( a) }return results})()
    """

    testCase """
      for of range start and end variable with step
      ---
      for a of [x...y] by z
        console.log a
      ---
      for (let i = x; z !== 0 && (z > 0 ? i < y : i > y); i += z) {const a = i;
        console.log(a)
      }
    """

    testCase """
      for of range with ref start, end, step
      ---
      for a of [x()...y()] by z()
        console.log a
      ---
      for (let end = y(), i = x(), step = z(); step !== 0 && (step > 0 ? i < end : i > end); i += step) {const a = i;
        console.log(a)
      }
    """

  describe "reductions", ->
    testCase """
      still work as variables
      ---
      z = for some of y
      z = for every of y
      z = for count of y
      z = for sum of y
      z = for product of y
      z = for min of y
      z = for max of y
      z = for join of y
      ---
      const results=[];for (const some of y) {results.push(some)};z = results
      const results1=[];for (const every of y) {results1.push(every)};z = results1
      const results2=[];for (const count of y) {results2.push(count)};z = results2
      const results3=[];for (const sum of y) {results3.push(sum)};z = results3
      const results4=[];for (const product of y) {results4.push(product)};z = results4
      const results5=[];for (const min of y) {results5.push(min)};z = results5
      const results6=[];for (const max of y) {results6.push(max)};z = results6
      const results7=[];for (const join of y) {results7.push(join)};z = results7
    """

    testCase """
      empty body
      ---
      z = for some x of y
      z = for every x of y
      z = for count x of y
      z = for sum x of y
      z = for product x of y
      z = for min x of y
      z = for max x of y
      z = for join x of y
      ---
      let results=false;for (const x of y) {results = true; break};z = results
      let results1=true;for (const x of y) {results1 = false; break};z = results1
      let results2=0;for (const x of y) {++results2};z = results2
      let results3=0;for (const x of y) {results3 += x};z = results3
      let results4=1;for (const x of y) {results4 *= x};z = results4
      let results5=Infinity;for (const x of y) {results5 = Math.min(results5, x)};z = results5
      let results6=-Infinity;for (const x of y) {results6 = Math.max(results6, x)};z = results6
      let results7="";for (const x of y) {results7 += x};z = results7
    """

    testCase """
      indented body
      ---
      z = for some x of y
        f x
      z = for every x of y
        f x
      z = for count x of y
        f x
      z = for sum x of y
        f x
      z = for product x of y
        f x
      z = for min x of y
        f x
      z = for max x of y
        f x
      z = for join x of y
        f x
      ---
      let results=false;for (const x of y) {
        if (f(x)) {results = true; break}
      };z = results
      let results1=true;for (const x of y) {
        if (!f(x)) {results1 = false; break}
      };z = results1
      let results2=0;for (const x of y) {
        if (f(x)) ++results2
      };z = results2
      let results3=0;for (const x of y) {
        results3 += f(x)
      };z = results3
      let results4=1;for (const x of y) {
        results4 *= f(x)
      };z = results4
      let results5=Infinity;for (const x of y) {
        results5 = Math.min(results5, f(x))
      };z = results5
      let results6=-Infinity;for (const x of y) {
        results6 = Math.max(results6, f(x))
      };z = results6
      let results7="";for (const x of y) {
        results7 += f(x)
      };z = results7
    """

    testCase """
      expression context
      ---
      z or for some x of y
      z or for every x of y
      z or for count x of y
      z or for sum x of y
      z or for product x of y
      z or for min x of y
      z or for max x of y
      z or for join x of y
      ---
      z || (()=>{let results=false;for (const x of y) {results = true; break}return results})()
      z || (()=>{let results1=true;for (const x of y) {results1 = false; break}return results1})()
      z || (()=>{let results2=0;for (const x of y) {++results2}return results2})()
      z || (()=>{let results3=0;for (const x of y) {results3 += x}return results3})()
      z || (()=>{let results4=1;for (const x of y) {results4 *= x}return results4})()
      z || (()=>{let results5=Infinity;for (const x of y) {results5 = Math.min(results5, x)}return results5})()
      z || (()=>{let results6=-Infinity;for (const x of y) {results6 = Math.max(results6, x)}return results6})()
      z || (()=>{let results7="";for (const x of y) {results7 += x}return results7})()
    """

    testCase """
      unassigned
      ---
      for some x of y
      for every x of y
      for count x of y
      for sum x of y
      for product x of y
      for min x of y
      for max x of y
      for join x of y
      ---
      let results=false;for (const x of y) {results = true; break}results
      let results1=true;for (const x of y) {results1 = false; break}results1
      let results2=0;for (const x of y) {++results2}results2
      let results3=0;for (const x of y) {results3 += x}results3
      let results4=1;for (const x of y) {results4 *= x}results4
      let results5=Infinity;for (const x of y) {results5 = Math.min(results5, x)}results5
      let results6=-Infinity;for (const x of y) {results6 = Math.max(results6, x)}results6
      let results7="";for (const x of y) {results7 += x}results7
    """

    testCase """
      function context
      ---
      => for some x of y
      => for every x of y
      => for count x of y
      => for sum x of y
      => for product x of y
      => for min x of y
      => for max x of y
      => for join x of y
      ---
      () => { let results=false;for (const x of y) {results = true; break};return results; };
      () => { let results1=true;for (const x of y) {results1 = false; break};return results1; };
      () => { let results2=0;for (const x of y) {++results2};return results2; };
      () => { let results3=0;for (const x of y) {results3 += x};return results3; };
      () => { let results4=1;for (const x of y) {results4 *= x};return results4; };
      () => { let results5=Infinity;for (const x of y) {results5 = Math.min(results5, x)};return results5; };
      () => { let results6=-Infinity;for (const x of y) {results6 = Math.max(results6, x)};return results6; };
      () => { let results7="";for (const x of y) {results7 += x};return results7; }
    """

    testCase """
      postfix
      ---
      a := x for some x of y
      b := x for every x of y
      c := x for count x of y
      d := x for sum x of y
      e := x for product x of y
      f := x for min x of y
      g := x for max x of y
      h := x for join x of y
      ---
      const a =(()=>{let results=false;for (const x of y) { if ( x) {results = true; break} }return results})()
      const b =(()=>{let results1=true;for (const x of y) { if (! x) {results1 = false; break} }return results1})()
      const c =(()=>{let results2=0;for (const x of y) { if ( x) ++results2 }return results2})()
      const d =(()=>{let results3=0;for (const x of y) { results3 +=  x }return results3})()
      const e =(()=>{let results4=1;for (const x of y) { results4 *=  x }return results4})()
      const f =(()=>{let results5=Infinity;for (const x of y) { results5 = Math.min(results5,  x) }return results5})()
      const g =(()=>{let results6=-Infinity;for (const x of y) { results6 = Math.max(results6,  x) }return results6})()
      const h =(()=>{let results7="";for (const x of y) { results7 +=  x }return results7})()
    """

    testCase """
      each, implicit body
      ---
      a := for some each x of y
      b := for every each x of y
      c := for count each x of y
      d := for sum each x of y
      e := for product each x of y
      f := for min each x of y
      g := for max each x of y
      h := for join each x of y
      ---
      let results=false;for (let i = 0, len = y.length; i < len; i++) {const x = y[i];results = true; break};const a =results
      let results1=true;for (let i1 = 0, len1 = y.length; i1 < len1; i1++) {const x = y[i1];results1 = false; break};const b =results1
      let results2=0;for (let i2 = 0, len2 = y.length; i2 < len2; i2++) {const x = y[i2];++results2};const c =results2
      let results3=0;for (let i3 = 0, len3 = y.length; i3 < len3; i3++) {const x = y[i3];results3 += x};const d =results3
      let results4=1;for (let i4 = 0, len4 = y.length; i4 < len4; i4++) {const x = y[i4];results4 *= x};const e =results4
      let results5=Infinity;for (let i5 = 0, len5 = y.length; i5 < len5; i5++) {const x = y[i5];results5 = Math.min(results5, x)};const f =results5
      let results6=-Infinity;for (let i6 = 0, len6 = y.length; i6 < len6; i6++) {const x = y[i6];results6 = Math.max(results6, x)};const g =results6
      let results7="";for (let i7 = 0, len7 = y.length; i7 < len7; i7++) {const x = y[i7];results7 += x};const h =results7
    """

    testCase """
      for concat
      ---
      flat := for concat x of y
      numbers := for concat x of y
        [x, x+1]
      ---
      var concatAssign: <B, A extends {push: (this: A, b: B) => void} | (B extends unknown[] ? {push: (this: A, ...b: B) => void} : never)>(lhs: A, rhs: B) => A = (lhs, rhs) => (((rhs as any)?.[Symbol.isConcatSpreadable] ?? Array.isArray(rhs)) ? (lhs as any).push.apply(lhs, rhs as any) : (lhs as any).push(rhs), lhs);
      let results=[];for (const x of y) {concatAssign(results, x)};const flat =results
      let results1=[];for (const x of y) {
        concatAssign(results1, [x, x+1])
      };const numbers =results1
    """

    testCase """
      for first
      ---
      first := for first x of y
      positive := for first x of y when x > 0
      complex := for first x of y
        continue unless x > 0
        x * x
      ---
      let results=undefined;for (const x of y) {results = x; break};const first =results
      let results1=undefined;for (const x of y) {if (!(x > 0)) continue;results1 = x; break};const positive =results1
      let results2=undefined;for (const x of y) {
        if (!(x > 0)) { continue }
        results2 = x * x; break
      };const complex =results2
    """

    testCase """
      implicit body array destructuring
      ---
      total := for sum [,x] of y
      ---
      let results=0;for (const [,x] of y) {results += x};const total =results
    """

    testCase """
      implicit body object destructuring
      ---
      total := for sum {x: {y}} of z
      ---
      let results=0;for (const {x: {y}} of z) {results += y};const total =results
    """

    throws """
      implicit body multiple destructuring
      ---
      total := for sum [x, y, z] of w
      ---
      ParseErrors: unknown:1:22 Ignored binding in reduction loop with implicit body
      unknown:1:25 Ignored binding in reduction loop with implicit body
    """

    testCase """
      for in
      ---
      nonEmpty = for some x in y
      empty = for every x in y
      ---
      let results=false;for (const x in y) {results = true; break};nonEmpty = results
      let results1=true;for (const x in y) {results1 = false; break};empty = results1
    """

    testCase """
      for own in
      ---
      nonEmpty = for some own x in y
      empty = for every own x in y
      ---
      var hasProp: <T>(object: T, prop: PropertyKey) => boolean = ({}.constructor as any).hasOwn;
      let results=false;for (const x in y) {if (!hasProp(y, x)) continue;results = true; break};nonEmpty = results
      let results1=true;for (const x in y) {if (!hasProp(y, x)) continue;results1 = false; break};empty = results1
    """

    testCase """
      when
      ---
      nonZeroProd := for product item of array when item
      nonNullSOS := for sum item of array when item?
        item * item
      ---
      let results=1;for (const item of array) {if (!item) continue;results *= item};const nonZeroProd =results
      let results1=0;for (const item of array) {if (!(item != null)) continue;
        results1 += item * item
      };const nonNullSOS =results1
    """

    testCase """
      in postfix
      ---
      return false unless for every f of facesHit
      ---
      if (!(()=>{let results=true;for (const f of facesHit) {results = false; break}return results})()) { return false }
    """

    throws """
      for* with reduction
      ---
      for* sum x of y
      ---
      ParseErrors: unknown:1:6 Cannot use reduction (sum) with generators
    """

    throws """
      assigned for* with reduction
      ---
      z := for* sum x of y
      ---
      ParseErrors: unknown:1:11 Cannot use reduction (sum) with generators
    """

  describe "spreads", ->
    testCase """
      comma in body
      ---
      function concatPairs(pairs)
        for [x, y] of pairs
          x, y
      ---
      function concatPairs(pairs) {
        const results=[];for (const [x, y] of pairs) {
          results.push(x, y)
        };return results;
      }
    """

    testCase """
      spread in body
      ---
      function concat(arrays)
        for array of arrays
          ...array
      ---
      function concat(arrays) {
        const results=[];for (const array of arrays) {
          results.push(...array)
        };return results;
      }
    """

    testCase """
      reverse spread in body
      ---
      function concat(arrays)
        for array of arrays
          array ...
      ---
      function concat(arrays) {
        const results=[];for (const array of arrays) {
          results.push( ...array)
        };return results;
      }
    """

    testCase """
      multiple spreads in body
      ---
      result :=
        for item of items
          item.pre, ...item.mid, item.post, ... item.tail
      ---
      const results=[];
        for (const item of items) {
          results.push(item.pre, ...item.mid, item.post, ... item.tail)
        };const result =results
    """

    testCase """
      spread iteration
      ---
      function flatSquare(arrays)
        for array of arrays
          ... for item of array
            item * item
      ---
      function flatSquare(arrays) {
        const results=[];for (const array of arrays) {
           for (const item of array) {
            results.push(item * item)
          }
        };return results;
      }
    """

    throws """
      spread iteration without parent
      ---
      function flatSquare(arrays)
        ... for item of array
          item * item
      ---
      ParseErrors: unknown:2:3 Could not find ancestor of spread iteration
    """
