Hera from ../source/parser.hera
{parse} := Hera

gen from ../source/generate.coffee
assert from assert

{ writeFileSync } from fs

{prune} := gen

verbose := false
displayAST := false
cacheDebug := false

compare := (src: string, result: string, filename: string) ->
  let events
  let cacheActive = false

  stack := []
  logs := []
  caches := new Map

  events =
    enter: (ruleName, state) ->
      if cacheActive
        let cache = caches.get(ruleName)
        if cache
          if cache.has(state.pos)
            arrow := 'ðŸ’°'
            logs.push "".padStart(stack.length * 2, " ") + arrow + "   " + ruleName + ":" + state.pos
            const result = cache.get(state.pos)
            return {
              cache: result ? {...result} : result
            }

      arrow := String.fromCharCode(0x27A1)
      logs.push "".padStart(stack.length * 2, " ") + arrow + "   " + ruleName + ":" + state.pos
      stack.push ruleName
      return

    exit: (ruleName, state, result) ->
      if cacheActive
        let cache = caches.get(ruleName)
        if !cache
          switch ruleName
            case "TrackIndented", "Samedent", "IndentedFurther", "PushIndent", "PopIndent", "Nested", "InsertIndent"
            case "Arguments", "ArgumentsWithTrailingCallExpressions", "ImplicitApplication", "IndentedApplicationAllowed", "ApplicationStart"
            case "CallExpression", "CallExpressionRest", "LeftHandSideExpression", "ActualAssignment", "UpdateExpression"
            case "UnaryExpression", "BinaryOpExpression", "BinaryOpRHS", "ConditionalExpression", "ShortCircuitExpression"
            case "NestedPropertyDefinitions", "NestedObject", "NestedObjectLiteral"
            case "AssignmentExpressionTail", "AssignmentExpression", "ExtendedExpression", "Expression"
              debugger
              break
            else
              cache = new Map
              caches.set(ruleName, cache)

        if cache
          if result
            cache.set(state.pos, {...result})
          else
            cache.set(state.pos, result)

      // emoji check mark or cross mark based on result
      mark := result ? "âœ…" : "âŒ"
      leftArrow := String.fromCharCode(0x2B05)

      stack.pop()
      logs.push "".padStart(stack.length * 2, " ") + leftArrow + " " + mark + ruleName + ":" + state.pos
      return

  let ast
  try
    if cacheDebug
      cacheActive = true
      ast = parse(src, {filename, events})
      writeFileSync "parse-cache.log", logs.join("\n")
      logs.length = 0
      cacheActive = false
      ast = parse(src, {filename, events})
      writeFileSync "parse.log", logs.join("\n")
    else
      ast = parse(src, {filename, events})

    if displayAST
      console.dir ast, {depth: null}
  catch e
    debugger
    // console.log(logs.join("\n"))
    throw e

  assert.equal gen(ast, {}), result

testCase := (text: string) ->
  [desc, src, result] := text.split("\n---\n")

  it desc, ->
    compare src, result, desc

throws := (text: string) ->
  assert.throws ->
    gen(parse(text))

export {
  compare
  testCase
  throws
}
