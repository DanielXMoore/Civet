{ testCase } from ./helper.civet

describe "object comprehensions", ->
  testCase """
    basic
    ---
    {
      for x of [1, 2, 3]
        [x]:  2 * x
        [x * 2]: 4 * x
    }
    ---
    ({
      ...(()=>{const results={};for (const x of [1, 2, 3]) {
        Object.assign(results,({[x]:  2 * x,
        [x * 2]: 4 * x}))
      }return results})()
    })
  """

  testCase """
    with other props
    ---
    {
      a: 'a prop'
      for x of [1, 2, 3]
        [x]:  2 * x
        [x * 2]: 4 * x
      b: 'b prop'
    }
    ---
    ({
      a: 'a prop',
      ...(()=>{const results={};for (const x of [1, 2, 3]) {
        Object.assign(results,({[x]:  2 * x,
        [x * 2]: 4 * x}))
      }return results})(),
      b: 'b prop'
    })
  """

  testCase """
    mixed trailing commas
    ---
    {
      a1: 'a1 prop'
      a2: 'a2 prop',
      for x of [1, 2, 3]
        [x]:  2 * x
        [x * 2]: 4 * x,
      b1: 'b1 prop'
      b2: 'b2 prop'
    }
    ---
    ({
      a1: 'a1 prop',
      a2: 'a2 prop',
      ...(()=>{const results={};for (const x of [1, 2, 3]) {
        Object.assign(results,({[x]:  2 * x,
        [x * 2]: 4 * x,}))
      }return results})(),
      b1: 'b1 prop',
      b2: 'b2 prop'
    })
  """

  testCase """
    indentation separates comprehension props from object props
    ---
    {
      [a]: 'a computed prop'
      for x of [1, 2, 3]
        [x]:  2 * x
        [x * 2]: 4 * x
      [b]: 'b computed prop'
    }
    ---
    ({
      [a]: 'a computed prop',
      ...(()=>{const results={};for (const x of [1, 2, 3]) {
        Object.assign(results,({[x]:  2 * x,
        [x * 2]: 4 * x}))
      }return results})(),
      [b]: 'b computed prop'
    })
  """

  testCase """
    scoping
    ---
    {
      for results of [1]
        [results]:  2 * x
    }
    ---
    ({
      ...(()=>{const results1={};for (const results of [1]) {
        Object.assign(results1,({[results]:  2 * x}))
      }return results1})()
    })
  """

  testCase """
    loop body with additional statements
    ---
    {
      for x of [1]
        foo bar
        [x]:  2 * x
    }
    ---
    ({
      ...(()=>{const results={};for (const x of [1]) {
        foo(bar)
        Object.assign(results,({[x]:  2 * x}))
      }return results})()
    })
  """
