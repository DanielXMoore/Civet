{ testCase } from ./helper.civet

describe "object comprehensions", ->
  testCase """
    basic
    ---
    {
      for x of [1, 2, 3]
        [x]:  2 * x
        [x * 2]: 4 * x
    }
    ---
    ({
      ...(()=>{const results={};for (const x of [1, 2, 3]) {
        Object.assign(results,({[x]:  2 * x,
        [x * 2]: 4 * x}))
      }return results})()
    })
  """

  testCase """
    with other props
    ---
    {
      a: 'a prop'
      for x of [1, 2, 3]
        [x]:  2 * x
        [x * 2]: 4 * x
      b: 'b prop'
    }
    ---
    ({
      a: 'a prop',
      ...(()=>{const results={};for (const x of [1, 2, 3]) {
        Object.assign(results,({[x]:  2 * x,
        [x * 2]: 4 * x}))
      }return results})(),
      b: 'b prop'
    })
  """

  testCase """
    mixed trailing commas
    ---
    {
      a1: 'a1 prop'
      a2: 'a2 prop',
      for x of [1, 2, 3]
        [x]:  2 * x
        [x * 2]: 4 * x,
      b1: 'b1 prop'
      b2: 'b2 prop'
    }
    ---
    ({
      a1: 'a1 prop',
      a2: 'a2 prop',
      ...(()=>{const results={};for (const x of [1, 2, 3]) {
        Object.assign(results,({[x]:  2 * x,
        [x * 2]: 4 * x,}))
      }return results})(),
      b1: 'b1 prop',
      b2: 'b2 prop'
    })
  """

  testCase """
    indentation separates comprehension props from object props
    ---
    {
      [a]: 'a computed prop'
      for x of [1, 2, 3]
        [x]:  2 * x
        [x * 2]: 4 * x
      [b]: 'b computed prop'
    }
    ---
    ({
      [a]: 'a computed prop',
      ...(()=>{const results={};for (const x of [1, 2, 3]) {
        Object.assign(results,({[x]:  2 * x,
        [x * 2]: 4 * x}))
      }return results})(),
      [b]: 'b computed prop'
    })
  """

  testCase """
    scoping
    ---
    {
      for results of [1]
        [results]:  2 * x
    }
    ---
    ({
      ...(()=>{const results1={};for (const results of [1]) {
        Object.assign(results1,({[results]:  2 * x}))
      }return results1})()
    })
  """

  testCase """
    loop body with additional statements: single prop
    ---
    {
      for x of [1]
        foo bar
        [x]:  2 * x
    }
    ---
    ({
      ...(()=>{const results={};for (const x of [1]) {
        foo(bar)
        Object.assign(results,({[x]:  2 * x}))
      }return results})()
    })
  """

  testCase """
    loop body with additional statements: multi prop style 1
    ---
    {
      for x of [1]
        foo bar
        {
          [x]:  2 * x
          [2*x]: 4 * x
        }
    }
    ---
    ({
      ...(()=>{const results={};for (const x of [1]) {
        foo(bar)
        Object.assign(results,({
          [x]:  2 * x,
          [2*x]: 4 * x
        }))
      }return results})()
    })
  """

  testCase """
    loop body with additional statements: multi prop style 2
    ---
    {
      for x of [1]
        foo bar
        [x]:  2 * x
        [2*x]: 4 * x
    }
    ---
    ({
      ...(()=>{const results={};for (const x of [1]) {
        foo(bar)
        Object.assign(results,({[x]:  2 * x,
        [2*x]: 4 * x}))
      }return results})()
    })
  """

  testCase """
    on first line
    ---
    {for x of [1]
      [x]:  2 * x
      [2*x]: 4 * x }
    ---
    ({...(()=>{const results={};for (const x of [1]) {
      Object.assign(results,({[x]:  2 * x,
      [2*x]: 4 * x}))
    }return results})() })
  """

  testCase """
    on first line with other props
    ---
    {a: "a prop",for x of [1]
      [x]:  2 * x
      [2*x]: 4 * x }
    ---
    ({a: "a prop",...(()=>{const results={};for (const x of [1]) {
      Object.assign(results,({[x]:  2 * x,
      [2*x]: 4 * x}))
    }return results})() })
  """

  testCase """
    single line
    ---
    o := {for x of [1] [x]: 2 * x }
    ---
    const o = {...(()=>{const results={};for (const x of [1]({[x]: 2 * x})) {Object.assign(results,x)}return results})() }
  """

  testCase """

    non-comprehension loop
    ---
    o := {...for x of [1] [x]: 2 * x }
    ---
    const o = {...(()=>{const results=[];for (const x of [1]({[x]: 2 * x})) {results.push(x)}return results})() }
  """

  testCase """
    while object comprehension
    ---
    o := {while(predicate(x)) [x]: f(x)}
    ---
    const o = {...(()=>{const results={};while(predicate(x)) Object.assign(results,({[x]: f(x)}));return results})()}
  """

  testCase """
    non-comprehension while loop
    ---
    o := {...while(predicate(x)) [x]: f(x)}
    ---
    const o = {...(()=>{const results=[];while(predicate(x)) results.push(({[x]: f(x)}));return results})()}
  """

  testCase """
    do while object comprehension
    ---
    o := {do [x]: f(x) while(predicate(x)) }
    ---
    const o = {...(()=>{const results={};do { Object.assign(results,({[x]: f(x)})) } while(predicate(x))return results})() }
  """
