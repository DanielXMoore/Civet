{testCase} from ./helper.civet

describe "pipe", ->
  testCase """
    pipe expression
    ---
    a |> fn
    ---
    fn(a)
  """

  testCase """
    chained pipe expression
    ---
    a |> foo |> bar
    ---
    bar(foo(a))
  """

  testCase """
    pipe expression with shorthand functions
    ---
    a |> & + 1 |> bar
    ---
    bar(($ => $ + 1)(a))
  """

  testCase """
    nested pipelines
    ---
    (a |> & + 1) |> (b |> bar)
    ---
    ((bar(b)))((($ => $ + 1)(a)))
  """

  testCase """
    multi line trailing
    ---
    x + 1 |>
      & * 2 |>
      foo |>
      baz(1)
    ---
    (baz(1))(foo(($ => $ * 2)(x + 1)))
  """

  testCase """
    multi line trailing with comments
    ---
    x + 1 |> // Next step:
      & * 2 |> // Subsequent step:
      foo |> /* Last step: */
      baz(1)
    ---
    ( /* Last step: */
      baz(1))( // Subsequent step:
      foo(( // Next step:
      $ => $ * 2)(x + 1)))
  """

  testCase """
    multi line leading
    ---
    x + 1
    |> & * 2
    |> foo
    |> baz(1)
    ---
    (baz(1))(foo(($ => $ * 2)(x + 1)))
  """

  testCase """
    multi line leading with comments
    ---
    x + 1
    |> & * 2 // Adds two
    |> foo // Processes through foo
    |> baz(1)
    ---
    (baz(1))(foo // Processes through foo
    (($ => $ * 2 // Adds two
    )(x + 1)))
  """

  testCase """
    await in pipeline
    ---
    x + 1
    |> performAsyncOp
    |> await
    |> foo
    ---
    foo(await performAsyncOp(x + 1))
  """

  testCase """
    yield in pipeline
    ---
    x + 1
    |> yield
    |> foo
    ---
    foo(yield x + 1)
  """

  testCase """
    return in pipeline
    ---
    x + 1
    |> foo
    |> return
    ---
    return foo(x + 1)
  """

  testCase """
    thick pipe first
    ---
    x ||> f |> g
    ---
    f(x),g(x)
  """

  testCase """
    thick pipe second
    ---
    x |> f ||> g
    ---
    let ref
    (ref=f(x)),g(ref)
  """

  testCase """
    two thick pipes
    ---
    x ||> f ||> g
    ---
    f(x),g(x),x
  """
