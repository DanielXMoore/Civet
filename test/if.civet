{ testCase, throws } from ./helper.civet

describe "if", ->
  testCase """
    if
    ---
    if (true) {
      return false
    }
    ---
    if (true) {
      return false
    }
  """

  testCase """
    inline parenthesized expression
    ---
    if (c & 0x7F) != c
      break
    ---
    if ((c & 0x7F) != c) {
      break
    }
  """

  testCase """
    else
    ---
    if (true) {
      return false
    } else {
      return true
    }
    ---
    if (true) {
      return false
    } else {
      return true
    }
  """

  testCase """
    nested
    ---
    if x
      if y
        a
    else
      c
    ---
    if (x) {
      if (y) {
        a
      }
    }
    else {
      c
    }
  """

  throws """
    invalid indentation
    ---
    ->
      if x
        if y
          a
    else
      c
  """

  testCase """
    if inline
    ---
    if (x) y else z
    ---
    if (x) y; else z
  """

  testCase """
    if then
    ---
    if x then y
    ---
    if (x) y
  """

  testCase """
    if with multiple semicolon-separated statements
    ---
    if x
      a; b
    else
      c; d
    ---
    if (x) {
      a; b
    }
    else {
      c; d
    }
  """

  testCase """
    if with multiple semicolon-separated commented statements
    ---
    if x
      /*a*/ a; /*b*/ b
    else
      /*c*/ c; /*d*/ d
    ---
    if (x) {
      /*a*/ a; /*b*/ b
    }
    else {
      /*c*/ c; /*d*/ d
    }
  """

  // TODO
  testCase.skip """
    if then nothing
    ---
    if x then
    ---
    if (x);
  """

  testCase """
    if then newline
    ---
    if true
    then y
    ---
    if (true) y
  """

  testCase """
    if then else
    ---
    if true then y else z
    ---
    if (true) y; else z
  """

  testCase """
    no parens
    ---
    if true
      return false
    ---
    if (true) {
      return false
    }
  """

  testCase """
    else if
    ---
    if x < 0
      -1
    else if y
      y
    ---
    if (x < 0) {
      -1
    }
    else if (y) {
      y
    }
  """

  testCase """
    no parens else
    ---
    if true
      return false
    else
      return
    ---
    if (true) {
      return false
    }
    else {
      return
    }
  """

  testCase """
    weird spacing
    ---
    if (true) 5
    else 3
    ---
    if (true) 5;
    else 3
  """

  testCase """
    unless
    ---
    unless x
      return y
    ---
    if(!(x)) {
      return y
    }
  """

  testCase """
    unless more complex exp
    ---
    unless x + z
      return y
    ---
    if(!(x + z)) {
      return y
    }
  """

  testCase """
    unless else
    ---
    unless x
      return y
    else
      return z
    ---
    if(!(x)) {
      return y
    }
    else {
      return z
    }
  """

  testCase """
    postfix if
    ---
    return true if x
    ---
    if (x) { return true }
  """

  testCase """
    postfix unless
    ---
    return true unless x
    ---
    if(!(x)) { return true }
  """

  testCase """
    postfix if inside if
    ---
    if x return true if y
    ---
    if (y) { if (x) return true }
  """

  testCase """
    postfix unless existential
    ---
    return "" unless h?
    let x = 2
    ---
    if(!(h != null)) { return "" }
    let x = 2
  """

  testCase """
    implied parens parethesized expression
    ---
    if (fs.statSync index).isFile()
      index
    ---
    if ((fs.statSync(index)).isFile()) {
      index
    }
  """

  describe "forbid indented application", ->
    testCase """
      object literal after condition
      ---
      if foo
        a: 1
      ---
      if (foo) {
        ({a: 1})
      }
    """

    testCase """
      allowed in parentheses
      ---
      if (foo
        a: 1
      )
        hi
      ---
      if (foo({
        a: 1,
      })
      ) {
        hi
      }
    """

    testCase """
      allowed in indirect parentheses
      ---
      if x + (foo
        a: 1
      )
        hi
      ---
      if (x + (foo({
        a: 1,
      })
      )) {
        hi
      }
    """

    testCase """
      forbidden again outside parentheses
      ---
      if x + (foo
        a: 1
      )
        b: 2
      ---
      if (x + (foo({
        a: 1,
      })
      )) {
        ({b: 2})
      }
    """

    testCase """
      allowed in array literal
      ---
      if [
        foo
          a: 1
      ]
        hi
      ---
      if ([
        foo({
          a: 1,
      })
      ]) {
        hi
      }
    """

    testCase """
      allowed in braced object literal
      ---
      if {f: foo
        a: 1
      }
        hi
      ---
      if ({f: foo({
        a: 1
      })
      }) {
        hi
      }
    """

  describe "expression", ->
    testCase """
      if expression
      ---
      x = if y
        "a"
      else
        "b"
      ---
      x = (y)?
        "a"
      :
        "b"
    """

    testCase """
      if expression on new line
      ---
      x =
      if y
        "a"
      else
        "b"
      ---
      x =
      (y)?
        "a"
      :
        "b"
    """

    testCase """
      if expression no else
      ---
      x = if (y)
        "a"
      ---
      x = (y)?
        "a":void 0
    """

    testCase """
      nested if expression
      ---
      x = if y
        if z
          "a"
        else
          "b"
      else
        "c"
      ---
      x = (y)?(
        (z)?
          "a"
        :
          "b"
      )
      :
        "c"
    """

    testCase """
      if expression with multiple semicolon-separated statements
      ---
      x = if y
        a; b
      else
        c; d
      ---
      x = (y)?(
        a, b
      )
      :(
        c, d
      )
    """

    testCase """
      if expression with multiple semicolon-separated commented statements
      ---
      x = if y
        /*a*/ a; /*b*/ b
      else
        /*c*/ c; /*d*/ d
      ---
      x = (y)?(
        /*a*/ a, /*b*/ b
      )
      :(
        /*c*/ c, /*d*/ d
      )
    """

    testCase """
      throw from inside if expression
      ---
      x = if y
        throw new Error
      else
        "b"
      ---
      x = (y)?(
        (()=>{throw new Error})()
      )
      :
        "b"
    """

    testCase """
      debugger inside if expression
      ---
      x = if y
        debugger
      else
        "b"
      ---
      x = (y)?(
        (()=>{debugger})()
      )
      :
        "b"
    """

    testCase """
      unless expression
      ---
      x = unless y
        "a"
      else
        "b"
      ---
      x = (!(y))?
        "a"
      :
        "b"
    """

    testCase """
      postfix inside parenthesized expression
      ---
      x = (a if y)
      ---
      x = ((y)?a:void 0)
    """

    testCase """
      postfix inside parenthesized expression with binary op
      ---
      x = (a if y) + 1
      ---
      x = ((y)?a:void 0) + 1
    """

    testCase """
      postfix unless inside parenthesized expression
      ---
      x = (a unless y)
      ---
      x = ((!(y))?a:void 0)
    """

  // TODO Eventually
  describe.skip "return if expression", ->
    testCase """
      return if expression
      ---
      return if y then 1 else 0
      ---
      return (y)? 1:  0
    """

    testCase """
      return if expression
      ---
      return if y
      then 1
      else 0
      ---
      return (y)? 1:
       0
    """

    testCase """
      return if expression
      ---
      return if y
        1
      else
        0
      ---
      return (y)?(
        1
      ):
      (
        0
      )
    """

  describe "DeclarationCondition", ->
    testCase """
      if declaration
      ---
      if [_, s] := s.match(re)
        s
      ---
      let ref;if (ref = s.match(re)) {
        const [_, s] = ref;
        s
      }
    """

    testCase """
      if declaration with @ rest
      ---
      if [_, ...@s] := s.match(re)
        s
      ---
      let ref;if (ref = s.match(re)) {
        const [_, ...s1] = ref;
        this.s = s1;
        s
      }
    """

    testCase """
      if declaration with @ rest in first position
      ---
      if [...@s, a] := s.match(re)
        s
      ---
      const splice: <T>(this: T[], start: number, deleteCount?: number) => T[] = [].splice as any
      let ref;if (ref = s.match(re)) {
        const [...s1] = ref, [a] = splice.call(s1, -1);
        this.s = s1;
        s
      }
    """

    testCase """
      if declaration with parens
      ---
      if ([_, s] := s.match(re))
        s
      ---
      let ref;if (ref = s.match(re)) {
        const [_, s] = ref;
        s
      }
    """

    testCase """
      longhand const
      ---
      if const match = regex.exec string
        console.log match
      ---
      let ref;if (ref = regex.exec(string)) {
        const match = ref;
        console.log(match)
      }
    """

    testCase """
      longhand const with @ rest
      ---
      if const [...@a, b] = regex.exec string
        console.log @a, b
      ---
      const splice: <T>(this: T[], start: number, deleteCount?: number) => T[] = [].splice as any
      let ref;if (ref = regex.exec(string)) {
        const [...a] = ref,[b] = splice.call(a, -1);
        this.a = a;
        console.log(this.a, b)
      }
    """

    // TODO
    throws """
      declaration in expression
      ---
      x = if {y} := f()
        a
      else
        b
    """
