{testCase, throws} from ./helper.civet

describe "break as value", ->
  testCase """
    for loop
    ---
    for item of list
      break if match item
      process item
    found := break
    ---
    var broke: boolean; { broke = false; for (const item of list) {
      if (match(item)) { { broke = true; break } }
      process(item)
    } }
    const found = broke
  """

  testCase """
    while loop
    ---
    while item = next()
      break if match item
    found := break
    ---
    var broke: boolean; { broke = false; while (item = next()) {
      if (match(item)) { { broke = true; break } }
    } }
    const found = broke
  """

  testCase """
    loop
    ---
    loop
      break if match()
    found := break
    ---
    var broke: boolean; { broke = false; while(true) {
      if (match()) { { broke = true; break } }
    } }
    const found = broke
  """

  testCase """
    two loops
    ---
    loop break
    loop break
    found := break
    ---
    var broke: boolean; { broke = false; while(true) { broke = true; break } }
    { broke = false; while(true) { broke = true; break } }
    const found = broke
  """

  testCase """
    broke in scope
    ---
    loop break
    broke := break
    ---
    var broke1: boolean; { broke1 = false; while(true) { broke1 = true; break } }
    const broke = broke1
  """

  testCase """
    if break
    ---
    for item of list
      break if match item
      process item
    if break
      console.log 'found'
    ---
    var broke: boolean; { broke = false; for (const item of list) {
      if (match(item)) { { broke = true; break } }
      process(item)
    } }
    if (broke) {
      console.log('found')
    }
  """

  testCase """
    for loop, if break in function
    ---
    function f
      for item of list
        break if match item
        process item
      if break
        console.log 'found'
    ---
    function f() {var broke: boolean; 
      { broke = false; for (const item of list) {
        if (match(item)) { { broke = true; break } }
        process(item)
      } }
      if (broke) {
        return console.log('found')
      }
      return
    }
  """

  testCase """
    return break
    ---
    function f
      for item of list
        break if match item
        process item
      return break
    ---
    function f() {var broke: boolean; 
      { broke = false; for (const item of list) {
        if (match(item)) { { broke = true; break } }
        process(item)
      } }
      return broke
    }
  """

  testCase """
    ignore switch
    ---
    loop break
    switch foo
      case 1
        break
      when 2
        break
    found := break
    ---
    var broke: boolean; { broke = false; while(true) { broke = true; break } }
    switch(foo) {
      case 1:
        break
      case 2: {
        break;break;
      }
    }
    const found = broke
  """

  testCase """
    expressionized loop
    ---
    items :=
      for item of list
        break if match item
        item
    found := break
    ---
    var broke: boolean; const items =
      (()=>{const results=[];{ broke = false; for (const item of list) {
        if (match(item)) { { broke = true; break } }
        results.push(item)
      } }; return results})()
    const found = broke
  """

  testCase """
    loops in switch
    ---
    switch foo
      case 1
        loop break
    found := break
    ---
    var broke: boolean; switch(foo) {
      case 1:
        { broke = false; while(true) { broke = true; break } }
    }
    const found = broke
  """

  throws """
    must be a loop
    ---
    unrelated := 'red herring'
    found := break
  """

  throws """
    must be a loop in scope, outer
    ---
    function foo
      loop forever
    found := break
  """

  throws """
    must be a loop in scope, inner
    ---
    loop forever
    function foo
      found := break
  """
