{testCase, throws} from ./helper.civet

describe "object", ->
  testCase """
    empty literal
    ---
    {}
    ---
    ({})
  """

  testCase """
    basic
    ---
    a = {x: 1, y: 2}
    ---
    a = {x: 1, y: 2}
  """

  testCase """
    keys are not reserved
    ---
    a =
      if: "cool"
      case: 1
    ---
    a = {
      if: "cool",
      case: 1,
    }
  """

  testCase """
    spread
    ---
    y = {...x}
    ---
    y = {...x}
  """

  testCase """
    multiple spread
    ---
    y = {...x, ...z}
    ---
    y = {...x, ...z}
  """

  testCase """
    single line literal
    ---
    a: b
    ---
    ({a: b})
  """

  testCase """
    single line literal with method
    ---
    {x, func(){5}}
    ---
    ({x, func(){return 5}})
  """

  testCase """
    object literal with empty method content
    ---
    {x, func(){}}
    ---
    ({x, func(){}})
  """

  testCase """
    object literal with semicolon method content
    ---
    {
      a();
      b();
    }
    ---
    ({
      a() {; },
      b() {; }
    })
  """

  testCase """
    flagging shorthand inline
    ---
    {+x, -y, !z}
    ---
    ({x: true, y: false, z: false})
  """

  testCase """
    flagging shorthand multiline
    ---
    {
      +x
      -y
    }
    ---
    ({
      x: true,
      y: false
    })
  """

  testCase """
    flagging shorthand with numeric, string, template, computed keys
    ---
    {
      -1
      !1
      +1
      +"a"
      !`b`
      +[c]
      +0
      !-1
      +-0
    }
    ---
    ({
      1: false,
      1: false,
      1: true,
      "a": true,
      [`b`]: false,
      [c]: true,
      0: true,
      [-1]: false,
      [-0]: true
    })
  """

  testCase """
    negative number as computed name
    ---
    {
      -1: 5
    }
    ---
    ({
      [-1]: 5
    })
  """

  testCase """
    computed property name
    ---
    { [x]: 5 }
    ---
    ({ [x]: 5 })
  """

  testCase """
    multiline unnested literal
    ---
    a: b
    b: c
    ---
    ({a: b,
    b: c})
  """

  testCase """
    keeps comments
    ---
    { /**/ x}
    ---
    ({ /**/ x})
  """

  testCase """
    spread
    ---
    { ...x }
    ---
    ({ ...x })
  """

  // describe.only "", ->
  testCase """
    optional commas
    ---
    x = {
      a
      b,
      c
    }
    ---
    x = {
      a,
      b,
      c
    }
  """

  throws """
    doesn't allow bare assignments inside
    ---
    {x=y}
  """

  throws """
    doesn't allow update assignments inside
    ---
    {x+=y}
  """

  throws """
    doesn't allow update assignments inside
    ---
    {x-=y}
  """

  throws """
    doesn't allow comparisons inside
    ---
    {x<=y}
  """

  testCase """
    allows for extra newlines and whitespace with braces
    ---
    x = {
      a:
              4
    }
    ---
    x = {
      a:
              4
    }
  """

  testCase """
    nested object syntax
    ---
    x =
      a: 1
      b: 2
      c:
        d: "a"
        e: "b"
    ---
    x = {
      a: 1,
      b: 2,
      c: {
        d: "a",
        e: "b",
      },
    }
  """

  testCase """
    expression values
    ---
    x =
      a: getA()
      b: getB()
    ---
    x = {
      a: getA(),
      b: getB(),
    }
  """

  testCase """
    method definition
    ---
    x = {
      id()
        return 5
    }
    ---
    x = {
      id() {
        return 5
      }
    }
  """

  testCase """
    method get definition
    ---
    x = {
      get id()
        return 5
    }
    ---
    x = {
      get id() {
        return 5
      }
    }
  """

  testCase """
    method set definition
    ---
    x = {
      set id(v)
        @id = v
    }
    ---
    x = {
      set id(v) {
        this.id = v
      }
    }
  """

  testCase """
    private method definition
    ---
    x = {
      get #id()
        return 5
    }
    ---
    x = {
      get #id() {
        return 5
      }
    }
  """

  testCase """
    async method definition
    ---
    x = {
      async x()
        return 5
    }
    ---
    x = {
      async x() {
        return 5
      }
    }
  """

  testCase """
    implicit async method definition
    ---
    x = {
      x()
        await 5
    }
    ---
    x = {
      async x() {
        return await 5
      }
    }
  """

  testCase """
    generator method definition
    ---
    x = {
      *x()
        return 5
    }
    ---
    x = {
      *x() {
        return 5
      }
    }
  """

  testCase """
    implicit generator method definition
    ---
    x = {
      x()
        yield 5
    }
    ---
    x = {
      *x() {
        return yield 5
      }
    }
  """

  testCase """
    async generator method definition
    ---
    x = {
      async * x()
        return 5
    }
    ---
    x = {
      async * x() {
        return 5
      }
    }
  """

  testCase """
    shorthand key value notation
    ---
    return {
      x: ->
        y
      options
      z: ->
        "y"
    }
    ---
    return {
      x: function() {
        return y
      },
      options,
      z: function() {
        return "y"
      }
    }
  """

  testCase """
    identifiers that start with get/set
    ---
    return {
      getx: -> x
      sety: (y) -> @y = y
    }
    ---
    return {
      getx: function() { return x },
      sety: function(y) { return this.y = y }
    }
  """

  testCase """
    multiline with optional commas
    ---
    {count, starts, compact, repeat, invertLiterate, merge,
    attachCommentsToNode, locationDataToString, throwSyntaxError
    replaceUnicodeCodePointEscapes, flatten, parseNumber} = require './helpers'
    ---
    ({count, starts, compact, repeat, invertLiterate, merge,
    attachCommentsToNode, locationDataToString, throwSyntaxError,
    replaceUnicodeCodePointEscapes, flatten, parseNumber} = require('./helpers'))
  """

  testCase """
    shorthand this property
    ---
    {@tokens, index: i}
    ---
    ({tokens: this.tokens, index: i})
  """

  // TODO: Should this be wrapped in parens?
  testCase """
    braceless inline object
    ---
    a: 1
    ---
    ({a: 1})
  """

  testCase """
    braceless inline object with multiple keys
    ---
    a: 1, b: 2
    ---
    ({a: 1, b: 2})
  """

  testCase """
    braceless inline object with multiple keys per line
    ---
    a: 1, b: 2
    c: 3, d: 4
    ---
    ({a: 1, b: 2,
    c: 3, d: 4})
  """

  testCase """
    multiple keys per line
    ---
    {
      a, b
      c, d
    }
    ---
    ({
      a, b,
      c, d
    })
  """

  testCase """
    single nested object as function return value
    ---
    json: (srcFileName, outFileName) ->
      version: 3
    updateSourceMap: (outputStr, inputPos) -> outputStr
    ---
    ({json: function(srcFileName, outFileName) {
      return ({version: 3})
    },
    updateSourceMap: function(outputStr, inputPos) { return outputStr }})
  """

  testCase """
    template literal key shorthand
    ---
    {`x${y}z`: value}
    ---
    ({[`x${y}z`]: value})
  """

  testCase '''
    triple-quoted template literal key shorthand
    ---
    {"""x#{y}z""": value}
    ---
    ({[`x${y}z`]: value})
  '''

  testCase '''
    coffee compat template literal key shorthand
    ---
    "civet coffee-compat"
    {"x#{y}z": value}
    ---
    ({[`x${y}z`]: value})
  '''

  testCase '''
    coffee compat template literal key without interpolations
    ---
    "civet coffee-compat"
    {"x": value}
    ---
    ({"x": value})
  '''

  describe "object literal shorthand", ->
    testCase """
      member
      ---
      {x.y}
      ---
      ({y: x.y})
    """

    testCase """
      two members
      ---
      {x.y.z}
      ---
      ({z: x.y.z})
    """

    testCase """
      call
      ---
      {x()}
      ---
      ({x: x()})
    """

    testCase """
      call with access
      ---
      {f().g}
      ---
      ({g: f().g})
    """

    testCase """
      call with optional access
      ---
      {f()?.g}
      ---
      ({g: f()?.g})
    """

    testCase """
      prop call
      ---
      {props.x()}
      ---
      ({x: props.x()})
    """

    testCase """
      two members with call in middle
      ---
      {x.y().z}
      ---
      ({z: x.y().z})
    """

    testCase """
      two members with call at end
      ---
      {x.y.z()}
      ---
      ({z: x.y.z()})
    """

    testCase """
      assertions and optional
      ---
      {x!.y?.z!}
      ---
      ({z: x!.y?.z!})
    """

    testCase """
      optional call
      ---
      {x?()}
      ---
      ({x: x?.()})
    """

    testCase """
      assertions and optional
      ---
      {x!.y?.z!}
      ---
      ({z: x!.y?.z!})
    """

    testCase """
      member access in middle
      ---
      {x[y].z}
      ---
      ({z: x[y].z})
    """

    testCase """
      member access at end
      ---
      {x[y]}
      ---
      ({[y]: x[y]})
    """

    testCase """
      super access
      ---
      {super.x}
      ---
      ({x: super.x})
    """

    testCase """
      super member access
      ---
      {super[x]}
      ---
      ({[x]: super[x]})
    """

    throws """
      no new properties
      ---
      {new.target}
    """

    throws """
      no meta properties
      ---
      {import.meta}
    """

  describe "object globs", ->
    testCase """
      single property
      ---
      obj.{a}
      ---
      ({a:obj.a})
    """

    testCase """
      optional .
      ---
      obj{a}
      ---
      ({a:obj.a})
    """

    testCase """
      multiple properties
      ---
      obj.{a,b,c}
      ---
      ({a:obj.a,b:obj.b,c:obj.c})
    """

    testCase """
      spacing and trailing comma
      ---
      obj.{ a,b, c,  }
      ---
      ({ a:obj.a,b:obj.b, c:obj.c,  })
    """

    // TODO: needs ref
    testCase """
      complex left-hand side
      ---
      x.y()?.z.{a,b}
      ---
      ({a:x.y()?.z.a,b:x.y()?.z.b})
    """

    testCase """
      complex right-hand side
      ---
      x.{a.b.c, d?.e().f!, g: h.i}
      ---
      ({c:x.a.b.c, f:x.d?.e().f!, g: x.h.i})
    """

    testCase """
      renamed
      ---
      obj.{ a, b: c, d : e }
      ---
      ({ a:obj.a, b: obj.c, d : obj.e })
    """

    testCase """
      assignment
      ---
      obj.{ a, b: c, d : e } = x
      ---
      ({ a:obj.a, b: obj.c, d : obj.e } = x)
    """

    testCase """
      ...spread
      ---
      obj.{...a, ... b}
      ---
      ({...obj.a, ... obj.b})
    """

    testCase """
      ...spread assignment
      ---
      obj.{a, b, ...rest} = x
      ---
      ({a:obj.a, b:obj.b, ...obj.rest} = x)
    """

    throws """
      no initializer
      ---
      obj.{a, b=5}
    """

    throws """
      no + flags
      ---
      obj.{+x}
    """
    throws """
      no - flags
      ---
      obj.{-x}
    """
    throws """
      no ! flags
      ---
      obj.{!x}
    """

    throws """
      no general expressions
      ---
      obj.{x: a+b}
    """
