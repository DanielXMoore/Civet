{testCase, throws} from ./helper.civet

describe "switch", ->
  testCase """
    basic
    ---
    switch (x) {
      case 1:
        break
    }
    ---
    switch (x) {
      case 1:
        break
    }
  """

  testCase """
    same line
    ---
    switch (x) {
      case 1: break
    }
    ---
    switch (x) {
      case 1: break
    }
  """

  testCase """
    optional parens
    ---
    switch x {
      case 1:
        break
    }
    ---
    switch(x) {
      case 1:
        break
    }
  """

  testCase """
    optional braces
    ---
    switch (x)
      case 1:
        break
    ---
    switch (x) {
      case 1:
        break
    }
  """

  testCase """
    open brace on next line
    ---
    switch (x)
    {
      case 1:
        break
    }
    ---
    switch (x)
    {
      case 1:
        break
    }
  """

  testCase """
    case doesn't allow object literal
    ---
    switch x
      case 1:
        2
    ---
    switch(x) {
      case 1:
        2
    }
  """

  testCase """
    case doesn't allow object literal, same line
    ---
    switch x
      case 1: 2
    ---
    switch(x) {
      case 1: 2
    }
  """

  // #593
  testCase """
    case doesn't allow object literal with object literal
    ---
    switch x
      case 1: {
        console.log('hello')
      }
    ---
    switch(x) {
      case 1: {
        console.log('hello')
      }
    }
  """

  testCase """
    case matching array isn't a computed property
    ---
    switch x
      case [1]: 2
    ---
    switch(x) {
      case [1]: 2
    }
  """

  testCase """
    implicit computed property isn't a computed property
    ---
    switch x
      case `hi ${y}`: y
      case -5: 5
    ---
    switch(x) {
      case `hi ${y}`: y
      case -5: 5
    }
  """

  testCase """
    multiple cases with colon
    ---
    switch (x) {
      case 1:
      case 2:
        break
    }
    ---
    switch (x) {
      case 1:
      case 2:
        break
    }
  """

  testCase """
    multiple cases without colon
    ---
    switch (x) {
      case 1
      case 2
        break
    }
    ---
    switch (x) {
      case 1:
      case 2:
        break
    }
  """

  testCase """
    default
    ---
    switch (x) {
      default
        break
    }
    ---
    switch (x) {
      default:
        break
    }
  """

  testCase """
    default one-liner
    ---
    switch (x) {
      default break
    }
    ---
    switch (x) {
      default: break
    }
  """

  testCase """
    else
    ---
    switch (x) {
      else
        break
    }
    ---
    switch (x) {
      default: {
        break
      }
    }
  """

  testCase """
    else one-liner
    ---
    switch (x) {
      else break
    }
    ---
    switch (x) {
      default: { break }
    }
  """

  testCase """
    when
    ---
    switch x
      when 1
        console.log y
    ---
    switch(x) {
      case 1: {
        console.log(y);break;
      }
    }
  """

  testCase """
    when then
    ---
    switch x
      when 1 then console.log a
      when 2 then console.log y; console.log x
    ---
    switch(x) {
      case 1: { console.log(a);break;
      }
      case 2: { console.log(y); console.log(x);break;
      }
    }
  """

  testCase """
    empty when body
    ---
    switch x
      when 1 // do nothing
      when 2
        console.log y
    ---
    switch(x) {
      case 1: {;break;
      } // do nothing
      case 2: {
        console.log(y);break;
      }
    }
  """

  testCase """
    when with multiple expressions
    ---
    switch x
      when 1, 2, 3
        console.log y
    ---
    switch(x) {
      case 1:case 2:case 3: {
        console.log(y);break;
      }
    }
  """

  testCase """
    case with multiple expressions
    ---
    switch x
      case 1, 2, 3
        console.log y
    ---
    switch(x) {
      case 1:case 2:case 3:
        console.log(y)
    }
  """

  testCase """
    when skips break if unnecessary
    ---
    switch x
      when 1
        return y
      when 2
        break
      when 3
        continue
      when 4
        throw e
      when 5
        throw e
        break
        continue
        console.log 'maybe'
    ---
    switch(x) {
      case 1: {
        return y
      }
      case 2: {
        break
      }
      case 3: {
        continue
      }
      case 4: {
        throw e
      }
      case 5: {
        throw e
        break
        continue
        console.log('maybe');break;
      }
    }
  """, wrapper: """
    while (true) {
      CODE
    }
  """

  throws """
    mixed when and pattern matching
    ---
    switch x
      when 1
        ;
      2
        ;
      else
        ;
  """

  testCase """
    declaration condition in pattern matching
    ---
    switch data := x()
      1
        2
    ---
    {let ref = x();const  data = ref;if(ref === 1) {
        2}}
  """

  testCase """
    declaration condition in pattern matching with destructuring
    ---
    switch [data] := x()
      [a, b]
        2
    ---
    {let ref = x();const  [data] = ref;if(Array.isArray(ref) && ref.length === 2) {
        const [a, b] = ref;
        2}}
  """

  testCase """
    declaration condition in switch
    ---
    switch data := x()
      case 1
        2
    ---
    {let ref = x();const  data = ref;switch(ref) {
      case 1:
        2
    }}
  """

  describe "expression", ->
    testCase """
      switch expression
      ---
      x = switch y
        when 1
          2
      ---
      x = (()=>{switch(y) {
        case 1: {
          return 2
        }
      }})()
    """

  describe "expressionless", ->
    testCase """
      basic
      ---
      switch
        when 1
          2
      ---
      switch (false) {
        case !1: {
          2;break;
        }
      }
    """

    testCase """
      with default
      ---
      switch
        when 1
          2
        else
          3
      ---
      switch (false) {
        case !1: {
          2;break;
        }
        default: {
          3
        }
      }
    """

    testCase """
      with more complex expression in when
      ---
      switch
        when 1 * x > 2
          3
      ---
      switch (false) {
        case !(1 * x > 2): {
          3;break;
        }
      }
    """

  describe "pattern matching", ->
    testCase """
      basic
      ---
      switch x
        1
          console.log "it's one"
        2
          console.log "it's two"
      ---
      if(x === 1) {
          console.log("it's one")}
      else if(x === 2) {
          console.log("it's two")}
    """

    testCase """
      basic then
      ---
      switch x
        1 then console.log "it's one"
        2 then console.log "it's two"
      ---
      if(x === 1) { console.log("it's one")}
      else if(x === 2) { console.log("it's two")}
    """

    testCase """
      with else
      ---
      switch x
        1
          console.log "it's one"
        else
          console.log "it's something else"
      ---
      if(x === 1) {
          console.log("it's one")}
      else  {
          console.log("it's something else")
        }
    """

    testCase """
      enum
      ---
      switch x
        Direction.Up
          console.log "up"
        Direction.Down
          console.log "down"
      ---
      if(x === Direction.Up) {
          console.log("up")}
      else if(x === Direction.Down) {
          console.log("down")}
    """

    testCase """
      pin enum
      ---
      switch x
        ^Direction.Up
          console.log "up"
        ^Direction.Down
          console.log "down"
      ---
      if(x === Direction.Up) {
          console.log("up")}
      else if(x === Direction.Down) {
          console.log("down")}
    """

    testCase """
      multiple non-binding cases
      ---
      switch x
        1, 2
          console.log "it's one or two"
        3,
        4
          console.log "it's three or four"
      ---
      if(x === 1 || x === 2) {
          console.log("it's one or two")}
      else if(x === 3 || x === 4) {
          console.log("it's three or four")}
    """

    testCase """
      multiple condition fragment cases
      ---
      switch x
        % 5 is 0, % 3 is 0
          console.log "it's divisible by 3 or 5"
      ---
      if(x % 5 === 0 || x % 3 === 0) {
          console.log("it's divisible by 3 or 5")}
    """

    testCase """
      array pattern
      ---
      switch x
        [a, b]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 2) {
          const [a, b] = x;
          console.log(a, b)}
    """

    testCase """
      indented array pattern
      ---
      switch x
        [
          a
          b
          4
        ]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 3 && x[2] === 4) {
          const [
          a,
          b,] = x;
          console.log(a, b)}
    """

    testCase """
      empty array
      ---
      switch x
        []
          console.log "empty"
      ---
      if(Array.isArray(x) && x.length === 0) {
          console.log("empty")}
    """

    testCase """
      array with empty object
      ---
      switch x
        [a, {}]
          console.log a
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[1] === 'object' && x[1] != null) {
          const [a, {}] = x;
          console.log(a)}
    """

    testCase """
      array with elisions
      ---
      switch x
        [a, , b]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 3) {
          const [a, , b] = x;
          console.log(a, b)}
    """

    testCase """
      array with literal match
      ---
      switch x
        [a, 3]
          console.log a
      ---
      if(Array.isArray(x) && x.length === 2 && x[1] === 3) {
          const [a,] = x;
          console.log(a)}
    """

    testCase """
      array with nested literal match
      ---
      switch x
        [a, [b, 3]]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 2 && Array.isArray(x[1]) && x[1].length === 2 && x[1][1] === 3) {
          const [a, [b,]] = x;
          console.log(a, b)}
    """

    testCase """
      array with literal after rest
      ---
      switch x
        [a, b..., 3]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length >= 2 && x[x.length - 1] === 3) {
          const [a, ...b] = x, [] = b.splice(-1);
          console.log(a, b)}
    """

    testCase """
      array with binding after rest
      ---
      switch x
        [a, b..., c]
          console.log a, b, c
      ---
      if(Array.isArray(x) && x.length >= 2) {
          const [a, ...b] = x, [c] = b.splice(-1);
          console.log(a, b, c)}
    """

    testCase """
      array rest matcher
      ---
      switch x
        [a, b...]
          console.log a
          console.log b
      ---
      if(Array.isArray(x) && x.length >= 1) {
          const [a, ...b] = x;
          console.log(a)
          console.log(b)}
    """

    testCase """
      array rest non end position
      ---
      switch x
        [...a, b]
          console.log a
          console.log b
      ---
      if(Array.isArray(x) && x.length >= 1) {
          const [...a] = x, [b] = a.splice(-1);
          console.log(a)
          console.log(b)}
    """

    testCase """
      array this binding
      ---
      switch x
        [@a, @b]
          console.log this
      ---
      if(Array.isArray(x) && x.length === 2) {
          const [a, b] = x;
          this.a = a;
          this.b = b;
          console.log(this)}
    """

    testCase """
      array rest this binding
      ---
      switch x
        [@a, @b...]
          console.log this
      ---
      if(Array.isArray(x) && x.length >= 1) {
          const [a, ...b] = x;
          this.a = a;
          this.b = b;
          console.log(this)}
    """

    testCase """
      array with pin pattern
      ---
      switch x
        [a, ^b]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 2 && x[1] === b) {
          const [a,] = x;
          console.log(a, b)}
    """

    testCase """
      nested array pattern
      ---
      switch x
        [a, [b, c]]
          console.log a, b, c
      ---
      if(Array.isArray(x) && x.length === 2 && Array.isArray(x[1]) && x[1].length === 2) {
          const [a, [b, c]] = x;
          console.log(a, b, c)}
    """

    testCase """
      object pattern
      ---
      switch x
        {a, b}
          console.log a, b
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x) {
          const {a, b} = x;
          console.log(a, b)}
    """

    testCase """
      empty object pattern
      ---
      switch x
        {}
          console.log "empty"
      ---
      if(typeof x === 'object' && x != null) {
          console.log("empty")}
    """

    testCase """
      object pattern with matcher
      ---
      switch x
        {a, b: 3}
          console.log a, b
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x && x.b === 3) {
          const {a, b} = x;
          console.log(a, b)}
    """

    testCase """
      object pattern with post rest matcher
      ---
      switch x
        {a, b..., c: 3}
          console.log a, b, c
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'c' in x && x.c === 3) {
          const {a, c, ...b} = x;
          console.log(a, b, c)}
    """

    testCase """
      object pattern with pin
      ---
      switch x
        {a, b: ^b}
          console.log a, b
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x && x.b === b) {
          const {a, b} = x;
          console.log(a, b)}
    """

    testCase """
      object pattern with pin shorthand
      ---
      switch x
        {a, ^b}
          console.log a, b
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x && x.b === b) {
          const {a, b} = x;
          console.log(a, b)}
    """

    testCase """
      object pattern with array binding match
      ---
      switch x
        {a, b: [c, d]}
          console.log a, c, d
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x && Array.isArray(x.b) && x.b.length === 2) {
          const {a, b: [c, d]} = x;
          console.log(a, c, d)}
    """

    testCase """
      object pattern with computed property
      ---
      switch x
        {a, [b]: c}
          console.log a
      ---
      if(typeof x === 'object' && x != null && 'a' in x && b in x) {
          const {a, [b]: c} = x;
          console.log(a)}
    """

    testCase """
      object pattern with string key
      ---
      switch x
        {a, '+': c}
          console.log a
      ---
      if(typeof x === 'object' && x != null && 'a' in x && '+' in x) {
          const {a, '+': c} = x;
          console.log(a)}
    """

    testCase """
      object pattern with number key
      ---
      switch x
        {a, 1: c}
          console.log a
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 1 in x) {
          const {a, 1: c} = x;
          console.log(a)}
    """

    testCase """
      nested object and array patterns
      ---
      switch x
        {a, b: [c, {d: e}]}
          console.log a, c, e
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x && Array.isArray(x.b) && x.b.length === 2 && typeof x.b[1] === 'object' && x.b[1] != null && 'd' in x.b[1]) {
          const {a, b: [c, {d: e}]} = x;
          console.log(a, c, e)}
    """

    testCase """
      nested array and object patterns
      ---
      switch x
        [a, {b: c, d: [e, f]}]
          console.log a, c, e, f
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[1] === 'object' && x[1] != null && 'b' in x[1] && 'd' in x[1] && Array.isArray(x[1].d) && x[1].d.length === 2) {
          const [a, {b: c, d: [e, f]}] = x;
          console.log(a, c, e, f)}
    """

    testCase """
      regular expression pattern
      ---
      switch x
        /^foo$/
          console.log "it's foo"
      ---
      if(typeof x === 'string' && /^foo$/.test(x)) {
          console.log("it's foo")}
    """

    testCase """
      nested regular expression pattern
      ---
      switch x
        [/^foo$/, b]
          console.log b
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[0] === 'string' && /^foo$/.test(x[0])) {
          const [, b] = x;
          console.log(b)}
    """

    testCase """
      regular expression block pattern
      ---
      switch x
        ///^ foo $///
          console.log "it's foo"
      ---
      if(typeof x === 'string' && /^foo$/.test(x)) {
          console.log("it's foo")}
    """

    testCase """
      regular expression block pattern with substitutions
      ---
      switch x
        ///^ ${foo} $///
          console.log "it's foo"
      ---
      if(typeof x === 'string' && RegExp(`^${foo}\\$`).test(x)) {
          console.log("it's foo")}
    """

    testCase """
      instanceof pattern
      ---
      switch x
        instanceof Foo
          console.log "it's a Foo"
        <? Bar
          console.log "it's a Bar"
      ---
      if(x instanceof Foo) {
          console.log("it's a Foo")}
      else if(x instanceof Bar) {
          console.log("it's a Bar")}
    """

    testCase """
      binary op rhs patterns
      ---
      switch x
        < 0
          console.log "it's negative"
        > 0
          console.log "it's positive"
        is 0
          console.log "it's zero"
        else
          console.log "it's something else"
      ---
      if(x < 0) {
          console.log("it's negative")}
      else if(x > 0) {
          console.log("it's positive")}
      else if(x === 0) {
          console.log("it's zero")}
      else  {
          console.log("it's something else")
        }
    """

    testCase """
      binary op rhs patterns with then
      ---
      switch x
        < 0 then console.log "it's negative"
        > 0 then console.log "it's positive"
        is 0 then console.log "it's zero"
        else console.log "it's something else"
      ---
      if(x < 0) { console.log("it's negative")}
      else if(x > 0) { console.log("it's positive")}
      else if(x === 0) { console.log("it's zero")}
      else  { console.log("it's something else") }
    """

    testCase """
      advanced binary operators rhs pattern
      ---
      switch x
        < 0 < 1
          console.log "it's negative"
        <? "string"
          console.log "it's a string"
        <? y <? z
          console.log "it's a y kind of z"
      ---
      if(x < 0 && 0 < 1) {
          console.log("it's negative")}
      else if(typeof x === "string") {
          console.log("it's a string")}
      else if(x instanceof y && y instanceof z) {
          console.log("it's a y kind of z")}
    """

    testCase """
      fizzbuzz pattern
      ---
      switch x
        % 15 is 0
          console.log "fizzbuzz"
        % 3 is 0
          console.log "fizz"
        % 5 is 0
          console.log "buzz"
        else
          console.log x
      ---
      if(x % 15 === 0) {
          console.log("fizzbuzz")}
      else if(x % 3 === 0) {
          console.log("fizz")}
      else if(x % 5 === 0) {
          console.log("buzz")}
      else  {
          console.log(x)
        }
    """

    testCase """
      implicit return
      ---
      ->
        switch x
          1
            2
          else
            3
      ---
      (function() {
        if(x === 1) {
            return 2}
      else  {
            return 3
          }
      })
    """

    testCase """
      implicit return with multiple cases
      ---
      ->
        switch x
          1
            2
          2
            3
          else
            4
      ---
      (function() {
        if(x === 1) {
            return 2}
      else if(x === 2) {
            return 3}
      else  {
            return 4
          }
      })
    """

    testCase """
      implicit return with then
      ---
      ->
        switch x
          1 then 2
          2 then 3
          else 4
      ---
      (function() {
        if(x === 1) { return 2}
      else if(x === 2) { return 3}
      else  { return 4 }
      })
    """

    testCase """
      iteration result
      ---
      y := for x in [1, 2, 3]
        switch x
          1
            2
          2
            3
          else
            4
      ---
      const results=[];for (const x in [1, 2, 3]) {
        if(x === 1) {
            results.push(2)}
      else if(x === 2) {
            results.push(3)}
      else  {
            results.push(4)
          }
      };const y =results
    """

    testCase """
      expression form
      ---
      y := switch x
        1
          2
        2
          3
        else
          4
      ---
      let ref;if(x === 1) {
          ref = 2}
      else if(x === 2) {
          ref = 3}
      else  {
          ref = 4
        };const y =ref
    """

    testCase """
      duplicate bindings
      ---
      switch x
        [{type: "text"}, {type: "image"}]
          x
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[0] === 'object' && x[0] != null && 'type' in x[0] && x[0].type === "text" && typeof x[1] === 'object' && x[1] != null && 'type' in x[1] && x[1].type === "image") {
          const [{type: type1}, {type: type2}] = x;
          const type = [type1, type2];
          x}
    """

    testCase """
      duplicate aliases
      ---
      switch x
        {a: y, b: y}
          y
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x) {
          const {a: y1, b: y2} = x;
          const y = [y1, y2];
          y}
    """

    testCase """
      duplicate bindings with rest
      ---
      switch x
        [{type: "text"}, ..., {type: "image"}]
          x
      ---
      if(Array.isArray(x) && x.length >= 2 && typeof x[0] === 'object' && x[0] != null && 'type' in x[0] && x[0].type === "text" && typeof x[x.length - 1] === 'object' && x[x.length - 1] != null && 'type' in x[x.length - 1] && x[x.length - 1].type === "image") {
          const [{type: type1}, ...ref] = x, [{type: type2}] = ref.splice(-1);
          const type = [type1, type2];
          x}
    """

    testCase """
      reserved word keys
      ---
      switch x
        {class: y}
          y
      ---
      if(typeof x === 'object' && x != null && 'class' in x) {
          const {class: y} = x;
          y}
    """

    testCase """
      multiple reserved word keys
      ---
      switch x
        [{else: y}, {else: z}]
          y
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[0] === 'object' && x[0] != null && 'else' in x[0] && typeof x[1] === 'object' && x[1] != null && 'else' in x[1]) {
          const [{else: y}, {else: z}] = x;
          y}
    """

    testCase """
      aliased duplicate bindings
      ---
      switch data
        {a: 'z', a: 'x'}
          a
      ---
      if(typeof data === 'object' && data != null && 'a' in data && data.a === 'z' && 'a' in data && data.a === 'x') {
          const {a: a1, a: a2} = data;
          const a = [a1, a2];
          a}
    """

    testCase """
      reference
      ---
      switch command.split(" ")
        ["turn", direction]
          console.log `Turning ${direction}!`
        ["move", distance]
          console.log `Moving ${distance}!`
      ---
      let m;if(m = command.split(" "),Array.isArray(m) && m.length === 2 && m[0] === "turn") {
          const [, direction] = m;
          console.log(`Turning ${direction}!`)}
      else if(Array.isArray(m) && m.length === 2 && m[0] === "move") {
          const [, distance] = m;
          console.log(`Moving ${distance}!`)}
    """

    testCase """
      expression reference
      ---
      x := switch command.split(" ")
        ["turn", direction]
          `Turning ${direction}!`
        ["move", distance]
          `Moving ${distance}!`
      ---
      let m;let ref;if(m = command.split(" "),Array.isArray(m) && m.length === 2 && m[0] === "turn") {
          const [, direction] = m;
          ref = `Turning ${direction}!`}
      else if(Array.isArray(m) && m.length === 2 && m[0] === "move") {
          const [, distance] = m;
          ref = `Moving ${distance}!`};const x =ref
    """

    // TODO
    testCase.skip """
      multiple binding patterns in one condition
      ---
      switch p
        [x, y], {x, y}
          x
      ---
      if(Array.isArray(p) && p.length === 2) {
          const [x, y] = p;
          x}
      else if(typeof p === "object" && p != null && "x" in p && "y" in p) {
          const { x, y } = p;
          x}
    """

    testCase """
      multi array duplicate bindings
      ---
      switch x
        [[y, y], [y, y]]
          y
      ---
      if(Array.isArray(x) && x.length === 2 && Array.isArray(x[0]) && x[0].length === 2 && Array.isArray(x[1]) && x[1].length === 2) {
          const [[y1, y2], [y3, y4]] = x;
          const y = [y1, y2, y3, y4];
          y}
    """

    testCase """
      multi array duplicate bindings with bound rest
      ---
      switch x
        [[y, y], ...y, [y, y]]
          y
      ---
      if(Array.isArray(x) && x.length >= 2 && Array.isArray(x[0]) && x[0].length === 2 && Array.isArray(x[x.length - 1]) && x[x.length - 1].length === 2) {
          const [[y1, y2], ...y3] = x, [[y4, y5]] = y3.splice(-1);
          const y = [y1, y2, y3, y4, y5];
          y}
    """

    testCase """
      conditional declaration
      ---
      switch u := funReturningEither()
        <? Error
          handle u
        <? UsefulType
          utilize u
      ---
      {let ref = funReturningEither();const  u = ref;if(ref instanceof Error) {
          handle(u)}
      else if(ref instanceof UsefulType) {
          utilize(u)}}
    """

    testCase """
      conditional declaration with StatementExpression
      ---
      switch x := try foo()
        when 1
          true
      ---
      {let ref;try { ref = foo() } catch(e) {ref = void 0;};const  x = ref;switch(ref) {
        case 1: {
          true;break;
        }
      }}
    """
