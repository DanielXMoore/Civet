{testCase} from ./helper.civet

describe "switch", ->
  testCase """
    basic
    ---
    switch (x) {
      case 1:
        break
    }
    ---
    switch (x) {
      case 1:
        break
    }
  """

  testCase """
    optional parens
    ---
    switch x {
      case 1:
        break
    }
    ---
    switch(x) {
      case 1:
        break
    }
  """

  testCase """
    optional braces
    ---
    switch (x)
      case 1:
        break
    ---
    switch (x) {
      case 1:
        break
    }
  """

  testCase """
    open brace on next line
    ---
    switch (x)
    {
      case 1:
        break
    }
    ---
    switch (x)
    {
      case 1:
        break
    }
  """

  testCase """
    multiple cases
    ---
    switch (x) {
      case 1:
      case 2:
        break
    }
    ---
    switch (x) {
      case 1:
      case 2:
        break
    }
  """

  testCase """
    default
    ---
    switch (x) {
      default
        break
    }
    ---
    switch (x) {
      default:
        break
    }
  """

  testCase """
    else
    ---
    switch (x) {
      else
        break
    }
    ---
    switch (x) {
      default: {
        break
      }
    }
  """

  testCase """
    when
    ---
    switch x
      when 1
        console.log y
    ---
    switch(x) {
      case 1: {
        console.log(y);break;
      }
    }
  """

  testCase """
    when then
    ---
    switch x
      when 1 then console.log a
      when 2 then console.log y; console.log x
    ---
    switch(x) {
      case 1: { console.log(a);break;
      }
      case 2: { console.log(y); console.log(x);break;
      }
    }
  """

  testCase """
    empty when body
    ---
    switch x
      when 1 // do nothing
      when 2
        console.log y
    ---
    switch(x) {
      case 1: {;break;
      } // do nothing
      case 2: {
        console.log(y);break;
      }
    }
  """

  testCase """
    when with multiple expressions
    ---
    switch x
      when 1, 2, 3
        console.log y
    ---
    switch(x) {
      case 1:case 2:case 3: {
        console.log(y);break;
      }
    }
  """

  testCase """
    case with multiple expressions
    ---
    switch x
      case 1, 2, 3
        console.log y
    ---
    switch(x) {
      case 1:case 2:case 3:
        console.log(y)
    }
  """

  describe "expression", ->
    testCase """
      switch expression
      ---
      x = switch y
        when 1
          2
      ---
      x = (()=>{switch(y) {
        case 1: {
          return 2
        }
      }})()
    """

  describe "expressionless", ->
    testCase """
      basic
      ---
      switch
        when 1
          2
      ---
      switch (false) {
        case !1: {
          2;break;
        }
      }
    """

    testCase """
      with default
      ---
      switch
        when 1
          2
        else
          3
      ---
      switch (false) {
        case !1: {
          2;break;
        }
        default: {
          3
        }
      }
    """

    testCase """
      with more complex expression in when
      ---
      switch
        when 1 * x > 2
          3
      ---
      switch (false) {
        case !(1 * x > 2): {
          3;break;
        }
      }
    """

  describe "pattern matching", ->
    testCase """
      basic
      ---
      switch x
        1
          console.log "it's one"
        2
          console.log "it's two"
      ---
      if(x === 1) {
          console.log("it's one")}
      else if(x === 2) {
          console.log("it's two")}
    """

    testCase.skip """
      multiple cases
      ---
      switch x
        1, 2
          console.log "it's one or two"
      ---
      if(x === 1 || x === 2) {
        console.log("it's one or two");
      }
    """

    testCase """
      array pattern
      ---
      switch x
        [a, b]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 2) {
          const [a, b] = x;
          console.log(a, b)}
    """

    testCase """
      array rest matcher
      ---
      switch x
        [a, b...]
          console.log a
          console.log b
      ---
      if(Array.isArray(x) && x.length >= 1) {
          const [a, ...b] = x;
          console.log(a)
          console.log(b)}
    """

    testCase """
      array rest non end position
      ---
      switch x
        [...a, b]
          console.log a
          console.log b
      ---
      const splice: <T>(this: T[], start: number, deleteCount?: number) => T[] = [].splice as any
      if(Array.isArray(x) && x.length >= 1) {
          const [...a] = x, [b] = splice.call(a, -1);
          console.log(a)
          console.log(b)}
    """

    testCase """
      array this binding
      ---
      switch x
        [@a, @b]
          console.log this
      ---
      if(Array.isArray(x) && x.length === 2) {
          const [a, b] = x;
          this.a = a;
          this.b = b;
          console.log(this)}
    """

    testCase """
      array rest this binding
      ---
      switch x
        [@a, @b...]
          console.log this
      ---
      if(Array.isArray(x) && x.length >= 1) {
          const [a, ...b] = x;
          this.a = a;
          this.b = b;
          console.log(this)}
    """

    testCase.skip """
      nested array pattern
      ---
      switch x
        [a, [b, c]]
          console.log a, b, c
      ---
      if(Array.isArray(x) && x.length === 2 && Array.isArray(x[1]) && x[1].length === 2) {
          const [a, [b, c]] = x;
          console.log(a, b, c)}
    """
