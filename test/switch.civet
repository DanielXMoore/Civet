{testCase} from ./helper.civet

describe "switch", ->
  testCase """
    basic
    ---
    switch (x) {
      case 1:
        break
    }
    ---
    switch (x) {
      case 1:
        break
    }
  """

  testCase """
    optional parens
    ---
    switch x {
      case 1:
        break
    }
    ---
    switch(x) {
      case 1:
        break
    }
  """

  testCase """
    optional braces
    ---
    switch (x)
      case 1:
        break
    ---
    switch (x) {
      case 1:
        break
    }
  """

  testCase """
    open brace on next line
    ---
    switch (x)
    {
      case 1:
        break
    }
    ---
    switch (x)
    {
      case 1:
        break
    }
  """

  testCase """
    case doesn't allow object literal
    ---
    switch x
      case 1:
        2
    ---
    switch(x) {
      case 1:
        2
    }
  """

  testCase """
    multiple cases
    ---
    switch (x) {
      case 1:
      case 2:
        break
    }
    ---
    switch (x) {
      case 1:
      case 2:
        break
    }
  """

  testCase """
    default
    ---
    switch (x) {
      default
        break
    }
    ---
    switch (x) {
      default:
        break
    }
  """

  testCase """
    else
    ---
    switch (x) {
      else
        break
    }
    ---
    switch (x) {
      default: {
        break
      }
    }
  """

  testCase """
    when
    ---
    switch x
      when 1
        console.log y
    ---
    switch(x) {
      case 1: {
        console.log(y);break;
      }
    }
  """

  testCase """
    when then
    ---
    switch x
      when 1 then console.log a
      when 2 then console.log y; console.log x
    ---
    switch(x) {
      case 1: { console.log(a);break;
      }
      case 2: { console.log(y); console.log(x);break;
      }
    }
  """

  testCase """
    empty when body
    ---
    switch x
      when 1 // do nothing
      when 2
        console.log y
    ---
    switch(x) {
      case 1: {;break;
      } // do nothing
      case 2: {
        console.log(y);break;
      }
    }
  """

  testCase """
    when with multiple expressions
    ---
    switch x
      when 1, 2, 3
        console.log y
    ---
    switch(x) {
      case 1:case 2:case 3: {
        console.log(y);break;
      }
    }
  """

  testCase """
    case with multiple expressions
    ---
    switch x
      case 1, 2, 3
        console.log y
    ---
    switch(x) {
      case 1:case 2:case 3:
        console.log(y)
    }
  """

  describe "expression", ->
    testCase """
      switch expression
      ---
      x = switch y
        when 1
          2
      ---
      x = (()=>{switch(y) {
        case 1: {
          return 2
        }
      }})()
    """

  describe "expressionless", ->
    testCase """
      basic
      ---
      switch
        when 1
          2
      ---
      switch (false) {
        case !1: {
          2;break;
        }
      }
    """

    testCase """
      with default
      ---
      switch
        when 1
          2
        else
          3
      ---
      switch (false) {
        case !1: {
          2;break;
        }
        default: {
          3
        }
      }
    """

    testCase """
      with more complex expression in when
      ---
      switch
        when 1 * x > 2
          3
      ---
      switch (false) {
        case !(1 * x > 2): {
          3;break;
        }
      }
    """

  describe "pattern matching", ->
    testCase """
      basic
      ---
      switch x
        1
          console.log "it's one"
        2
          console.log "it's two"
      ---
      if(x === 1) {
          console.log("it's one")}
      else if(x === 2) {
          console.log("it's two")}
    """

    testCase """
      basic then
      ---
      switch x
        1 then console.log "it's one"
        2 then console.log "it's two"
      ---
      if(x === 1) { console.log("it's one")}
      else if(x === 2) { console.log("it's two")}
    """

    testCase """
      with else
      ---
      switch x
        1
          console.log "it's one"
        else
          console.log "it's something else"
      ---
      if(x === 1) {
          console.log("it's one")}
      else  {
          console.log("it's something else")
        }
    """

    testCase.skip """
      multiple cases
      ---
      switch x
        1, 2
          console.log "it's one or two"
      ---
      if(x === 1 || x === 2) {
        console.log("it's one or two");
      }
    """

    testCase """
      array pattern
      ---
      switch x
        [a, b]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 2) {
          const [a, b] = x;
          console.log(a, b)}
    """

    testCase """
      empty array
      ---
      switch x
        []
          console.log "empty"
      ---
      if(Array.isArray(x) && x.length === 0) {
          console.log("empty")}
    """

    testCase """
      array with empty object
      ---
      switch x
        [a, {}]
          console.log a
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[1] === 'object' && x[1] != null) {
          const [a, {}] = x;
          console.log(a)}
    """

    testCase """
      array with elisions
      ---
      switch x
        [a, , b]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 3) {
          const [a, , b] = x;
          console.log(a, b)}
    """

    testCase """
      array with binding matcher
      ---
      switch x
        [a, b: 3]
          console.log a, b
      ---
      if(Array.isArray(x) && x.length === 2 && x[1] === 3) {
          const [a, b] = x;
          console.log(a, b)}
    """

    testCase """
      array with nested binding matcher
      ---
      switch x
        [a, b: [c, d: 3]]
          console.log a, b, c, d
      ---
      if(Array.isArray(x) && x.length === 2 && Array.isArray(x[1]) && x[1].length === 2 && x[1][1] === 3) {
          const [a, b] = x, [c, d] = b;
          console.log(a, b, c, d)}
    """

    testCase """
      array with matcher after rest
      ---
      switch x
        [a, b..., 3]
          console.log a, b
      ---
      const splice: <T>(this: T[], start: number, deleteCount?: number) => T[] = [].splice as any
      if(Array.isArray(x) && x.length >= 2 && x[x.length - 1] === 3) {
          const [a, ...b] = x, [] = splice.call(b, -1);
          console.log(a, b)}
    """

    testCase """
      array with binding matcher after rest
      ---
      switch x
        [a, b..., c: 3]
          console.log a, b, c
      ---
      const splice: <T>(this: T[], start: number, deleteCount?: number) => T[] = [].splice as any
      if(Array.isArray(x) && x.length >= 2 && x[x.length - 1] === 3) {
          const [a, ...b] = x, [c] = splice.call(b, -1);
          console.log(a, b, c)}
    """

    testCase """
      array rest matcher
      ---
      switch x
        [a, b...]
          console.log a
          console.log b
      ---
      if(Array.isArray(x) && x.length >= 1) {
          const [a, ...b] = x;
          console.log(a)
          console.log(b)}
    """

    testCase """
      array rest non end position
      ---
      switch x
        [...a, b]
          console.log a
          console.log b
      ---
      const splice: <T>(this: T[], start: number, deleteCount?: number) => T[] = [].splice as any
      if(Array.isArray(x) && x.length >= 1) {
          const [...a] = x, [b] = splice.call(a, -1);
          console.log(a)
          console.log(b)}
    """

    testCase """
      array this binding
      ---
      switch x
        [@a, @b]
          console.log this
      ---
      if(Array.isArray(x) && x.length === 2) {
          const [a, b] = x;
          this.a = a;
          this.b = b;
          console.log(this)}
    """

    testCase """
      array rest this binding
      ---
      switch x
        [@a, @b...]
          console.log this
      ---
      if(Array.isArray(x) && x.length >= 1) {
          const [a, ...b] = x;
          this.a = a;
          this.b = b;
          console.log(this)}
    """

    testCase """
      nested array pattern
      ---
      switch x
        [a, [b, c]]
          console.log a, b, c
      ---
      if(Array.isArray(x) && x.length === 2 && Array.isArray(x[1]) && x[1].length === 2) {
          const [a, [b, c]] = x;
          console.log(a, b, c)}
    """

    testCase """
      object pattern
      ---
      switch x
        {a, b}
          console.log a, b
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x) {
          const {a, b} = x;
          console.log(a, b)}
    """

    testCase """
      empty object pattern
      ---
      switch x
        {}
          console.log "empty"
      ---
      if(typeof x === 'object' && x != null) {
          console.log("empty")}
    """

    testCase """
      object pattern with matcher
      ---
      switch x
        {a, b: 3}
          console.log a, b
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x && x.b === 3) {
          const {a, b} = x;
          console.log(a, b)}
    """

    testCase """
      object pattern with post rest matcher
      ---
      switch x
        {a, b..., c: 3}
          console.log a, b, c
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'c' in x && x.c === 3) {
          const {a, c, ...b} = x;
          console.log(a, b, c)}
    """

    testCase """
      object pattern with array binding match
      ---
      switch x
        {a, b: [c, d]}
          console.log a, c, d
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x && Array.isArray(x.b) && x.b.length === 2) {
          const {a, b: [c, d]} = x;
          console.log(a, c, d)}
    """

    testCase """
      object pattern with computed property
      ---
      switch x
        {a, [b]: c}
          console.log a
      ---
      if(typeof x === 'object' && x != null && 'a' in x && b in x && x[b] === c) {
          const {a, [b]: c} = x;
          console.log(a)}
    """

    testCase """
      object pattern with string key
      ---
      switch x
        {a, '+': c}
          console.log a
      ---
      if(typeof x === 'object' && x != null && 'a' in x && '+' in x && x['+'] === c) {
          const {a, '+': c} = x;
          console.log(a)}
    """

    testCase """
      object pattern with number key
      ---
      switch x
        {a, 1: c}
          console.log a
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 1 in x && x[1] === c) {
          const {a, 1: c} = x;
          console.log(a)}
    """

    testCase """
      nested object and array patterns
      ---
      switch x
        {a, b: [c, {d: e}]}
          console.log a, c, e
      ---
      if(typeof x === 'object' && x != null && 'a' in x && 'b' in x && Array.isArray(x.b) && x.b.length === 2 && typeof x.b[1] === 'object' && x.b[1] != null && 'd' in x.b[1] && x.b[1].d === e) {
          const {a, b: [c, {d}]} = x;
          console.log(a, c, e)}
    """

    testCase """
      nested array and object patterns
      ---
      switch x
        [a, {b: c, d: [e, f]}]
          console.log a, c, e, f
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[1] === 'object' && x[1] != null && 'b' in x[1] && x[1].b === c && 'd' in x[1] && Array.isArray(x[1].d) && x[1].d.length === 2) {
          const [a, {b, d: [e, f]}] = x;
          console.log(a, c, e, f)}
    """

    testCase """
      regular expression pattern
      ---
      switch x
        /^foo$/
          console.log "it's foo"
      ---
      if(typeof x === 'string' && /^foo$/.test(x)) {
          console.log("it's foo")}
    """

    testCase """
      nested regular expression pattern
      ---
      switch x
        [/^foo$/, b]
          console.log b
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[0] === 'string' && /^foo$/.test(x[0])) {
          const [, b] = x;
          console.log(b)}
    """

    testCase.skip """
      instanceof pattern
      ---
      switch x
        instanceof Foo
          console.log "it's a Foo"
        <? Bar
          console.log "it's a Bar"
      ---
      if(x instanceof Foo) {
          console.log("it's a Foo")}
      else if(x instanceof Bar) {
          console.log("it's a Bar")}
    """

    testCase """
      implicit return
      ---
      ->
        switch x
          1
            2
          else
            3
      ---
      (function() {
        if(x === 1) {
            return 2}
      else  {
            return 3
          }
      })
    """

    testCase """
      implicit return with multiple cases
      ---
      ->
        switch x
          1
            2
          2
            3
          else
            4
      ---
      (function() {
        if(x === 1) {
            return 2}
      else if(x === 2) {
            return 3}
      else  {
            return 4
          }
      })
    """

    testCase """
      iteration result
      ---
      y := for x in [1, 2, 3]
        switch x
          1
            2
          2
            3
          else
            4
      ---
      const y = (()=>{const results=[]; for (const x in [1, 2, 3]) {
        if(x === 1) {
            results.push(2)}
      else if(x === 2) {
            results.push(3)}
      else  {
            results.push(4)
          }
      }; return results})()
    """

    testCase """
      expression form
      ---
      y := switch x
        1
          2
        2
          3
        else
          4
      ---
      const y =(()=>{if(x === 1) {
          return 2}
      else if(x === 2) {
          return 3}
      else  {
          return 4
        }})()
    """

    testCase """
      duplicate bindings
      ---
      switch x
        [{type: "text"}, {type: "image"}]
          x
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[0] === 'object' && x[0] != null && 'type' in x[0] && x[0].type === "text" && typeof x[1] === 'object' && x[1] != null && 'type' in x[1] && x[1].type === "image") {
          const [{type: type1}, {type: type2}] = x;
          const type = [type1, type2];
          x}
    """

    testCase """
      duplicate bindings with rest
      ---
      switch x
        [{type: "text"}, ..., {type: "image"}]
          x
      ---
      const splice: <T>(this: T[], start: number, deleteCount?: number) => T[] = [].splice as any
      if(Array.isArray(x) && x.length >= 2 && typeof x[0] === 'object' && x[0] != null && 'type' in x[0] && x[0].type === "text" && typeof x[x.length - 1] === 'object' && x[x.length - 1] != null && 'type' in x[x.length - 1] && x[x.length - 1].type === "image") {
          const [{type: type1}, ...ref] = x, [{type: type2}] = splice.call(ref, -1);
          const type = [type1, type2];
          x}
    """

    testCase """
      reserved word keys
      ---
      switch x
        {class: y}
          y
      ---
      if(typeof x === 'object' && x != null && 'class' in x && x.class === y) {
          const {class: _class} = x;
          y}
    """

    testCase """
      multiple reserved word keys
      ---
      switch x
        [{else: y}, {else: z}]
          y
      ---
      if(Array.isArray(x) && x.length === 2 && typeof x[0] === 'object' && x[0] != null && 'else' in x[0] && x[0].else === y && typeof x[1] === 'object' && x[1] != null && 'else' in x[1] && x[1].else === z) {
          const [{else: _else}, {else: _else1}] = x;
          y}
    """

    testCase.skip """
      multi array duplicate bindings
      ---
      switch x
        [[y, y], [y, y]]
          y
      ---
      if(Array.isArray(x) && x.length === 2 && Array.isArray(x[0]) && x[0].length === 2 && Array.isArray(x[1]) && x[1].length === 2) {
          const [[y1, y2], [y3, y4]] = x;
          const y = [y1, y2, y3, y4];
          y}
    """
