{ testCase, throws } from ./helper.civet

describe "call-expression", ->
  testCase """
    parens
    ---
    x(y)
    ---
    x(y)
  """

  testCase """
    space args
    ---
    x y
    x y z
    x y, z
    a b, c d
    ---
    x(y)
    x(y(z))
    x(y, z)
    a(b, c(d))
  """

  testCase """
    optional function
    ---
    x?.(y)
    x?(y)
    x? y
    ---
    x?.(y)
    x?.(y)
    x?.(y)
  """

  testCase """
    leading .
    ---
    $ 'body'
    .click (e) ->
      $ '.box'
      .fadeIn 'fast'
      .addClass 'show'
    .css 'background', 'white'
    ---
    $('body')
    .click(function(e) {
      return $('.box')
      .fadeIn('fast')
      .addClass('show')
    })
    .css('background', 'white')
  """

  describe "https://github.com/DanielXMoore/Civet/issues/197", ->
    testCase """
      leading . after plain identifier
      ---
      data
      .map (x) => x + 1
      .forEach (x) => console.log
      ---
      data
      .map((x) => x + 1)
      .forEach((x) => console.log)
    """

    testCase """
      nested leading . after plain identifier
      ---
      data
        .map (x) => x + 1
        .forEach (x) => console.log
      ---
      data
        .map((x) => x + 1)
        .forEach((x) => console.log)
    """

    testCase """
      nested member property after function argument
      ---
      f x
        .y
      ---
      f(x)
        .y
    """

    testCase """
      nested leading . after plain identifier, nested . shouldn't be suppressed inside function body
      ---
      data
      .map (x) =>
        f x
          .y
      .forEach (x) => console.log
      ---
      data
      .map((x) => {
        return f(x)
          .y
      })
      .forEach((x) => console.log)
    """

    testCase """
      parenthesized expression function argument
      ---
      hello world, (
        hello world
        .foo bar
      )
      .foo bar
      ---
      hello(world, (
        hello(world)
        .foo(bar)
      ))
      .foo(bar)
    """

    testCase """
      ?. after plain identifier
      ---
      data
      ?.map (x) => x + 1
      ---
      data
      ?.map((x) => x + 1)
    """

    it "should not parse with !. on newline after plain identifier", ->
      throws """
        data
        !.map (x) => x + 1
      """

    testCase """
      . after plain identifier with ! suffix
      ---
      data!
      .map (x) => x + 1
      ---
      data!
      .map((x) => x + 1)
    """
